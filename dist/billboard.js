(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-transition"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-brush", "d3-axis", "d3-scale", "d3-dsv", "d3-drag", "d3-transition", "d3-zoom", "d3-ease", "d3-color", "d3-shape", "d3-interpolate"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-transition"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__37__, __WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__42__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(32);
module.exports = __webpack_require__(49);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var _require = __webpack_require__(11),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_entities_1 = __webpack_require__(12);
exports.XmlEntities = xml_entities_1.XmlEntities;
var html4_entities_1 = __webpack_require__(13);
exports.Html4Entities = html4_entities_1.Html4Entities;
var html5_entities_1 = __webpack_require__(14);
exports.Html5Entities = html5_entities_1.Html5Entities;
exports.AllHtmlEntities = html5_entities_1.Html5Entities;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};
var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};
var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};
var XmlEntities = /** @class */ (function () {
    function XmlEntities() {
    }
    XmlEntities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/[<>"'&]/g, function (s) {
            return CHAR_S_INDEX[s];
        });
    };
    XmlEntities.encode = function (str) {
        return new XmlEntities().encode(str);
    };
    XmlEntities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
            if (s.charAt(1) === '#') {
                var code = s.charAt(2).toLowerCase() === 'x' ?
                    parseInt(s.substr(3), 16) :
                    parseInt(s.substr(2));
                if (isNaN(code) || code < -32768 || code > 65535) {
                    return '';
                }
                return String.fromCharCode(code);
            }
            return ALPHA_INDEX[s] || s;
        });
    };
    XmlEntities.decode = function (str) {
        return new XmlEntities().decode(str);
    };
    XmlEntities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var alpha = CHAR_INDEX[c];
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
            if (c < 32 || c > 126) {
                result += '&#' + c + ';';
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonUTF = function (str) {
        return new XmlEntities().encodeNonUTF(str);
    };
    XmlEntities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLenght = str.length;
        var result = '';
        var i = 0;
        while (i < strLenght) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonASCII = function (str) {
        return new XmlEntities().encodeNonASCII(str);
    };
    return XmlEntities;
}());
exports.XmlEntities = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
var alphaIndex = {};
var numIndex = {};
(function () {
    var i = 0;
    var length = HTML_ALPHA.length;
    while (i < length) {
        var a = HTML_ALPHA[i];
        var c = HTML_CODES[i];
        alphaIndex[a] = String.fromCharCode(c);
        numIndex[c] = a;
        i++;
    }
})();
var Html4Entities = /** @class */ (function () {
    function Html4Entities() {
    }
    Html4Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1).toLowerCase() === 'x' ?
                    parseInt(entity.substr(2), 16) :
                    parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                    chr = String.fromCharCode(code);
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html4Entities.decode = function (str) {
        return new Html4Entities().decode(str);
    };
    Html4Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var alpha = numIndex[str.charCodeAt(i)];
            result += alpha ? "&" + alpha + ";" : str.charAt(i);
            i++;
        }
        return result;
    };
    Html4Entities.encode = function (str) {
        return new Html4Entities().encode(str);
    };
    Html4Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var cc = str.charCodeAt(i);
            var alpha = numIndex[cc];
            if (alpha) {
                result += "&" + alpha + ";";
            }
            else if (cc < 32 || cc > 126) {
                result += "&#" + cc + ";";
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonUTF = function (str) {
        return new Html4Entities().encodeNonUTF(str);
    };
    Html4Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonASCII = function (str) {
        return new Html4Entities().encodeNonASCII(str);
    };
    return Html4Entities;
}());
exports.Html4Entities = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];
var alphaIndex = {};
var charIndex = {};
createIndexes(alphaIndex, charIndex);
var Html5Entities = /** @class */ (function () {
    function Html5Entities() {
    }
    Html5Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1) === 'x' ?
                    parseInt(entity.substr(2).toLowerCase(), 16) :
                    parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                    chr = String.fromCharCode(code);
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html5Entities.decode = function (str) {
        return new Html5Entities().decode(str);
    };
    Html5Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var charInfo = charIndex[str.charCodeAt(i)];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            result += str.charAt(i);
            i++;
        }
        return result;
    };
    Html5Entities.encode = function (str) {
        return new Html5Entities().encode(str);
    };
    Html5Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var charInfo = charIndex[c];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            if (c < 32 || c > 126) {
                result += '&#' + c + ';';
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonUTF = function (str) {
        return new Html5Entities().encodeNonUTF(str);
    };
    Html5Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonASCII = function (str) {
        return new Html5Entities().encodeNonASCII(str);
    };
    return Html5Entities;
}());
exports.Html5Entities = Html5Entities;
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo = void 0;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            addChar && (charInfo[chr2] = alpha);
        }
        else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            addChar && (charInfo[''] = alpha);
        }
    }
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(33);
            var content = __webpack_require__(34);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(35);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused, .bb-circles.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step, .bb-circles.bb-focused path.bb-line, .bb-circles.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused, .bb-circles.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping, .bb-circles.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__36__;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__37__;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__42__;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "bb", function() { return /* binding */ bb; });
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ bb; });

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(36);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(37);

// CONCATENATED MODULE: ./src/config/classes.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartCircles: "bb-chart-circles",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./src/config/Store/Element.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Elements class.
 * @class Elements
 * @ignore
 * @private
 */
var Element = function () {
  return {
    chart: null,
    main: null,
    svg: null,
    axis: {
      // axes
      x: null,
      y: null,
      y2: null,
      subX: null
    },
    defs: null,
    tooltip: null,
    legend: null,
    title: null,
    subchart: {
      main: null,
      // $$.context
      bar: null,
      // $$.contextBar
      line: null,
      // $$.contextLine
      area: null // $$.contextArea

    },
    arcs: null,
    bar: null,
    // mainBar,
    line: null,
    // mainLine,
    area: null,
    // mainArea,
    circle: null,
    // mainCircle,
    radars: null,
    text: null,
    // mainText,
    grid: {
      main: null,
      // grid (also focus)
      x: null,
      // xgrid,
      y: null // ygrid,

    },
    gridLines: {
      main: null,
      // gridLines
      x: null,
      // xgridLines,
      y: null // ygridLines

    },
    region: {
      main: null,
      // region
      list: null // mainRegion

    },
    eventRect: null
  };
};


// CONCATENATED MODULE: ./src/config/Store/State.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * State class.
 * @class State
 * @ignore
 * @private
 */
var State = function () {
  return {
    width: 0,
    width2: 0,
    height: 0,
    height2: 0,
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin2: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin3: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    arcWidth: 0,
    arcHeight: 0,
    hasAxis: !1,
    hasRadar: !1,
    current: {
      width: 0,
      height: 0,
      dataMax: 0,
      maxTickWidths: {
        x: {
          size: 0,
          ticks: [],
          clipPath: 0,
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      },
      // current used chart type list
      types: []
    },
    // legend
    isLegendRight: !1,
    isLegendInset: !1,
    isLegendTop: !1,
    isLegendLeft: !1,
    legendStep: 0,
    legendItemWidth: 0,
    legendItemHeight: 0,
    legendHasRendered: !1,
    axis: {
      x: {
        padding: {
          left: 0,
          right: 0
        },
        tickCount: 0
      }
    },
    rotatedPadding: {
      left: 30,
      right: 0,
      top: 5
    },
    withoutFadeIn: {},
    inputType: "",
    datetimeId: "",
    // clip id string
    clip: {
      id: "",
      idXAxis: "",
      idYAxis: "",
      idXAxisTickTexts: "",
      idGrid: "",
      idSubchart: "",
      // clipIdForSubchart
      path: "",
      pathXAxis: "",
      pathYAxis: "",
      pathXAxisTickTexts: "",
      pathGrid: ""
    },
    // status
    dragStart: null,
    dragging: !1,
    flowing: !1,
    cancelClick: !1,
    mouseover: !1,
    rendered: !1,
    transiting: !1,
    hasNegativeValue: !1,
    hasPositiveValue: !0,
    orgAreaOpacity: "0.2",
    // ID strings
    hiddenTargetIds: [],
    hiddenLegendIds: [],
    focusedTargetIds: [],
    defocusedTargetIds: [],
    // value for Arc
    radius: 0,
    innerRadius: 0,
    innerRadiusRatio: 0,
    gaugeArcWidth: 0,
    radiusExpanded: 0,
    // xgrid attribute
    xgridAttr: {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }
  };
};


// CONCATENATED MODULE: ./src/config/Store/Store.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // mapping

var Store_classes = {
  element: Element,
  state: State
};
/**
 * Internal store class.
 * @class Store
 * @ignore
 * @private
 */

var Store = /*#__PURE__*/function () {
  function Store() {
    var _this = this;

    Object.keys(Store_classes).forEach(function (v) {
      _this[v] = new Store_classes[v]();
    });
  }

  var _proto = Store.prototype;
  return _proto.getStore = function getStore(name) {
    return this[name];
  }, Store;
}();


// CONCATENATED MODULE: ./src/config/Options/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data config options
 */
/* harmony default export */ var data_data = ({
  /**
   * Converts data id value
   * @name data․idConverter
   * @memberof Options
   * @type {Function}
   * @default function(id) { return id; }
   * @example
   * data: {
   *    idConverter: function(id) {
   *       // when id is 'data1', converts to be 'data2'
   *       // 'data2' should be given as the initial data value
   *       if (id === "data1") {
   *          return "data2";
   *       } else {
   *          return id;
   *       }
   *    }
   * }
   */
  data_idConverter: function data_idConverter(id) {
    return id;
  },

  /**
   * Set custom data name.
   * @name data․names
   * @memberof Options
   * @type {object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
   * @example
   * data: {
   *   names: {
   *     data1: "Data Name 1",
   *     data2: "Data Name 2"
   *   }
   * }
   */
  data_names: {},

  /**
   * Set custom data class.<br><br>
   * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
   * @name data․classes
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   classes: {
   *     data1: "additional-data1-class",
   *     data2: "additional-data2-class"
   *   }
   * }
   */
  data_classes: {},

  /**
   * Set chart type at once.<br><br>
   * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
   * **Available Values:**
   * - area
   * - area-line-range
   * - area-spline
   * - area-spline-range
   * - area-step
   * - bar
   * - bubble
   * - donut
   * - gauge
   * - line
   * - pie
   * - radar
   * - scatter
   * - spline
   * - step
   * @name data․type
   * @memberof Options
   * @type {string}
   * @default line
   * @example
   * data: {
   *    type: "bar"
   * }
   */
  data_type: undefined,

  /**
   * Set chart type for each data.<br>
   * This setting overwrites data.type setting.
   * - **NOTE:** `radar` type can't be combined with other types.
   * @name data․types
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   types: {
   *     data1: "bar",
   *     data2: "spline"
   *   }
   * }
   */
  data_types: {},

  /**
   *  This option changes the order of stacking data and pieces of pie/donut.
   *  - If `null` specified, it will be the order the data loaded.
   *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
   *
   *  **Available Values:**
   *  - `desc`: In descending order
   *  - `asc`: In ascending order
   *  - `null`: It keeps the data load order
   *  - `function(data1, data2) { ... }`: Array.sort compareFunction
   * @name data․order
   * @memberof Options
   * @type {string|Function|null}
   * @default desc
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
   * @example
   * data: {
   *   // in descending order (default)
   *   order: "desc"
   *
   *   // in ascending order
   *   order: "asc"
   *
   *   // keeps data input order
   *   order: null
   *
   *   // specifying sort function
   *   order: function(a, b) {
   *       // param data passed format
   *       {
   *          id: "data1", id_org: "data1", values: [
   *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
   *              ...
   *          ]
   *       }
   *   }
   * }
   */
  data_order: "desc",

  /**
   * Set color converter function.<br><br>
   * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
   * @name data․color
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
   * @example
   * data: {
   *   color: function(color, d) { ... }
   * }
   */
  data_color: undefined,

  /**
   * Set color for each data.
   * @name data․colors
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   colors: {
   *     data1: "#ff0000",
   *     data2: function(d) {
   *        return "#000";
   *     }
   *     ...
   *   }
   * }
   */
  data_colors: {},

  /**
   * Hide each data when the chart appears.<br><br>
   * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
   * @name data․hide
   * @memberof Options
   * @type {boolean|Array}
   * @default false
   * @example
   * data: {
   *   // all of data will be hidden
   *   hide: true
   *
   *   // specified data will be hidden
   *   hide: ["data1", ...]
   * }
   */
  data_hide: !1,

  /**
   * Filter values to be shown
   * The data value is the same as the returned by `.data()`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   * @name data․filter
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * data: {
   *   // filter for id value
   *   filter: function(v) {
   *      // v: [{id: "data1", id_org: "data1", values: [
   *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
   *      //    }, ...]
   *      return v.id !== "data1";
   *   }
   */
  data_filter: undefined,

  /**
   * Set a callback for click event on each data point.<br><br>
   * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
   * - `d` is the data clicked and element is the element clicked.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onclick
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onclick: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onclick: function data_onclick() {},

  /**
   * Set a callback for mouse/touch over event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
   * - `d` is the data where mouse cursor moves onto.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onover
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onover: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onover: function data_onover() {},

  /**
   * Set a callback for mouse/touch out event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
   * - `d` is the data where mouse cursor moves out.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onout
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onout: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onout: function data_onout() {},

  /**
   * Set a callback for minimum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmin
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmin: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmin: undefined,

  /**
   * Set a callback for maximum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmax
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmax: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmax: undefined,

  /**
   * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
   * @name data․url
   * @memberof Options
   * @type {string}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
   * @example
   * data: {
   *     url: "/data/test.csv"
   * }
   */
  data_url: undefined,

  /**
   * XHR header value
   * - **NOTE:** Should be used with `data.url` option
   * @name data․headers
   * @memberof Options
   * @type {string}
   * @default undefined
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
   * @example
   * data: {
   *     url: "/data/test.csv",
   *     headers: {
   *        "Content-Type": "text/xml",
   *        ...
   *     }
   * }
   */
  data_headers: undefined,

  /**
   * Parse a JSON object for data. See also data.keys.
   * @name data․json
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [data․keys](#.data%25E2%2580%25A4keys)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_json: undefined,

  /**
   * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
   * @name data․rows
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
   * @example
   * data: {
   *   rows: [
   *     ["A", "B", "C"],
   *     [90, 120, 300],
   *     [40, 160, 240],
   *     [50, 200, 290],
   *     [120, 160, 230],
   *     [80, 130, 300],
   *     [90, 220, 320]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {high:150, mid: 140, low: 110}, 120
   *        [150, 140, 110], 120
   *      ],
   *      [[155, 130, 115], 55],
   *      [[160, 135, 120], 60]
   *   ],
   *   types: {
   *       data1: "area-line-range",
   *       data2: "line"
   *   }
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {y:10, z: 140}, 120
   *        [10, 140], 120
   *      ],
   *      [[100, 30], 55],
   *      [[50, 100], 60]
   *   ],
   *   types: {
   *       data1: "bubble",
   *       data2: "line"
   *   }
   * }
   */
  data_rows: undefined,

  /**
   * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
   * @name data․columns
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
   * @example
   * data: {
   *   columns: [
   *      ["data1", 30, 20, 50, 40, 60, 50],
   *      ["data2", 200, 130, 90, 240, 130, 220],
   *      ["data3", 300, 200, 160, 400, 250, 250]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   columns: [
   *      ["data1",
   *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
   *          [150, 140, 110],
   *          [150, 140, 110]
   *      ]
   *   ],
   *   type: "area-line-range"
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   columns: [
   *      ["data1",
   *          [10, 140],  // or {y:10, z: 140}
   *          [100, 30],
   *          [50, 100]
   *      ]
   *   ],
   *   type: "bubble"
   * }
   */
  data_columns: undefined,

  /**
   * Used if loading JSON via data.url.
   * - **Available Values:**
   *   - json
   *   - csv
   *   - tsv
   * @name data․mimeType
   * @memberof Options
   * @type {string}
   * @default csv
   * @example
   * data: {
   *     mimeType: "json"
   * }
   */
  data_mimeType: "csv",

  /**
   * Choose which JSON object keys correspond to desired data.
   * - **NOTE:** Only for JSON object given as array.
   * @name data․keys
   * @memberof Options
   * @type {string}
   * @default undefined
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_keys: undefined,

  /**
   * Set text label to be displayed when there's no data to show.
   * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
   * @name data․empty․label․text
   * @memberof Options
   * @type {string}
   * @default ""
   * @example
   * data: {
   *   empty: {
   *     label: {
   *       text: "No Data"
   *     }
   *   }
   * }
   */
  data_empty_label_text: ""
});
// CONCATENATED MODULE: ./src/config/Options/common/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * color config options
 */
/* harmony default export */ var common_color = ({
  /**
   * Set color of the data values
   * @name color
   * @memberof Options
   * @type {object}
   * @property {object} color color object
   * @property {string|object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
   * @property {Array|null} [color.pattern=[]] Set custom color pattern. Passing `null` will not set a color for these elements, which requires the usage of custom CSS-based theming to work.
   * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
   *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
   *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
   *    - `bb-colorize-pattern-red`
   *    - `bb-colorize-pattern-fff`
   * @property {object} [color.threshold] color threshold for gauge and tooltip color
   * @property {string} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
   * @property {Array} [color.threshold.values] Threshold values for each steps
   * @property {number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
   * @example
   *  color: {
   *      pattern: ["#1f77b4", "#aec7e8", ...],
   *
   *      // Set colors' patterns
   *      // it should return an array of SVGPatternElement
   *      tiles: function() {
   *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
   *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
   *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
   *
   *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
   *         pattern.setAttribute("width", "32");
   *         pattern.setAttribute("height", "32");
   *
   *         g.style.fill = "#000";
   *         g.style.opacity = "0.2";
   *
   *         circle1.setAttribute("cx", "3");
   *         circle1.setAttribute("cy", "3");
   *         circle1.setAttribute("r", "3");
   *
   *         g.appendChild(circle1);
   *         pattern.appendChild(g);
   *
   *         return [pattern];
   *      },
   *
   *      // for threshold usage, pattern values should be set for each steps
   *      pattern: ["grey", "green", "yellow", "orange", "red"],
   *      threshold: {
   *          unit: "value",
   *
   *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
   *          values: [10, 20, 30, 40, 50],
   *
   *          // the equation for max:
   *          // - unit == 'value': max => 30
   *          // - unit != 'value': max => value*100/30
   *          max: 30
   *      },
   *
   *      // set all data to 'red'
   *      onover: "red",
   *
   *      // set different color for data
   *      onover: {
   *          data1: "red",
   *          data2: "yellow"
   *      },
   *
   *      // will pass data object to the callback
   *      onover: function(d) {
   *          return d.id === "data1" ? "red" : "green";
   *      }
   *  }
   */
  color_pattern: [],
  color_tiles: undefined,
  color_threshold: {},
  color_onover: undefined
});
// CONCATENATED MODULE: ./src/config/Options/common/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * interaction config options
 */
/* harmony default export */ var interaction = ({
  /**
   * Interaction options
   * @name interaction
   * @memberof Options
   * @type {object}
   * @property {object} interaction Intersection object
   * @property {boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
   *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
   * @property {boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
   * @property {boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
   * @property {boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
   * @property {boolean|number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
   * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
   * @example
   * interaction: {
   *    enabled: false,
   *    brighten: false,
   *    inputType: {
   *        mouse: true,
   *        touch: false
   *
   *        // or declare preventDefault explicitly.
   *        // In this case touch inputType is enabled by default
   *        touch: {
   *            preventDefault: true
   *
   *            // or threshold pixel value (pixel moved from touchstart to touchmove)
   *            preventDefault: 5
   *        }
   *    }
   * }
   */
  interaction_enabled: !0,
  interaction_brighten: !0,
  interaction_inputType_mouse: !0,
  interaction_inputType_touch: {}
});
// CONCATENATED MODULE: ./src/config/Options/common/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * legend config options
 */
/* harmony default export */ var common_legend = ({
  /**
   * Legend options
   * @name legend
   * @memberof Options
   * @type {object}
   * @property {object} legend Legend object
   * @property {boolean} [legend.show=true] Show or hide legend.
   * @property {boolean} [legend.hide=false] Hide legend
   *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
   * @property {string|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
   * @property {string|Function} [legend.contents.template=undefined] Set item's template.<br>
   *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
   *    - {=COLOR}: data color value
   *    - {=TITLE}: data title value
   *  - If set `function` value, will pass following arguments to the given function:
   *   - title {string}: data's id value
   *   - color {string}: color string
   *   - data {Array}: data array
   * @property {string} [legend.position=bottom] Change the position of legend.<br>
   *  Available values are: `bottom`, `right` and `inset` are supported.
   * @property {object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
   *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
   *  - **anchor** decides the position of the legend:
   *   - top-left
   *   - top-right
   *   - bottom-left
   *   - bottom-right
   *  - **x** and **y**:
   *   - set the position of the legend based on the anchor.
   *  - **step**:
   *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
   * @property {boolean} [legend.equally=false] Set to all items have same width size.
   * @property {boolean} [legend.padding=0] Set padding value
   * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
   * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
   * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
   * @property {number} [legend.item.tile.width=10] Set width of item tile element
   * @property {number} [legend.item.tile.height=10] Set height of item tile element
   * @property {boolean} [legend.usePoint=false] Whether to use custom points in legend.
   * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
   * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
   * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
   * @example
   *  legend: {
   *      show: true,
   *      hide: true,
   *      //or hide: "data1"
   *      //or hide: ["data1", "data2"]
   *      contents: {
   *          bindto: "#legend",   // <ul id='legend'></ul>
   *
   *          // will be as: <li style='background-color:#1f77b4'>data1</li>
   *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
   *
   *          // or using function
   *          template: function(id, color, data) {
   *               // if you want omit some legend, return falsy value
   *               if (id !== "data1") {
   *                    return "<li style='background-color:"+ color +">"+ id +"</li>";
   *               }
   *          }
   *      },
   *      position: "bottom",  // bottom, right, inset
   *      inset: {
   *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
   *          x: 20,
   *          y: 10,
   *          step: 2
   *      },
   *      equally: false,
   *      padding: 10,
   *      item: {
   *          onclick: function(id) { ... },
   *          onover: function(id) { ... },
   *          onout: function(id) { ... },
   *
   *          // set tile's size
   *          tile: {
   *              width: 20,
   *              height: 15
   *          }
   *      },
   *      usePoint: true
   *  }
   */
  legend_show: !0,
  legend_hide: !1,
  legend_contents_bindto: undefined,
  legend_contents_template: undefined,
  legend_position: "bottom",
  legend_inset_anchor: "top-left",
  legend_inset_x: 10,
  legend_inset_y: 0,
  legend_inset_step: undefined,
  legend_item_onclick: undefined,
  legend_item_onover: undefined,
  legend_item_onout: undefined,
  legend_equally: !1,
  legend_padding: 0,
  legend_item_tile_width: 10,
  legend_item_tile_height: 10,
  legend_usePoint: !1
});
// CONCATENATED MODULE: ./src/config/Options/common/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * title config options
 */
/* harmony default export */ var common_title = ({
  /**
   * Set title options
   * @name title
   * @memberof Options
   * @type {object}
   * @property {object} title Title object
   * @property {string} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
   * @property {number} [title.padding.top=0] Top padding value.
   * @property {number} [title.padding.right=0] Right padding value.
   * @property {number} [title.padding.bottom=0] Bottom padding value.
   * @property {number} [title.padding.left=0] Left padding value.
   * @property {string} [title.position=center] Available values are: 'center', 'right' and 'left'.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
   * @example
   *  title: {
   *      text: "Title Text",
   *
   *      // or Multiline title text
   *      text: "Main title text\nSub title text",
   *
   *      padding: {
   *          top: 10,
   *          right: 10,
   *          bottom: 10,
   *          left: 10
   *      },
   *      position: "center"
   *  }
   */
  title_text: undefined,
  title_padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  title_position: "center"
});
// CONCATENATED MODULE: ./src/config/Options/common/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * tooltip config options
 */
/* harmony default export */ var common_tooltip = ({
  /**
   * Tooltip options
   * @name tooltip
   * @memberof Options
   * @type {object}
   * @property {object} tooltip Tooltip object
   * @property {boolean} [tooltip.show=true] Show or hide tooltip.
   * @property {boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
   * @property {boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
   *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
   * @property {boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
   * @property {string} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
   * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
   *  Specified function receives x of the data point to show.
   * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   *  If undefined returned, the row of that value will be skipped.
   * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>
   *  This option can be used to modify the tooltip position by returning object that has top and left.
   * @property {Function|object} [tooltip.contents] Set custom HTML for the tooltip.<br>
   *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
   * @property {string|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
   *  - **NOTE:** When is specified, will not be updating tooltip's position.
   * @property {string} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
   *  Within template, below syntax will be replaced using template-like syntax string:
   *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
   *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
   *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
   *    - **{=TITLE}**: title value.
   *    - **{=COLOR}**: data color.
   *    - **{=VALUE}**: data value.
   * @property {object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
   *  - **NOTE:** It should contain `{ key: Array, ... }` value
   *    - 'key' name is used as substitution within template as '{=KEY}'
   *    - The value array length should match with the data length
   * @property {boolean} [tooltip.init.show=false] Show tooltip at the initialization.
   * @property {number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
   * @property {object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
   * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
   * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
   * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
   * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
   * @property {string|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
   *  **Available Values:**
   *  - `desc`: In descending data value order
   *  - `asc`: In ascending data value order
   *  - `null`: It keeps the data display order<br>
   *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
   *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
   *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
   * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
   * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
   * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
   * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
   * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
   * @example
   *  tooltip: {
   *      show: true,
   *      doNotHide: true,
   *      grouped: false,
   *      format: {
   *          title: function(x) { return "Data " + x; },
   *          name: function(name, ratio, id, index) { return name; },
   *          value: function(value, ratio, id, index) { return ratio; }
   *      },
   *      position: function(data, width, height, element) {
   *          return {top: 0, left: 0}
   *      },
   *
   *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
   *          return ... // formatted html as you want
   *      },
   *
   *       // specify tooltip contents using template
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
   *      		'}}</ul>'
   *      }
   *
   *       // with additional text value
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	text: {
   *      		// a) 'key' name is used as substitution within template as '{=KEY}'
   *      		// b) the length should match with the data length
   *      		VAR1: ["text1", "text2"],
   *      		VAR2: ["comment1", "comment2"],
   *      	},
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
   *      		'}}</ul>'
   *      }
   *
   *      // sort tooltip data value display in ascending order
   *      order: "asc",
   *
   *      // specifying sort function
   *      order: function(a, b) {
   *         // param data passed format
   *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
   *           ...
   *      },
   *
   *      // show at the initialization
   *      init: {
   *          show: true,
   *          x: 2,
   *          position: {
   *              top: "150px",
   *              left: "250px"
   *          }
   *      },
   *
   *      // fires prior tooltip is shown
   *      onshow: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires prior tooltip is hidden
   *      onhide: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is shown
   *      onshown: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is hidden
   *      onhidden: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
   *      // Useful for timeseries correlation
   *      linked: true,
   *
   *      // Specify name to interact those with the same name only.
   *      linked: {
   *          name: "some-group"
   *      }
   *  }
   */
  tooltip_show: !0,
  tooltip_doNotHide: !1,
  tooltip_grouped: !0,
  tooltip_format_title: undefined,
  tooltip_format_name: undefined,
  tooltip_format_value: undefined,
  tooltip_position: undefined,
  tooltip_contents: {},
  tooltip_init_show: !1,
  tooltip_init_x: 0,
  tooltip_init_position: {
    top: "0px",
    left: "50px"
  },
  tooltip_linked: !1,
  tooltip_linked_name: "",
  tooltip_onshow: function tooltip_onshow() {},
  tooltip_onhide: function tooltip_onhide() {},
  tooltip_onshown: function tooltip_onshown() {},
  tooltip_onhidden: function tooltip_onhidden() {},
  tooltip_order: null
});
// CONCATENATED MODULE: ./src/config/Options/data/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Axis based chart data config options
 */
/* harmony default export */ var data_axis = ({
  /**
   * Specify the key of x values in the data.<br><br>
   * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
   * @name data․x
   * @memberof Options
   * @type {string}
   * @default undefined
   * @example
   * data: {
   *   x: "date"
   * }
   */
  data_x: undefined,

  /**
   * Specify the keys of the x values for each data.<br><br>
   * This option can be used if we want to show the data that has different x values.
   * @name data․xs
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   xs: {
   *      data1: "x1",
   *      data2: "x2"
   *   }
   * }
   */
  data_xs: {},

  /**
   * Set a format specifier to parse string specifed as x.
   * @name data․xFormat
   * @memberof Options
   * @type {string}
   * @default %Y-%m-%d
   * @example
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "01012019", "02012019", "03012019"],
   *        ["data1", 30, 200, 100]
   *    ],
   *    // Format specifier to parse as datetime for given 'x' string value
   *    xFormat: "%m%d%Y"
   * },
   * axis: {
   *    x: {
   *        type: "timeseries"
   *    }
   * }
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   */
  data_xFormat: "%Y-%m-%d",

  /**
   * Set localtime format to parse x axis.
   * @name data․xLocaltime
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *   xLocaltime: false
   * }
   */
  data_xLocaltime: !0,

  /**
   * Sort on x axis.
   * @name data․xSort
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *   xSort: false
   * }
   */
  data_xSort: !0,

  /**
   * Set groups for the data for stacking.
   * @name data․groups
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * data: {
   *   groups: [
   *     ["data1", "data2"],
   *     ["data3"]
   *   ]
   * }
   */
  data_groups: [],

  /**
   * Set y axis the data related to. y and y2 can be used.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @name data․axes
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   axes: {
   *     data1: "y",
   *     data2: "y2"
   *   }
   * }
   */
  data_axes: {},

  /**
   * Set labels options
   * @name data․labels
   * @memberof Options
   * @type {object}
   * @property {object} data Data object
   * @property {boolean} [data.labels=false] Show or hide labels on each data points
   * @property {boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
   * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
   * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
   *  - `v` is the value of the data point where the label is shown.
   *  - `id` is the id of the data where the label is shown.
   *  - `i` is the index of the data point where the label is shown.
   *  - `j` is the sub index of the data point where the label is shown.<br><br>
   * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
   * @property {string|object} [data.labels.colors] Set label text colors.
   * @property {object} [data.labels.position] Set each dataset position, relative the original.
   * @property {number} [data.labels.position.x=0] x coordinate position, relative the original.
   * @property {number} [data.labels.position.y=0] y coordinate position, relative the original.
   * @memberof Options
   * @type {object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
   * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
   * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
   * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
   * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
   * @example
   * data: {
   *   labels: true,
   *
   *   // or set specific options
   *   labels: {
   *     format: function(v, id, i, j) { ... },
   *
   *     // it's possible to set for each data
   *     format: {
   *         data1: function(v, id, i, j) { ... },
   *         ...
   *     },
   *
   *     // align text to center of the 'bar' shape (works only for 'bar' type)
   *     centered: true,
   *
   *     // apply for all label texts
   *     colors: "red",
   *
   *     // or set different colors per dataset
   *     // for not specified dataset, will have the default color value
   *     colors: {
   *        data1: "yellow",
   *        data3: "green"
   *     },
   *
   *     // set x, y coordinate position
   *     position: {
   *        x: -10,
   *        y: 10
   *     },
   *
   *     // or set x, y coordinate position by each dataset
   *     position: {
   *        data1: {x: 5, y: 5},
   *        data2: {x: 10, y: -20}
   *     }
   *   }
   * }
   */
  data_labels: {},
  data_labels_colors: undefined,
  data_labels_position: {},

  /**
   * Define regions for each data.<br>
   * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
   * - The object type should be as:
   *   - start {number}: Start data point number. If not set, the start will be the first data point.
   *   - [end] {number}: End data point number. If not set, the end will be the last data point.
   *   - [style.dasharray="2 2"] {object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
   * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
   * @name data․regions
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   regions: {
   *     data1: [{
   *         start: 1,
   *         end: 2,
   *         style: {
   *             dasharray: "5 2"
   *         }
   *     }, {
   *         start: 3
   *     }],
   *     ...
   *   }
   * }
   */
  data_regions: {},

  /**
   * Set the stacking to be normalized
   * - **NOTE:**
   *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
   *   - y Axis will be set in percentage value (0 ~ 100%)
   *   - Must have postive values
   * @name data․stack․normalize
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
   * @example
   * data: {
   *   stack: {
   *      normalize: true
   *   }
   * }
   */
  data_stack_normalize: !1
});
// CONCATENATED MODULE: ./src/config/Options/data/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data.selection config options
 */
/* harmony default export */ var data_selection = ({
  /**
   * Set data selection enabled<br><br>
   * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
   * @name data․selection․enabled
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
   * @example
   * data: {
   *    selection: {
   *       enabled: true
   *    }
   * }
   */
  data_selection_enabled: !1,

  /**
   * Set grouped selection enabled.<br><br>
   * If this option set true, multiple data points that have same x value will be selected by one selection.
   * @name data․selection․grouped
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       grouped: true
   *    }
   * }
   */
  data_selection_grouped: !1,

  /**
   * Set a callback for each data point to determine if it's selectable or not.<br><br>
   * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
   * @name data․selection․isselectable
   * @memberof Options
   * @type {Function}
   * @default function() { return true; }
   * @example
   * data: {
   *    selection: {
   *       isselectable: function(d) { ... }
   *    }
   * }
   */
  data_selection_isselectable: function data_selection_isselectable() {
    return !0;
  },

  /**
   * Set multiple data points selection enabled.<br><br>
   * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
   * @name data․selection․multiple
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *    selection: {
   *       multiple: false
   *    }
   * }
   */
  data_selection_multiple: !0,

  /**
   * Enable to select data points by dragging.
   * If this option set true, data points can be selected by dragging.
   * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
   * @name data․selection․draggable
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       draggable: true
   *   }
   * }
   */
  data_selection_draggable: !1,

  /**
   * Set a callback for on data selection.
   * @name data․onselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onselected: function data_onselected() {},

  /**
   * Set a callback for on data un-selection.
   * @name data․onunselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onunselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onunselected: function data_onunselected() {}
});
// CONCATENATED MODULE: ./src/config/Options/axis/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var axis_x = ({
  /**
   * Set clip-path attribute for x axis element
   * @name axis․x․clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo]()
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_x_clipPath: !0,

  /**
   * Show or hide x axis.
   * @name axis․x․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     show: false
   *   }
   * }
   */
  axis_x_show: !0,

  /**
   * Set type of x axis.<br><br>
   * **Available Values:**
   * - timeseries
   * - category
   * - indexed
   * @name axis․x․type
   * @memberof Options
   * @type {string}
   * @default indexed
   * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
   * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
   * @example
   * axis: {
   *   x: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_x_type: "indexed",

  /**
   * Set how to treat the timezone of x values.<br>
   * If true, treat x value as localtime. If false, convert to UTC internally.
   * @name axis․x․localtime
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     localtime: false
   *   }
   * }
   */
  axis_x_localtime: !0,

  /**
   * Set category names on category axis.
   * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @name axis․x․categories
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * axis: {
   *   x: {
   *     categories: ["Category 1", "Category 2", ...]
   *   }
   * }
   */
  axis_x_categories: [],

  /**
   * centerize ticks on category axis.
   * @name axis․x․tick․centered
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       centered: true
   *     }
   *   }
   * }
   */
  axis_x_tick_centered: !1,

  /**
   * A function to format tick value. Format string is also available for timeseries data.
   * @name axis․x․tick․format
   * @memberof Options
   * @type {Function|string}
   * @default undefined
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *        // for timeseries, a 'datetime' object is given as parameter
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *
   *       // for category, index(Number) and categoryName(String) are given as parameter
   *       format: function(index, categoryName) {
   *           return categoryName.substr(0, 10);
   *       },
   *
   *        // for timeseries format specifier
   *        format: "%Y-%m-%d %H:%M:%S"
   *     }
   *   }
   * }
   */
  axis_x_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.x.tick.culling.max.
   * @name axis․x․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default
   * - true for indexed axis and timeseries axis
   * - false for category axis
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_x_tick_culling: {},

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․x․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 10
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_culling_max: 10,

  /**
   * The number of x axis ticks to show.<br><br>
   * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
   * @name axis․x․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_x_tick_count: undefined,

  /**
   * Show or hide x axis tick line.
   * @name axis․x․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_x_tick_show: !0,

  /**
   * Show or hide x axis tick text.
   * @name axis․x․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_show: !0,

  /**
   * Set the x Axis tick text's position relatively its original position
   * @name axis․x․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Fit x axis ticks.
   * - **true**: ticks will be positioned nicely to have same intervals.
   * - **false**: ticks will be positioned according to x value of the data points.
   * @name axis․x․tick․fit
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
   * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       fit: false
   *     }
   *   }
   * }
   */
  axis_x_tick_fit: !0,

  /**
   * Set the x values of ticks manually.<br><br>
   * If this option is provided, the position of the ticks will be determined based on those values.<br>
   * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
   * @name axis․x․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       values: [1, 2, 4, 8, 16, 32, ...],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_values: null,

  /**
   * Rotate x axis tick text if there is not enough space for 'category' and 'timeseries' type axis.
   * - **NOTE:** The conditions where `autorotate` is enabled are:
   *   - axis.x.type='category' or 'timeseries
   *   - axis.x.tick.multiline=false
   *   - axis.x.tick.culling=false
   *   - axis.x.tick.fit=true
   * @name axis․x․tick․autorotate
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickAutorotate)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 15,
   *       autorotate: true,
   *       multiline: false,
   *       culling: false,
   *       fit: true
   *     }
   *   }
   * }
   */
  axis_x_tick_autorotate: !1,

  /**
   * Rotate x axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
   * - As long as `axis_x_tick_fit` is set to `true` it will calculate an overflow for the y2 axis and add this value to the right padding.
   * @name axis․x․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_x_tick_rotate: 0,

  /**
   * Show x axis outer tick.
   * @name axis․x․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_x_tick_outer: !0,

  /**
   * Set tick text to be multiline
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
   * @name axis․x․tick․multiline
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       multiline: false
   *     }
   *   }
   * }
   * @example
   * // example of line break with '\n'
   * // In this case, 'axis.x.tick.width' is ignored
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "long\ntext", "Another\nLong\nText"],
   *        ...
   *    ],
   * }
   */
  axis_x_tick_multiline: !0,

  /**
   * Set tick width
   * - **NOTE:**
   *  > When x tick text contains `\n`, this option is ignored.
   * @name axis․x․tick․width
   * @memberof Options
   * @type {number}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       width: 50
   *     }
   *   }
   * }
   */
  axis_x_tick_width: null,

  /**
   * Set to display system tooltip(via 'title' attribute) for tick text
   * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
   * @name axis․x․tick․tooltip
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       tooltip: true
   *     }
   *   }
   * }
   */
  axis_x_tick_tooltip: !1,

  /**
   * Set max value of x axis range.
   * @name axis․x․max
   * @memberof Options
   * @property {number} max Set the max value
   * @property {boolean} [max.fit=false] When specified `max.value` is greater than the bound data value, setting `true` will make x axis max to be fitted to the bound data max value.
   * - **NOTE:** If the bound data max value is greater than the `max.value`, the x axis max will be limited as the given `max.value`.
   * @property {number} [max.value] Set the max value
   * @example
   * axis: {
   *   x: {
   *     max: 100,
   *
   *     max: {
   *       // 'fit=true' will make x axis max to be limited as the bound data value max when 'max.value' is greater.
   *       // - when bound data max is '10' and max.value: '100' ==>  x axis max will be '10'
   *       // - when bound data max is '1000' and max.value: '100' ==> x axis max will be '100'
   *       fit: true,
   *       value: 100
   *     }
   *   }
   * }
   */
  axis_x_max: undefined,

  /**
   * Set min value of x axis range.
   * @name axis․x․min
   * @memberof Options
   * @property {number} min Set the min value
   * @property {boolean} [min.fit=false] When specified `min.value` is lower than the bound data value, setting `true` will make x axis min to be fitted to the bound data min value.
   * - **NOTE:** If the bound data min value is lower than the `min.value`, the x axis min will be limited as the given `min.value`.
   * @property {number} [min.value] Set the min value
   * @example
   * axis: {
   *   x: {
   *     min: -100,
   *
   *     min: {
   *       // 'fit=true' will make x axis min to be limited as the bound data value min when 'min.value' is lower.
   *       // - when bound data min is '-10' and min.value: '-100' ==>  x axis min will be '-10'
   *       // - when bound data min is '-1000' and min.value: '-100' ==> x axis min will be '-100'
   *       fit: true,
   *       value: -100
   *     }
   *   }
   * }
   */
  axis_x_min: undefined,

  /**
   * Set padding for x axis.<br><br>
   * If this option is set, the range of x axis will increase/decrease according to the values.
   * If no padding is needed in the rage of x axis, 0 should be set.
   * - **NOTE:**
   *   The padding values aren't based on pixels. It differs according axis types<br>
   *   - **category:** The unit of tick value
   *     ex. the given value `1`, is same as the width of 1 tick width
   *   - **timeseries:** Numeric time value
   *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
   * @name axis․x․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   x: {
   *     padding: {
   *       // when axis type is 'category'
   *       left: 1,  // set left padding width of equivalent value of a tick's width
   *       right: 0.5  // set right padding width as half of equivalent value of tick's width
   *
   *       // when axis type is 'timeseries'
   *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
   *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_x_padding: {},

  /**
   * Set height of x axis.<br><br>
   * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
   * @name axis․x․height
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     height: 20
   *   }
   * }
   */
  axis_x_height: undefined,

  /**
   * Set default extent for subchart and zoom. This can be an array or function that returns an array.
   * @name axis․x․extent
   * @memberof Options
   * @type {Array|Function}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     // extent range as a pixel value
   *     extent: [0, 200],
   *
   *     // when axis is 'timeseries', parsable datetime string
   *     extent: ["2019-03-01", "2019-03-05"],
   *
   *     // return extent value
   *     extent: function(domain, scale) {
   *    	 var extent = domain.map(function(v) {
   *     	    return scale(v);
   *     	 });
   *
   *   	 // it should return a format of array
   *   	 // ex) [0, 584]
   *     	 return extent;
   *     }
   *   }
   * }
   */
  axis_x_extent: undefined,

  /**
   * Set label on x axis.<br><br>
   * You can set x axis label and change its position by this option.
   * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
   * Available position differs according to the axis direction (vertical or horizontal).
   * If string set, the position will be the default.
   *
   *  - **If it's horizontal axis:**
   *    - inner-right [default]
   *    - inner-center
   *    - inner-left
   *    - outer-right
   *    - outer-center
   *    - outer-left
   *  - **If it's vertical axis:**
   *    - inner-top [default]
   *    - inner-middle
   *    - inner-bottom
   *    - outer-top
   *    - outer-middle
   *    - outer-bottom
   * @name axis․x․label
   * @memberof Options
   * @type {string|object}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     label: "Your X Axis"
   *   }
   * }
   *
   * axis: {
   *   x: {
   *     label: {
   *        text: "Your X Axis",
   *        position: "outer-center"
   *     }
   *   }
   * }
   */
  axis_x_label: {},

  /**
   * Set additional axes for x Axis.
   * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․x․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * x: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main x Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_x_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y Axis  config options
 */
/* harmony default export */ var axis_y = ({
  /**
   * Set clip-path attribute for y axis element
   * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
   * @name axis․y․clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_y_clipPath: !0,

  /**
   * Show or hide y axis.
   * @name axis․y․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     show: false
   *   }
   * }
   */
  axis_y_show: !0,

  /**
   * Set type of y axis.<br><br>
   * **Available Values:**
   *   - timeseries
   *   - indexed
   * @name axis․y․type
   * @memberof Options
   * @type {string}
   * @default "indexed"
   * @example
   * axis: {
   *   y: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_y_type: undefined,

  /**
   * Set max value of y axis.
   * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․max
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     max: 1000
   *   }
   * }
   */
  axis_y_max: undefined,

  /**
   * Set min value of y axis.
   * - **NOTE:**
   *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․min
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     min: 1000
   *   }
   * }
   */
  axis_y_min: undefined,

  /**
   * Change the direction of y axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y․inverted
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inverted: true
   *   }
   * }
   */
  axis_y_inverted: !1,

  /**
   * Set center value of y axis.
   * @name axis․y․center
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     center: 0
   *   }
   * }
   */
  axis_y_center: undefined,

  /**
   * Show y axis inside of the chart.
   * @name axis․y․inner
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inner: true
   *   }
   * }
   */
  axis_y_inner: !1,

  /**
   * Set label on y axis.<br><br>
   * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y․label
   * @memberof Options
   * @type {string|object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y: {
   *     label: "Your Y Axis"
   *   }
   * }
   *
   * axis: {
   *   y: {
   *     label: {
   *        text: "Your Y Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y_label: {},

  /**
   * Set formatter for y axis tick text.<br><br>
   * This option accepts d3.format object as well as a function you define.
   * @name axis․y․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 5
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_culling_max: 5,

  /**
   * Show y axis outer tick.
   * @name axis․y․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y_tick_outer: !0,

  /**
   * Set y axis tick values manually.
   * @name axis․y․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_values: null,

  /**
   * Rotate y axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y_tick_rotate: 0,

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y_tick_count: undefined,

  /**
   * Show or hide y axis tick line.
   * @name axis․y․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
   * @name axis․y․tick․stepSize
   * @memberof Options
   * @type {number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y_tick_stepSize: null,

  /**
   * Show or hide y axis tick text.
   * @name axis․y․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_show: !0,

  /**
   * Set the y Axis tick text's position relatively its original position
   * @name axis․y․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․time
   * @memberof Options
   * @private
   * @type {object}
   * @property {object} time time object
   * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       time: {
   *          // ticks at 15-minute intervals
   *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
   *          value: d3.timeMinute.every(15)
   *       }
   *     }
   *   }
   * }
   */
  // @TODO: not fully implemented yet
  axis_y_tick_time_value: undefined,

  /**
   * Set padding for y axis.<br><br>
   * You can set padding for y axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:**
   *   - Given values are translated relative to the y Axis domain value for padding
   *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   y: {
   *     padding: {
   *       top: 0,
   *       bottom: 0
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_y_padding: {},

  /**
   * Set default range of y axis.<br><br>
   * This option set the default value for y axis when there is no data on init.
   * @name axis․y․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y_default: undefined,

  /**
   * Set additional axes for y Axis.
   * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y2.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y2 Axis  config options
 */
/* harmony default export */ var axis_y2 = ({
  /**
   * Show or hide y2 axis.
   * - **NOTE**:
   *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
   *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
   * @name axis․y2․show
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     show: true
   *   }
   * }
   */
  axis_y2_show: !1,

  /**
   * Set max value of y2 axis.
   * @name axis․y2․max
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     max: 1000
   *   }
   * }
   */
  axis_y2_max: undefined,

  /**
   * Set min value of y2 axis.
   * @name axis․y2․min
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     min: -1000
   *   }
   * }
   */
  axis_y2_min: undefined,

  /**
   * Change the direction of y2 axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y2․inverted
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inverted: true
   *   }
   * }
   */
  axis_y2_inverted: !1,

  /**
   * Set center value of y2 axis.
   * @name axis․y2․center
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     center: 0
   *   }
   * }
   */
  axis_y2_center: undefined,

  /**
   * Show y2 axis inside of the chart.
   * @name axis․y2․inner
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inner: true
   *   }
   * }
   */
  axis_y2_inner: !1,

  /**
   * Set label on y2 axis.<br><br>
   * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y2․label
   * @memberof Options
   * @type {string|object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y2: {
   *     label: "Your Y2 Axis"
   *   }
   * }
   *
   * axis: {
   *   y2: {
   *     label: {
   *        text: "Your Y2 Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y2_label: {},

  /**
   * Set formatter for y2 axis tick text.<br><br>
   * This option works in the same way as axis.y.format.
   * @name axis․y2․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       format: d3.format("$,")
   *       //or format: function(d) { return "$" + d; }
   *     }
   *   }
   * }
   */
  axis_y2_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y2․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y2․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 5
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling_max: 5,

  /**
   * Show or hide y2 axis outer tick.
   * @name axis․y2․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_outer: !0,

  /**
   * Set y2 axis tick values manually.
   * @name axis․y2․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_values: null,

  /**
   * Rotate y2 axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y2․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y2_tick_rotate: 0,

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y2_tick_count: undefined,

  /**
   * Show or hide y2 axis tick line.
   * @name axis․y2․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
   * @name axis․y2․tick․stepSize
   * @memberof Options
   * @type {number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y2_tick_stepSize: null,

  /**
   * Show or hide y2 axis tick text.
   * @name axis․y2․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_show: !0,

  /**
   * Set the y2 Axis tick text's position relatively its original position
   * @name axis․y2․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set padding for y2 axis.<br><br>
   * You can set padding for y2 axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:**
   *   - Given values are translated relative to the y2 Axis domain value for padding
   *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y2․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   y2: {
   *     padding: {
   *       top: 100,
   *       bottom: 100
   *     }
   *
   *     // or set both values at once.
   *     padding: 10
   * }
   */
  axis_y2_padding: {},

  /**
   * Set default range of y2 axis.<br><br>
   * This option set the default value for y2 axis when there is no data on init.
   * @name axis․y2․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y2_default: undefined,

  /**
   * Set additional axes for y2 Axis.
   * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y2․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y2: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y2 Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y2_axes: []
});
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(38);

// CONCATENATED MODULE: ./src/module/browser.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @private
 */

/* eslint-disable no-new-func, no-undef */


var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */
// CONCATENATED MODULE: ./src/module/util.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */






var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isboolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof v === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return Array.isArray(arr);
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
};

/**
 * Get specified key value from object
 * If default value is given, will return if given key value not found
 * @param {object} options Source object
 * @param {string} key Key value
 * @param {*} defaultValue Default value
 * @returns {*}
 * @private
 */
function getOption(options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
}
/**
 * Check if value exist in the given object
 * @param {object} dict Target object to be checked
 * @param {*} value Value to be checked
 * @returns {boolean}
 * @private
 */


function hasValue(dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
}
/**
 * Call function with arguments
 * @param {Function} fn Function to be called
 * @param {*} args Arguments
 * @returns {boolean} true: fn is function, false: fn is not function
 * @private
 */


function callFn(fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
}
/**
 * Call function after all transitions ends
 * @param {d3.transition} transition Transition
 * @param {Fucntion} cb Callback function
 * @private
 */


function endall(transition, cb) {
  var n = 0;
  transition.each(function () {
    return ++n;
  }).on("end", function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];

    --n || cb.apply.apply(cb, [this].concat(args));
  });
}
/**
 * Replace tag sign to html entity
 * @param {string} str Target string value
 * @returns {string}
 * @private
 */


function sanitise(str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
}
/**
 * Set text value. If there's multiline add nodes.
 * @param {d3Selection} node Text node
 * @param {string} text Text value string
 * @param {Array} dy dy value for multilined text
 * @param {boolean} toMiddle To be alingned vertically middle
 * @private
 */


function setTextValue(node, text, dy, toMiddle) {
  if (dy === void 0 && (dy = [-1, 1]), toMiddle === void 0 && (toMiddle = !1), node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", (i === 0 ? dy[0] * len : dy[1]) + "em").text(v);
      });
    }
  }
}
/**
 * Substitution of SVGPathSeg API polyfill
 * @param {SVGGraphicsElement} path Target svg element
 * @returns {Array}
 * @private
 */


function getRectSegList(path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
}
/**
 * Get svg bounding path box dimension
 * @param {SVGGraphicsElement} path Target svg element
 * @returns {object}
 * @private
 */


function getPathBox(path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Return brush selection array
 * @param {object} $el Selection object
 * @returns {d3.brushSelection}
 * @private
 */


function getBrushSelection(_ref) {
  var selection,
      $el = _ref.$el,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = $el.subchart.main || $el.main;
  return event && event.type === "brush" ? selection = event.selection : main && (selection = main.select("." + config_classes.brush).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
}
/**
 * Get boundingClientRect.
 * Cache the evaluated value once it was called.
 * @param {HTMLElement} node Target element
 * @returns {object}
 * @private
 */


var getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
};
/**
 * Retrun random number
 * @param {boolean} asStr Convert returned value as string
 * @returns {number|string}
 * @private
 */


function getRandom(asStr) {
  asStr === void 0 && (asStr = !0);
  var rand = Math.random();
  return asStr ? rand + "" : rand;
}
/**
 * Check if brush is empty
 * @param {object} ctx Bursh context
 * @returns {boolean}
 * @private
 */


function brushEmpty(ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
}
/**
 * Extend target from source object
 * @param {object} target Target object
 * @param {object} source Source object
 * @returns {object}
 * @private
 */


function extend(target, source) {
  // exclude name with only numbers
  for (var p in target === void 0 && (target = {}), isArray(source) && source.forEach(function (v) {
    return extend(target, v);
  }), source) /^\d+$/.test(p) || (target[p] = source[p]);

  return target;
}
/**
 * Return first letter capitalized
 * @param {string} str Target string
 * @returns {string} capitalized string
 * @private
 */


var capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
};
/**
 * Convert to array
 * @param {object} v Target to be converted
 * @returns {Array}
 * @private
 */


/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
function getCssRules(styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
    }
  }), rules;
}
/**
 * Gets the SVGMatrix of an SVGGElement
 * @param {SVGElement} node Node element
 * @returns {SVGMatrix} matrix
 * @private
 */


var getTranslation = function (node) {
  var transform = node ? node.transform : null,
      baseVal = transform && transform.baseVal;
  return baseVal && baseVal.numberOfItems ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
};
/**
 * Get unique value from array
 * @param {Array} data Source data
 * @returns {Array} Unique array value
 * @private
 */


function getUnique(data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
}
/**
 * Merge array
 * @param {Array} arr Source array
 * @returns {Array}
 * @private
 */


function mergeArray(arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
}
/**
 * Merge object returning new object
 * @param {object} target Target object
 * @param {object} objectN Source object
 * @returns {object} merged target object
 * @private
 */


function mergeObj(target) {
  for (var _len3 = arguments.length, objectN = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) objectN[_key3 - 1] = arguments[_key3];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}
/**
 * Sort value
 * @param {Array} data value to be sorted
 * @param {boolean} isAsc true: asc, false: desc
 * @returns {number|string|Date} sorted date
 * @private
 */


function util_sortValue(data, isAsc) {
  isAsc === void 0 && (isAsc = !0);
  var fn;
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
}
/**
 * Get min/max value
 * @param {string} type 'min' or 'max'
 * @param {Array} data Array data value
 * @returns {number|Date|undefined}
 * @private
 */


function getMinMax(type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, res) : res[0] instanceof Date && (res = util_sortValue(res, type === "min")[0]) : res = undefined, res;
}
/**
 * Get range
 * @param {number} start Start number
 * @param {number} end End number
 * @param {number} step Step number
 * @returns {Array}
 * @private
 */


var getRange = function (start, end, step) {
  step === void 0 && (step = 1);
  var res = [],
      n = Math.max(0, Math.ceil((end - start) / step)) | 0;

  for (var i = start; i < n; i++) res.push(start + i * step);

  return res;
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType, params) {
        params === void 0 && (params = getParams()), el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType, params) {
        params === void 0 && (params = getParams());
        var mouseEvent = browser_doc.createEvent("MouseEvent"); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
}; // emulate event


/**
 * Process the template  & return bound string
 * @param {string} tpl Template string
 * @param {object} data Data value to be replaced
 * @returns {string}
 * @private
 */
function tplProcess(tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=" + x + "}", "g"), data[x]);

  return res;
}
/**
 * Get parsed date value
 * (It must be called in 'ChartInternal' context)
 * @param {Date|string|number} date Value of date to be parsed
 * @returns {Date}
 * @private
 */


function parseDate(date) {
  var parsedDate;
  if (date instanceof Date) parsedDate = date;else if (isString(date)) {
    var config = this.config,
        format = this.format;
    parsedDate = format.dataTime(config.data_xFormat)(date);
  } else isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date));
  return (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
}
/**
 * Return if the current doc is visible or not
 * @returns {boolean}
 * @private
 */


function isTabVisible() {
  return !browser_doc.hidden;
}
/**
 * Get the current input type
 * @param {boolean} mouse Config value: interaction.inputType.mouse
 * @param {boolean} touch Config value: interaction.inputType.touch
 * @returns {string} "mouse" | "touch" | null
 * @private
 */


function convertInputType(mouse, touch) {
  var isMobile = !1; // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop

  if (/Mobi/.test(win.navigator.userAgent) && touch) {
    // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
    var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
        hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
    // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

    isMobile = hasTouchPoints || hasTouch;
  }

  var hasMouse = !(!mouse || isMobile) && "onmouseover" in win;
  return hasMouse && "mouse" || isMobile && "touch" || null;
}
// CONCATENATED MODULE: ./src/config/Options/axis/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * y Axis  config options
 */

/* harmony default export */ var axis_axis = (mergeObj({
  /**
   * Switch x and y axis position.
   * @name axis․rotated
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   rotated: true
   * }
   */
  axis_rotated: !1
}, axis_x, axis_y, axis_y2));
// CONCATENATED MODULE: ./src/config/Options/common/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * grid config options
 */
/* harmony default export */ var common_grid = ({
  /**
   * Set related options
   * @name grid
   * @memberof Options
   * @type {object}
   * @property {boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
   * @property {object} x Grid x object
   * @property {boolean} [x.show=false] Show grids along x axis.
   * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
   *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
   *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
   * @property {object} y Grid y object
   * @property {boolean} [y.show=false] Show grids along x axis.
   * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
   *  This option accepts array including object that has value, text, position and class.
   * @property {number} [y.ticks=10] Number of y grids to be shown.
   * @property {object} focus Grid focus object
   * @property {boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {boolean} [focus.show=true] Show grid line when focus.
   * @property {boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {object} lines Grid lines object
   * @property {boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
   * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
   * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
   * @example
   * grid: {
   *   x: {
   *     show: true,
   *     lines: [
   *       {value: 2, text: "Label on 2"},
   *       {value: 5, text: "Label on 5", class: "label-5"},
   *       {value: 6, text: "Label on 6", position: "start"}
   *     ]
   *   },
   *   y: {
   *     show: true,
   *     lines: [
   *       {value: 100, text: "Label on 100"},
   *       {value: 200, text: "Label on 200", class: "label-200"},
   *       {value: 300, text: "Label on 300", position: 'middle'}
   *     ],
   *     ticks: 5
   *   },
   *   front: true,
   *   focus: {
   *      show: false,
   *
   *      // Below options are available when 'tooltip.grouped=false' option is set
   *      edge: true,
   *      y: true
   *   },
   *   lines: {
   *      front: false
   *   }
   * }
   */
  grid_x_show: !1,
  grid_x_type: "tick",
  grid_x_lines: [],
  grid_y_show: !1,
  grid_y_lines: [],
  grid_y_ticks: 10,
  grid_focus_edge: !1,
  grid_focus_show: !0,
  grid_focus_y: !1,
  grid_front: !1,
  grid_lines_front: !0
});
// CONCATENATED MODULE: ./src/config/Options/common/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * point config options
 */
/* harmony default export */ var common_point = ({
  /**
   * Set point options
   * @name point
   * @memberof Options
   * @type {object}
   * @property {object} point Point object
   * @property {boolean} [point.show=true] Whether to show each point in line.
   * @property {number|Function} [point.r=2.5] The radius size of each point.
   *  - **NOTE:** Disabled for 'bubble' type
   * @property {boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
   * @property {number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
   *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
   * @property {boolean} [point.focus.only=false] Show point only when is focused.
   * @property {number} [point.sensitivity=10] The senstivity value for interaction boundary.
   * @property {number} [point.select.r=point.r*4] The radius size of each point on selected.
   * @property {string} [point.type="circle"] The type of point to be drawn
   * - **NOTE:**
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
   * - **NOTE:**
   *   - This is an `experimental` feature and can have some unexpected behaviors.
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   *   - svg shape tag interpreted as string<br>
   *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
   * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
   * @example
   *  point: {
   *      show: false,
   *      r: 5,
   *
   *      // or customize the radius
   *      r: function(d) {
   *          ...
   *          return r;
   *      },
   *
   *      focus: {
   *          expand: {
   *              enabled: true,
   *              r: 1
   *          },
   *          only: true
   *      },
   *      select: {
   *          r: 3
   *      },
   *
   *      // having lower value, means how closer to be for interaction
   *      sensitivity: 3,
   *
   *      // valid values are "circle" or "rectangle"
   *      type: "rectangle",
   *
   *      // or indicate as pattern
   *      pattern: [
   *        "circle",
   *        "rectangle",
   *        "<polygon points='0 6 4 0 -4 0'></polygon>"
   *     ],
   *  }
   */
  point_show: !0,
  point_r: 2.5,
  point_sensitivity: 10,
  point_focus_expand_enabled: !0,
  point_focus_expand_r: undefined,
  point_focus_only: !1,
  point_pattern: [],
  point_select_r: undefined,
  point_type: "circle"
});
// CONCATENATED MODULE: ./src/config/Options/common/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var common_subchart = ({
  /**
   * Set subchart options
   * @name subchart
   * @memberof Options
   * @type {object}
   * @property {object} subchart Subchart object
   * @property {boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
   * @property {boolean} [subchart.axis.x.show=true] Show or hide x axis.
   * @property {boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
   * @property {boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
   * @property {number} [subchart.size.height] Change the height of the subchart.
   * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
   *  Specified function receives the current zoomed x domain.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
   * @example
   *  subchart: {
   *      axis: {
   *      	x: {
   *      	  show: true,
   *      	    tick: {
   *      	      show: true,
   *      	      text: {
   *      	        show: false
   *      	      }
   *      	    }
   *      	}
   *      },
   *      show: true,
   *      size: {
   *          height: 20
   *      },
   *      onbrush: function(domain) { ... }
   *  }
   */
  subchart_show: !1,
  subchart_size_height: 60,
  subchart_axis_x_show: !0,
  subchart_axis_x_tick_show: !0,
  subchart_axis_x_tick_text_show: !0,
  subchart_onbrush: function subchart_onbrush() {}
});
// CONCATENATED MODULE: ./src/config/Options/common/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * zoom config options
 */
/* harmony default export */ var common_zoom = ({
  /**
   * Set zoom options
   * @name zoom
   * @memberof Options
   * @type {object}
   * @property {object} zoom Zoom object
   * @property {boolean} [zoom.enabled=false] Enable zooming.
   * @property {string} [zoom.enabled.type='wheel'] Set zoom interaction type.
   *  - **Available types:**
   *    - wheel
   *    - drag
   * @property {boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
   *  If true set, y domain will be updated according to the zoomed region.
   * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
   * @property {number|Date} [zoom.x.min] Set x Axis minimum zoom range
   * @property {number|Date} [zoom.x.max] Set x Axis maximum zoom range
   * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
   *  Specified function receives the zoom event.
   * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
   *  Specified function receives the zoomed domain.
   * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
   *  Specified function receives the zoomed domain.
   * @property {boolean|object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
   * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
   * @property {string} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
   * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
   * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
   * @example
   *  zoom: {
   *      enabled: {
   *          type: "drag"
   *      },
   *      rescale: true,
   *      extent: [1, 100]  // enable more zooming
   *      x: {
   *          min: -1,  // set min range
   *          max: 10  // set max range
   *      },
   *      onzoomstart: function(event) { ... },
   *      onzoom: function(domain) { ... },
   *      onzoomend: function(domain) { ... },
   *
   *      // show reset button when is zoomed-in
   *      resetButton: true,
   *
   *      resetButton: {
   *          // onclick callback when reset button is clicked
   *          onclick: function(button) {
   *            button; // Reset button element reference
   *            ...
   *          },
   *
   *          // customized text value for reset zoom button
   *          text: "Unzoom"
   *      }
   *  }
   */
  zoom_enabled: undefined,
  zoom_extent: undefined,
  zoom_privileged: !1,
  zoom_rescale: !1,
  zoom_onzoom: undefined,
  zoom_onzoomstart: undefined,
  zoom_onzoomend: undefined,
  zoom_resetButton: !0,
  zoom_x_min: undefined,
  zoom_x_max: undefined
});
// CONCATENATED MODULE: ./src/config/Options/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * area config options
 */
/* harmony default export */ var shape_area = ({
  /**
   * Set area options
   * @name area
   * @memberof Options
   * @type {object}
   * @property {object} area Area object
   * @property {boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
   * @property {boolean} [area.above=false] Set background area above the data chart line.
   * @property {boolean|object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
   * Or customize by giving below object value:
   *  - x {Array}: `x1`, `x2` value
   *  - y {Array}: `y1`, `y2` value
   *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
   * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
   * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
   * @example
   *  area: {
   *      zerobased: false,
   *      above: true,
   *
   *      // will generate follwing linearGradient:
   *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
   *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
   *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
   *      // </linearGradient>
   *      linearGradient: true,
   *
   *      // Or customized gradient
   *      linearGradient: {
   *      	x: [0, 0],  // x1, x2 attributes
   *      	y: [0, 0],  // y1, y2 attributes
   *      	stops: [
   *      	  // offset, stop-color, stop-opacity
   *      	  [0, "#7cb5ec", 1],
   *
   *      	  // setting 'null' for stop-color, will set its original data color
   *      	  [0.5, null, 0],
   *
   *      	  // setting 'function' for stop-color, will pass data id as argument.
   *      	  // It should return color string or null value
   *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
   *      	]
   *      }
   *  }
   */
  area_zerobased: !0,
  area_above: !1,
  area_linearGradient: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bar config options
 */
/* harmony default export */ var shape_bar = ({
  /**
   * Set bar options
   * @name bar
   * @memberof Options
   * @type {object}
   * @property {object} bar Bar object
   * @property {number} [bar.padding=0] The padding pixel value between each bar.
   * @property {number} [bar.radius] Set the radius of bar edge in pixel.
   * - **NOTE:** Works only for non-stacked bar
   * @property {number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
   * @property {number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
   * @property {number} [bar.width] Change the width of bar chart.
   * @property {number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
   * @property {number} [bar.width.max] The maximum width value for ratio.
   * @property {number} [bar.width.dataname] Change the width of bar for indicated dataset only.
   * - **NOTE:**
   *   - Works only for non-stacked bar
   *   - Bars are centered accoding its total width value
   * @property {number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
   * @property {number} [bar.width.dataname.max] The maximum width value for ratio.
   * @property {boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
   * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
   * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
   * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
   * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
   * @example
   *  bar: {
   *      padding: 1,
   *
   *      // the 'radius' option can be used only for non-stacking bars
   *      radius: 10,
   *      // or
   *      radius: {
   *          ratio: 0.5
   *      }
   *
   *      // will not have offset between each bar elements for interaction
   *      sensitivity: 0,
   *
   *      width: 10,
   *
   *      // or
   *      width: {
   *          ratio: 0.2,
   *          max: 20
   *      },
   *
   *      // or specify width per dataset
   *      width: {
   *          data1: 20,
   *          data2: {
   *              ratio: 0.2,
   *              max: 20
   *          }
   *      },
   *
   *      zerobased: false
   *  }
   */
  bar_padding: 0,
  bar_radius: undefined,
  bar_radius_ratio: undefined,
  bar_sensitivity: 2,
  bar_width: undefined,
  bar_width_ratio: .6,
  bar_width_max: undefined,
  bar_zerobased: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bubble config options
 */
/* harmony default export */ var bubble = ({
  /**
   * Set bubble options
   * @name bubble
   * @memberof Options
   * @type {object}
   * @property {object} bubble bubble object
   * @property {number|Function} [bubble.maxR=35] Set the max bubble radius value
   * @property {boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
   * @example
   *  bubble: {
   *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
   *      // And the lesser will have radius relatively from tha max value.
   *      maxR: 50,
   *
   *      // or set radius callback
   *      maxR: function(d) {
   *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
   *          ...
   *          return Math.sqrt(d.value * 2);
   *      },
   *      zerobased: false
   *  }
   */
  bubble_maxR: 35,
  bubble_zerobased: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * line config options
 */
/* harmony default export */ var shape_line = ({
  /**
   * Set line options
   * @name line
   * @memberof Options
   * @type {object}
   * @property {object} line Line object
   * @property {boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
   *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
   * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
   * @property {boolean} [line.step.type=step] Change step type for step chart.<br>
   * **Available values:**
   * - step
   * - step-before
   * - step-after
   * @property {boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
   * @property {boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
   * @example
   *  line: {
   *      connectNull: true,
   *      classes: [
   *          "line-class1",
   *          "line-class2"
   *      ],
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  line_connectNull: !1,
  line_step_type: "step",
  line_zerobased: !1,
  line_classes: undefined,
  line_point: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/spline.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var spline = ({
  /**
   * Set spline options
   * - **Available interpolation type values:**
   *  - basis (d3.curveBasis)
   *  - basis-closed (d3.curveBasisClosed)
   *  - basis-open (d3.curveBasisOpen)
   *  - bundle (d3.curveBundle)
   *  - cardinal (d3.curveCardinal)
   *  - cardinal-closed (d3.curveCardinalClosed)
   *  - cardinal-open (d3.curveCardinalOpen)
   *  - catmull-rom (d3.curveCatmullRom)
   *  - catmull-rom-closed (d3.curveCatmullRomClosed)
   *  - catmull-rom-open (d3.curveCatmullRomOpen)
   *  - monotone-x (d3.curveMonotoneX)
   *  - monotone-y (d3.curveMonotoneY)
   *  - natural (d3.curveNatural)
   *  - linear-closed (d3.curveLinearClosed)
   *  - linear (d3.curveLinear)
   *  - step (d3.curveStep)
   *  - step-after (d3.curveStepAfter)
   *  - step-before (d3.curveStepBefore)
   * @name spline
   * @memberof Options
   * @type {object}
   * @property {object} spline Spline object
   * @property {object} spline.interpolation Spline interpolation object
   * @property {string} [spline.interpolation.type="cardinal"] Interpolation type
   * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
   * @example
   *  spline: {
   *      interpolation: {
   *          type: "cardinal"
   *      }
   *  }
   */
  spline_interpolation_type: "cardinal"
});
// CONCATENATED MODULE: ./src/config/Options/shape/donut.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * donut config options
 */
/* harmony default export */ var donut = ({
  /**
   * Set donut options
   * @name donut
   * @memberof Options
   * @type {object}
   * @property {object} donut Donut object
   * @property {boolean} [donut.label.show=true] Show or hide label on each donut piece.
   * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
   * @property {number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
   * @property {boolean} [donut.expand=true] Enable or disable expanding donut pieces.
   * @property {number} [donut.expand.rate=0.98] Set expand rate.
   * @property {number} [donut.expand.duration=50] Set expand transition time in ms.
   * @property {number} [donut.width] Set width of donut chart.
   * @property {string} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
   * @property {number} [donut.padAngle=0] Set padding between data.
   * @property {number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  donut: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *          	...
   *          	return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      width: 10,
   *      padAngle: 0.2,
   *      startingAngle: 1,
   *      title: "Donut Title"
   *
   *      // title with line break
   *      title: "Title1\nTitle2"
   *  }
   */
  donut_label_show: !0,
  donut_label_format: undefined,
  donut_label_threshold: .05,
  donut_label_ratio: undefined,
  donut_width: undefined,
  donut_title: "",
  donut_expand: {},
  donut_expand_rate: .98,
  donut_expand_duration: 50,
  donut_padAngle: 0,
  donut_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/gauge.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * gauge config options
 */
/* harmony default export */ var gauge = ({
  /**
   * Set gauge options
   * @name gauge
   * @memberof Options
   * @type {object}
   * @property {object} gauge Gauge object
   * @property {boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
   * @property {boolean} [gauge.label.show=true] Show or hide label on gauge.
   * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
   * @property {Function} [gauge.label.extents] Set customized min/max label text.
   * @property {boolean} [gauge.expand=true] Enable or disable expanding gauge.
   * @property {number} [gauge.expand.rate=0.98] Set expand rate.
   * @property {number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
   * @property {number} [gauge.min=0] Set min value of the gauge.
   * @property {number} [gauge.max=100] Set max value of the gauge.
   * @property {number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
   * @property {string} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
   * @property {string} [gauge.units] Set units of the gauge.
   * @property {number} [gauge.width] Set width of gauge chart.
   * @property {string} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
   * **Available Values:**
   * - single
   * - multi
   * @property {string} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
   * @example
   *  gauge: {
   *      fullCircle: false,
   *      label: {
   *          show: false,
   *          format: function(value, ratio) {
   *              return value;
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          extents: function(value, isMax) {
   *              return (isMax ? "Max:" : "Min:") + value;
   *          }
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      min: -100,
   *      max: 200,
   *      type: "single"  // or 'multi'
   *      title: "Title Text",
   *      units: "%",
   *      width: 10,
   *      arcs: {
   *          minWidth: 5
   *      }
   *  }
   */
  gauge_fullCircle: !1,
  gauge_label_show: !0,
  gauge_label_format: undefined,
  gauge_label_extents: undefined,
  gauge_min: 0,
  gauge_max: 100,
  gauge_type: "single",
  gauge_startingAngle: -1 * Math.PI / 2,
  gauge_title: "",
  gauge_units: undefined,
  gauge_width: undefined,
  gauge_arcs_minWidth: 5,
  gauge_expand: {},
  gauge_expand_rate: .98,
  gauge_expand_duration: 50
});
// CONCATENATED MODULE: ./src/config/Options/shape/pie.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var pie = ({
  /**
   * Set pie options
   * @name pie
   * @memberof Options
   * @type {object}
   * @property {object} pie Pie object
   * @property {boolean} [pie.label.show=true] Show or hide label on each pie piece.
   * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
   * @property {number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
   * @property {boolean|object} [pie.expand=true] Enable or disable expanding pie pieces.
   * @property {number} [pie.expand.rate=0.98] Set expand rate.
   * @property {number} [pie.expand.duration=50] Set expand transition time in ms.
   * @property {number|object} [pie.innerRadius=0] Sets the inner radius of pie arc.
   * @property {number} [pie.padAngle=0] Set padding between data.
   * @property {number} [pie.padding=0] Sets the gap between pie arcs.
   * @property {object} donut Donut object
   * @property {number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  pie: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *              ...
   *              return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      innerRadius: 0,
   *
   *      // set different innerRadius for each data
   *      innerRadius: {
   *      	data1: 10,
   *      	data2: 0
   *      }
   *
   *      padAngle: 0.1,
   *      padding: 0,
   *      startingAngle: 1
   *  }
   */
  pie_label_show: !0,
  pie_label_format: undefined,
  pie_label_threshold: .05,
  pie_label_ratio: undefined,
  pie_expand: {},
  pie_expand_rate: .98,
  pie_expand_duration: 50,
  pie_innerRadius: 0,
  pie_padAngle: 0,
  pie_padding: 0,
  pie_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var radar = ({
  /**
   * Set radar options
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break.
   * @name radar
   * @memberof Options
   * @type {object}
   * @property {object} radar Radar object
   * @property {number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
   * @property {boolean} [radar.axis.line.show=true] Show or hide axis line.
   * @property {number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
   * @property {number} [radar.axis.text.position.y=0] y coordinate position, relative the original.
   * @property {boolean} [radar.axis.text.show=true] Show or hide axis text.
   * @property {boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
   * @property {number} [radar.level.depth=3] Set the level depth.
   * @property {boolean} [radar.level.show=true] Show or hide level.
   * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
   * @property {boolean} [radar.level.text.show=true] Show or hide level text.
   * @property {number} [radar.size.ratio=0.87] Set size ratio.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
   * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
   * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
   * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
   * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
   * @example
   *  radar: {
   *      axis: {
   *          max: 50,
   *          line: {
   *              show: false
   *          },
   *          text: {
   *              position: {
   *              	x: 0,
   *              	y: 0
   *              },
   *              show: false
   *          }
   *      },
   *      direction: {
   *          clockwise: true
   *      },
   *      level: {
   *          show: false,
   *          text: {
   *              format: function(x) {
   *                  return x + "%";
   *              },
   *              show: true
   *          }
   *      },
   *      size: {
   *          ratio: 0.7
   *      }
   *  }
   */
  radar_axis_max: undefined,
  radar_axis_line_show: !0,
  radar_axis_text_show: !0,
  radar_axis_text_position: {},
  radar_level_depth: 3,
  radar_level_show: !0,
  radar_level_text_format: function radar_level_text_format(x) {
    return x % 1 === 0 ? x : x.toFixed(2);
  },
  radar_level_text_show: !0,
  radar_size_ratio: .87,
  radar_direction_clockwise: !1
});
// CONCATENATED MODULE: ./src/config/Options/Options.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// common





 // Axis based












 // Non-Axis based






/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */

var Options = function () {
  var config = [data_data, common_color, interaction, common_legend, common_title, common_tooltip].concat([donut, gauge, pie, radar], [data_axis, data_selection, axis_axis, common_grid, common_point, common_subchart, common_zoom], [shape_area, shape_bar, bubble, shape_line, spline]);
  return mergeObj.apply(void 0, [{
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {string|HTMLElement|d3.selection|object} [bindto="#chart"] Specify the element where chart will be drawn.
     * @property {string|HTMLElement|d3.selection} bindto.element="#chart" Specify the element where chart will be drawn.
     * @property {string} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set chart background.
     * @name background
     * @memberof Options
     * @property {object} background background object
     * @property {string} background.class Specify the class name for background element.
     * @property {string} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
     * @property {string} background.imgUrl Specify the image url string for background.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
     * @example
     * background: {
     *    class: "myClass",
     *    color: "red",
     *
     *    // Set image url for background.
     *    // If specified, 'color' option will be ignored.
     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
     * }
     */
    background: {},

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {object}
     * @property {object} [svg] svg object
     * @property {string} [svg.classname] class name for svg element
     * @example
     * svg: {
     *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {object}
     * @property {object} [size] size object
     * @property {number} [size.width] width of the chart element
     * @property {number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
     *   width: 640,
     *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {object}
     * @property {object} [padding] padding object
     * @property {number} [padding.top] padding on the top of chart
     * @property {number} [padding.right] padding on the right of chart
     * @property {number} [padding.bottom] padding on the bottom of chart
     * @property {number} [padding.left] padding on the left of chart
     * @example
     * padding: {
     *   top: 20,
     *   right: 20,
     *   bottom: 20,
     *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {object}
     * @property {object} [resize] resize object
     * @property {boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * Set a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {object}
     * @property {object} [transition] transition object
     * @property {number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Set scatter options
     * @name scatter
     * @memberof Options
     * @type {object}
     * @property {object} [scatter] scatter object
     * @property {boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
     * @example
     *  scatter: {
     *      connectNull: true,
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ],
     *
     *      zerobased: false
     *  }
     */
    scatter_zerobased: !1,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {object}
     * @property {object} [render] render object
     * @property {boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class.
     * The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end.
     * If not specified, the edge values will be used.
     * If timeseries x axis, date string, Date object and unixtime integer can be used.
     * If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: []
  }].concat(config));
};


// CONCATENATED MODULE: ./src/module/Cache.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Constant for cache key
 * - NOTE: Prefixed with '$', will be resetted when .load() is called
 * @private
 */
var KEY = {
  bubbleBaseLength: "$baseLength",
  colorPattern: "__colorPattern__",
  dataMinMax: "$dataMinMax",
  dataTotalSum: "$dataTotalSum",
  dataTotalPerIndex: "$totalPerIndex",
  legendItemTextBox: "legendItemTextBox",
  radarPoints: "$radarPoints",
  textRect: "textRect"
};

var Cache_Cache = /*#__PURE__*/function () {
  function Cache() {
    _defineProperty(this, "cache", {});
  }

  var _proto = Cache.prototype;
  return _proto.add =
  /**
   * Add cache
   * @param {string} key Cache key
   * @param {*} value Value to be stored
   * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'
   * @returns {*} Added data value
   * @private
   */
  function add(key, value, isDataType) {
    return isDataType === void 0 && (isDataType = !1), this.cache[key] = isDataType ? this.cloneTarget(value) : value, this.cache[key];
  }
  /**
   * Remove cache
   * @param {string|Array} key Cache key
   * @private
   */
  , _proto.remove = function remove(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  }
  /**
   * Get cahce
   * @param {string|Array} key Cache key
   * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'
   * @returns {*}
   * @private
   */
  , _proto.get = function get(key, isDataType) {
    if (isDataType === void 0 && (isDataType = !1), isDataType) {
      for (var id, targets = [], i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  }
  /**
   * Reset cached data
   * @param {boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
   */
  , _proto.reset = function reset(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
  /**
   * Clone data target object
   * @param {object} target Data object
   * @returns {object}
   * @private
   */
  // eslint-disable-next-line camelcase
  , _proto.cloneTarget = function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  }, Cache;
}();


// CONCATENATED MODULE: ./src/module/generator.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


var generator_setTimeout = win.setTimeout,
    generator_clearTimeout = win.clearTimeout;
/**
 * Generate resize queue function
 * @returns {Fucntion}
 * @private
 */

function generateResize() {
  var timeout,
      fn = [],
      callResizeFn = function () {
    callResizeFn.clear(), timeout = generator_setTimeout(function () {
      fn.forEach(function (f) {
        return f();
      });
    }, 200);
  };

  return callResizeFn.clear = function () {
    timeout && (generator_clearTimeout(timeout), timeout = null);
  }, callResizeFn.add = function (f) {
    return fn.push(f);
  }, callResizeFn.remove = function (f) {
    return fn.splice(fn.indexOf(f), 1);
  }, callResizeFn;
}
/**
 * Generate transition queue function
 * @returns {Function}
 * @private
 */

function generateWait() {
  var transitionsToWait = [],
      f = function (t, callback) {
    // eslint-disable-next-line
    function loop() {
      for (var _t, done = 0, i = 0; _t = transitionsToWait[i]; i++) {
        if (_t === !0 || _t.empty && _t.empty()) {
          done++;
          continue;
        }

        try {
          _t.transition();
        } catch (e) {
          done++;
        }
      }

      timer && generator_clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = generator_setTimeout(loop, 50);
    }

    var timer;
    loop();
  };

  return f.add = function (t) {
    isArray(t) ? transitionsToWait = transitionsToWait.concat(t) : transitionsToWait.push(t);
  }, f;
}
// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(39);

// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(40);

// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRendererHelper.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper = /*#__PURE__*/function () {
  function AxisRendererHelper(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "scale", void 0);
    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node <g class=tick> node
   * @returns {{w: number, h: number}}
   * @private
   */


  AxisRendererHelper.getSizeFor1Char = function getSizeFor1Char(node) {
    // default size for one character
    var size = {
      w: 5.5,
      h: 11.5
    };
    return node.empty() || node.select("text").text("0").call(function (el) {
      try {
        var _el$node$getBBox = el.node().getBBox(),
            width = _el$node$getBBox.width,
            height = _el$node$getBBox.height;

        width && height && (size.w = width, size.h = height);
      } catch (e) {} finally {
        el.text("");
      }
    }), this.getSizeFor1Char = function () {
      return size;
    }, size;
  }
  /**
   * Get tick transform setter function
   * @param {string} id Axis id
   * @returns {Function} transfrom setter function
   * @private
   */
  ;

  var _proto = AxisRendererHelper.prototype;
  return _proto.getTickTransformSetter = function getTickTransformSetter(id) {
    var config = this.config,
        fn = id === "x" ? function (value) {
      return "translate(" + (value + config.tickOffset) + ",0)";
    } : function (value) {
      return "translate(0," + value + ")";
    };
    return function (selection, scale) {
      selection.attr("transform", function (d) {
        return fn(Math.ceil(scale(d)));
      });
    };
  }, _proto.scaleExtent = function scaleExtent(domain) {
    var start = domain[0],
        stop = domain[domain.length - 1];
    return start < stop ? [start, stop] : [stop, start];
  }, _proto.generateTicks = function generateTicks(scale, isYAxes) {
    var tickStepSize = this.owner.params.tickStepSize,
        ticks = [];
    // When 'axis[y|y2].tick.stepSize' option is set
    if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), start = _scale$domain[0], end = _scale$domain[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, this.config.tickArguments || []).map(function (v) {
      return (// round the tick value if is number
        isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
      );
    });else {
      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
    }
    return ticks;
  }, _proto.copyScale = function copyScale() {
    var newScale = this.scale.copy();
    return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
  }, _proto.textFormatted = function textFormatted(v) {
    var tickFormat = this.config.tickFormat,
        value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
        formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
    // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

    return isDefined(formatted) ? formatted : "";
  }, _proto.transitionise = function transitionise(selection) {
    var config = this.config;
    return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
  }, AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRenderer.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer = /*#__PURE__*/function () {
  function AxisRenderer(params) {
    params === void 0 && (params = {}), _defineProperty(this, "helper", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "params", void 0), _defineProperty(this, "g", void 0);
    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g Axis selection
   * @private
   */


  var _proto = AxisRenderer.prototype;
  return _proto.create = function create(g) {
    var ctx = this,
        config = this.config,
        helper = this.helper,
        params = this.params,
        scale = helper.scale,
        orient = config.orient,
        splitTickText = this.splitTickText.bind(this),
        isLeftRight = /^(left|right)$/.test(orient),
        isTopBottom = /^(top|bottom)$/.test(orient),
        tickTransform = helper.getTickTransformSetter(isTopBottom ? "x" : "y"),
        axisPx = tickTransform === helper.axisX ? "y" : "x",
        sign = /^(top|left)$/.test(orient) ? -1 : 1,
        rotate = params.tickTextRotate;
    this.config.range = scale.rangeExtent ? scale.rangeExtent() : helper.scaleExtent((params.orgXScale || scale).range());
    var $g,
        _config2 = config,
        innerTickSize = _config2.innerTickSize,
        tickLength = _config2.tickLength,
        range = _config2.range,
        id = params.id,
        tickTextPos = id && /^(x|y|y2)$/.test(id) ? params.config["axis_" + id + "_tick_text_position"] : {
      x: 0,
      y: 0
    },
        prefix = id === "subX" ? "subchart_axis_x" : "axis_" + id,
        axisShow = params.config[prefix + "_show"],
        tickShow = {
      tick: !!axisShow && params.config[prefix + "_tick_show"],
      text: !!axisShow && params.config[prefix + "_tick_text_show"]
    }; // // get the axis' tick position configuration

    g.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          scale0 = this.__chart__ || scale,
          scale1 = helper.copyScale();
      $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
      // update selection - data join
      var path = g.selectAll(".domain").data([0]); // enter + update selection

      if (path.enter().append("path").attr("class", "domain").merge(helper.transitionise(path)).attr("d", function () {
        var outerTickSized = config.outerTickSize * sign;
        return isTopBottom ? "M" + range[0] + "," + outerTickSized + "V0H" + range[1] + "V" + outerTickSized : "M" + outerTickSized + "," + range[0] + "H0V" + range[1] + "H" + outerTickSized;
      }), tickShow.tick || tickShow.text) {
        // count of tick data in array
        var ticks = config.tickValues || helper.generateTicks(scale1, isLeftRight),
            tick = g.selectAll(".tick").data(ticks, scale1),
            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
            tickExit = tick.exit().remove(); // update selection

        tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
        var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
            counts = [],
            tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
          var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helper.textFormatted(d)) ? helper.textFormatted(d).concat() : [helper.textFormatted(d)];
          return counts[index] = split.length, split.map(function (splitted) {
            return {
              index: index,
              splitted: splitted
            };
          });
        });
        tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
          return d.splitted;
        }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
          var dx = 0;
          return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
        }()).attr("dy", function (d, i) {
          var dy = 0;
          return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
        });
        var lineUpdate = tick.select("line"),
            textUpdate = tick.select("text");

        // Append <title> for tooltip display
        if (tickEnter.select("line").attr(axisPx + "2", innerTickSize * sign), tickEnter.select("text").attr(axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle) {
          var title = textUpdate.select("title");
          (title.empty() ? textUpdate.append("title") : title).text(function (index) {
            return params.tickTitle[index];
          });
        }

        if (scale1.bandwidth) {
          var x = scale1,
              dx = x.bandwidth() / 2;
          scale0 = function (d) {
            return x(d) + dx;
          }, scale1 = scale0;
        } else scale0.bandwidth ? scale0 = scale1 : tickTransform(tickExit, scale1);

        tickTransform(tickEnter, scale0), tickTransform(helper.transitionise(tick).style("opacity", "1"), scale1);
      }
    }), this.g = $g;
  }
  /**
   * Get tick x/y coordinate
   * @returns {{x: number, y: number}}
   * @private
   */
  , _proto.getTickXY = function getTickXY() {
    var config = this.config,
        pos = {
      x: 0,
      y: 0
    };
    return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
  }
  /**
   * Get tick size
   * @param {object} d data object
   * @returns {number}
   * @private
   */
  , _proto.getTickSize = function getTickSize(d) {
    var scale = this.helper.scale,
        config = this.config,
        _config3 = config,
        innerTickSize = _config3.innerTickSize,
        range = _config3.range,
        tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
    return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
  }
  /**
   * Set tick's line & text position
   * @param {d3.selection} lineUpdate Line selection
   * @param {d3.selection} textUpdate Text selection
   * @private
   */
  , _proto.setTickLineTextPosition = function setTickLineTextPosition(lineUpdate, textUpdate) {
    var tickPos = this.getTickXY(),
        _this$config = this.config,
        innerTickSize = _this$config.innerTickSize,
        orient = _this$config.orient,
        tickLength = _this$config.tickLength,
        tickOffset = _this$config.tickOffset,
        rotate = this.params.tickTextRotate,
        textAnchorForText = function (r) {
      var value = ["start", "end"];
      return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
    },
        textTransform = function (r) {
      return r ? "rotate(" + r + ")" : null;
    },
        yForText = function (r) {
      var r2 = r / (orient === "bottom" ? 15 : 23);
      return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
    };

    orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
  } // this should be called only when category axis
  , _proto.splitTickText = function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
    // split given text by tick width size
    // eslint-disable-next-line
    function split(splitted, text) {
      for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
      if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

      return splitted.concat(text);
    }

    var params = this.params,
        tickText = this.helper.textFormatted(d),
        splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
    if (splitted.length) return splitted;
    if (isArray(tickText)) return tickText;
    var tickWidth = params.tickWidth;
    return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
  }, _proto.scale = function scale(x) {
    return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
  }, _proto.orient = function orient(x) {
    return arguments.length ? (this.config.orient = x in {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    } ? x + "" : "bottom", this) : this.config.orient;
  }, _proto.tickFormat = function tickFormat(format) {
    var config = this.config;
    return arguments.length ? (config.tickFormat = format, this) : config.tickFormat;
  }, _proto.tickCentered = function tickCentered(isCentered) {
    var config = this.config;
    return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
  }
  /**
   * Return tick's offset value.
   * The value will be set for 'category' axis type.
   * @returns {number}
   * @private
   */
  , _proto.tickOffset = function tickOffset() {
    return this.config.tickOffset;
  }
  /**
   * Get tick interval count
   * @private
   * @param {number} size Total data size
   * @returns {number}
   */
  , _proto.tickInterval = function tickInterval(size) {
    var interval;
    if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
      var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
      interval = length / (size || this.g.selectAll("line").size());
    }
    return interval === Infinity ? 0 : interval;
  }, _proto.ticks = function ticks() {
    for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
  }, _proto.tickCulling = function tickCulling(culling) {
    var config = this.config;
    return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
  }, _proto.tickValues = function tickValues(x) {
    var _this = this,
        config = this.config;

    if (isFunction(x)) config.tickValues = function () {
      return x(_this.helper.scale.domain());
    };else {
      if (!arguments.length) return config.tickValues;
      config.tickValues = x;
    }
    return this;
  }, _proto.setTransition = function setTransition(t) {
    return this.config.transition = t, this;
  }, AxisRenderer;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/Axis.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






var Axis_Axis = /*#__PURE__*/function () {
  function Axis(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "x", void 0), _defineProperty(this, "subX", void 0), _defineProperty(this, "y", void 0), _defineProperty(this, "y2", void 0), _defineProperty(this, "axesList", {}), _defineProperty(this, "tick", {
      x: null,
      y: null,
      y2: null
    }), _defineProperty(this, "xs", []), _defineProperty(this, "orient", {
      x: "bottom",
      y: "left",
      y2: "right",
      subX: "bottom"
    }), this.owner = owner, this.setOrient();
  }

  var _proto = Axis.prototype;
  return _proto.getAxisClassName = function getAxisClassName(id) {
    return config_classes.axis + " " + config_classes["axis" + capitalize(id)];
  }, _proto.isHorizontal = function isHorizontal($$, forHorizontal) {
    var isRotated = $$.config.axis_rotated;
    return forHorizontal ? isRotated : !isRotated;
  }, _proto.isCategorized = function isCategorized() {
    var _this$owner = this.owner,
        config = _this$owner.config,
        state = _this$owner.state;
    return config.axis_x_type.indexOf("category") >= 0 || state.hasRadar;
  }, _proto.isCustomX = function isCustomX() {
    var config = this.owner.config;
    return !this.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  }, _proto.isTimeSeries = function isTimeSeries(id) {
    id === void 0 && (id = "x");
    var config = this.owner.config;
    return config["axis_" + id + "_type"] === "timeseries";
  }, _proto.isTimeSeriesY = function isTimeSeriesY() {
    return this.isTimeSeries("y");
  }, _proto.init = function init() {
    var _this = this,
        $$ = this.owner,
        config = $$.config,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        axis = _$$$$el.axis,
        clip = $$.state.clip,
        isRotated = config.axis_rotated,
        target = ["x", "y"];

    config.axis_y2_show && target.push("y2"), target.forEach(function (v) {
      var classAxis = _this.getAxisClassName(v),
          classLabel = config_classes["axis" + v.toUpperCase() + "Label"];

      axis[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
        var res = null;
        return v === "x" ? res = clip.pathXAxis : v === "y" && config.axis_y_inner && (res = clip.pathYAxis), res;
      }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_" + v + "_show"] ? "visible" : "hidden"), axis[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", function () {
        return _this.textAnchorForAxisLabel(v);
      }), _this.generateAxes(v);
    });
  }
  /**
   * Set axis orient according option value
   * @private
   */
  , _proto.setOrient = function setOrient() {
    var $$ = this.owner,
        _$$$config = $$.config,
        isRotated = _$$$config.axis_rotated,
        yInner = _$$$config.axis_y_inner,
        y2Inner = _$$$config.axis_y2_inner;
    this.orient = {
      x: isRotated ? "left" : "bottom",
      y: isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left",
      y2: isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right",
      subX: isRotated ? "left" : "bottom"
    };
  }
  /**
   * Generate axes
   * It's used when axis' axes option is set
   * @param {string} id Axis id
   * @private
   */
  , _proto.generateAxes = function generateAxes(id) {
    var d3Axis,
        $$ = this.owner,
        config = $$.config,
        axes = [],
        axesConfig = config["axis_" + id + "_axes"],
        isRotated = config.axis_rotated;
    id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
      var tick = v.tick || {},
          scale = $$.scale[id].copy();
      v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(isFunction(tick.format) ? tick.format.bind($$.api) : function (x) {
        return x;
      }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
    }), this.axesList[id] = axes;
  }
  /**
   * Update axes nodes
   * @private
   */
  , _proto.updateAxes = function updateAxes() {
    var _this2 = this,
        $$ = this.owner,
        config = $$.config,
        main = $$.$el.main;

    Object.keys(this.axesList).forEach(function (id) {
      var axesConfig = config["axis_" + id + "_axes"],
          scale = $$.scale[id].copy(),
          range = scale.range();

      _this2.axesList[id].forEach(function (v, i) {
        var axisRange = v.scale().range(); // adjust range value with the current
        // https://github.com/naver/billboard.js/issues/859

        range.every(function (v, i) {
          return v === axisRange[i];
        }) || v.scale().range(range);
        var className = _this2.getAxisClassName(id) + "-" + (i + 1),
            g = main.select("." + className.replace(/\s/, "."));
        g.empty() ? g = main.append("g").attr("class", className).style("visibility", config["axis_" + id + "_show"] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), _this2.x.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
      });
    });
  }
  /**
   * Set Axis & tick values
   * called from: updateScales()
   * @param {string} id Axis id string
   * @param {Array} args Arguments
   * @private
   */
  , _proto.setAxis = function setAxis(id) {
    id !== "subX" && (this.tick[id] = this.getTickValues(id));

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

    this[id] = this.getAxis.apply(this, [id].concat(args));
  } // called from : getMaxTickWidth()
  , _proto.getAxis = function getAxis(id, scale, outerTick, noTransition, noTickTextRotate) {
    var tickFormat,
        $$ = this.owner,
        config = $$.config,
        isX = /^(x|subX)$/.test(id),
        type = isX ? "x" : id,
        isCategory = isX && this.isCategorized(),
        orient = this.orient[id],
        tickTextRotate = noTickTextRotate ? 0 : $$.getAxisTickRotate(type);
    if (isX) tickFormat = $$.format.xAxisTick;else {
      var fn = config["axis_" + id + "_tick_format"];
      isFunction(fn) && (tickFormat = fn.bind($$.api));
    }
    var tickValues = this.tick[type],
        axisParams = mergeObj({
      outerTick: outerTick,
      noTransition: noTransition,
      config: config,
      id: id,
      tickTextRotate: tickTextRotate
    }, isX && {
      isCategory: isCategory,
      tickMultiline: config.axis_x_tick_multiline,
      tickWidth: config.axis_x_tick_width,
      tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
      orgXScale: $$.scale.x
    });
    isX || (axisParams.tickStepSize = config["axis_" + type + "_tick_stepSize"]);
    var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.scale.zoom || scale).orient(orient);

    if (isX && this.isTimeSeries() && tickValues && !isFunction(tickValues)) {
      var _fn = parseDate.bind($$);

      tickValues = tickValues.map(function (v) {
        return _fn(v);
      });
    } else !isX && this.isTimeSeriesY() && ( // https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time
    axis.ticks(config.axis_y_tick_time_value), tickValues = null);

    tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
      return x + "%";
    }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1));
    var tickCount = config["axis_" + type + "_tick_count"];
    return tickCount && axis.ticks(tickCount), axis;
  }, _proto.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
    var values,
        $$ = this.owner,
        config = $$.config,
        fit = config.axis_x_tick_fit,
        count = config.axis_x_tick_count;
    return (fit || count && fit) && (values = $$.mapTargetsToUniqueXs(targets), this.isCategorized() && count > values.length && (count = values.length), values = this.generateTickValues(values, count, this.isTimeSeries())), axis ? axis.tickValues(values) : this.x && (this.x.tickValues(values), this.subX && this.subX.tickValues(values)), values;
  }, _proto.getId = function getId(id) {
    var _this$owner2 = this.owner,
        config = _this$owner2.config,
        scale = _this$owner2.scale,
        axis = config.data_axes[id];
    return axis && scale[axis] || (axis = "y"), axis;
  }, _proto.getXAxisTickFormat = function getXAxisTickFormat() {
    var currFormat,
        $$ = this.owner,
        config = $$.config,
        format = $$.format,
        tickFormat = config.axis_x_tick_format,
        isTimeSeries = this.isTimeSeries(),
        isCategorized = this.isCategorized();
    return tickFormat ? isFunction(tickFormat) ? currFormat = tickFormat.bind($$.api) : isTimeSeries && (currFormat = function (date) {
      return date ? format.axisTime(tickFormat)(date) : "";
    }) : currFormat = isTimeSeries ? format.defaultAxisTime : isCategorized ? $$.categoryName : function (v) {
      return v < 0 ? v.toFixed(0) : v;
    }, isFunction(currFormat) ? function (v) {
      return currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
    } : currFormat;
  }, _proto.getTickValues = function getTickValues(id) {
    var $$ = this.owner,
        tickValues = $$.config["axis_" + id + "_tick_values"],
        axis = $$[id + "Axis"];
    return (isFunction(tickValues) ? tickValues.call($$.api) : tickValues) || (axis ? axis.tickValues() : undefined);
  }, _proto.getLabelOptionByAxisId = function getLabelOptionByAxisId(id) {
    return this.owner.config["axis_" + id + "_label"];
  }, _proto.getLabelText = function getLabelText(id) {
    var option = this.getLabelOptionByAxisId(id);
    return isString(option) ? option : option ? option.text : null;
  }, _proto.setLabelText = function setLabelText(id, text) {
    var $$ = this.owner,
        config = $$.config,
        option = this.getLabelOptionByAxisId(id);
    isString(option) ? config["axis_" + id + "_label"] = text : option && (option.text = text);
  }, _proto.getLabelPosition = function getLabelPosition(id, defaultPosition) {
    var isRotated = this.owner.config.axis_rotated,
        option = this.getLabelOptionByAxisId(id),
        position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
        has = function (v) {
      return !!~position.indexOf(v);
    };

    return {
      isInner: has("inner"),
      isOuter: has("outer"),
      isLeft: has("left"),
      isCenter: has("center"),
      isRight: has("right"),
      isTop: has("top"),
      isMiddle: has("middle"),
      isBottom: has("bottom")
    };
  }, _proto.getAxisLabelPosition = function getAxisLabelPosition(id) {
    return this.getLabelPosition(id, id === "x" ? ["inner-top", "inner-right"] : ["inner-right", "inner-top"]);
  }, _proto.getLabelPositionById = function getLabelPositionById(id) {
    return this.getAxisLabelPosition(id);
  }, _proto.xForAxisLabel = function xForAxisLabel(id) {
    var $$ = this.owner,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        position = this.getAxisLabelPosition(id),
        x = position.isMiddle ? -height / 2 : 0;
    return this.isHorizontal($$, id !== "x") ? x = position.isLeft ? 0 : position.isCenter ? width / 2 : width : position.isBottom && (x = -height), x;
  }, _proto.dxForAxisLabel = function dxForAxisLabel(id) {
    var $$ = this.owner,
        position = this.getAxisLabelPosition(id),
        dx = position.isBottom ? "0.5em" : "0";
    return this.isHorizontal($$, id !== "x") ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
  }, _proto.textAnchorForAxisLabel = function textAnchorForAxisLabel(id) {
    var $$ = this.owner,
        position = this.getAxisLabelPosition(id),
        anchor = position.isMiddle ? "middle" : "end";
    return this.isHorizontal($$, id !== "x") ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
  }, _proto.dyForAxisLabel = function dyForAxisLabel(id) {
    var dy,
        $$ = this.owner,
        config = $$.config,
        isRotated = config.axis_rotated,
        isInner = this.getAxisLabelPosition(id).isInner,
        tickRotate = config["axis_" + id + "_tick_rotate"] ? $$.getHorizontalAxisHeight(id) : 0,
        maxTickWidth = this.getMaxTickWidth(id);

    if (id === "x") {
      var xHeight = config.axis_x_height;
      dy = isRotated ? isInner ? "1.2em" : -25 - maxTickWidth : isInner ? "-0.5em" : xHeight ? xHeight - 10 : tickRotate ? tickRotate - 10 : "3em";
    } else dy = {
      y: ["-0.5em", 10, "3em", "1.2em", 10],
      y2: ["1.2em", -20, "-2.2em", "-0.5em", 15]
    }[id], dy = isRotated ? isInner ? dy[0] : tickRotate ? tickRotate * (id === "y2" ? -1 : 1) - dy[1] : dy[2] : isInner ? dy[3] : (dy[4] + (config["axis_" + id + "_inner"] ? 0 : maxTickWidth + dy[4])) * (id === "y" ? -1 : 1);

    return dy;
  }, _proto.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
    var $$ = this.owner,
        config = $$.config,
        current = $$.state.current,
        _$$$$el2 = $$.$el,
        svg = _$$$$el2.svg,
        chart = _$$$$el2.chart,
        currentTickMax = current.maxTickWidths[id],
        maxWidth = 0;
    if (withoutRecompute || !config["axis_" + id + "_show"] || $$.filterTargetsToShow().length === 0) return currentTickMax.size;

    if (svg) {
      var isYAxis = /^y2?$/.test(id),
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          scale = $$.scale[id].copy().domain($$["get" + (isYAxis ? "Y" : "X") + "Domain"](targetsToShow, id)),
          domain = scale.domain();
      // do not compute if domain is same
      if (domain[0] === domain[1] || isArray(currentTickMax.domain) && currentTickMax.domain[0] === currentTickMax.domain[1]) return currentTickMax.size;
      currentTickMax.domain = domain;
      var axis = this.getAxis(id, scale, !1, !1, !0),
          tickCount = config["axis_" + id + "_tick_count"],
          tickValues = config["axis_" + id + "_tick_values"];
      !tickValues && tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? this.isTimeSeriesY() : this.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
      var dummy = chart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
      axis.create(dummy), dummy.selectAll("text").each(function (d, i) {
        var currentTextWidth = this.getBoundingClientRect().width;
        maxWidth = Math.max(maxWidth, currentTextWidth), id === "x" && (currentTickMax.ticks[i] = currentTextWidth);
      }), dummy.remove();
    }

    return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
  }, _proto.getXAxisTickTextY2Overflow = function getXAxisTickTextY2Overflow(defaultPadding) {
    var $$ = this.owner,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if ((axis.isCategorized() || axis.isTimeSeries()) && config.axis_x_tick_fit && !config.axis_x_tick_culling && !config.axis_x_tick_multiline && xAxisTickRotate > 0 && xAxisTickRotate < 90) {
      var widthWithoutCurrentPaddingLeft = state.current.width - $$.getCurrentPaddingLeft(),
          maxOverflow = this.getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft - defaultPadding),
          xAxisTickTextY2Overflow = Math.max(0, maxOverflow) + defaultPadding;
      // for display inconsistencies between browsers
      return Math.min(xAxisTickTextY2Overflow, widthWithoutCurrentPaddingLeft / 2);
    }

    return 0;
  }, _proto.getXAxisTickMaxOverflow = function getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft) {
    for (var $$ = this.owner, axis = $$.axis, config = $$.config, state = $$.state, isTimeSeries = axis.isTimeSeries(), tickTextWidths = state.current.maxTickWidths.x.ticks, tickCount = tickTextWidths.length, _state$axis$x$padding = state.axis.x.padding, left = _state$axis$x$padding.left, right = _state$axis$x$padding.right, maxOverflow = 0, remaining = tickCount - (isTimeSeries && config.axis_x_tick_fit ? .5 : 0), i = 0; i < tickCount; i++) {
      var tickIndex = i + 1,
          rotatedTickTextWidth = Math.cos(Math.PI * xAxisTickRotate / 180) * tickTextWidths[i],
          ticksBeforeTickText = tickIndex - (isTimeSeries ? 1 : .5) + left;

      // Skip ticks if there are no ticks before them
      if (!(ticksBeforeTickText <= 0)) {
        var tickLength = (widthWithoutCurrentPaddingLeft - rotatedTickTextWidth) / ticksBeforeTickText;
        maxOverflow = Math.max(maxOverflow, rotatedTickTextWidth - tickLength / 2 - ((remaining - tickIndex) * tickLength + right * tickLength));
      }
    }

    var tickOffset = 0;

    if (!isTimeSeries) {
      var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])().domain([left * -1, $$.getXDomainMax($$.data.targets) + 1 + right]).range([0, widthWithoutCurrentPaddingLeft - maxOverflow]);
      tickOffset = Math.ceil((scale(1) - scale(0)) / 2);
    }

    return maxOverflow + tickOffset;
  }
  /**
   * Get x Axis padding
   * @param {number} tickCount Tick count
   * @returns {object} Padding object values with 'left' & 'right' key
   * @private
   */
  , _proto.getXAxisPadding = function getXAxisPadding(tickCount) {
    var $$ = this.owner,
        padding = $$.config.axis_x_padding;

    if (isEmpty(padding) ? padding = {
      left: 0,
      right: 0
    } : (padding.left = padding.left || 0, padding.right = padding.right || 0), $$.axis.isTimeSeries()) {
      var firstX = +$$.getXDomainMin($$.data.targets),
          lastX = +$$.getXDomainMax($$.data.targets),
          timeDiff = lastX - firstX,
          range = timeDiff + padding.left + padding.right,
          relativeTickWidth = timeDiff / tickCount / range,
          left = padding.left / range / relativeTickWidth || 0,
          _right = padding.right / range / relativeTickWidth || 0;

      padding = {
        left: left,
        right: _right
      };
    }

    return padding;
  }, _proto.updateLabels = function updateLabels(withTransition) {
    var _this3 = this,
        $$ = this.owner,
        main = $$.$el.main,
        labels = {
      x: main.select("." + config_classes.axisX + " ." + config_classes.axisXLabel),
      y: main.select("." + config_classes.axisY + " ." + config_classes.axisYLabel),
      y2: main.select("." + config_classes.axisY2 + " ." + config_classes.axisY2Label)
    };

    Object.keys(labels).filter(function (id) {
      return !labels[id].empty();
    }).forEach(function (v) {
      var node = labels[v];
      (withTransition ? node.transition() : node).attr("x", function () {
        return _this3.xForAxisLabel(v);
      }).attr("dx", function () {
        return _this3.dxForAxisLabel(v);
      }).attr("dy", function () {
        return _this3.dyForAxisLabel(v);
      }).text(function () {
        return _this3.getLabelText(v);
      });
    });
  }, _proto.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
    var p = isNumber(padding) ? padding : padding[key];
    return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
  }, _proto.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
    var $$ = this.owner,
        config = $$.config,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        length = config.axis_rotated ? width : height;
    return domainLength * (pixels / length);
  }, _proto.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
    var tickValues = values;

    if (tickCount) {
      var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

      if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
        var tickValue,
            isCategorized = this.isCategorized(),
            count = targetCount - 2,
            start = values[0],
            end = values[values.length - 1];
        tickValues = [start];

        for (var i = 0; i < count; i++) tickValue = +start + (end - start) / (count + 1) * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

        tickValues.push(end);
      }
    }

    return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
      return a - b;
    })), tickValues;
  }, _proto.generateTransitions = function generateTransitions(duration) {
    var $$ = this.owner,
        axis = $$.$el.axis,
        _map = ["x", "y", "y2", "subX"].map(function (v) {
      var ax = axis[v];
      return ax && duration && (ax = ax.transition().duration(duration)), ax;
    }),
        axisX = _map[0],
        axisY = _map[1],
        axisY2 = _map[2],
        axisSubX = _map[3];

    return {
      axisX: axisX,
      axisY: axisY,
      axisY2: axisY2,
      axisSubX: axisSubX
    };
  }, _proto.redraw = function redraw(transitions, isHidden, isInit) {
    var _this4 = this,
        $$ = this.owner,
        config = $$.config,
        $el = $$.$el,
        opacity = isHidden ? "0" : "1";

    ["x", "y", "y2", "subX"].forEach(function (id) {
      var axis = _this4[id],
          $axis = $el.axis[id];
      axis && $axis && (!isInit && (axis.config.withoutTransition = !config.transition_duration), $axis.style("opacity", opacity), axis.create(transitions["axis" + capitalize(id)]));
    }), this.updateAxes();
  }
  /**
   * Redraw axis
   * @param {Array} targetsToShow targets data to be shown
   * @param {object} wth option object
   * @param {d3.Transition} transitions Transition object
   * @param {object} flow flow object
   * @param {boolean} isInit called from initialization
   * @private
   */
  , _proto.redrawAxis = function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
    var xDomainForZoom,
        _this5 = this,
        $$ = this.owner,
        config = $$.config,
        scale = $$.scale,
        $el = $$.$el,
        hasZoom = !!scale.zoom;

    !hasZoom && this.isCategorized() && targetsToShow.length === 0 && scale.x.domain([0, $el.axis.x.selectAll(".tick").size()]), scale.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : this.x && (this.x.tickValues([]), this.subX && this.subX.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = scale.x.orgDomain()), ["y", "y2"].forEach(function (key) {
      var axisScale = scale[key];

      if (axisScale) {
        var tickValues = config["axis_" + key + "_tick_values"],
            tickCount = config["axis_" + key + "_tick_count"];

        if (axisScale.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
          var _axis = $$.axis[key],
              domain = axisScale.domain();

          _axis.tickValues(_this5.generateTickValues(domain, domain.every(function (v) {
            return v === 0;
          }) ? 1 : tickCount, _this5.isTimeSeriesY()));
        }
      }
    }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && (scale.subY && scale.subY.domain($$.getYDomain(targetsToShow, "y")), scale.subY2 && scale.subY2.domain($$.getYDomain(targetsToShow, "y2")));
  }
  /**
   * Set manual culling
   * @private
   */
  , _proto.setCulling = function setCulling() {
    var $$ = this.owner,
        config = $$.config,
        _$$$state3 = $$.state,
        clip = _$$$state3.clip,
        current = _$$$state3.current,
        $el = $$.$el;
    ["subX", "x", "y", "y2"].forEach(function (type) {
      var axis = $el.axis[type],
          id = type === "subX" ? "x" : type,
          toCull = config["axis_" + id + "_tick_culling"]; // subchart x axis should be aligned with x axis culling

      if (axis && toCull) {
        var intervalForCulling,
            tickText = axis.selectAll(".tick text"),
            tickValues = util_sortValue(tickText.data()),
            tickSize = tickValues.length,
            cullingMax = config["axis_" + id + "_tick_culling_max"];

        if (tickSize) {
          for (var i = 1; i < tickSize; i++) if (tickSize / i < cullingMax) {
            intervalForCulling = i;
            break;
          }

          tickText.each(function (d) {
            this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
          });
        } else tickText.style("display", "block"); // set/unset x_axis_tick_clippath


        if (type === "x") {
          var clipPath = current.maxTickWidths.x.clipPath ? clip.pathXAxisTickTexts : null;
          $el.svg.selectAll("." + config_classes.axisX + " .tick text").attr("clip-path", clipPath);
        }
      }
    });
  }, Axis;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ChartInternal/data/data.convert.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Data convert
 * @memberof ChartInternal
 * @private
 */

/* harmony default export */ var data_convert = ({
  /**
   * Convert data according its type
   * @param {object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @returns {object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_" + v;
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) this.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = this.convertJsonToData(data.json, data.keys);else if (data.rows) data = this.convertRowsToData(data.rows);else if (data.columns) data = this.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {string} url Remote URL
   * @param {string} mimeType MIME type string: json | csv | tsv
   * @param {object} headers Header object
   * @param {object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url, mimeType, headers, keys, done) {
    var _this = this;

    mimeType === void 0 && (mimeType = "csv");
    var req = new XMLHttpRequest();
    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert" + capitalize(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error(url + ": Something went wrong loading!");
    }, req.send();
  },

  /**
   * Convert CSV/TSV data
   * @param {object} parser Parser object
   * @param {object} xsv Data
   * @private
   * @returns {object}
   */
  convertCsvTsvToData: function convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var _this3 = this,
        $$ = this,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        isCategorized = !1,
        isTimeSeries = !1,
        isCustomX = !1;

    axis && (isCategorized = axis.isCategorized(), isTimeSeries = axis.isTimeSeries(), isCustomX = axis.isCustomX());
    var xsData,
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];
    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      isCustomX || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter.bind($$.api)(id),
          xKey = $$.getXKey(id),
          isCategory = isCustomX && isCategorized,
          hasCategory = isCategory && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, (isCategory || state.hasRadar) && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), state.hasNegativeValue = $$.hasNegativeValueInTargets(targets), state.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.cache.add(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_data_data = ({
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return !!(config.data_stack_normalize && config.data_groups.length);
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|number|string} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @returns {number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this,
        config = $$.config;
    Object.keys(xs).forEach(function (id) {
      config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this,
        config = $$.config;
    return data && (name = config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },

  /**
   * Get all values on given index
   * @param {number} index Index
   * @param {boolean} filterNull Filter nullish value
   * @returns {Array}
   * @private
   */
  getAllValuesOnIndex: function getAllValuesOnIndex(index, filterNull) {
    filterNull === void 0 && (filterNull = !1);
    var $$ = this,
        value = $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
    return filterNull && (value = value.filter(function (v) {
      return isValue(v.value);
    })), value;
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        axis = $$.axis,
        x = axis && axis.isCategorized() ? index : rawX || index;

    if (axis && axis.isTimeSeries()) {
      var fn = parseDate.bind($$);
      x = rawX ? fn(rawX) : fn($$.getXValue(id, index));
    } else axis && axis.isCustomX() && !axis.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index));

    return x;
  },
  updateXs: function updateXs(values) {
    values.length && (this.axis.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.axis.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.axis.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param {object} data Data object
   * @returns {number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        hasAxis = $$.state.hasAxis,
        value = data.value;
    return value && hasAxis && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @returns {{min: {number}, max: {number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(value)), max = Math.max.apply(Math, [i ? max : -Infinity].concat(value));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @returns {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = KEY.dataMinMax,
        minMaxData = $$.cache.get(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.cache.add(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @returns {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        cacheKey = KEY.dataTotalPerIndex,
        sum = $$.cache.get(cacheKey);
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @param {boolean} subtractHidden Subtract hidden data from total
   * @returns {number}
   * @private
   */
  getTotalDataSum: function getTotalDataSum(subtractHidden) {
    var $$ = this,
        cacheKey = KEY.dataTotalSum,
        total = $$.cache.get(cacheKey);

    if (!isNumber(total)) {
      var sum = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.cache.add(cacheKey, total = sum);
    }

    return subtractHidden && (total -= $$.getHiddenTotalDataSum()), total;
  },

  /**
   * Get total hidden data sum
   * @returns {number}
   * @private
   */
  getHiddenTotalDataSum: function getHiddenTotalDataSum() {
    var $$ = this,
        api = $$.api,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        total = 0;
    return hiddenTargetIds.length && (total = api.data.values.bind(api)(hiddenTargetIds).reduce(function (p, c) {
      return p + c;
    })), total;
  },

  /**
   * Get filtered data by value
   * @param {object} data Data
   * @param {number} value Value to be filtered
   * @returns {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @returns {number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, this.data.targets.map(function (t) {
      return t.values.length;
    }));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = util_sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.state.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.state.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        axis = $$.axis,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = axis && axis.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), util_sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        hasAxis = $$.state.hasAxis,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, value) : isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : $$.isBubbleZType(v) ? data.push(hasAxis && $$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue Target value
   * @returns {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = [].concat(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();
    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order.bind($$.api)), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isboolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.$el.chart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = main.select("." + config_classes.bars + $$.getTargetSelectorSuffix(v.id) + " ." + config_classes.bar + "-" + v.index).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        scale = $$.scale,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = (scale.zoom || scale.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @returns {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = !!axis && axis.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length - 1, value = converted[x].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_" + name];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {string} type Ratio for given type
   * @param {object} d Data value object
   * @param {boolean} asPercent Convert the return as percent or not
   * @returns {number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        api = $$.api,
        ratio = 0;
    if (d && api.data.shown().length) if (ratio = d.ratio || d.value, type === "arc") ratio = $$.pie.padAngle()() ? d.value / $$.getTotalDataSum(!0) : (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));else if (type === "index") {
      var dataValues = api.data.values.bind(api),
          total = this.getTotalPerIndex();

      if (state.hiddenTargetIds.length) {
        var hiddenSum = dataValues(state.hiddenTargetIds, !1);
        hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
          return acc.map(function (v, i) {
            return (isNumber(v) ? v : 0) + curr[i];
          });
        }), total = total.map(function (v, i) {
          return v - hiddenSum[i];
        }));
      }

      d.ratio = isNumber(d.value) && total && total[d.index] > 0 ? d.value / total[d.index] : 0, ratio = d.ratio;
    } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0) + "") / state.current.dataMax * config.radar_size_ratio);
    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var data_load = ({
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    // Update current state chart type and elements list after redraw
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), $$.updateTypesElements(), args.done && args.done.call($$.api);
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.cache.reset();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        state = $$.state,
        $el = $$.$el,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.cache.reset(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ( // Update current state chart type and elements list after redraw
    $el.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call(endall, done), targetIds.forEach(function (id) {
      state.withoutFadeIn[id] = !1, $el.legend && $el.legend.selectAll("." + config_classes.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    }), $$.updateTypesElements()) : void done();
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(42);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_interaction = ({
  /**
   * Handle data.onover/out callback options
   * @param {boolean} isOver Over or not
   * @param {number|object} d data object
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, main.select("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).node());else if (!config.tooltip_grouped) {
        var callee = $$.setOverOut,
            last = callee.last || [],
            shape = main.selectAll("." + config_classes.shape + "-" + d).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), callee.last = last;
      } else isOver && (config.point_focus_only ? $$.showCircleFocus($$.getAllValuesOnIndex(d, !0)) : $$.expandCirclesBars(d, null, !0)), $$.isMultipleX() || main.selectAll("." + config_classes.shape + "-" + d).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {number|object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @returns {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      // @ts-ignore
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      // @ts-ignore
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {string} type event type
   * @param {number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = "." + (isMultipleX ? config_classes.eventRect : config_classes.eventRect + "-" + index),
        eventRect = $$.$el.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/class.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_class = ({
  generateClass: function generateClass(prefix, targetId) {
    return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return this.generateClass(config_classes.region, i) + " " + ("class" in d ? d.class : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " " + config_classes.target + "-" + additionalClassSuffix), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " " + (this.state.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " " + (this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    var pfx = prefix || "",
        target = this.getTargetSelectorSuffix(id);
    // select target & circle
    return pfx + "." + (config_classes.target + target) + ", " + pfx + "." + (config_classes.circles + target);
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return "." + (config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var category = ({
  /**
   * Category Name
   * @param {number} i Index number
   * @returns {string} category Name
   * @private
   */
  categoryName: function categoryName(i) {
    var categories = this.config.axis_x_categories;
    return i < categories.length ? categories[i] : i;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {string} color Color string
 * @param {string} id ID to be set
 * @returns {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


/* harmony default export */ var internals_color = ({
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @returns {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var cacheKey = KEY.colorPattern,
        body = browser_doc.body,
        pattern = body[cacheKey];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body[cacheKey] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles.bind($$.api)(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = $$.state.datetimeId + "-pattern-" + color + "-" + index;
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#" + p.id + ")";
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id].bind($$.api)(d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback.bind($$.api)(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restate in its previous color value
   * @param {boolean} isOver true: set overed color, false: restore
   * @param {number|object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) ? color = function () {
      return onover;
    } : isFunction(onover) && (color = color.bind($$.api)), isObject(d) ? main.selectAll("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).style("fill", color(d)) : main.selectAll("." + config_classes.shape + "-" + d).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/config/const.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Chart type constant
 * @private
 */
var TYPE = {
  AREA: "area",
  AREA_LINE_RANGE: "area-line-range",
  AREA_SPLINE: "area-spline",
  AREA_SPLINE_RANGE: "area-spline-range",
  AREA_STEP: "area-step",
  BAR: "bar",
  BUBBLE: "bubble",
  DONUT: "donut",
  GAUGE: "gauge",
  LINE: "line",
  PIE: "pie",
  RADAR: "radar",
  SCATTER: "scatter",
  SPLINE: "spline",
  STEP: "step"
};
/**
 * chart types by category
 * @private
 */

var TYPE_BY_CATEGORY = {
  Area: [TYPE.AREA, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE, TYPE.AREA_STEP],
  AreaRange: [TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE],
  Arc: [TYPE.PIE, TYPE.DONUT, TYPE.GAUGE, TYPE.RADAR],
  Line: [TYPE.LINE, TYPE.SPLINE, TYPE.AREA, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE, TYPE.STEP, TYPE.AREA_STEP],
  Step: [TYPE.STEP, TYPE.AREA_STEP],
  Spline: [TYPE.SPLINE, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE]
};
// CONCATENATED MODULE: ./src/ChartInternal/internals/domain.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_domain = ({
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },

  /**
   * Check if hidden targets bound to the given axis id
   * @param {string} id ID to be checked
   * @returns {boolean}
   * @private
   */
  isHiddenTargetWithYDomain: function isHiddenTargetWithYDomain(id) {
    var $$ = this;
    return $$.state.hiddenTargetIds.some(function (v) {
      return $$.axis.getId(v) === id;
    });
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        scale = $$.scale,
        pfx = "axis_" + axisId;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) // use domain of the other axis if target of axisId is none
      return $$.isHiddenTargetWithYDomain(axisId) ? scale[axisId].domain() : axisId === "y2" ? scale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
      // So, it needs to call to get y2 domain here
      $$.getYDomain(targets, "y2", xDomain);
    var yMin = config[pfx + "_min"],
        yMax = config[pfx + "_max"],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config[pfx + "_center"],
        isZeroBased = [TYPE.BAR, TYPE.BUBBLE, TYPE.SCATTER].concat(TYPE_BY_CATEGORY.Line).some(function (v) {
      var type = v.indexOf("area") > -1 ? "area" : v;
      return $$.hasType(v, yTargets) && config[type + "_zerobased"];
    }),
        isInverted = config[pfx + "_inverted"],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain(scale.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    } // if padding is set, the domain will be updated relative the current domain value
    // ex) $$.height=300, padding.top=150, domainLength=4  --> domain=6


    var p = config[pfx + "_padding"];
    notEmpty(p) && ["bottom", "top"].forEach(function (v) {
      padding[v] = axis.getPadding(p, v, padding[v], domainLength);
    }), isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        configValue = $$.config["axis_x_" + type],
        dataValue = getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    })),
        value = isObject(configValue) ? configValue.value : configValue;
    return value = isDefined(value) && $$.axis.isTimeSeries() ? parseDate(value) : value, isObject(configValue) && configValue.fit && (type === "min" && value < dataValue || type === "max" && value > dataValue) && (value = undefined), isDefined(value) ? value : dataValue;
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        axis = $$.axis,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    axis.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        isCategorized = $$.axis.isCategorized(),
        isTimeSeries = $$.axis.isTimeSeries(),
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        padding = $$.getXDomainPadding(xDomain),
        _xDomain = xDomain,
        firstX = _xDomain[0],
        lastX = _xDomain[1],
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || isCategorized || (isTimeSeries ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = isTimeSeries ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = isTimeSeries ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        subX = _$$$scale.subX,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && (x.domain(domain || util_sortValue($$.getXDomain(targets))), org.xDomain = x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), subX.domain(x.domain()), $$.brush && $$.brush.scale(subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? org.xDomain : getBrushSelection($$).map(subX.invert);
      x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && x.domain($$.trimXDomain(x.orgDomain())), x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        min = zoomDomain[0],
        max = zoomDomain[1];
    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/format.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get formatted
 * @param {object} $$ Context
 * @param {string} typeValue Axis type
 * @param {number} v Value to be formatted
 * @returns {number | string}
 * @private
 */
function getFormat($$, typeValue, v) {
  var config = $$.config,
      type = "axis_" + typeValue + "_tick_format",
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
}

/* harmony default export */ var internals_format = ({
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        yFormat = $$.yFormat,
        y2Format = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (yFormat = $$.defaultArcValueFormat, y2Format = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis && $$.axis.getId(id) === "y2" ? y2Format : yFormat;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return (ratio * 100).toFixed(1) + "%";
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format.bind($$.api);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var internals_legend = ({
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.legendItemTextBox = {}, $$.state.legendHasRendered = !1, config.legend_show ? (!config.legend_contents_bindto && ($el.legend = $$.$el.svg.append("g").attr("transform", $$.getTranslate("legend"))), $$.updateLegend()) : $$.state.hiddenLegendIds = $$.mapToIds($$.data.targets);
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        scale = $$.scale,
        $el = $$.$el,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !scale.zoom), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), state.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.bind($$.api)(v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $el.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @param {Obejct} size Size object
   * @private
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        isLegendTop = _$$$state.isLegendTop,
        isLegendLeft = _$$$state.isLegendLeft,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        current = _$$$state.current,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : current.height - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : current.width - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.state.margin3 = {
      top: isLegendRight ? 0 : isLegendInset ? insetLegendPosition.top : current.height - height,
      right: NaN,
      bottom: 0,
      left: isLegendRight ? current.width - width : isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @param {boolean} withTransition whether or not to transition.
   * @private
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this,
        legend = $$.$el.legend;
    (withTransition ? legend.transition() : legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @param {number} step Step value
   * @private
   */
  updateLegendStep: function updateLegendStep(step) {
    this.state.legendStep = step;
  },

  /**
   * Update legend item width
   * @param {number} width Width value
   * @private
   */
  updateLegendItemWidth: function updateLegendItemWidth(width) {
    this.state.legendItemWidth = width;
  },

  /**
   * Update legend item height
   * @param {number} height Height value
   * @private
   */
  updateLegendItemHeight: function updateLegendItemHeight(height) {
    this.state.legendItemHeight = height;
  },

  /**
   * Update legend item color
   * @param {string} id Corresponding data ID value
   * @param {string} color Color value
   * @private
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.$el.legend.select("." + config_classes.legendItem + "-" + id + " line").style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @returns {number} width
   * @private
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        width = _$$$state2.current.width,
        isLegendRight = _$$$state2.isLegendRight,
        isLegendInset = _$$$state2.isLegendInset,
        legendItemWidth = _$$$state2.legendItemWidth,
        legendStep = _$$$state2.legendStep;
    return $$.config.legend_show ? isLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : width : 0;
  },

  /**
   * Get the height of the legend
   * @returns {number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this,
        _$$$state3 = $$.state,
        current = _$$$state3.current,
        isLegendRight = _$$$state3.isLegendRight,
        legendItemHeight = _$$$state3.legendItemHeight,
        legendStep = _$$$state3.legendStep;
    return $$.config.legend_show ? isLegendRight ? current.height : Math.max(20, legendItemHeight) * (legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @param {d3.selection} legendItem Legend item node
   * @returns {string|null} opacity
   * @private
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @param {d3.selection} legendItem Legend item node
   * @returns {string|null} opacity
   * @private
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @param {Array} targetIds ID's of target
   * @param {boolean} focus whether or not to focus.
   * @private
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        legend = $$.$el.legend,
        targetIdz = $$.mapToTargetIds(targetIds);
    legend && legend.selectAll("." + config_classes.legendItem).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this,
        legend = $$.$el.legend;
    legend && legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @param {Array} targetIds ID's of target
   * @private
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    config.legend_show || (config.legend_show = !0, $el.legend ? $el.legend.style("visibility", "visible") : $$.initLegend(), !$$.state.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $el.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @param {Array} targetIds ID's of target
   * @private
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Get legend item textbox dimension
   * @param {string} id Data ID
   * @param {HTMLElement|d3.selection} textElement Text node element
   * @returns {object} Bounding rect
   * @private
   */
  getLegendItemTextBox: function getLegendItemTextBox(id, textElement) {
    var data,
        $$ = this,
        cache = $$.cache,
        cacheKey = KEY.legendItemTextBox;
    return id && (data = cache.get(cacheKey) || {}, !data[id] && (data[id] = $$.getTextRect(textElement, config_classes.legendItem), cache.add(cacheKey, data)), data = data[id]), data;
  },

  /**
   * Set legend item style & bind events
   * @param {d3.selection} item Item node
   * @private
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, api, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? (api.hide(), api.show(id)) : (api.toggle(id), !isTouch && $$.isTargetToShow(id) ? api.focus(id) : api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, "." + config_classes.gaugeValue), !state.transiting && $$.isTargetToShow(id) && api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = state.isLegendRight || state.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = $$.getLegendItemTextBox(id, textElement),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = state.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    state.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), state.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : state.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = legend.selectAll("." + config_classes.legendItem).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#" + state.datetimeId + "-point-" + data : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = legend.select("." + config_classes.legendBackground + " rect"), state.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = legend.insert("g", "." + config_classes.legendItem).attr("class", config_classes.legendBackground).append("rect"));
    var texts = legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = legend.selectAll("rect." + config_classes.legendItemEvent).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = legend.selectAll("." + config_classes.legendItemPoint).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = legend.selectAll("line." + config_classes.legendItemTile).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache.get(id).values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(43);

// CONCATENATED MODULE: ./src/ChartInternal/internals/redraw.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_redraw = ({
  redraw: function redraw(options, transitionsValue) {
    options === void 0 && (options = {});
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        main = $el.main,
        targetsToShow = $$.filterTargetsToShow($$.data.targets),
        initializing = options.initializing,
        flow = options.flow,
        wth = $$.getWithOption(options),
        duration = wth.Transition ? config.transition_duration : 0,
        durationForExit = wth.TransitionForExit ? duration : 0,
        durationForAxis = wth.TransitionForAxis ? duration : 0,
        transitions = transitionsValue || $$.axis && $$.axis.generateTransitions(durationForAxis);
    // text
    // title
    $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.hasDataLabel() && $$.updateText(durationForExit), (!$$.hasArcType() || state.hasRadar) && $$.updateCircleY(), ($$.hasPointType() || state.hasRadar) && $$.updateCircle(), state.hasAxis ? ($$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), config.data_empty_label_text && main.select("text." + config_classes.text + "." + config_classes.empty).attr("x", state.width / 2).attr("y", state.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.hasGrid() && $$.updateGrid(duration), config.regions.length && $$.updateRegion(duration), $$.hasType("bar") && $$.updateBar(durationForExit), $$.hasTypeOf("Line") && $$.updateLine(durationForExit), $$.hasTypeOf("Area") && $$.updateArea(durationForExit), $el.text && main.selectAll("." + config_classes.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent()) : ($el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $el.radars && $$.redrawRadar(durationForExit)), $$.redrawTitle && $$.redrawTitle(), initializing && $$.updateTypesElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
  },

  /**
   * Generate redraw list
   * @param {object} targets targets data to be shown
   * @param {object} flow flow object
   * @param {number} duration duration value
   * @param {boolean} withSubchart whether or not to show subchart
   * @private
   */
  generateRedrawList: function generateRedrawList(targets, flow, duration, withSubchart) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        shape = $$.getDrawShape();
    state.hasAxis && config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
    // generate flow
    var flowFn = flow && $$.generateFlow({
      targets: targets,
      flow: flow,
      duration: flow.duration,
      shape: shape,
      xv: $$.xv.bind($$)
    }),
        isTransition = (duration || flowFn) && isTabVisible(),
        redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
        afterRedraw = flow || config.onrendered ? function () {
      flowFn && flowFn(), callFn(config.onrendered, $$.api);
    } : null;
    if (afterRedraw) // Only use transition when current tab is visible.
      if (isTransition && redrawList.length) {
        // Wait for end of transitions for callback
        var waitForDraw = generateWait(); // transition should be derived from one transition

        Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
          redrawList.reduce(function (acc, t1) {
            return acc.concat(t1);
          }, []).forEach(function (t) {
            return waitForDraw.add(t);
          });
        }).call(waitForDraw, afterRedraw);
      } else state.transiting || afterRedraw(); // update fadein condition

    $$.mapToIds($$.data.targets).forEach(function (id) {
      state.withoutFadeIn[id] = !0;
    });
  },
  getRedrawList: function getRedrawList(shape, flow, flowFn, isTransition) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        hasAxis = _$$$state.hasAxis,
        hasRadar = _$$$state.hasRadar,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        list = [];

    if (hasAxis) {
      var _shape$type = shape.type,
          area = _shape$type.area,
          bar = _shape$type.bar,
          line = _shape$type.line;
      (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition)), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), flow || list.push($$.updateGridFocus());
    }

    return (!$$.hasArcType() || hasRadar) && notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition)), ($$.hasPointType() || hasRadar) && !config.point_focus_only && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
  },
  updateAndRedraw: function updateAndRedraw(options) {
    options === void 0 && (options = {});
    var transitions,
        $$ = this,
        config = $$.config,
        state = $$.state;
    // same with redraw
    // NOT same with redraw
    // Draw with new sizes & scales
    options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (state.hasAxis && (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0)), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
  },
  redrawWithoutRescale: function redrawWithoutRescale() {
    this.redraw({
      withY: !1,
      withSubchart: !1,
      withEventRect: !1,
      withTransitionForAxis: !1
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/scale.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_scale = ({
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {number} min Min value
   * @param {number} max Max value
   * @param {Array} domain Domain value
   * @param {Function} offset The offset getter to be sum
   * @returns {Function} scale
   * @private
   */
  getXScale: function getXScale(min, max, domain, offset) {
    var $$ = this,
        scale = $$.scale.zoom || $$.getScale(min, max, $$.axis.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {number} min Min value
   * @param {number} max Max value
   * @param {Array} domain Domain value
   * @returns {Function} Scale function
   * @private
   */
  getYScale: function getYScale(min, max, domain) {
    var $$ = this,
        scale = $$.getScale(min, max, $$.axis.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get y Axis scale
   * @param {string} id Axis id
   * @param {boolean} isSub Weather is sub Axis
   * @returns {Function} Scale function
   * @private
   */
  getYScaleById: function getYScaleById(id, isSub) {
    isSub === void 0 && (isSub = !1);
    var isY2 = this.axis.getId(id) === "y2",
        key = isSub ? isY2 ? "subY2" : "subY" : isY2 ? "y2" : "y";
    return this.scale[key];
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue Scale function
   * @param {Function} offsetValue Offset getter to be sum
   * @returns {Function} Scale function
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.axis.x.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.axis.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },

  /**
   * Update scale
   * @param {boolean} isInit Param is given at the init rendering
   * @param {boolean} updateXDomain If update x domain
   * @private
   */
  updateScales: function updateScales(isInit, updateXDomain) {
    updateXDomain === void 0 && (updateXDomain = !0);
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        format = $$.format,
        org = $$.org,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        width2 = _$$$state.width2,
        height2 = _$$$state.height2,
        hasAxis = _$$$state.hasAxis;

    if (hasAxis) {
      var isRotated = config.axis_rotated,
          min = {
        x: isRotated ? 1 : 0,
        y: isRotated ? 0 : height,
        subX: isRotated ? 1 : 0,
        subY: isRotated ? 0 : height2
      },
          max = {
        x: isRotated ? height : width,
        y: isRotated ? width : 1,
        subX: isRotated ? height : width,
        subY: isRotated ? width2 : 1
      },
          xDomain = updateXDomain && scale.x && scale.x.orgDomain(),
          xSubDomain = updateXDomain && org.xDomain; // update edges

      // y Axis
      scale.x = $$.getXScale(min.x, max.x, xDomain, function () {
        return axis.x.tickOffset();
      }), scale.subX = $$.getXScale(min.x, max.x, xSubDomain, function (d) {
        return d % 1 ? 0 : axis.subX.tickOffset();
      }), format.xAxisTick = axis.getXAxisTickFormat(), axis.setAxis("x", scale.x, config.axis_x_tick_outer, isInit), config.subchart_show && axis.setAxis("subX", scale.subX, config.axis_x_tick_outer, isInit), scale.y = $$.getYScale(min.y, max.y, scale.y ? scale.y.domain() : config.axis_y_default), scale.subY = $$.getYScale(min.subY, max.subY, scale.subY ? scale.subY.domain() : config.axis_y_default), axis.setAxis("y", scale.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && (scale.y2 = $$.getYScale(min.y, max.y, scale.y2 ? scale.y2.domain() : config.axis_y2_default), scale.subY2 = $$.getYScale(min.subY, max.subY, scale.subY2 ? scale.subY2.domain() : config.axis_y2_default), axis.setAxis("y2", scale.y2, config.axis_y2_tick_outer, isInit));
    } else // update for arc
    $$.updateArc && $$.updateArc();
  },

  /**
   * Get the zoom or unzoomed scaled value
   * @param {Date|number|object} d Data value
   * @returns {number|null}
   * @private
   */
  xx: function xx(d) {
    var $$ = this,
        config = $$.config,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom,
        fn = config.zoom_enabled && zoom ? zoom : x;
    return d ? fn(isValue(d.x) ? d.x : d) : null;
  },
  xv: function xv(d) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        x = $$.scale.x,
        value = $$.getBaseValue(d);
    return axis.isTimeSeries() ? value = parseDate.call($$, value) : axis.isCategorized() && isString(value) && (value = config.axis_x_categories.indexOf(value)), Math.ceil(x(value));
  },
  yv: function yv(d) {
    var $$ = this,
        _$$$scale2 = $$.scale,
        y = _$$$scale2.y,
        y2 = _$$$scale2.y2,
        yScale = d.axis && d.axis === "y2" ? y2 : y;
    return Math.ceil(yScale($$.getBaseValue(d)));
  },
  subxx: function subxx(d) {
    return d ? this.scale.subX(d.x) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_size = ({
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this,
        state = $$.state;
    state.current.width = $$.getCurrentWidth(), state.current.height = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {string} id Axis id value - x, y or y2
   * @returns {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $el.title && $el.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_" + axisId + "_axes"].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_" + axisId + "_axes"].length,
        axisWidth = hasAxis ? $$.getAxisWidthByAxisId(axisId, withoutRecompute) : 0;
    return padding = isValue(config.padding_left) ? config.padding_left : hasAxis && isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : hasAxis && (!config.axis_y_show || config.axis_y_inner) ? $$.axis.getAxisLabelPosition("y").isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight(withoutTickTextOverflow) {
    withoutTickTextOverflow === void 0 && (withoutTickTextOverflow = !1);
    var padding,
        $$ = this,
        config = $$.config,
        defaultPadding = 10,
        legendWidthOnRight = $$.state.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2"),
        xAxisTickTextOverflow = withoutTickTextOverflow ? 0 : $$.axis.getXAxisTickTextY2Overflow(defaultPadding);
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : $$.axis && config.axis_rotated ? defaultPadding + legendWidthOnRight : $$.axis && (!config.axis_y2_show || config.axis_y2_inner) ? Math.max(2 + legendWidthOnRight + ($$.axis.getAxisLabelPosition("y2").isOuter ? 20 : 0), xAxisTickTextOverflow) : Math.max(ceil10(axisWidth) + legendWidthOnRight, xAxisTickTextOverflow), padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {string} key property/attribute name
   * @returns {number}
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset" + capitalize(key), parent = this.$el.chart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.$el.chart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $el.main.select("." + leftAxisClass).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $el.chart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this;

    if ($$.axis) {
      var position = $$.axis && $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    }

    return 40;
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        current = _$$$state.current,
        rotatedPadding = _$$$state.rotatedPadding,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || isLegendRight || isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return rotatedPadding.top;
    var rotate = $$.getAxisTickRotate(id); // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180), !config.axis_x_tick_multiline && current.height && h > current.height / 2 && (h = current.height / 2)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.axis.x.tickInterval());
  },

  /**
   * Get axis tick test rotate value
   * @param {string} id Axis id
   * @returns {number} rotate value
   * @private
   */
  getAxisTickRotate: function getAxisTickRotate(id) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        rotate = config["axis_" + id + "_tick_rotate"];

    if (id === "x") {
      var isCategorized = axis.isCategorized(),
          isTimeSeries = axis.isTimeSeries(),
          allowedXAxisTypes = isCategorized || isTimeSeries,
          tickCount = 0;
      config.axis_x_tick_fit && allowedXAxisTypes && (tickCount = state.current.maxTickWidths.x.ticks.length + (isTimeSeries ? -1 : 1), tickCount !== state.axis.x.tickCount && (state.axis.x.padding = $$.axis.getXAxisPadding(tickCount)), state.axis.x.tickCount = tickCount), $el.svg && config.axis_x_tick_fit && !config.axis_x_tick_multiline && !config.axis_x_tick_culling && config.axis_x_tick_autorotate && allowedXAxisTypes && (rotate = $$.needToRotateXAxisTickTexts() ? config.axis_x_tick_rotate : 0);
    }

    return rotate;
  },

  /**
   * Check weather axis tick text needs to be rotated
   * @returns {boolean}
   * @private
   */
  needToRotateXAxisTickTexts: function needToRotateXAxisTickTexts() {
    var $$ = this,
        _$$$state2 = $$.state,
        axis = _$$$state2.axis,
        current = _$$$state2.current,
        xAxisLength = current.width - $$.getCurrentPaddingLeft(!1) - $$.getCurrentPaddingRight(!0),
        tickCountWithPadding = axis.x.tickCount + axis.x.padding.left + axis.x.padding.right,
        maxTickWidth = $$.axis.getMaxTickWidth("x");
    return maxTickWidth > (xAxisLength / tickCountWithPadding || 0);
  },
  updateDimension: function updateDimension(withoutAxis) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        $el = $$.$el;
    // pass 'withoutAxis' param to not animate at the init rendering
    hasAxis && !withoutAxis && ($$.axis.x && config.axis_rotated ? ($$.axis.x.create($el.axis.x), $$.axis.subX && $$.axis.subX.create($el.axis.subX)) : ($$.axis.y && $$.axis.y.create($el.axis.y), $$.axis.y2 && $$.axis.y2.create($el.axis.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
  },
  updateSvgSize: function updateSvgSize() {
    var $$ = this,
        state = $$.state,
        svg = $$.$el.svg;

    if (svg.attr("width", state.current.width).attr("height", state.current.height), state.hasAxis) {
      var brush = svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), svg.selectAll(["#" + state.clip.id, "#" + state.clip.idGrid]).select("rect").attr("width", state.width).attr("height", state.height), svg.select("#" + state.clip.idXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), svg.select("#" + state.clip.idYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), state.clip.idSubchart && svg.select("#" + state.clip.idSubchart).select("rect").attr("width", state.width).attr("height", brushSize.height), svg.select("." + config_classes.zoomRect).attr("width", state.width).attr("height", state.height);
    }
  },

  /**
   * Update size values
   * @param {boolean} isInit If is called at initialization
   * @private
   */
  updateSizes: function updateSizes(isInit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        isRotated = config.axis_rotated,
        hasArc = $$.hasArcType();
    isInit || $$.setContainerSize();
    var currLegend = {
      width: legend ? $$.getLegendWidth() : 0,
      height: legend ? $$.getLegendHeight() : 0
    },
        legendHeightForBottom = state.isLegendRight || state.isLegendInset ? 0 : currLegend.height,
        xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
        subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
    // for main
    // for subchart
    // for legend
    // for arc
    state.margin = isRotated ? {
      top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
    } : {
      top: 4 + $$.getCurrentPaddingTop(),
      // for top tick text
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: hasArc ? 0 : $$.getCurrentPaddingLeft()
    }, state.margin2 = isRotated ? {
      top: state.margin.top,
      right: NaN,
      bottom: 20 + legendHeightForBottom,
      left: $$.state.rotatedPadding.left
    } : {
      top: state.current.height - subchartHeight - legendHeightForBottom,
      right: NaN,
      bottom: subchartXAxisHeight + legendHeightForBottom,
      left: state.margin.left
    }, state.margin3 = {
      top: 0,
      right: NaN,
      bottom: 0,
      left: 0
    }, $$.updateSizeForLegend && $$.updateSizeForLegend(currLegend), state.width = state.current.width - state.margin.left - state.margin.right, state.height = state.current.height - state.margin.top - state.margin.bottom, state.width < 0 && (state.width = 0), state.height < 0 && (state.height = 0), state.width2 = isRotated ? state.margin.left - state.rotatedPadding.left - state.rotatedPadding.right : state.width, state.height2 = isRotated ? state.height : state.current.height - state.margin2.top - state.margin2.bottom, state.width2 < 0 && (state.width2 = 0), state.height2 < 0 && (state.height2 = 0), state.arcWidth = state.width - (state.isLegendRight ? currLegend.width + 10 : 0), state.arcHeight = state.height - (state.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && (state.arcHeight += state.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), state.isLegendRight && hasArc && (state.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1), !hasArc && config.axis_x_show && config.axis_x_tick_culling && $$.updateXAxisTickClip();
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/text.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_text = ({
  opacityForText: function opacityForText() {
    return this.hasDataLabel() ? "1" : "0";
  },

  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $el = this.$el;
    $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartTexts);
  },

  /**
   * Update chartText
   * @param {object} targets $$.data.targets
   * @private
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.$el.main.select("." + config_classes.chartTexts).selectAll("." + config_classes.chartText).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").style("opacity", "0").attr("class", classChartText).style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $el.text = $el.main.selectAll("." + config_classes.texts).selectAll("." + config_classes.text).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $el.text.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $el.text = $el.text.enter().append("text").merge($$.$el.text).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {boolean} forFlow Weather is flow
   * @param {boolean} withTransition transition is enabled
   * @returns {Array}
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()
    return $$.$el.text.each(function (d, i) {
      var _this2 = this,
          text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x.bind(this)(d, i)).attr("y", function (d) {
        return y.bind(_this2)(d, i);
      }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    }), !0;
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @param {HTMLElement|d3.selection} element Target element
   * @param {string} className Class name
   * @returns {object} value of element.getBoundingClientRect()
   * @private
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = KEY.textRect + "-" + text.replace(/\W/g, "_"),
        rect = $$.cache.get(cacheKey);
    return rect || ($$.$el.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.cache.add(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {object} indices Indices values
   * @param {boolean} forX whether or not to x
   * @returns {number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet" + capitalize(v) + "Points"](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @param {object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} Position value
   * @private
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {string} id Data id value
   * @param {string} type x | y
   * @returns {number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @param {object} points Data points position
   * @param {object} d Data object
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} x coordinate
   * @private
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > state.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = state.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @param {object} points Data points position
   * @param {object} d Data object
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} y coordinate
   * @private
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !state.hasPositiveValue && state.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > state.height && (yPos = state.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @param {string} id Axis id
   * @param {ChartInternal} $$ ChartInternal context
   * @param {string} selector Selector string
   * @private
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.$el.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 0);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @param {ChartInternal} $$ ChartInternal context
   * @param {string} selector Selector string
   * @private
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.$el.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get the text position
 * @param {string} pos right, left or center
 * @param {number} width chart width
 * @returns {string|number} text-anchor value or position in pixel
 * @private
 */

function getTextPos(pos, width) {
  pos === void 0 && (pos = "left");
  var position,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
}

/* harmony default export */ var internals_title = ({
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.title_text) {
      $el.title = $el.svg.append("g");
      var text = $el.title.append("text").style("text-anchor", getTextPos(config.title_position)).attr("class", config_classes.title);
      setTextValue(text, config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        title = $$.$el.title;

    if (title) {
      var y = $$.yForTitle.call($$);
      /g/i.test(title.node().tagName) ? title.attr("transform", "translate(" + getTextPos(config.title_position, current.width) + ", " + y + ")") : title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @returns {number} x attribute value
   * @private
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        current = $$.state.current,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.$el.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = current.width - textRectWidth, position.indexOf("right") >= 0 ? x = current.width - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = (current.width - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @returns {number} y attribute value
   * @private
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.$el.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @returns {number} padding value
   * @private
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_tooltip = ({
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($el.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $el.tooltip.empty() && ($el.tooltip = $el.chart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.axis.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = parseDate.call($$, config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $el.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $el.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }

    $$.bindTooltipResizePos();
  },

  /**
   * Get the tooltip HTML string
   * @param  {Array} args Arguments
   * @returns {string} Formatted HTML string
   * @private
   */
  getTooltipHTML: function getTooltipHTML() {
    var $$ = this,
        api = $$.api,
        config = $$.config;
    return isFunction(config.tooltip_contents) ? config.tooltip_contents.bind(api).apply(void 0, arguments) : $$.getTooltipContent.apply($$, arguments);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {string} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        _map = ["title", "name", "value"].map(function (v) {
      var fn = config["tooltip_format_" + v];
      return isFunction(fn) ? fn.bind(api) : fn;
    }),
        titleFormat = _map[0],
        nameFormat = _map[1],
        valueFormat = _map[2];

    titleFormat = titleFormat || defaultTitleFormat, nameFormat = nameFormat || function (name) {
      return name;
    }, valueFormat = valueFormat || ($$.isStackNormalized() ? function (v, ratio) {
      return (ratio * 100).toFixed(2) + "%";
    } : defaultValueFormat);

    var order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.axis && $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order.bind(api));

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">" + title + "</th></tr>" : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(param))), $$.isAreaRangeType(row)) {
        var _map2 = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(param)));
        }),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> " + value + " <b>High:</b> " + high + " <b>Low:</b> " + low;
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(param))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:" + color + "\" width=\"10\" height=\"10\"></rect></svg>",
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return text + "</table>";
  },

  /**
   * Get the content template string
   * @param {string} tplStr Tempalte string
   * @returns {Array} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">" + (this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>") + "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>").replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {object} dataToShow data
   * @param {string} tWidth Width value of tooltip element
   * @param {string} tHeight Height value of tooltip element
   * @param {HTMLElement} element Tooltip element
   * @returns {object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        current = _$$$state.current,
        isLegendRight = _$$$state.isLegendRight,
        inputType = _$$$state.inputType,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        left = _d3Mouse[0],
        top = _d3Mouse[1],
        chartRight = svgLeft + current.width - $$.getCurrentPaddingRight(!0),
        chartLeft = $$.getCurrentPaddingLeft(!0),
        size = 20;

    // Determine tooltip position
    if (top += size, $$.hasArcType()) {
      var raw = inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? height : height / 2, left += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = scale.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + size, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + chartLeft + size + ($$.zoomScale ? left : dataScale));
    } // when tooltip left + tWidth > chart's width


    return left + tWidth + 15 > chartRight && (left -= tWidth + chartLeft), top + tHeight > current.height && (top -= hasGauge ? tHeight * 3 : tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @param {object} selectedData Data object
   * @param {HTMLElement} element Tooltip element
   * @private
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        tooltip = $$.$el.tooltip,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = tooltip.datum(),
          _ref = datum || {},
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 0 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 0 : _ref$height,
          dataStr = JSON.stringify(selectedData);

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$.api, selectedData), tooltip.html($$.getTooltipHTML(selectedData, // data
        $$.axis ? $$.axis.getXAxisTickFormat() : $$.categoryName.bind($$), // defaultTitleFormat
        $$.getYFormat(forArc), // defaultValueFormat
        $$.color // color
        )).style("display", null).style("visibility", null) // for IE9
        .datum(datum = {
          index: index,
          current: dataStr,
          width: width = tooltip.property("offsetWidth"),
          height: height = tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        var fnPos = config.tooltip_position || $$.tooltipPosition,
            pos = fnPos.call(this, dataToShow, width, height, element); // Get tooltip dimensions

        ["top", "left"].forEach(function (v) {
          var value = pos[v];
          tooltip.style(v, value + "px"), v !== "left" || datum.xPosInPercent || (datum.xPosInPercent = value / state.current.width * 100);
        });
      }
    }
  },

  /**
   * Adjust tooltip position on resize event
   * @private
   */
  bindTooltipResizePos: function bindTooltipResizePos() {
    var $$ = this,
        resizeFunction = $$.resizeFunction,
        state = $$.state,
        tooltip = $$.$el.tooltip;
    resizeFunction.add(function () {
      if (tooltip.style("display") === "block") {
        var current = state.current,
            _tooltip$datum = tooltip.datum(),
            width = _tooltip$datum.width,
            xPosInPercent = _tooltip$datum.xPosInPercent,
            _value = current.width / 100 * xPosInPercent,
            diff = current.width - (_value + width);

        diff < 0 && (_value += diff), tooltip.style("left", _value + "px");
      }
    });
  },

  /**
   * Hide the tooltip
   * @param {boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        tooltip = $$.$el.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {boolean} show true: show, false: hide
   * @param {number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this,
        charts = $$.charts,
        config = $$.config;

    if (config.tooltip_linked && charts.length > 1) {
      var linkedName = config.tooltip_linked_name;
      charts.forEach(function (c) {
        if (c !== $$.api) {
          var _c$internal = c.internal,
              _config = _c$internal.config,
              $el = _c$internal.$el,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains($el.chart.node());

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.$el.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/transform.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_transform = ({
  getTranslate: function getTranslate(target, index) {
    index === void 0 && (index = 0);
    var x,
        y,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        hasGauge = $$.hasType("gauge"),
        padding = 0;
    if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel(state.margin.left), y = asHalfPixel(state.margin.top);else if (target === "context") x = asHalfPixel(state.margin2.left), y = asHalfPixel(state.margin2.top);else if (target === "legend") x = state.margin3.left, y = state.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : state.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? state.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : state.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subX") x = 0, y = isRotated ? 0 : state.height2;else if (target === "arc") x = state.arcWidth / 2, y = state.arcHeight / 2;else if (target === "radar") {
      var _$$$getRadarSize = $$.getRadarSize(),
          width = _$$$getRadarSize[0];

      x = state.width / 2 - width, y = asHalfPixel(state.margin.top);
    }
    return "translate(" + x + ", " + y + ")";
  },
  transformMain: function transformMain(withTransition, transitions) {
    var xAxis,
        yAxis,
        y2Axis,
        $$ = this,
        main = $$.$el.main;
    transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = main.select("." + config_classes.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = main.select("." + config_classes.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = main.select("." + config_classes.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? main.transition() : main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), main.select("." + config_classes.chartArcs).attr("transform", $$.getTranslate("arc"));
  },
  transformAll: function transformAll(withTransition, transitions) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        $el = $$.$el;
    $$.transformMain(withTransition, transitions), hasAxis && config.subchart_show && $$.transformContext(withTransition, transitions), $el.legend && $$.transformLegend(withTransition);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/type.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_type = ({
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config,
        withoutFadeIn = $$.state.withoutFadeIn;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },

  /**
   * Updte current used chart types
   * @private
   */
  updateTypesElements: function updateTypesElements() {
    var $$ = this,
        current = $$.state.current;
    // Update current chart elements reference
    Object.keys(TYPE).forEach(function (v) {
      var t = TYPE[v],
          has = $$.hasType(t, null, !0),
          idx = current.types.indexOf(t);
      idx === -1 && has ? current.types.push(t) : idx > -1 && !has && current.types.splice(idx, 1);
    }), $$.setChartElements();
  },

  /**
   * Check if given chart types exists
   * @param {string} type Chart type
   * @param {Array} targetsValue Data array
   * @param {boolean} checkFromData Force to check type cotains from data targets
   * @returns {boolean}
   * @private
   */
  hasType: function hasType(type, targetsValue, checkFromData) {
    checkFromData === void 0 && (checkFromData = !1);
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        types = config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return !checkFromData && current.types.length && current.types.indexOf(type) > -1 ? has = !0 : targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      t !== type && (t || type !== "line") || (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @param {string} type Type key
   * @param {object} targets Target data
   * @param {Array} exclude Excluded types
   * @returns {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets, exclude) {
    var _this = this;

    // 실제 노드 존재 여부도 확인필요
    return exclude === void 0 && (exclude = []), !TYPE_BY_CATEGORY[type] // @ts-ignore
    .filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {object} d Data object
   * @param {string|Array} type chart type
   * @returns {boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },
  hasPointType: function hasPointType() {
    var $$ = this;
    return $$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter");
  },

  /**
   * Check if contains arc types chart
   * @param {object} targets Target data
   * @param {Array} exclude Excluded types
   * @returns {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPE_BY_CATEGORY.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint(node) {
    var config = this.config,
        pattern = config.point_pattern,
        isCircle = !1;
    return isCircle = !!(node && node.tagName === "circle") || config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0), isCircle;
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {object} d Data object
   * @returns {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Set the min/max value
 * @param {Chart} $$ Chart instance
 * @param {string} type Set type 'min' or 'max'
 * @param {object} value Value to be set
 * @private
 */

function setMinMax($$, type, value) {
  var config = $$.config,
      axisY = "axis_y_" + type,
      axisY2 = "axis_y2_" + type;
  isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config["axis_x_" + type] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  }));
}
/**
 * Get the min/max value
 * @param {Chart} $$ Chart instance
 * @param {string} type Set type 'min' or 'max'
 * @returns {{x, y, y2}}
 * @private
 */


function axis_getMinMax($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_" + type],
    y: config["axis_y_" + type],
    y2: config["axis_y2_" + type]
  };
}
/**
 * Define axis
 * @ignore
 */


var api_axis_axis = {
  /**
   * Get and set axis labels.
   * @function axis․labels
   * @instance
   * @memberof Chart
   * @param {object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @function axis․min
   * @instance
   * @memberof Chart
   * @param {object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @returns {object|undefined}
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return isValue(_min) ? setMinMax($$, "min", _min) : axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @function axis․max
   * @instance
   * @memberof Chart
   * @param {object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @returns {object|undefined}
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @function axis․range
   * @instance
   * @memberof Chart
   * @param {object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @returns {object|undefined}
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
};
/* harmony default export */ var api_axis = ({
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/Chart/api/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_category = ({
  /**
   * Set specified category name on category axis.
   * @function category
   * @instance
   * @memberof Chart
   * @param {number} i index of category to be changed
   * @param {string} category category value to be changed
   * @returns {string}
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @function categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @returns {Array}
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_flow = ({
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @function flow
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
   *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0),
          isTimeSeries = $$.axis.isTimeSeries();
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, isTimeSeries || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: isTimeSeries ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: isTimeSeries ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, isTimeSeries || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = isTimeSeries ? parseDate.call($$, args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && isTimeSeries && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = isTimeSeries ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
});
// CONCATENATED MODULE: ./src/Chart/api/grid.x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @function xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @returns {object}
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 * // --> Returns: [{value: 1, text: "Label 1"}, {value: 4, text: "Label 4"}]
 */
function xgrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
}

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @function xgrids․add
   * @instance
   * @memberof Chart
   * @param {Array|object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @returns {object}
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @function xgrids․remove
   * @instance
   * @memberof Chart
   * @param {object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});
/* harmony default export */ var grid_x = ({
  xgrids: xgrids
});
// CONCATENATED MODULE: ./src/Chart/api/grid.y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update y grid lines.
 * @function ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @returns {object}
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 * // --> Returns: [{value: 100, text: "Label 1"}, {value: 400, text: "Label 4"}]
 */

function ygrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
}

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @function ygrids․add
   * @instance
   * @memberof Chart
   * @param {Array|object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @returns {object}
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @function ygrids․remove
   * @instance
   * @memberof Chart
   * @param {object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
});
/* harmony default export */ var grid_y = ({
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/Chart/api/group.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var group = ({
  /**
   * Update groups for the targets.
   * @function groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @returns {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/regions.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @function regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @returns {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */
function regions_regions(regions) {
  var $$ = this.internal,
      config = $$.config;
  return regions ? (config.regions = regions, $$.redrawWithoutRescale(), regions) : config.regions;
}

extend(regions_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @function regions․add
   * @instance
   * @memberof Chart
   * @param {Array|object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @returns {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @function regions․remove
   * @instance
   * @memberof Chart
   * @param {object} optionsValue This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @returns {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.$el.main.select("." + config_classes.regions).selectAll(classes.map(function (c) {
      return "." + c;
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region.class || (region.class.split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
});
/* harmony default export */ var api_regions = ({
  regions: regions_regions
});
// CONCATENATED MODULE: ./src/Chart/api/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var api_selection = ({
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @function selected
   * @instance
   * @memberof Chart
   * @param {string} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @returns {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.$el.main.selectAll("." + (config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + config_classes.shape).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @function select
   * @instance
   * @memberof Chart
   * @param {string|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable.bind($$.api)(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @function unselect
   * @instance
   * @memberof Chart
   * @param {string|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable.bind($$.api)(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_x = ({
  /**
   * Get and set x values for the chart.
   * @function x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @returns {object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        axis = $$.axis,
        data = $$.data,
        isCategorized = axis.isCustomX() && axis.isCategorized();
    return isArray(_x) && (isCategorized ? this.categories(_x) : ($$.updateTargetX(data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? this.categories() : data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @function xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @returns {object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(44);

// CONCATENATED MODULE: ./src/Chart/api/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Check if the given domain is within zoom range
 * @param {Array} domain domain value
 * @param {Array} range zoom range value
 * @returns {boolean}
 * @private
 */

function withinRange(domain, range) {
  var min = range[0],
      max = range[1];
  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
}
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @function zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @returns {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


var zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      config = $$.config,
      scale = $$.scale,
      domain = domainValue;

  if (config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.axis.isTimeSeries();

    if (isTimeSeries) {
      var fn = parseDate.bind($$);
      domain = domain.map(function (x) {
        return fn(x);
      });
    }

    if (config.subchart_show) {
      var xScale = scale.zoom || scale.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else scale.x.domain(domain), scale.zoom = scale.x, $$.axis.x.scale(scale.zoom), resultDomain = scale.zoom.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn(config.zoom_onzoom, $$.api, resultDomain);
  } else resultDomain = scale.zoom ? scale.zoom.domain() : scale.x.orgDomain();

  return resultDomain;
};

extend(zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @function zoom․enable
   * @instance
   * @memberof Chart
   * @param {string|boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable(enabled) {
    var $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @function zoom․max
   * @instance
   * @memberof Chart
   * @param {number} [max] maximum value to set for zoom
   * @returns {number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [xDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @function zoom․min
   * @instance
   * @memberof Chart
   * @param {number} [min] minimum value to set for zoom
   * @returns {number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [xDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @function zoom․range
   * @instance
   * @memberof Chart
   * @param {object} [range] zoom range
   * @returns {object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range) {
    var zoom = this.zoom;

    if (isObject(_range)) {
      var min = _range.min,
          max = _range.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
});
/* harmony default export */ var api_zoom = ({
  zoom: zoom_zoom,

  /**
   * Unzoom zoomed area
   * @function unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.scale.zoom) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.$el.main.select("." + config_classes.eventRects);
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/drag.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var interactions_drag = ({
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _state$dragStart = state.dragStart,
            sx = _state$dragStart[0],
            sy = _state$dragStart[1],
            mx = mouse[0],
            my = mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? state.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? state.height : Math.max(sy, my);
        main.select("." + config_classes.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).filter(function (d) {
          return config.data_selection_isselectable.bind($$.api)(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = +shape.attr("cx") * 1,
                y = +shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return; // @ts-ignore


          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (state.dragStart = mouse, main.select("." + config_classes.chart).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (main.select("." + config_classes.dragarea).transition().duration(100).style("opacity", "0").remove(), main.selectAll("." + config_classes.shape).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.state.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(45);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var interactions_flow = ({
  /**
   * Generate flow
   * @param {object} args option object
   * @returns {Function}
   * @private
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        data = $$.data,
        state = $$.state,
        $el = $$.$el;
    return function () {
      var flowLength = args.flow.length; // set flag

      state.flowing = !0, data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      }), $$.updateXGrid && $$.updateXGrid(!0);
      // target elements
      var elements = {};
      ["axis.x", "grid.x", "gridLines.x", "region.list", "text", "bar", "line", "area", "circle"].forEach(function (v) {
        var name = v.split("."),
            node = $el[name[0]];
        node && name.length > 1 && (node = node[name[1]]), node && node.size() && (elements[v] = node);
      }), $$.hideGridFocus(), $$.setFlowList(elements, args);
    };
  },

  /**
   * Set flow list
   * @param {object} elements Target elements
   * @param {object} args option object
   * @private
   */
  setFlowList: function setFlowList(elements, args) {
    var $$ = this,
        flow = args.flow,
        targets = args.targets,
        _flow = flow,
        _flow$duration = _flow.duration,
        duration = _flow$duration === void 0 ? args.duration : _flow$duration,
        flowIndex = _flow.index,
        flowLength = _flow.length,
        orgDataCount = _flow.orgDataCount,
        transform = $$.getFlowTransform(targets, orgDataCount, flowIndex, flowLength),
        wait = generateWait(),
        gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(duration);
    wait.add(Object.keys(elements).map(function (v) {
      var n = elements[v];
      return n = v === "axis.x" ? n.transition(gt).call(function (g) {
        return $$.axis.x.setTransition(gt).create(g);
      }) : v === "region.list" ? n.filter($$.isRegionOnX).transition(gt).attr("transform", transform) : n.transition(gt).attr("transform", transform), n;
    })), gt.call(wait, function () {
      $$.cleanUpFlow(elements, args);
    });
  },

  /**
   * Clean up flow
   * @param {object} elements Target elements
   * @param {object} args option object
   * @private
   */
  cleanUpFlow: function cleanUpFlow(elements, args) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        isRotated = config.axis_rotated,
        flow = args.flow,
        shape = args.shape,
        xv = args.xv,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        _flow2 = flow,
        _flow2$done = _flow2.done,
        done = _flow2$done === void 0 ? function () {} : _flow2$done,
        flowLength = _flow2.length;
    // draw again for removing flowed elements and reverting attr
    // callback for end of flow
    flowLength && (["circle", "text", "shape", "eventRect"].forEach(function (v) {
      var target = [];

      for (var i = 0; i < flowLength; i++) target.push("." + config_classes[v] + "-" + i);

      svg.selectAll("." + config_classes[v + "s"]) // circles, shapes, texts, eventRects
      .selectAll(target).remove();
    }), svg.select("." + config_classes.xgrid).remove()), Object.keys(elements).forEach(function (v) {
      var n = elements[v];
      if (v !== "axis.x" && n.attr("transform", null), v === "grid.x") n.attr(state.xgridAttr);else if (v === "gridLines.x") n.attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv);else if (v === "gridLines.x") n.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv), n.select("text").attr("x", isRotated ? state.width : 0).attr("y", xv);else if (/^(area|bar|line)$/.test(v)) n.attr("d", shape.type[v]);else if (v === "text") n.attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$));else if (v !== "circle") v === "region.list" && n.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));else if ($$.isCirclePoint()) n.attr("cx", cx).attr("cy", cy);else {
        var xFunc = function (d) {
          return cx(d) - config.point_r;
        },
            yFunc = function (d) {
          return cy(d) - config.point_r;
        };

        n.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
        .attr("cy", cy);
      }
    }), config.interaction_enabled && $$.redrawEventRect(), done.call($$.api), state.flowing = !1;
  },

  /**
   * Get flow transform value
   * @param {object} targets target
   * @param {number} orgDataCount original data count
   * @param {number} flowIndex flow index
   * @param {number} flowLength flow length
   * @returns {string}
   * @private
   */
  getFlowTransform: function getFlowTransform(targets, orgDataCount, flowIndex, flowLength) {
    var translateX,
        $$ = this,
        data = $$.data,
        x = $$.scale.x,
        dataValues = data.targets[0].values,
        flowStart = $$.getValueOnIndex(dataValues, flowIndex),
        flowEnd = $$.getValueOnIndex(dataValues, flowIndex + flowLength),
        orgDomain = x.domain(),
        domain = $$.updateXDomain(targets, !0, !0);
    orgDataCount ? orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = x(orgDomain[0]) - x(domain[0]) : translateX = $$.axis.isTimeSeries() ? x(orgDomain[0]) - x(domain[0]) : x(flowStart.x) - x(flowEnd.x) : dataValues.length === 1 ? $$.axis.isTimeSeries() ? (flowStart = $$.getValueOnIndex(dataValues, 0), flowEnd = $$.getValueOnIndex(dataValues, dataValues.length - 1), translateX = x(flowStart.x) - x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = x(orgDomain[0]) - x(domain[0]);
    var scaleX = diffDomain(orgDomain) / diffDomain(domain);
    return "translate(" + translateX + ",0) scale(" + scaleX + ",1)";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/eventrect.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var eventrect = ({
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.$el.main.select("." + config_classes.eventRects).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll("." + config_classes.eventRect).remove(), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), isMultipleX) eventRectUpdate = $el.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $el.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), eventRectUpdate = $el.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $el.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.state.inputType !== "touch" || $el.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + config_classes.eventRect + "-?|s)", "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isboolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if (state.dragging || state.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || state.cancelClick) && state.cancelClick && (state.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @param {object} eventRectUpdate d3.select(CLASS.eventRects) object.
   * @private
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        xScale = scale.zoom || scale.x,
        eventRectData = eventRectUpdate || $$.$el.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = state.width, h = state.height;else {
      var rectW, rectX;
      if ($$.axis.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? state.height : state.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? state.width : rectW, h = isRotated ? rectW : state.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || main.selectAll("." + config_classes.shape + "-" + index).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable.bind($$.api)(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config,
        _$$$$el = $$.$el,
        bar = _$$$$el.bar,
        circle = _$$$$el.circle;
    circle && config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), bar && $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if (state.mouseover && (!closest || closest.id !== state.mouseover.id) && (config.data_onout.call($$.api, state.mouseover), state.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.$el.svg.select("." + config_classes.eventRect).style("cursor", "pointer"), !state.mouseover && (config.data_onover.call($$.api, closest), state.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this,
        _$$$$el2 = $$.$el,
        bar = _$$$$el2.bar,
        circle = _$$$$el2.circle,
        tooltip = _$$$$el2.tooltip;
    $$.$el.svg.select("." + config_classes.eventRect).style("cursor", null), $$.hideGridFocus(), tooltip && ($$.hideTooltip(), $$._handleLinkedCharts(!1)), circle && $$.unexpandCircles(), bar && $$.unexpandBars();
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @param {object} eventRectEnter d3.select(CLASS.eventRects) object.
   * @returns {object} d3.select(CLASS.eventRects) object.
   * @private
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return state.inputType === "mouse" && rect.on("mouseover", function (d) {
      state.dragging || state.flowing || $$.hasArcType() || config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!(state.dragging || state.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.$el.svg.select("." + config_classes.eventRect + "-" + index);
        $$.isStepType(d) && config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.scale.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    if ($$.hasArcType() || !$$.toggleShape || state.cancelClick) return void (state.cancelClick && (state.cancelClick = !1));
    var index = d.index;
    main.selectAll("." + config_classes.shape + "-" + index).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.bind($$.api)(d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @param {object} eventRectEnter d3.select(CLASS.eventRects) object.
   * @returns {object} d3.select(CLASS.eventRects) object.
   * @private
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        inputType = _$$$state.inputType,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.$el.main.selectAll("." + config_classes.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + config_classes.shape + "-" + closest.index).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.bind($$.api)(closest, this));
      });
    } // select if selection enabled

  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_subchart = ({
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        subchart = $$.$el.subchart,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.$el.svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.state.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = scale.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map(scale.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && subchart.main && subchart.main.select("." + config_classes.brush).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return (// @ts-ignore
        subchart.main ? subchart.main.select("." + config_classes.brush) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([])
      );
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        clip = _$$$state.clip,
        hasAxis = _$$$state.hasAxis,
        _$$$$el = $$.$el,
        defs = _$$$$el.defs,
        svg = _$$$$el.svg,
        subchart = _$$$$el.subchart,
        axis = _$$$$el.axis;

    if (hasAxis) {
      var visibility = config.subchart_show ? "visible" : "hidden",
          clipId = clip.id + "-subchart",
          clipPath = $$.getClipPath(clipId);
      clip.idSubchart = clipId, $$.appendClip(defs, clipId), $$.initBrush(), subchart.main = svg.append("g").attr("transform", $$.getTranslate("context"));
      var main = subchart.main;
      main.style("visibility", visibility), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars), main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), axis.subX = main.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subX")).attr("clip-path", config.axis_rotated ? "" : clip.pathXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
    }
  },

  /**
   * Update sub chart
   * @param {object} targets $$.data.targets
   * @private
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.subchart.main,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var barUpdate = main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", classChartBar),
          barEnter = barUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(barUpdate);
      barEnter.append("g").attr("class", classBars);
      // -- Line --//
      var lineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", classChartLine),
          lineEnter = lineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(lineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      lineEnter.append("g").attr("class", classLines), $$.hasType("area") && lineEnter.append("g").attr("class", classAreas), main.selectAll("." + config_classes.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? state.width2 : state.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @param {object} durationForExit Transition duration
   * @private
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.bar = subchart.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data($$.barData.bind($$)), subchart.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.bar = subchart.bar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge(subchart.bar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @param {string} drawBarOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   * @private
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var bar = this.$el.subchart.bar;
    (withTransition ? bar.transition(getRandom()).duration(duration) : bar).attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.line = subchart.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), subchart.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.line = subchart.line.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge(subchart.line).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {string} drawLineOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var line = this.$el.subchart.line;
    (withTransition ? line.transition(getRandom()).duration(duration) : line).attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.area = subchart.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), subchart.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.area = subchart.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge(subchart.area).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {string} drawAreaOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var area = this.$el.subchart.area;
    (withTransition ? area.transition(getRandom()).duration(duration) : area).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.state.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {boolean} withSubchart whether or not to show subchart
   * @param {number} duration duration
   * @param {object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.subchart.main;
    main.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw" + name](shape.indices[v], !0);
      $$["update" + name + "ForSubchart"](duration), $$["redraw" + name + "ForSubchart"](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this,
        _$$$config = $$.config,
        onBrush = _$$$config.subchart_onbrush,
        withY = _$$$config.zoom_rescale,
        scale = $$.scale;
    $$.redraw({
      withTransition: !1,
      withY: withY,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), onBrush.bind($$.api)(scale.x.orgDomain());
  },

  /**
   * Transform context
   * @param {boolean} withTransition indicates transition is enabled
   * @param {object} transitions The return value of the generateTransitions method of Axis.
   * @private
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this,
        main = $$.$el.subchart.main;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = main.select("." + config_classes.axisX), withTransition && (subXAxis = subXAxis.transition())), main.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subX"));
  },

  /**
   * Get extent value
   * @returns {Array} default extent
   * @private
   */
  getExtent: function getExtent() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        extent = config.axis_x_extent;
    if (extent) if (isFunction(extent)) extent = extent.bind($$.api)($$.getXDomain($$.data.targets), scale.subX);else if ($$.axis.isTimeSeries() && extent.every(isNaN)) {
      var fn = parseDate.bind($$);
      extent = extent.map(function (v) {
        return scale.subX(fn(v));
      });
    }
    return extent;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var interactions_zoom = ({
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.scale.zoom = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent(bind) {
    bind === void 0 && (bind = !0);
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        zoomEnabled = config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = main.select("." + config_classes.eventRects);
    zoomEnabled && bind ? !config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent
    // @ts-ignore
    // @ts-ignore

    /**
     * Update scale according zoom transform value
     * @param {object} transform transform object
     * @private
     */
    // @ts-ignore
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      org.xScale && org.xScale.range(scale.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"](org.xScale || scale.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, org.xDomain), scale.zoom = $$.getCustomizedScale(newScale), $$.axis.x.scale(scale.zoom), rescale && (!org.xScale && (org.xScale = scale.x.copy()), scale.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        org = $$.org,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && (scale.zoom || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && scale.x.domain().every(function (v, i) {
        return v !== org.xDomain[i];
      }) && scale.x.domain(org.xDomain), $$.zoom.updateTransformScale(transform), $$.axis.isCategorized() && scale.x.orgDomain()[0] === org.xDomain[0] && scale.x.domain([org.xDomain[0] - 1e-10, scale.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.state.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, scale.zoom.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn(config.zoom_onzoomend, $$.api, scale[scale.zoom ? "zoom" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
   * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _org$xDomain = org.xDomain,
        min = _org$xDomain[0],
        max = _org$xDomain[1];
    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this,
        _$$$scale = $$.scale,
        subX = _$$$scale.subX,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom;

    if (zoom) {
      var zoomDomain = zoom.domain(),
          xDomain = subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.axis.x.scale(subX), x.domain(subX.orgDomain()), $$.scale.zoom = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @param {d3.selection} eventRects evemt <rect> element
   * @param {string} type zoom type
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var zoomRect,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      // @ts-ignore
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.$el.main.append("rect").attr("clip-path", state.clip.path).attr("class", config_classes.zoomBrush).attr("width", isRotated ? state.width : 0).attr("height", isRotated ? 0 : state.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      // @ts-ignore
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.scale.zoom || $$.scale.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event3 = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event3 ? [_event3.clientX, _event3.clientY] : [_event3.x, _event3.y],
            x = _ref2[0],
            y = _ref2[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.$el.chart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick.bind($$.api)(this), $$.api.unzoom();
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/clip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_clip = ({
  initClip: function initClip() {
    var $$ = this,
        clip = $$.state.clip;
    // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
    // Define 'clip-path' attribute values
    clip.id = $$.state.datetimeId + "-clip", clip.idXAxis = clip.id + "-xaxis", clip.idYAxis = clip.id + "-yaxis", clip.idGrid = clip.id + "-grid", clip.path = $$.getClipPath(clip.id), clip.pathXAxis = $$.getClipPath(clip.idXAxis), clip.pathYAxis = $$.getClipPath(clip.idYAxis), clip.pathGrid = $$.getClipPath(clip.idGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(" + (isIE9 ? "" : browser_doc.URL.split("#")[0]) + "#" + id + ")";
  },
  appendClip: function appendClip(parent, id) {
    id && parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    var margin = this.state.margin,
        left = Math.max(30, margin.left); // axis line width + padding for left

    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    var margin = this.state.margin;
    return forHorizontal ? -20 : -margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        _$$$state = $$.state,
        margin = _$$$state.margin,
        width = _$$$state.width,
        left = Math.max(30, margin.left),
        right = Math.max(30, margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? width + 2 + left + right : margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    var _this$state = this.state,
        margin = _this$state.margin,
        height = _this$state.height; // less than 20 is not enough to show the axis label 'outer' without legend

    return (forHorizontal ? margin.bottom : margin.top + height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  },
  updateXAxisTickClip: function updateXAxisTickClip() {
    var $$ = this,
        clip = $$.state.clip,
        newXAxisHeight = $$.getHorizontalAxisHeight("x");
    clip.idXAxisTickTexts = $$.clipId + "-xaxisticktexts", clip.pathXAxisTickTexts = $$.getClipPath(clip.idXAxisTickTexts), !$$.config.axis_x_tick_multiline && $$.getAxisTickRotate("x") && newXAxisHeight !== $$.xAxisHeight && ($$.setXAxisTickClipWidth(), $$.setXAxisTickTextClipPathWidth()), $$.xAxisHeight = newXAxisHeight;
  },
  setXAxisTickClipWidth: function setXAxisTickClipWidth() {
    var $$ = this,
        config = $$.config,
        maxTickWidths = $$.state.current.maxTickWidths,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if (!config.axis_x_tick_multiline && xAxisTickRotate) {
      var sinRotation = Math.sin(Math.PI / 180 * Math.abs(xAxisTickRotate));
      maxTickWidths.x.clipPath = ($$.getHorizontalAxisHeight("x") - 20) / sinRotation;
    } else maxTickWidths.x.clipPath = null;
  },
  setXAxisTickTextClipPathWidth: function setXAxisTickTextClipPathWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        clip = _$$$state2.clip,
        current = _$$$state2.current,
        svg = $$.$el.svg;
    svg && svg.select("#" + clip.idXAxisTickTexts + " rect").attr("width", current.maxTickWidths.x.clipPath).attr("height", 30);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
};

/**
 * Get grid text x value getter function
 * @param {boolean} isX Is x Axis
 * @param {number} width Width value
 * @param {number} height Height value
 * @returns {Function}
 * @private
 */
function getGridTextX(isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
}
/**
 * Update coordinate attributes value
 * @param {d3.selection} el Target node
 * @param {string} type Type
 * @private
 */


function smoothLines(el, type) {
  type === "grid" && el.each(function () {
    var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
    ["x1", "x2", "y1", "y2"].forEach(function (v) {
      return g.attr(v, Math.ceil(+g.attr(v)));
    });
  });
}

/* harmony default export */ var internals_grid = ({
  hasGrid: function hasGrid() {
    var config = this.config;
    return ["x", "y"].some(function (v) {
      return config["grid_" + v + "_show"] || config["grid_" + v + "_lines"].length;
    });
  },
  initGrid: function initGrid() {
    var $$ = this;
    $$.hasGrid() && $$.initGridLines(), $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($el.gridLines.main = $el.main.insert("g", "." + config_classes.chart + (config.grid_lines_front ? " + *" : "")).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid + " " + config_classes.gridLines), $el.gridLines.main.append("g").attr("class", config_classes.xgridLines), $el.gridLines.main.append("g").attr("class", config_classes.ygridLines), $el.gridLines.x = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        grid = _$$$$el.grid,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, scale.x),
        tickOffset = $$.axis.isCategorized() ? $$.axis.x.tickOffset() : 0,
        pos = function (d) {
      return ((scale.zoom || scale.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    state.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": state.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": state.height
    }, grid.x = main.select("." + config_classes.xgrids).selectAll("." + config_classes.xgrid).data(xgridData), grid.x.exit().remove(), grid.x = grid.x.enter().append("line").attr("class", config_classes.xgrid).merge(grid.x), withoutUpdate || grid.x.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys(state.xgridAttr).forEach(function (id) {
        grid.attr(id, state.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? state.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el2 = $$.$el,
        grid = _$$$$el2.grid,
        main = _$$$$el2.main,
        isRotated = config.axis_rotated,
        gridValues = $$.axis.y.tickValues() || $$.scale.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.scale.y(d));
    };

    grid.y = main.select("." + config_classes.ygrids).selectAll("." + config_classes.ygrid).data(gridValues), grid.y.exit().remove(), grid.y = grid.y.enter().append("line").attr("class", config_classes.ygrid).merge(grid.y), grid.y.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : state.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? state.height : pos), smoothLines(grid.y, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this,
        _$$$$el3 = $$.$el,
        grid = _$$$$el3.grid,
        gridLines = _$$$$el3.gridLines;
    // hide if arc type
    gridLines.main || $$.initGridLines(), grid.main.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {number} duration Dration value
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$$el4 = $$.$el,
        gridLines = _$$$$el4.gridLines,
        main = _$$$$el4.main,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid();
    var xLines = main.select("." + config_classes.xgridLines).selectAll("." + config_classes.xgridLine).data(config.grid_x_lines); // exit

    xLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = xLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), xLines = xgridLine.merge(xLines), xLines.attr("class", function (d) {
      return (config_classes.xgridLine + " " + (d.class || "")).trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), gridLines.x = xLines;
  },

  /**
   * Update Y Grid lines
   * @param {number} duration Duration value
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid();
    var ygridLines = $el.main.select("." + config_classes.ygridLines).selectAll("." + config_classes.ygridLine).data(config.grid_y_lines); // exit

    ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), ygridLines = ygridLine.merge(ygridLines);
    // update
    var yv = $$.yv.bind($$);
    ygridLines.attr("class", function (d) {
      return (config_classes.ygridLine + " " + (d.class || "")).trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? height : yv).transition().style("opacity", "1"), ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, width, height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.gridLines.y = ygridLines;
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        gridLines = $$.$el.gridLines,
        xv = $$.xv.bind($$),
        lines = gridLines.x.select("line"),
        texts = gridLines.x.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, width, height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        isFront = config.grid_front,
        className = "." + config_classes[isFront && $el.gridLines.main ? "gridLines" : "chart"] + (isFront ? " + *" : ""),
        grid = $el.main.insert("g", className).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid);
    $el.grid.main = grid, config.grid_x_show && grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && (grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} selectedData Selected data
   * @private
   */
  showGridFocus: function showGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        _$$$state3 = $$.state,
        width = _$$$state3.width,
        height = _$$$state3.height,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var focusEl = $$.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus),
          isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScaleById(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), smoothLines(focusEl, "grid"), $$.showCircleFocus(selectedData);
    }
  },
  hideGridFocus: function hideGridFocus() {
    var $$ = this,
        inputType = $$.state.inputType,
        main = $$.$el.main;
    inputType === "mouse" && (main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus).style("visibility", "hidden"), $$.hideCircleFocus());
  },
  updateGridFocus: function updateGridFocus() {
    var $$ = this,
        _$$$state4 = $$.state,
        inputType = _$$$state4.inputType,
        width = _$$$state4.width,
        height = _$$$state4.height,
        grid = $$.$el.grid,
        xgridFocus = grid.main.select("line." + config_classes.xgridFocus);

    if (inputType === "touch") {
      if (!xgridFocus.empty()) {
        var d = xgridFocus.datum();
        d && $$.showGridFocus([d]);
      }

      $$.showCircleFocus();
    } else {
      var _isRotated = $$.config.axis_rotated;
      xgridFocus.attr("x1", _isRotated ? 0 : -10).attr("x2", _isRotated ? width : -10).attr("y1", _isRotated ? -10 : 0).attr("y2", _isRotated ? -10 : height);
    } // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()


    return !0;
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.$el.main.select("." + config_classes.axisX).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.$el.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/region.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection



/* harmony default export */ var region = ({
  initRegion: function initRegion() {
    var $$ = this,
        $el = $$.$el;
    $el.region.main = $el.main.append("g").attr("clip-path", $$.state.clip.path).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $el.region.main || $$.initRegion(), $el.region.main.style("visibility", $$.hasArcType() ? "hidden" : "visible");
    // select <g> element
    var list = $el.main.select("." + config_classes.regions).selectAll("." + config_classes.region).data(config.regions);
    list.exit().transition().duration(duration).style("opacity", "0").remove(), list = list.enter().append("g").merge(list).attr("class", $$.classRegion.bind($$)), list.append("rect").style("fill-opacity", "0"), $el.region.list = list;
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.$el.region.list.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], pos = currScale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, pos = currScale($$.axis.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = state[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], end = currScale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, end = currScale($$.axis.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/ChartInternal/internals/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_selection = ({
  /**
   * Select a point
   * @param {object} target Target point
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @param {object} target Target point
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    // remove selected-circle from low layer g
    callFn(config.data_onunselected, $$.api, d, target.node()), $el.main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @param {boolean} selected whether or not to select.
   * @param {object} target Target object
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = (selected ? "" : "un") + "selectPoint";
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @param {object} target Target path
   * @param {object} d Data object
   * @private
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {object} target Target path
   * @param {object} d Data object
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @param {boolean} selected whether or not to select.
   * @param {object} target Target object
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  togglePath: function togglePath(selected, target, d, i) {
    this[(selected ? "" : "un") + "selectPath"](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @param {object} that shape
   * @param {object} d Data object
   * @returns {Function} toggle method
   * @private
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @param {object} that shape
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable.bind($$.api)(d)) {
      if (!config.data_selection_multiple) {
        var selector = "." + config_classes.shapes;
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), main.selectAll(selector).selectAll("." + config_classes.shape).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_shape_bar = ({
  initBar: function initBar() {
    var $el = this.$el;
    $el.bar = $el.main.select("." + config_classes.chart) // should positioned at the beginning of the shape node to not overlap others
    .insert("g", ":first-child").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.bar || $$.initBar();
    var mainBarUpdate = $$.$el.main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        $el = $$.$el,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $el.bar = $el.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data(barData), $el.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.bar = $el.bar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($el.bar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    var bar = this.$el.bar;
    return [(withTransition ? bar.transition(getRandom()) : bar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = config.data_groups.length,
        tickInterval = (scale.zoom || $$) && !$$.axis.isCategorized() ? $$.xx(scale.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        main = $$.$el.main,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? main.selectAll("." + config_classes.bars + $$.getTargetSelectorSuffix(id)) : main).selectAll("." + config_classes.bar + suffix);
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a" + radius + "," + radius + " " + (isNegative ? "1 0 0" : "0 0 1") + " ";
        pathRadius[+!isRotated] = "" + arc + radius + "," + radius, pathRadius[+isRotated] = "" + arc + [-radius, radius][isRotated ? "sort" : "reverse"](), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H" + (points[1][indexX] - radius) + " " + pathRadius[0] + "V" + (points[2][indexY] - radius) + " " + pathRadius[1] + "H" + points[3][indexX] : "V" + (points[1][indexY] + (isNegative ? -radius : radius)) + " " + pathRadius[0] + "H" + (points[2][indexX] - radius) + " " + pathRadius[1] + "V" + points[3][indexY];
      return "M" + points[0][indexX] + "," + points[0][indexY] + path + "z";
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        axis = isSub ? $$.axis.subX : $$.axis.x,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list = list,
        seg0 = _list[0],
        seg1 = _list[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var shape_bubble = ({
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value
   * @returns {number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        cacheKey = KEY.bubbleBaseLength,
        baseLength = $$.cache.get(cacheKey);
    return baseLength || $$.cache.add(cacheKey, baseLength = getMinMax("min", [width, height])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR.bind($$.api)(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {object|Array} d data value
   * @param {string} type - y or z
   * @returns {number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {object|Array} d data value
   * @returns {boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/ChartInternal/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_line = ({
  initLine: function initLine() {
    var $el = this.$el;
    $el.line = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        $el = $$.$el,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.line || $$.initLine();
    var mainLineUpdate = $el.main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    mainLineEnter.append("g").attr("class", classLines), $$.hasTypeOf("Area") && mainLineEnter.append("g").attr("class", $$.classAreas.bind($$));
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this,
        extraLineClasses = $$.format.extraLineClasses,
        $el = $$.$el;
    $el.line = $el.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $el.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.line = $el.line.enter().append("path").attr("class", function (d) {
      return $$.classLine.bind($$)(d) + " " + (extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($el.line).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    var line = this.$el.line;
    return [(withTransition ? line.transition(getRandom()) : line).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @returns {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? scale.subX : scale.x;
    return function (d) {
      var path,
          y = yScale(d.id, isSub),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.axis.isTimeSeries(),
        xOffset = $$.axis.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? parseDate.call($$, v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M" + points[0][0] + "," + points[0][1] + "L" + points[1][0] + "," + points[1][1];
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "" + (_i && hasPrevData ? "L" : "M") + xValue(data) + "," + yValue(data);else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1].bind($$.api)(d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param {object} areaIndices Indices
   * @param {boolean} isSub Weather is sub axis
   * @returns {Function}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : $$.getShapeYMin(d.id));
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScaleById(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var getTransitionName = function () {
  return getRandom();
};

/* harmony default export */ var shape_point = ({
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  initialOpacityForCircle: function initialOpacityForCircle(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
  },
  opacityForCircle: function opacityForCircle(d) {
    var config = this.config,
        opacity = config.point_show && !config.point_focus_only ? "1" : "0";
    return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
  },
  initCircle: function initCircle() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.point = $$.generatePoint(), config.point_show && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartCircles);
  },
  updateTargetForCircle: function updateTargetForCircle(t) {
    var $$ = this,
        config = $$.config,
        data = $$.data,
        $el = $$.$el,
        targets = t || data.targets,
        classCircles = $$.classCircles.bind($$);
    !$el.circle && config.point_show && $$.initCircle();
    var mainCircle = $el.main.select("." + config_classes.chartCircles).style("pointer-events", "none").selectAll("." + config_classes.circles).data(targets).attr("class", classCircles),
        mainCircleEnter = mainCircle.enter();
    // Circles for each data point on lines
    // Update date for selected circles
    config.data_selection_enabled && mainCircleEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainCircleEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }), targets.forEach(function (t) {
      $el.main.selectAll("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + config_classes.selectedCircle).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateCircle: function updateCircle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        focusOnly = config.point_focus_only;

    if (config.point_show) {
      var circles = $el.main.selectAll("." + config_classes.circles).selectAll("." + config_classes.circle).data(function (d) {
        var data = !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
        return focusOnly ? [data[0]] : data;
      });
      circles.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      circles.enter().append(fn).merge(circles).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$)), $el.circle = $el.main.selectAll("." + config_classes.circles + " ." + config_classes.circle);
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        rendered = $$.state.rendered,
        _$$$$el = $$.$el,
        circle = _$$$$el.circle,
        main = _$$$$el.main,
        selectedCircles = main.selectAll("." + config_classes.selectedCircle);
    if (!$$.config.point_show) return [];
    var fn = $$.point("update", $$, cx, cy, $$.color, withTransition, flow, selectedCircles),
        posAttr = $$.isCirclePoint() ? "c" : "",
        t = getRandom(),
        opacityStyleFn = $$.opacityForCircle.bind($$),
        mainCircles = [];
    return circle.each(function (d) {
      var result = fn.bind(this)(d);
      result = (withTransition || !rendered ? result.transition(t) : result).style("opacity", opacityStyleFn), mainCircles.push(result);
    }), [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
  },

  /**
   * Show focused data point circle
   * @param {object} d Selected data
   * @private
   */
  showCircleFocus: function showCircleFocus(d) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;

    if (state.transiting === !1 && config.point_focus_only) {
      var circle = $el.circle,
          hasRadar = state.hasRadar,
          cx = (hasRadar ? $$.radarCircleX : $$.circleX).bind($$),
          cy = (hasRadar ? $$.radarCircleY : $$.circleY).bind($$),
          fn = $$.point("update", $$, cx, cy, $$.color, !1);
      d && (circle = circle.filter(function (t) {
        return d.some(function (v) {
          return v.id === t.id;
        });
      }).data(d)), circle.attr("class", this.updatePointClass.bind(this)).style("opacity", "1").each(function (d) {
        fn.bind(this)(d), $$.expandCircles(d.index, d.id);
      }).style("visibility", null);
    }
  },

  /**
   * Hide focused data point circle
   * @private
   */
  hideCircleFocus: function hideCircleFocus() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    config.point_focus_only && $el.circle.style("visibility", "hidden");
  },
  circleX: function circleX(d) {
    return this.xx(d);
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScaleById(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? $$.$el.main.selectAll("." + config_classes.circles + $$.getTargetSelectorSuffix(id)) : $$.$el.main).selectAll("." + config_classes.circle + suffix);
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(" + x + " " + y + ") scale(" + scale + ")");
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(" + r(circles) / $$.config.point_r + ")");
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR.bind($$.api)(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint(node) ? "c" : "",
        cx = +element.attr(prefix + "x"),
        cy = +element.attr(prefix + "y");

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _getBoundingRect = getBoundingRect(node),
          x = _getBoundingRect.x,
          y = _getBoundingRect.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.$el.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.$el.defs.select("#" + id);
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        circle = $$.$el.circle,
        pointClass = !1;
    return (isObject(d) || circle) && (pointClass = d === !0 ? circle.each(function (d) {
      var className = $$.classCircle.bind($$)(d);
      this.getAttribute("class").indexOf(config_classes.EXPANDED) > -1 && (className += " " + config_classes.EXPANDED), this.setAttribute("class", className);
    }) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = datetimeId + "-point-" + id,
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#" + id).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/shape.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_shape = ({
  /**
   * Get the shape draw function
   * @returns {object}
   * @private
   */
  getDrawShape: function getDrawShape() {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        hasRadar = $$.state.hasRadar,
        shape = {
      type: {},
      indices: {},
      pos: {}
    };

    // setup drawer - MEMO: these must be called after axis updated
    if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
      var indices = $$.getShapeIndices($$.isLineType);

      if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
        var _indices = $$.getShapeIndices($$.isAreaType);

        shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
      }
    }

    if ($$.hasType("bar")) {
      var _indices2 = $$.getShapeIndices($$.isBarType);

      shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
    }

    return (!$$.hasArcType() || hasRadar) && (shape.pos = {
      xForText: $$.generateXYForText(shape.indices, !0),
      yForText: $$.generateXYForText(shape.indices, !1),
      // generate circle x/y functions depending on updated params
      cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
      cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
    }), shape;
  },
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {object} indices Indices object
   * @param {string} id Data id value
   * @returns {object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {object} indices Indices object
   * @returns {number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        currScale = isSub ? scale.subX : scale.zoom || scale.x,
        barPadding = config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = currScale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return $$.getYScaleById(d.id, isSub)(value);
    };
  },

  /**
   * Get shape based y Axis min value
   * @param {string} id Data id
   * @returns {number}
   * @private
   */
  getShapeYMin: function getShapeYMin(id) {
    var $$ = this,
        _$$$scale$$$$axis$get = $$.scale[$$.axis.getId(id)].domain(),
        yMin = _$$$scale$$$$axis$get[0];

    return !$$.isGrouped(id) && yMin > 0 ? yMin : 0;
  },

  /**
   * Get Shape's offset data
   * @param {Function} typeFilter Type filter function
   * @returns {object}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        isStackNormalized = $$.isStackNormalized(),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values,
          values = {};
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var rowValueMapByXValue = rowValues.reduce(function (out, d) {
        var key = +d.x;
        return out[key] = d, values[key] = isStackNormalized ? $$.getRatio("index", d, !0) : d.value, out;
      }, {});
      return {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref, index) {
      var id = _ref.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = $$.getYScaleById(d.id, isSub),
          y0 = scale($$.getShapeYMin(d.id)),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.filter(function (t) {
        return t.id !== d.id;
      }).forEach(function (t) {
        if (ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var row = t.rowValues[idx]; // check if the x values line up

          row && +row.x === dataXAsNumber || (row = t.rowValueMapByXValue[dataXAsNumber]), row && row.value * d.value >= 0 && (offset += scale(t.values[dataXAsNumber]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScaleById(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        config = $$.config,
        type = config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? config.line_step_type : "linear";
  }
});
// CONCATENATED MODULE: ./src/config/resolver/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Axis based chart
 */
// Chart









 // ChartInternal















var axis_api = [api_axis, api_category, api_flow, grid_x, grid_y, group, api_regions, api_selection, api_x, api_zoom];
var internal = [interactions_drag, interactions_flow, interactions_subchart, interactions_zoom, internals_clip, internals_grid, region, internals_selection, eventrect, ChartInternal_shape_bar, shape_bubble, ChartInternal_shape_line, shape_point, shape_shape];
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/ChartInternal/shape/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var shape_arc = ({
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config[dataType + "_startingAngle"] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config[dataType + "_padAngle"]) || 0,
        sortValue = $$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues(sortValue).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    state.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), state.radius = state.radiusExpanded * .95, state.innerRadiusRatio = w ? (state.radius - w) / state.radius : .6, state.gaugeArcWidth = w || (gaugeArcWidth <= state.radius - state.innerRadius ? state.radius - state.innerRadius : gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius);
    var innerRadius = radius || (padding ? padding * (state.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    state.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? state.radius * state.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        innerRadius = $$.state.innerRadius;
    return !isNumber(innerRadius) && d && (innerRadius = innerRadius[d.data.id] || 0), innerRadius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data) && !$$.hasMultiArcGauge()) {
      // to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value
      var totalSum = $$.getTotalDataSum(state.rendered); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        state = $$.state,
        ir = $$.getInnerRadius(),
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index : state.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        state = $$.state,
        newRate = rate || 1,
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min(state.radiusExpanded * newRate - state.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index + expandWidth : state.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : state.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        radius = _$$$state.radius,
        radiusExpanded = _$$$state.radiusExpanded,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * (radiusExpanded + 25),
          y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(" + x + "," + y + ")";
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio.bind($$.api)(d, radius, h) : ratio : radius && (h ? (36 / radius > .375 ? 1.175 - 36 / radius : .8) * radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")";
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this,
        hasGauge = $$.hasType("gauge");
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          ratio = $$.getRatio("arc", updated),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var value = (updated || d).value,
            text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, d.data.id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      } else node.text("");
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var $$ = this,
        config = $$.config,
        format = config.gauge_label_extents;
    return isFunction(format) ? format.bind($$.api)(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        $el = $$.$el;

    // MEMO: avoid to cancel transition
    if (transiting) {
      var interval = setInterval(function () {
        transiting || (clearInterval(interval), $el.legend.selectAll("." + config_classes.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $el.svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        svg = $$.$el.svg;

    if (!transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), svg.selectAll("" + config_classes.arc).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {string} id data ID
   * @param {string} key config key: 'duration | rate'
   * @returns {number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config[type + "_expand_" + key] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config[v + "_label_show"];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), isFunction(format) ? format.bind($$.api) : format;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config[type + "_title"] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.$el.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select("." + config_classes.chartArcs).selectAll("." + config_classes.chartArc).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this,
        $el = $$.$el;
    $el.arcs = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.$el.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arc).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      state.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call(endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      state.transiting = !1, callFn(config.onrendered, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        arcLabelLines = $el.main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arcLabelLine).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return config_classes.arcLabelLine + " " + config_classes.target + " " + config_classes.target + "-" + d.data.id;
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if (hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = state.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = state.radiusExpanded - state.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    // eslint-disable-next-line
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    } // eslint-disable-next-line


    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        isMouse = state.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), config.data_onclick.bind($$.api)(arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!state.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.$el.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        arcs = _$$$$el.arcs,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll("." + config_classes.chartArc).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? Math.round(state.radius / 5) + "px" : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select("." + config_classes.chartArcsTitle).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "" + Math.round(state.radius / 14));
      var backgroundArc = $$.$el.arcs.select((hasMultiArcGauge ? "g" : "") + "." + config_classes.chartArcsBackground);

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path." + config_classes.chartArcsBackground).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return config_classes.chartArcsBackground + " " + config_classes.chartArcsBackground + "-" + i;
        }).merge(backgroundArc).attr("d", function (d1) {
          if (state.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      arcs.select("." + config_classes.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && (arcs.select("." + config_classes.chartArcsGaugeMin).attr("dx", -1 * (state.innerRadius + (state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && arcs.select("." + config_classes.chartArcsGaugeMax).attr("dx", state.innerRadius + (state.radius - state.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.$el.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {boolean} isClockwise If the direction is clockwise
 * @param {string} type Coordinate type 'x' or 'y'
 * @param {number} edge Number of edge
 * @param {number} pos The indexed position
 * @param {number} range Range value
 * @param {number} ratio Ratio value
 * @returns {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = KEY.radarPoints;
/* harmony default export */ var shape_radar = ({
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        $el = $$.$el;
    $$.hasType("radar") && ($el.radars = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartRadars), $el.radars.levels = $el.radars.append("g").attr("class", config_classes.levels), $el.radars.axes = $el.radars.append("g").attr("class", config_classes.axis), $el.radars.shapes = $el.radars.append("g").attr("class", config_classes.shapes), current.dataMax = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        arcWidth = _$$$state.arcWidth,
        arcHeight = _$$$state.arcHeight,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min(arcWidth, arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        width = _$$$getRadarSize[0],
        height = _$$$getRadarSize[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize2 = $$.getRadarSize(),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        points = $$.cache.get(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.cache.add(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(durationForExit) {
    var $$ = this,
        _$$$$el = $$.$el,
        radars = _$$$$el.radars,
        main = _$$$$el.main,
        translate = $$.getTranslate("radar");
    translate && (radars.attr("transform", translate), main.selectAll("." + config_classes.circles).attr("transform", translate), main.select("." + config_classes.chartTexts).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var points = this.cache.get(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radars = $$.$el.radars,
        _$$$getRadarSize3 = $$.getRadarSize(),
        width = _$$$getRadarSize3[0],
        height = _$$$getRadarSize3[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = (config.radar_level_text_format || function () {}).bind($$.api),
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll("." + config_classes.level).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return config_classes.level + " " + config_classes.level + "-" + i;
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat(state.current.dataMax / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(" + (width - levelRatio[d]) + ", " + (height - levelRatio[d]) + ")";
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        radars = $$.$el.radars,
        _$$$getRadarSize4 = $$.getRadarSize(),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        categories = config.axis_x_categories,
        axis = radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return config_classes.axis + "-" + i;
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(" + posX + " " + posY + ")";
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var $$ = this,
        config = $$.config,
        _$$$state2 = $$.state,
        inputType = _$$$state2.inputType,
        transiting = _$$$state2.transiting,
        _$$$$el2 = $$.$el,
        radars = _$$$$el2.radars,
        svg = _$$$$el2.svg,
        focusOnly = config.point_focus_only;

    if (config.interaction_enabled) {
      var isMouse = inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && ($$.hideTooltip(), focusOnly ? $$.hideCircleFocus() : $$.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      radars.select("." + config_classes.axis).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle(svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.cache.get(radar_cacheKey),
        areas = $$.$el.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", $$.color).style("stroke", $$.color).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/config/resolver/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Arc based chart
 */
// shape


var arc_internal = [shape_arc, shape_radar];
// CONCATENATED MODULE: ./src/ChartInternal/ChartInternal.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */








 // Axis

 // data



 // interactions

 // internals


 // used to retrieve radar Axis name















/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal = /*#__PURE__*/function () {
  // API interface
  // config object
  // cache instance
  // elements
  // state variables
  // all Chart instances array within page (equivalent of 'bb.instances')
  // if is Arc type chart
  // data object
  // Axis
  // Axis
  // scales
  // original values
  // formatter function
  // format function
  function ChartInternal(api) {
    _defineProperty(this, "api", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "cache", void 0), _defineProperty(this, "$el", void 0), _defineProperty(this, "state", void 0), _defineProperty(this, "charts", void 0), _defineProperty(this, "isArc", !1), _defineProperty(this, "data", {
      xs: {},
      targets: []
    }), _defineProperty(this, "axis", void 0), _defineProperty(this, "scale", {
      x: null,
      y: null,
      y2: null,
      subX: null,
      subY: null,
      subY2: null,
      zoom: null
    }), _defineProperty(this, "org", {
      xScale: null,
      xDomain: null
    }), _defineProperty(this, "color", void 0), _defineProperty(this, "patterns", void 0), _defineProperty(this, "levelColor", void 0), _defineProperty(this, "point", void 0), _defineProperty(this, "brush", void 0), _defineProperty(this, "format", {
      extraLineClasses: null,
      xAxisTick: null,
      dataTime: null,
      // dataTimeFormat
      defaultAxisTime: null,
      // defaultAxisTimeFormat
      axisTime: null // axisTimeFormat

    });
    var $$ = this;
    $$.api = api, $$.config = new Options(), $$.cache = new Cache_Cache();
    var store = new Store();
    $$.$el = store.getStore("element"), $$.state = store.getStore("state");
  }

  var _proto = ChartInternal.prototype;
  return _proto.beforeInit = function beforeInit() {
    var $$ = this;
    $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$.api);
  }, _proto.afterInit = function afterInit() {
    var $$ = this;
    $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$.api);
  }, _proto.init = function init() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    state.hasAxis = !$$.hasArcType(), state.hasRadar = !state.hasAxis && $$.hasType("radar"), $$.initParams();
    var bindto = {
      element: config.bindto,
      classname: "bb"
    };
    isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $el.chart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $el.chart.empty() && ($el.chart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $el.chart.html("").classed(bindto.classname, !0), $$.initToRender();
  }
  /**
   * Initialize the rendering process
   * @param {boolean} forced Force to render process
   * @private
   */
  , _proto.initToRender = function initToRender(forced) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        chart = $$.$el.chart,
        isHidden = function () {
      return chart.style("display") === "none" || chart.style("visibility") === "hidden";
    },
        isLazy = config.render.lazy || isHidden(),
        MutationObserver = win.MutationObserver;

    if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
      isHidden() || (observer.disconnect(), !state.rendered && $$.initToRender(!0));
    }).observe(chart.node(), {
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), !isLazy || forced) {
      var convertedData = $$.convertData(config, $$.initWithData);
      convertedData && $$.initWithData(convertedData), $$.afterInit();
    }
  }, _proto.initParams = function initParams() {
    var $$ = this,
        _ref = $$,
        config = _ref.config,
        format = _ref.format,
        state = _ref.state,
        isRotated = config.axis_rotated;

    if (state.datetimeId = "bb-" + +new Date(), $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.hasPointType() && ($$.point = $$.generatePoint()), state.hasAxis) {
      $$.initClip(), format.extraLineClasses = $$.generateExtraLineClass(), format.dataTime = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], format.axisTime = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";

      format.defaultAxisTime = function (d) {
        var _$$$scale = $$.scale,
            x = _$$$scale.x,
            zoom = _$$$scale.zoom,
            isZoomed = isDragZoom ? zoom : zoom && x.orgDomain().toString() !== zoom.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return format.axisTime(specifier)(d);
      };
    }

    state.isLegendRight = config.legend_position === "right", state.isLegendInset = config.legend_position === "inset", state.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", state.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", state.rotatedPaddingRight = isRotated && !config.axis_x_show ? 0 : 30, state.inputType = convertInputType(config.interaction_inputType_mouse, config.interaction_inputType_touch);
  }, _proto.initWithData = function initWithData(data) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        $el = $$.$el,
        org = $$.org,
        hasAxis = state.hasAxis;
    hasAxis && ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom()), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter.bind($$.api))), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0);
    // retrieve scale after the 'updateScales()' is called
    var x = scale.x,
        y = scale.y,
        y2 = scale.y2,
        subX = scale.subX,
        subY = scale.subY,
        subY2 = scale.subY2; // Set domains for each scale

    if (x && (x.domain(util_sortValue($$.getXDomain($$.data.targets))), subX.domain(x.domain()), org.xDomain = x.domain()), y && (y.domain($$.getYDomain($$.data.targets, "y")), subY.domain(y.domain())), y2 && (y2.domain($$.getYDomain($$.data.targets, "y2")), subY2 && subY2.domain(y2.domain())), $el.svg = $el.chart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && state.inputType) {
      var isTouch = state.inputType === "touch";
      $el.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
        return callFn(config.onover, $$.api);
      }).on(isTouch ? "touchend" : "mouseleave", function () {
        return callFn(config.onout, $$.api);
      });
    }

    config.svg_classname && $el.svg.attr("class", config.svg_classname);
    // Define defs
    var hasColorPatterns = isFunction(config.color_tiles) && $$.patterns;
    (hasAxis || hasColorPatterns) && ($el.defs = $el.svg.append("defs"), hasAxis && ["id", "idXAxis", "idYAxis", "idXAxisTickTexts", "idGrid"].forEach(function (v) {
      $$.appendClip($el.defs, state.clip[v]);
    }), hasColorPatterns && $$.patterns.forEach(function (p) {
      return $el.defs.append(function () {
        return p.node;
      });
    })), $$.updateSvgSize(), $$.bindResize();
    // Define regions
    var main = $el.svg.append("g").attr("transform", $$.getTranslate("main"));

    // data.onmin/max callback
    if ($el.main = main, config.subchart_show && $$.initSubchart(), config.tooltip_show && $$.initTooltip(), config.title_text && $$.initTitle(), config.legend_show && $$.initLegend(), config.data_empty_label_text && main.append("text").attr("class", config_classes.text + " " + config_classes.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
    .attr("dominant-baseline", "middle"), hasAxis && (config.regions.length && $$.initRegion(), !config.clipPath && $$.axis.init()), main.append("g").attr("class", config_classes.chart).attr("clip-path", state.clip.path), $$.callPluginHook("$init"), hasAxis && ($$.initEventRect && $$.initEventRect(), $$.initGrid(), config.clipPath && $$.axis && $$.axis.init()), $$.initChartElements(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$.api), $$.setBackground(), $$.redraw({
      withTransition: !1,
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withTransitionForAxis: !1,
      initializing: !0
    }), config.data_onmin || config.data_onmax) {
      var minMax = $$.getMinMaxData();
      callFn(config.data_onmin, $$.api, minMax.min), callFn(config.data_onmax, $$.api, minMax.max);
    }

    state.rendered = !0;
  }, _proto.initChartElements = function initChartElements() {
    var $$ = this,
        _$$$state = $$.state,
        hasAxis = _$$$state.hasAxis,
        hasRadar = _$$$state.hasRadar,
        types = [];
    hasAxis ? ($$.hasType("bar") && types.push("Bar"), $$.hasType("bubble") && types.push("Bubble"), $$.hasTypeOf("Line") && types.push("Line")) : (!hasRadar && types.push("Arc", "Pie"), $$.hasType("gauge") ? types.push("Gauge") : hasRadar && types.push("Radar")), types.forEach(function (v) {
      $$["init" + v]();
    }), notEmpty($$.config.data_labels) && $$.initText();
  }, _proto.setChartElements = function setChartElements() {
    var $$ = this,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg,
        defs = _$$$$el.defs,
        main = _$$$$el.main,
        tooltip = _$$$$el.tooltip,
        legend = _$$$$el.legend,
        title = _$$$$el.title,
        grid = _$$$$el.grid,
        arc = _$$$$el.arcs,
        circles = _$$$$el.circle,
        bars = _$$$$el.bar,
        lines = _$$$$el.line,
        areas = _$$$$el.area,
        texts = _$$$$el.text;
    $$.api.$ = {
      chart: chart,
      svg: svg,
      defs: defs,
      main: main,
      tooltip: tooltip,
      legend: legend,
      title: title,
      grid: grid,
      arc: arc,
      circles: circles,
      bar: {
        bars: bars
      },
      line: {
        lines: lines,
        areas: areas
      },
      text: {
        texts: texts
      }
    };
  }
  /**
   * Set background element/image
   * @private
   */
  , _proto.setBackground = function setBackground() {
    var $$ = this,
        bg = $$.config.background,
        state = $$.state,
        svg = $$.$el.svg;

    if (notEmpty(bg)) {
      var element = svg.select("g").insert(bg.imgUrl ? "image" : "rect", ":first-child");
      bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color).attr("clip-path", state.clip.path), element.attr("class", bg.class || null).attr("width", "100%").attr("height", "100%");
    }
  }
  /**
   * Update targeted element with given data
   * @param {object} targets Data object formatted as 'target'
   * @private
   */
  , _proto.updateTargets = function updateTargets(targets) {
    var $$ = this,
        _$$$state2 = $$.state,
        hasAxis = _$$$state2.hasAxis,
        hasRadar = _$$$state2.hasRadar;
    $$.updateTargetsForText(targets), ($$.hasPointType() || hasRadar) && $$.updateTargetForCircle(), hasAxis ? ($$.hasType("bar") && $$.updateTargetsForBar(targets), $$.hasTypeOf("Line") && $$.updateTargetsForLine(targets), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets)) : $$.hasArcType(targets) && (hasRadar ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.showTargets();
  }
  /**
   * Display targeted elements
   * @private
   */
  , _proto.showTargets = function showTargets() {
    var $$ = this,
        config = $$.config,
        svg = $$.$el.svg;
    svg.selectAll("." + config_classes.target).filter(function (d) {
      return $$.isTargetToShow(d.id);
    }).transition().duration(config.transition_duration).style("opacity", "1");
  }, _proto.getWithOption = function getWithOption(options) {
    var withOptions = {
      Y: !0,
      Subchart: !0,
      Transition: !0,
      EventRect: !0,
      Dimension: !0,
      TrimXDomain: !0,
      Transform: !1,
      UpdateXDomain: !1,
      UpdateOrgXDomain: !1,
      Legend: !1,
      UpdateXAxis: "UpdateXDomain",
      TransitionForExit: "Transition",
      TransitionForAxis: "Transition"
    };
    return Object.keys(withOptions).forEach(function (key) {
      var defVal = withOptions[key];
      isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with" + key, defVal);
    }), withOptions;
  }, _proto.initialOpacity = function initialOpacity(d) {
    var $$ = this,
        withoutFadeIn = $$.state.withoutFadeIn;
    return $$.getBaseValue(d) !== null && withoutFadeIn[d.id] ? "1" : "0";
  }, _proto.bindResize = function bindResize() {
    var $$ = this,
        config = $$.config,
        resizeFunction = generateResize(),
        list = [];
    list.push(function () {
      return callFn(config.onresize, $$, $$.api);
    }), config.resize_auto && list.push(function () {
      return $$.api.flush(!1, !0);
    }), list.push(function () {
      return callFn(config.onresized, $$, $$.api);
    }), list.forEach(function (v) {
      return resizeFunction.add(v);
    }), win.addEventListener("resize", $$.resizeFunction = resizeFunction);
  }
  /**
   * Call plugin hook
   * @param {string} phase The lifecycle phase
   * @param {Array} args Arguments
   * @private
   */
  , _proto.callPluginHook = function callPluginHook(phase) {
    for (var _this = this, _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

    this.config.plugins.forEach(function (v) {
      phase === "$beforeInit" && (v.$$ = _this, _this.api.plugins.push(v)), v[phase].apply(v, args);
    });
  }, ChartInternal;
}();


extend(ChartInternal_ChartInternal.prototype, [// common
data_convert, ChartInternal_data_data, data_load, category, internals_class, internals_color, internals_domain, interactions_interaction, internals_format, internals_legend, internals_redraw, internals_scale, internals_size, internals_text, internals_title, internals_tooltip, internals_transform, internals_type].concat(arc_internal, internal));
// CONCATENATED MODULE: ./src/config/config.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Load configuration option
 * @param {object} config User's generation config value
 * @private
 */
function loadConfig(config) {
  var target,
      keys,
      read,
      thisConfig = this.config,
      find = function () {
    var key = keys.shift();
    return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
  };

  Object.keys(thisConfig).forEach(function (key) {
    target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
  });
}
// CONCATENATED MODULE: ./src/Chart/api/chart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_chart = ({
  /**
   * Resize the chart.
   * @function resize
   * @instance
   * @memberof Chart
   * @param {object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state;
    state.rendered && (config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0), $$.resizeFunction());
  },

  /**
   * Force to redraw.
   * @function flush
   * @instance
   * @memberof Chart
   * @param {boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft) {
    var $$ = this.internal;
    $$.state.rendered ? (arguments[1] ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.scale.zoom = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @function destroy
   * @instance
   * @memberof Chart
   * @returns {null}
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), svg.select("*").interrupt(), $$.resizeFunction.clear(), win.removeEventListener("resize", $$.resizeFunction), chart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @function config
   * @instance
   * @memberof Chart
   * @param {string} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @returns {*}
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function (name, value, redraw) {
    var res,
        $$ = this.internal,
        config = $$.config,
        key = name && name.replace(/\./g, "_");
    return key in config && (isDefined(value) ? (config[key] = value, res = value, redraw && this.flush()) : res = config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_color = ({
  /**
   * Get the color
   * @function color
   * @instance
   * @memberof Chart
   * @param {string} id id to get the color
   * @returns {string}
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/Chart/api/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get data loaded in the chart.
 * @function data
 * @instance
 * @memberof Chart
 * @param {string|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @returns {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */
function api_data_data(targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
}

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @function data․shown
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @returns {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @function data․values
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @param {boolean} [flat=true] Get flatten values
   * @returns {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetIds, flat) {
    flat === void 0 && (flat = !0);
    var values = null;

    if (targetIds) {
      var targets = this.data(targetIds);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @function data․names
   * @instance
   * @memberof Chart
   * @param {object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @returns {object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    var $$ = this.internal; // reset existing legend item dimension cache data

    return $$.cache.remove(KEY.legendItemTextBox), $$.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @function data․colors
   * @instance
   * @memberof Chart
   * @param {object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @returns {object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @function data․axes
   * @instance
   * @memberof Chart
   * @param {object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @returns {object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @function data․min
   * @instance
   * @memberof Chart
   * @returns {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @function data․max
   * @instance
   * @memberof Chart
   * @returns {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
});
/* harmony default export */ var api_data = ({
  data: api_data_data
});
// CONCATENATED MODULE: ./src/Chart/api/export.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {string} str string to be encoded
 * @returns {string}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode(+("0x" + p));
  }));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node target node
 * @param {object} size object containing {width, height}
 * @returns {string}
 * @private
 */


function nodeToSvgDataUrl(node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = ("<svg xmlns=\"" + external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg + "\" width=\"" + size.width + "\" height=\"" + size.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t" + styleXml + "\n\t\t\t\t" + nodeXml.replace(/(url\()[^#]+/g, "$1") + "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
}

/* harmony default export */ var api_export = ({
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @function export
   * @instance
   * @memberof Chart
   * @param {string} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @returns {string} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  export: function _export(mimeType, callback) {
    var _this = this,
        $$ = this.internal,
        state = $$.state,
        chart = $$.$el.chart,
        _state$current = state.current,
        width = _state$current.width,
        height = _state$current.height,
        svgDataUrl = nodeToSvgDataUrl(chart.node(), {
      width: width,
      height: height
    });

    if (callback && isFunction(callback)) {
      var img = new Image();
      img.crossOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = width, canvas.height = height, ctx.drawImage(img, 0, 0), callback.bind(_this)(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/focus.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_focus = ({
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @function focus
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && !state.hasRadar && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !0), state.focusedTargetIds = targetIds, state.defocusedTargetIds = state.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @function defocus
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !1), state.focusedTargetIds = state.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), state.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @function revert
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $el.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $el.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), state.focusedTargetIds = [], state.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/Chart/api/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define legend
 * @ignore
 */
var legend_legend = {
  /**
   * Show legend for each target.
   * @function legend․show
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @function legend․hide
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
};
/* harmony default export */ var api_legend = ({
  legend: legend_legend
});
// CONCATENATED MODULE: ./src/Chart/api/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var load = ({
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @function load
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.axis.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @function unload
   * @instance
   * @memberof Chart
   * @param {object} argsValue
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var _this = this,
        $$ = this.internal,
        args = argsValue || {};

    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.cache.remove(ids), args.done && args.done.call(_this);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/show.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Show/Hide data series
 * @param {boolean} show Show or hide
 * @param {Array} targetIdsValue Target id values
 * @param {object} options Options
 * @private
 */

function showHide(show, targetIdsValue, options) {
  var $$ = this.internal,
      targetIds = $$.mapToTargetIds(targetIdsValue);
  $$[(show ? "remove" : "add") + "HiddenTargetIds"](targetIds);
  var targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds)),
      opacity = show ? "1" : "0";
  targets.transition().style("opacity", opacity, "important").call(endall, function () {
    targets.style("opacity", null).style("opacity", opacity);
  }), options.withLegend && $$[(show ? "show" : "hide") + "Legend"](targetIds), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0,
    withLegend: !0
  });
}

/* harmony default export */ var api_show = ({
  /**
   * Show data series on chart
   * @function show
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIdsValue] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @function hide
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIdsValue] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @function toggle
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIds] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds, options) {
    var _this = this;

    options === void 0 && (options = {});
    var $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };
    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define tooltip
 * @ignore
 */

var tooltip_tooltip = {
  /**
   * Show tooltip
   * @function tooltip․show
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {number &verbar; Date}: x Axis value<br>- index {number}: x Axis index (useless for data.xs)<br>- id {string}: data id<br>- value {number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show(args) {
    var index,
        mouse,
        $$ = this.internal,
        config = $$.config,
        inputType = $$.state.inputType;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var data = args.data,
          y = $$.getYScaleById(data.id)(data.value);
      $$.isMultipleX() ? mouse = [$$.scale.x(data.x), y] : (!config.tooltip_grouped && (mouse = [0, y]), index = isValue(data.index) ? data.index : $$.getIndexByX(data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    (inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @function tooltip․hide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal; // reset last touch point index

    $$.inputType === "touch" && $$.callOverOutForTouch(), $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
};
/* harmony default export */ var api_tooltip = ({
  tooltip: tooltip_tooltip
});
// CONCATENATED MODULE: ./src/Chart/Chart.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */













/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
 */

/**
 * Access instance's primary node elements
 * @member {object} $
 * @property {object} $ Access instance's primary node elements
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {d3.selection} $.circles Data point circle elements
 * @property {object} $.bar Bar element object
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {object} $.line Line element object
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {object} $.text Text element object
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

/**
 * Plugin instance array
 * @member {Array} plugins
 * @memberof Chart
 * @example
 *  var chart = bb.generate({
 *     ...
 *     plugins: [
 *        new bb.plugin.stanford({ ... }),
 *        new PluginA()
 *     ]
 *  });
 *
 *  chart.plugins; // [Stanford, PluginA] - instance array
 */

var Chart_Chart = function Chart(options) {
  _defineProperty(this, "plugins", []), _defineProperty(this, "internal", void 0);
  var ctx = this,
      $$ = new ChartInternal_ChartInternal(ctx); // const {type, types} = options.data;
  // let isArc = false;
  // if (type) {
  // 	isArc = TYPES.Arc.indexOf(type) > -1;
  // } else if (types) {
  // 	for (const x in types) {
  // 		if (TYPES.Arc.indexOf(types[x]) > -1) {
  // 			isArc = true;
  // 			break;
  // 		}
  // 	}
  // }

  // bind to namespaced APIs
  this.internal = $$, function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      var isFunc = isFunction(fn[key]),
          isChild = target !== argThis,
          hasChild = Object.keys(fn[key]).length > 0;
      isFunc && (!isChild && hasChild || isChild) ? target[key] = fn[key].bind(argThis) : !isFunc && (target[key] = {}), hasChild && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this), loadConfig.call($$, options), $$.beforeInit(), $$.init();
}; // extend common APIs as part of Chart class



extend(Chart_Chart.prototype, [api_chart, api_color, api_data, api_export, api_focus, api_legend, load, api_show, api_tooltip].concat(axis_api));
// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */

 // eslint-disable-next-line no-use-before-define


var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {string} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "2.0.0-alpha",

  /**
   * Generate chart
   * @param {Options} config chart options
   * @memberof bb
   * @returns {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @returns {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {}
};
/**
 * @namespace bb
 * @version 2.0.0-alpha
 */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmlsbGJvYXJkLnNjc3M/MWI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmlsbGJvYXJkLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJjb21tb25qczJcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJhbWRcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNlbGVjdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy1zZWxlY3Rpb25cIixcImFtZFwiOlwiZDMtc2VsZWN0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWJydXNoXCIsXCJjb21tb25qczJcIjpcImQzLWJydXNoXCIsXCJhbWRcIjpcImQzLWJydXNoXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWF4aXNcIixcImNvbW1vbmpzMlwiOlwiZDMtYXhpc1wiLFwiYW1kXCI6XCJkMy1heGlzXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNjYWxlXCIsXCJjb21tb25qczJcIjpcImQzLXNjYWxlXCIsXCJhbWRcIjpcImQzLXNjYWxlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRzdlwiLFwiY29tbW9uanMyXCI6XCJkMy1kc3ZcIixcImFtZFwiOlwiZDMtZHN2XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRyYWdcIixcImNvbW1vbmpzMlwiOlwiZDMtZHJhZ1wiLFwiYW1kXCI6XCJkMy1kcmFnXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRyYW5zaXRpb25cIixcImNvbW1vbmpzMlwiOlwiZDMtdHJhbnNpdGlvblwiLFwiYW1kXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXpvb21cIixcImNvbW1vbmpzMlwiOlwiZDMtem9vbVwiLFwiYW1kXCI6XCJkMy16b29tXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWVhc2VcIixcImNvbW1vbmpzMlwiOlwiZDMtZWFzZVwiLFwiYW1kXCI6XCJkMy1lYXNlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWNvbG9yXCIsXCJjb21tb25qczJcIjpcImQzLWNvbG9yXCIsXCJhbWRcIjpcImQzLWNvbG9yXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNoYXBlXCIsXCJjb21tb25qczJcIjpcImQzLXNoYXBlXCIsXCJhbWRcIjpcImQzLXNoYXBlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWludGVycG9sYXRlXCIsXCJjb21tb25qczJcIjpcImQzLWludGVycG9sYXRlXCIsXCJhbWRcIjpcImQzLWludGVycG9sYXRlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jbGFzc2VzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvU3RvcmUvRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL1N0b3JlL1N0YXRlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvU3RvcmUvU3RvcmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2RhdGEvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vaW50ZXJhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi90aXRsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2RhdGEvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMveC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy95LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9heGlzL3kyLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvYnJvd3Nlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlL3V0aWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2dyaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9wb2ludC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3N1YmNoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvYXJlYS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvYmFyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9idWJibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2xpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3NwbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvZG9udXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2dhdWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9waWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3JhZGFyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9PcHRpb25zLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvQ2FjaGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9nZW5lcmF0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzUmVuZGVyZXJIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS5jb252ZXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9kYXRhL2RhdGEubG9hZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsYXNzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25zdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZG9tYWluLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9mb3JtYXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2xlZ2VuZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVkcmF3LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zY2FsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2l6ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGV4dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGl0bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdHlwZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2Zsb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLngudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncm91cC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3JlZ2lvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS94LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZXZlbnRyZWN0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xpcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVnaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYmFyLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2J1YmJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9saW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3BvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3NoYXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvcmVzb2x2ZXIvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9hcmMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9yZXNvbHZlci9hcmMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQ2hhcnRJbnRlcm5hbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvZXhwb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvZm9jdXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvc2hvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L0NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJhcmMiLCJhcmNMYWJlbExpbmUiLCJhcmNzIiwiYXJlYSIsImFyZWFzIiwiYXhpcyIsImF4aXNYIiwiYXhpc1hMYWJlbCIsImF4aXNZIiwiYXhpc1kyIiwiYXhpc1kyTGFiZWwiLCJheGlzWUxhYmVsIiwiYmFyIiwiYmFycyIsImJydXNoIiwiYnV0dG9uIiwiYnV0dG9uWm9vbVJlc2V0IiwiY2hhcnQiLCJjaGFydEFyYyIsImNoYXJ0QXJjcyIsImNoYXJ0QXJjc0JhY2tncm91bmQiLCJjaGFydEFyY3NHYXVnZU1heCIsImNoYXJ0QXJjc0dhdWdlTWluIiwiY2hhcnRBcmNzR2F1Z2VVbml0IiwiY2hhcnRBcmNzVGl0bGUiLCJjaGFydEFyY3NHYXVnZVRpdGxlIiwiY2hhcnRCYXIiLCJjaGFydEJhcnMiLCJjaGFydENpcmNsZXMiLCJjaGFydExpbmUiLCJjaGFydExpbmVzIiwiY2hhcnRSYWRhciIsImNoYXJ0UmFkYXJzIiwiY2hhcnRUZXh0IiwiY2hhcnRUZXh0cyIsImNpcmNsZSIsImNpcmNsZXMiLCJjb2xvclBhdHRlcm4iLCJjb2xvclNjYWxlIiwiZGVmb2N1c2VkIiwiZHJhZ2FyZWEiLCJlbXB0eSIsImV2ZW50UmVjdCIsImV2ZW50UmVjdHMiLCJldmVudFJlY3RzTXVsdGlwbGUiLCJldmVudFJlY3RzU2luZ2xlIiwiZm9jdXNlZCIsImdhdWdlVmFsdWUiLCJncmlkIiwiZ3JpZExpbmVzIiwibGVnZW5kQmFja2dyb3VuZCIsImxlZ2VuZEl0ZW0iLCJsZWdlbmRJdGVtRXZlbnQiLCJsZWdlbmRJdGVtRm9jdXNlZCIsImxlZ2VuZEl0ZW1IaWRkZW4iLCJsZWdlbmRJdGVtUG9pbnQiLCJsZWdlbmRJdGVtVGlsZSIsImxldmVsIiwibGV2ZWxzIiwibGluZSIsImxpbmVzIiwicmVnaW9uIiwicmVnaW9ucyIsInNlbGVjdGVkQ2lyY2xlIiwic2VsZWN0ZWRDaXJjbGVzIiwic2hhcGUiLCJzaGFwZXMiLCJzdGFuZm9yZEVsZW1lbnRzIiwic3RhbmZvcmRMaW5lIiwic3RhbmZvcmRMaW5lcyIsInN0YW5mb3JkUmVnaW9uIiwic3RhbmZvcmRSZWdpb25zIiwidGFyZ2V0IiwidGV4dCIsInRleHRzIiwidGl0bGUiLCJ0b29sdGlwIiwidG9vbHRpcENvbnRhaW5lciIsInRvb2x0aXBOYW1lIiwieGdyaWQiLCJ4Z3JpZEZvY3VzIiwieGdyaWRMaW5lIiwieGdyaWRMaW5lcyIsInhncmlkcyIsInlncmlkIiwieWdyaWRGb2N1cyIsInlncmlkTGluZSIsInlncmlkTGluZXMiLCJ5Z3JpZHMiLCJ6b29tQnJ1c2giLCJ6b29tUmVjdCIsIkVYUEFOREVEIiwiU0VMRUNURUQiLCJJTkNMVURFRCIsIlRleHRPdmVybGFwcGluZyIsIkVsZW1lbnQiLCJtYWluIiwic3ZnIiwieCIsInkiLCJ5MiIsInN1YlgiLCJkZWZzIiwibGVnZW5kIiwic3ViY2hhcnQiLCJyYWRhcnMiLCJsaXN0IiwiU3RhdGUiLCJ3aWR0aCIsIndpZHRoMiIsImhlaWdodCIsImhlaWdodDIiLCJtYXJnaW4iLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJtYXJnaW4yIiwibWFyZ2luMyIsImFyY1dpZHRoIiwiYXJjSGVpZ2h0IiwiaGFzQXhpcyIsImhhc1JhZGFyIiwiY3VycmVudCIsImRhdGFNYXgiLCJtYXhUaWNrV2lkdGhzIiwic2l6ZSIsInRpY2tzIiwiY2xpcFBhdGgiLCJkb21haW4iLCJ0eXBlcyIsImlzTGVnZW5kUmlnaHQiLCJpc0xlZ2VuZEluc2V0IiwiaXNMZWdlbmRUb3AiLCJpc0xlZ2VuZExlZnQiLCJsZWdlbmRTdGVwIiwibGVnZW5kSXRlbVdpZHRoIiwibGVnZW5kSXRlbUhlaWdodCIsImxlZ2VuZEhhc1JlbmRlcmVkIiwicGFkZGluZyIsInRpY2tDb3VudCIsInJvdGF0ZWRQYWRkaW5nIiwid2l0aG91dEZhZGVJbiIsImlucHV0VHlwZSIsImRhdGV0aW1lSWQiLCJjbGlwIiwiaWQiLCJpZFhBeGlzIiwiaWRZQXhpcyIsImlkWEF4aXNUaWNrVGV4dHMiLCJpZEdyaWQiLCJpZFN1YmNoYXJ0IiwicGF0aCIsInBhdGhYQXhpcyIsInBhdGhZQXhpcyIsInBhdGhYQXhpc1RpY2tUZXh0cyIsInBhdGhHcmlkIiwiZHJhZ1N0YXJ0IiwiZHJhZ2dpbmciLCJmbG93aW5nIiwiY2FuY2VsQ2xpY2siLCJtb3VzZW92ZXIiLCJyZW5kZXJlZCIsInRyYW5zaXRpbmciLCJoYXNOZWdhdGl2ZVZhbHVlIiwiaGFzUG9zaXRpdmVWYWx1ZSIsIm9yZ0FyZWFPcGFjaXR5IiwiaGlkZGVuVGFyZ2V0SWRzIiwiaGlkZGVuTGVnZW5kSWRzIiwiZm9jdXNlZFRhcmdldElkcyIsImRlZm9jdXNlZFRhcmdldElkcyIsInJhZGl1cyIsImlubmVyUmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImdhdWdlQXJjV2lkdGgiLCJyYWRpdXNFeHBhbmRlZCIsInhncmlkQXR0ciIsIngxIiwieDIiLCJ5MSIsImNsYXNzZXMiLCJlbGVtZW50Iiwic3RhdGUiLCJTdG9yZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidiIsImdldFN0b3JlIiwibmFtZSIsImRhdGFfaWRDb252ZXJ0ZXIiLCJkYXRhX25hbWVzIiwiZGF0YV9jbGFzc2VzIiwiZGF0YV90eXBlIiwidW5kZWZpbmVkIiwiZGF0YV90eXBlcyIsImRhdGFfb3JkZXIiLCJkYXRhX2NvbG9yIiwiZGF0YV9jb2xvcnMiLCJkYXRhX2hpZGUiLCJkYXRhX2ZpbHRlciIsImRhdGFfb25jbGljayIsImRhdGFfb25vdmVyIiwiZGF0YV9vbm91dCIsImRhdGFfb25taW4iLCJkYXRhX29ubWF4IiwiZGF0YV91cmwiLCJkYXRhX2hlYWRlcnMiLCJkYXRhX2pzb24iLCJkYXRhX3Jvd3MiLCJkYXRhX2NvbHVtbnMiLCJkYXRhX21pbWVUeXBlIiwiZGF0YV9rZXlzIiwiZGF0YV9lbXB0eV9sYWJlbF90ZXh0IiwiY29sb3JfcGF0dGVybiIsImNvbG9yX3RpbGVzIiwiY29sb3JfdGhyZXNob2xkIiwiY29sb3Jfb25vdmVyIiwiaW50ZXJhY3Rpb25fZW5hYmxlZCIsImludGVyYWN0aW9uX2JyaWdodGVuIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoIiwibGVnZW5kX3Nob3ciLCJsZWdlbmRfaGlkZSIsImxlZ2VuZF9jb250ZW50c19iaW5kdG8iLCJsZWdlbmRfY29udGVudHNfdGVtcGxhdGUiLCJsZWdlbmRfcG9zaXRpb24iLCJsZWdlbmRfaW5zZXRfYW5jaG9yIiwibGVnZW5kX2luc2V0X3giLCJsZWdlbmRfaW5zZXRfeSIsImxlZ2VuZF9pbnNldF9zdGVwIiwibGVnZW5kX2l0ZW1fb25jbGljayIsImxlZ2VuZF9pdGVtX29ub3ZlciIsImxlZ2VuZF9pdGVtX29ub3V0IiwibGVnZW5kX2VxdWFsbHkiLCJsZWdlbmRfcGFkZGluZyIsImxlZ2VuZF9pdGVtX3RpbGVfd2lkdGgiLCJsZWdlbmRfaXRlbV90aWxlX2hlaWdodCIsImxlZ2VuZF91c2VQb2ludCIsInRpdGxlX3RleHQiLCJ0aXRsZV9wYWRkaW5nIiwidGl0bGVfcG9zaXRpb24iLCJ0b29sdGlwX3Nob3ciLCJ0b29sdGlwX2RvTm90SGlkZSIsInRvb2x0aXBfZ3JvdXBlZCIsInRvb2x0aXBfZm9ybWF0X3RpdGxlIiwidG9vbHRpcF9mb3JtYXRfbmFtZSIsInRvb2x0aXBfZm9ybWF0X3ZhbHVlIiwidG9vbHRpcF9wb3NpdGlvbiIsInRvb2x0aXBfY29udGVudHMiLCJ0b29sdGlwX2luaXRfc2hvdyIsInRvb2x0aXBfaW5pdF94IiwidG9vbHRpcF9pbml0X3Bvc2l0aW9uIiwidG9vbHRpcF9saW5rZWQiLCJ0b29sdGlwX2xpbmtlZF9uYW1lIiwidG9vbHRpcF9vbnNob3ciLCJ0b29sdGlwX29uaGlkZSIsInRvb2x0aXBfb25zaG93biIsInRvb2x0aXBfb25oaWRkZW4iLCJ0b29sdGlwX29yZGVyIiwiZGF0YV94IiwiZGF0YV94cyIsImRhdGFfeEZvcm1hdCIsImRhdGFfeExvY2FsdGltZSIsImRhdGFfeFNvcnQiLCJkYXRhX2dyb3VwcyIsImRhdGFfYXhlcyIsImRhdGFfbGFiZWxzIiwiZGF0YV9sYWJlbHNfY29sb3JzIiwiZGF0YV9sYWJlbHNfcG9zaXRpb24iLCJkYXRhX3JlZ2lvbnMiLCJkYXRhX3N0YWNrX25vcm1hbGl6ZSIsImRhdGFfc2VsZWN0aW9uX2VuYWJsZWQiLCJkYXRhX3NlbGVjdGlvbl9ncm91cGVkIiwiZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlIiwiZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUiLCJkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUiLCJkYXRhX29uc2VsZWN0ZWQiLCJkYXRhX29udW5zZWxlY3RlZCIsImF4aXNfeF9jbGlwUGF0aCIsImF4aXNfeF9zaG93IiwiYXhpc194X3R5cGUiLCJheGlzX3hfbG9jYWx0aW1lIiwiYXhpc194X2NhdGVnb3JpZXMiLCJheGlzX3hfdGlja19jZW50ZXJlZCIsImF4aXNfeF90aWNrX2Zvcm1hdCIsImF4aXNfeF90aWNrX2N1bGxpbmciLCJheGlzX3hfdGlja19jdWxsaW5nX21heCIsImF4aXNfeF90aWNrX2NvdW50IiwiYXhpc194X3RpY2tfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3hfdGlja19maXQiLCJheGlzX3hfdGlja192YWx1ZXMiLCJheGlzX3hfdGlja19hdXRvcm90YXRlIiwiYXhpc194X3RpY2tfcm90YXRlIiwiYXhpc194X3RpY2tfb3V0ZXIiLCJheGlzX3hfdGlja19tdWx0aWxpbmUiLCJheGlzX3hfdGlja193aWR0aCIsImF4aXNfeF90aWNrX3Rvb2x0aXAiLCJheGlzX3hfbWF4IiwiYXhpc194X21pbiIsImF4aXNfeF9wYWRkaW5nIiwiYXhpc194X2hlaWdodCIsImF4aXNfeF9leHRlbnQiLCJheGlzX3hfbGFiZWwiLCJheGlzX3hfYXhlcyIsImF4aXNfeV9jbGlwUGF0aCIsImF4aXNfeV9zaG93IiwiYXhpc195X3R5cGUiLCJheGlzX3lfbWF4IiwiYXhpc195X21pbiIsImF4aXNfeV9pbnZlcnRlZCIsImF4aXNfeV9jZW50ZXIiLCJheGlzX3lfaW5uZXIiLCJheGlzX3lfbGFiZWwiLCJheGlzX3lfdGlja19mb3JtYXQiLCJheGlzX3lfdGlja19jdWxsaW5nIiwiYXhpc195X3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3lfdGlja19vdXRlciIsImF4aXNfeV90aWNrX3ZhbHVlcyIsImF4aXNfeV90aWNrX3JvdGF0ZSIsImF4aXNfeV90aWNrX2NvdW50IiwiYXhpc195X3RpY2tfc2hvdyIsImF4aXNfeV90aWNrX3N0ZXBTaXplIiwiYXhpc195X3RpY2tfdGV4dF9zaG93IiwiYXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeV90aWNrX3RpbWVfdmFsdWUiLCJheGlzX3lfcGFkZGluZyIsImF4aXNfeV9kZWZhdWx0IiwiYXhpc195X2F4ZXMiLCJheGlzX3kyX3Nob3ciLCJheGlzX3kyX21heCIsImF4aXNfeTJfbWluIiwiYXhpc195Ml9pbnZlcnRlZCIsImF4aXNfeTJfY2VudGVyIiwiYXhpc195Ml9pbm5lciIsImF4aXNfeTJfbGFiZWwiLCJheGlzX3kyX3RpY2tfZm9ybWF0IiwiYXhpc195Ml90aWNrX2N1bGxpbmciLCJheGlzX3kyX3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3kyX3RpY2tfb3V0ZXIiLCJheGlzX3kyX3RpY2tfdmFsdWVzIiwiYXhpc195Ml90aWNrX3JvdGF0ZSIsImF4aXNfeTJfdGlja19jb3VudCIsImF4aXNfeTJfdGlja19zaG93IiwiYXhpc195Ml90aWNrX3N0ZXBTaXplIiwiYXhpc195Ml90aWNrX3RleHRfc2hvdyIsImF4aXNfeTJfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195Ml9wYWRkaW5nIiwiYXhpc195Ml9kZWZhdWx0IiwiYXhpc195Ml9heGVzIiwid2luIiwiZGVmIiwibyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJnbG9iYWxUaGlzIiwiRnVuY3Rpb24iLCJkb2MiLCJkb2N1bWVudCIsImlzVmFsdWUiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNib29sZWFuIiwiY2VpbDEwIiwiTWF0aCIsImNlaWwiLCJhc0hhbGZQaXhlbCIsIm4iLCJkaWZmRG9tYWluIiwiZCIsImlzT2JqZWN0VHlwZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJEYXRlIiwiaXNOYU4iLCJub3RFbXB0eSIsImlzQXJyYXkiLCJhcnIiLCJBcnJheSIsImlzT2JqZWN0Iiwib2JqIiwibm9kZVR5cGUiLCJnZXRPcHRpb24iLCJvcHRpb25zIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaGFzVmFsdWUiLCJkaWN0IiwidmFsdWUiLCJmb3VuZCIsImNhbGxGbiIsImZuIiwiaXNGbiIsImFyZ3MiLCJjYWxsIiwiZW5kYWxsIiwidHJhbnNpdGlvbiIsImNiIiwiZWFjaCIsIm9uIiwiYXBwbHkiLCJzYW5pdGlzZSIsInN0ciIsInJlcGxhY2UiLCJzZXRUZXh0VmFsdWUiLCJub2RlIiwiZHkiLCJ0b01pZGRsZSIsImluZGV4T2YiLCJkaWZmIiwibWFwIiwibXVsdGlsaW5lIiwic3BsaXQiLCJsZW4iLCJodG1sIiwiaSIsImFwcGVuZCIsImF0dHIiLCJnZXRSZWN0U2VnTGlzdCIsImdldEJCb3giLCJnZXRQYXRoQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXRlbXMiLCJtaW4iLCJnZXRCcnVzaFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsIiRlbCIsImV2ZW50IiwiZDNFdmVudCIsInR5cGUiLCJzZWxlY3QiLCJDTEFTUyIsImQzQnJ1c2hTZWxlY3Rpb24iLCJnZXRCb3VuZGluZ1JlY3QiLCJyZWN0IiwiZ2V0UmFuZG9tIiwiYXNTdHIiLCJyYW5kIiwicmFuZG9tIiwiYnJ1c2hFbXB0eSIsImN0eCIsImV4dGVuZCIsInNvdXJjZSIsInAiLCJ0ZXN0IiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0FycmF5IiwiZ2V0Q3NzUnVsZXMiLCJzdHlsZVNoZWV0cyIsInJ1bGVzIiwic2hlZXQiLCJjc3NSdWxlcyIsImNvbmNhdCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJocmVmIiwidG9TdHJpbmciLCJnZXRUcmFuc2xhdGlvbiIsInRyYW5zZm9ybSIsImJhc2VWYWwiLCJudW1iZXJPZkl0ZW1zIiwiZ2V0SXRlbSIsIm1hdHJpeCIsImEiLCJiIiwiYyIsImYiLCJnZXRVbmlxdWUiLCJkYXRhIiwiaXNEYXRlIiwiTnVtYmVyIiwiZmlsdGVyIiwibWVyZ2VBcnJheSIsInJlZHVjZSIsIm1lcmdlT2JqIiwib2JqZWN0TiIsInNoaWZ0Iiwic29ydFZhbHVlIiwiaXNBc2MiLCJldmVyeSIsInNvcnQiLCJnZXRNaW5NYXgiLCJyZXMiLCJnZXRSYW5nZSIsInN0YXJ0IiwiZW5kIiwic3RlcCIsIm1heCIsInB1c2giLCJlbXVsYXRlRXZlbnQiLCJtb3VzZSIsImdldFBhcmFtcyIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlRXZlbnQiLCJlbCIsImV2ZW50VHlwZSIsInBhcmFtcyIsImRpc3BhdGNoRXZlbnQiLCJtb3VzZUV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInRvdWNoIiwidG91Y2hPYmoiLCJUb3VjaCIsImlkZW50aWZpZXIiLCJub3ciLCJyYWRpdXNYIiwicmFkaXVzWSIsInJvdGF0aW9uQW5nbGUiLCJmb3JjZSIsIlRvdWNoRXZlbnQiLCJzaGlmdEtleSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJ0cGxQcm9jZXNzIiwidHBsIiwiUmVnRXhwIiwicGFyc2VEYXRlIiwiZGF0ZSIsInBhcnNlZERhdGUiLCJjb25maWciLCJmb3JtYXQiLCJkYXRhVGltZSIsImlzVGFiVmlzaWJsZSIsImhpZGRlbiIsImNvbnZlcnRJbnB1dFR5cGUiLCJpc01vYmlsZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImhhc1RvdWNoUG9pbnRzIiwibWF4VG91Y2hQb2ludHMiLCJoYXNUb3VjaCIsIkRvY3VtZW50VG91Y2giLCJoYXNNb3VzZSIsImF4aXNfcm90YXRlZCIsImdyaWRfeF9zaG93IiwiZ3JpZF94X3R5cGUiLCJncmlkX3hfbGluZXMiLCJncmlkX3lfc2hvdyIsImdyaWRfeV9saW5lcyIsImdyaWRfeV90aWNrcyIsImdyaWRfZm9jdXNfZWRnZSIsImdyaWRfZm9jdXNfc2hvdyIsImdyaWRfZm9jdXNfeSIsImdyaWRfZnJvbnQiLCJncmlkX2xpbmVzX2Zyb250IiwicG9pbnRfc2hvdyIsInBvaW50X3IiLCJwb2ludF9zZW5zaXRpdml0eSIsInBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkIiwicG9pbnRfZm9jdXNfZXhwYW5kX3IiLCJwb2ludF9mb2N1c19vbmx5IiwicG9pbnRfcGF0dGVybiIsInBvaW50X3NlbGVjdF9yIiwicG9pbnRfdHlwZSIsInN1YmNoYXJ0X3Nob3ciLCJzdWJjaGFydF9zaXplX2hlaWdodCIsInN1YmNoYXJ0X2F4aXNfeF9zaG93Iiwic3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdyIsInN1YmNoYXJ0X29uYnJ1c2giLCJ6b29tX2VuYWJsZWQiLCJ6b29tX2V4dGVudCIsInpvb21fcHJpdmlsZWdlZCIsInpvb21fcmVzY2FsZSIsInpvb21fb256b29tIiwiem9vbV9vbnpvb21zdGFydCIsInpvb21fb256b29tZW5kIiwiem9vbV9yZXNldEJ1dHRvbiIsInpvb21feF9taW4iLCJ6b29tX3hfbWF4IiwiYXJlYV96ZXJvYmFzZWQiLCJhcmVhX2Fib3ZlIiwiYXJlYV9saW5lYXJHcmFkaWVudCIsImJhcl9wYWRkaW5nIiwiYmFyX3JhZGl1cyIsImJhcl9yYWRpdXNfcmF0aW8iLCJiYXJfc2Vuc2l0aXZpdHkiLCJiYXJfd2lkdGgiLCJiYXJfd2lkdGhfcmF0aW8iLCJiYXJfd2lkdGhfbWF4IiwiYmFyX3plcm9iYXNlZCIsImJ1YmJsZV9tYXhSIiwiYnViYmxlX3plcm9iYXNlZCIsImxpbmVfY29ubmVjdE51bGwiLCJsaW5lX3N0ZXBfdHlwZSIsImxpbmVfemVyb2Jhc2VkIiwibGluZV9jbGFzc2VzIiwibGluZV9wb2ludCIsInNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGUiLCJkb251dF9sYWJlbF9zaG93IiwiZG9udXRfbGFiZWxfZm9ybWF0IiwiZG9udXRfbGFiZWxfdGhyZXNob2xkIiwiZG9udXRfbGFiZWxfcmF0aW8iLCJkb251dF93aWR0aCIsImRvbnV0X3RpdGxlIiwiZG9udXRfZXhwYW5kIiwiZG9udXRfZXhwYW5kX3JhdGUiLCJkb251dF9leHBhbmRfZHVyYXRpb24iLCJkb251dF9wYWRBbmdsZSIsImRvbnV0X3N0YXJ0aW5nQW5nbGUiLCJnYXVnZV9mdWxsQ2lyY2xlIiwiZ2F1Z2VfbGFiZWxfc2hvdyIsImdhdWdlX2xhYmVsX2Zvcm1hdCIsImdhdWdlX2xhYmVsX2V4dGVudHMiLCJnYXVnZV9taW4iLCJnYXVnZV9tYXgiLCJnYXVnZV90eXBlIiwiZ2F1Z2Vfc3RhcnRpbmdBbmdsZSIsIlBJIiwiZ2F1Z2VfdGl0bGUiLCJnYXVnZV91bml0cyIsImdhdWdlX3dpZHRoIiwiZ2F1Z2VfYXJjc19taW5XaWR0aCIsImdhdWdlX2V4cGFuZCIsImdhdWdlX2V4cGFuZF9yYXRlIiwiZ2F1Z2VfZXhwYW5kX2R1cmF0aW9uIiwicGllX2xhYmVsX3Nob3ciLCJwaWVfbGFiZWxfZm9ybWF0IiwicGllX2xhYmVsX3RocmVzaG9sZCIsInBpZV9sYWJlbF9yYXRpbyIsInBpZV9leHBhbmQiLCJwaWVfZXhwYW5kX3JhdGUiLCJwaWVfZXhwYW5kX2R1cmF0aW9uIiwicGllX2lubmVyUmFkaXVzIiwicGllX3BhZEFuZ2xlIiwicGllX3BhZGRpbmciLCJwaWVfc3RhcnRpbmdBbmdsZSIsInJhZGFyX2F4aXNfbWF4IiwicmFkYXJfYXhpc19saW5lX3Nob3ciLCJyYWRhcl9heGlzX3RleHRfc2hvdyIsInJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbiIsInJhZGFyX2xldmVsX2RlcHRoIiwicmFkYXJfbGV2ZWxfc2hvdyIsInJhZGFyX2xldmVsX3RleHRfZm9ybWF0IiwidG9GaXhlZCIsInJhZGFyX2xldmVsX3RleHRfc2hvdyIsInJhZGFyX3NpemVfcmF0aW8iLCJyYWRhcl9kaXJlY3Rpb25fY2xvY2t3aXNlIiwiT3B0aW9ucyIsImNvbG9yIiwiaW50ZXJhY3Rpb24iLCJkb251dCIsImdhdWdlIiwicGllIiwicmFkYXIiLCJkYXRhQXhpcyIsImRhdGFTZWxlY3Rpb24iLCJwb2ludCIsInpvb20iLCJidWJibGUiLCJzcGxpbmUiLCJiaW5kdG8iLCJiYWNrZ3JvdW5kIiwic3ZnX2NsYXNzbmFtZSIsInNpemVfd2lkdGgiLCJzaXplX2hlaWdodCIsInBhZGRpbmdfbGVmdCIsInBhZGRpbmdfcmlnaHQiLCJwYWRkaW5nX3RvcCIsInBhZGRpbmdfYm90dG9tIiwicmVzaXplX2F1dG8iLCJvbm92ZXIiLCJvbm91dCIsIm9ucmVzaXplIiwib25yZXNpemVkIiwib25iZWZvcmVpbml0Iiwib25pbml0Iiwib25hZnRlcmluaXQiLCJvbnJlbmRlcmVkIiwidHJhbnNpdGlvbl9kdXJhdGlvbiIsInNjYXR0ZXJfemVyb2Jhc2VkIiwicGx1Z2lucyIsInJlbmRlciIsIktFWSIsImJ1YmJsZUJhc2VMZW5ndGgiLCJkYXRhTWluTWF4IiwiZGF0YVRvdGFsU3VtIiwiZGF0YVRvdGFsUGVySW5kZXgiLCJsZWdlbmRJdGVtVGV4dEJveCIsInJhZGFyUG9pbnRzIiwidGV4dFJlY3QiLCJDYWNoZSIsImFkZCIsImlzRGF0YVR5cGUiLCJjYWNoZSIsImNsb25lVGFyZ2V0IiwicmVtb3ZlIiwiZ2V0IiwidGFyZ2V0cyIsInJlc2V0IiwiYWxsIiwiJCQiLCJpZF9vcmciLCJ2YWx1ZXMiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2VuZXJhdGVSZXNpemUiLCJ0aW1lb3V0IiwiY2FsbFJlc2l6ZUZuIiwiY2xlYXIiLCJzcGxpY2UiLCJnZW5lcmF0ZVdhaXQiLCJ0cmFuc2l0aW9uc1RvV2FpdCIsInQiLCJjYWxsYmFjayIsImxvb3AiLCJkb25lIiwidGltZXIiLCJBeGlzUmVuZGVyZXJIZWxwZXIiLCJvd25lciIsInNjYWxlIiwiZDNTY2FsZUxpbmVhciIsIm5vVHJhbnNpdGlvbiIsIndpdGhvdXRUcmFuc2l0aW9uIiwicmFuZ2UiLCJzY2FsZUV4dGVudCIsIm9yZ1hTY2FsZSIsImdldFNpemVGb3IxQ2hhciIsInciLCJoIiwiZ2V0VGlja1RyYW5zZm9ybVNldHRlciIsInRpY2tPZmZzZXQiLCJzdG9wIiwiZ2VuZXJhdGVUaWNrcyIsImlzWUF4ZXMiLCJ0aWNrU3RlcFNpemUiLCJpbnRlcnZhbCIsInRpY2tBcmd1bWVudHMiLCJyb3VuZCIsInVuc2hpZnQiLCJjb3B5U2NhbGUiLCJuZXdTY2FsZSIsImNvcHkiLCJ0ZXh0Rm9ybWF0dGVkIiwidGlja0Zvcm1hdCIsImZvcm1hdHRlZCIsInRyYW5zaXRpb25pc2UiLCJpbnRlcnJ1cHQiLCJBeGlzUmVuZGVyZXIiLCJpbm5lclRpY2tTaXplIiwib3V0ZXJUaWNrU2l6ZSIsIm91dGVyVGljayIsIm9yaWVudCIsInRpY2tDZW50ZXJlZCIsInRpY2tDdWxsaW5nIiwidGlja0xlbmd0aCIsInRpY2tQYWRkaW5nIiwidGlja1ZhbHVlcyIsImhlbHBlciIsIkhlbHBlciIsImNyZWF0ZSIsImciLCJzcGxpdFRpY2tUZXh0IiwiYmluZCIsImlzTGVmdFJpZ2h0IiwiaXNUb3BCb3R0b20iLCJ0aWNrVHJhbnNmb3JtIiwiYXhpc1B4Iiwic2lnbiIsInJvdGF0ZSIsInRpY2tUZXh0Um90YXRlIiwicmFuZ2VFeHRlbnQiLCIkZyIsInRpY2tUZXh0UG9zIiwicHJlZml4IiwiYXhpc1Nob3ciLCJ0aWNrU2hvdyIsInRpY2siLCJkM1NlbGVjdCIsInNjYWxlMCIsIl9fY2hhcnRfXyIsInNjYWxlMSIsImlzQ2F0ZWdvcnkiLCJzZWxlY3RBbGwiLCJlbnRlciIsIm1lcmdlIiwib3V0ZXJUaWNrU2l6ZWQiLCJ0aWNrRW50ZXIiLCJpbnNlcnQiLCJzdHlsZSIsInRpY2tFeGl0IiwiZXhpdCIsInNpemVGb3IxQ2hhciIsImNvdW50cyIsInRzcGFuIiwiaW5kZXgiLCJ0aWNrTXVsdGlsaW5lIiwic3BsaXR0ZWQiLCJkeCIsInNpbiIsImxpbmVVcGRhdGUiLCJ0ZXh0VXBkYXRlIiwic2V0VGlja0xpbmVUZXh0UG9zaXRpb24iLCJ0aWNrVGl0bGUiLCJiYW5kd2lkdGgiLCJnZXRUaWNrWFkiLCJwb3MiLCJnZXRUaWNrU2l6ZSIsInRpY2tQb3NpdGlvbiIsInRpY2tQb3MiLCJ0ZXh0QW5jaG9yRm9yVGV4dCIsInIiLCJyZXZlcnNlIiwidGV4dFRyYW5zZm9ybSIsInlGb3JUZXh0IiwicjIiLCJjaGFyV2lkdGgiLCJzdWJ0ZXh0Iiwic3BhY2VJbmRleCIsInRleHRXaWR0aCIsInN1YnN0ciIsInRpY2tXaWR0aCIsInRpY2tUZXh0IiwiYXJndW1lbnRzIiwiaXNDZW50ZXJlZCIsInRpY2tJbnRlcnZhbCIsImdldFRvdGFsTGVuZ3RoIiwiSW5maW5pdHkiLCJjdWxsaW5nIiwic2V0VHJhbnNpdGlvbiIsIkF4aXMiLCJzZXRPcmllbnQiLCJnZXRBeGlzQ2xhc3NOYW1lIiwiaXNIb3Jpem9udGFsIiwiZm9ySG9yaXpvbnRhbCIsImlzUm90YXRlZCIsImlzQ2F0ZWdvcml6ZWQiLCJpc0N1c3RvbVgiLCJpc1RpbWVTZXJpZXMiLCJpc1RpbWVTZXJpZXNZIiwiaW5pdCIsImNsYXNzQXhpcyIsImNsYXNzTGFiZWwiLCJnZXRUcmFuc2xhdGUiLCJ0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsIiwiZ2VuZXJhdGVBeGVzIiwieUlubmVyIiwieTJJbm5lciIsImQzQXhpcyIsImF4ZXMiLCJheGVzQ29uZmlnIiwiZDNBeGlzTGVmdCIsImQzQXhpc0JvdHRvbSIsImQzQXhpc1RvcCIsImQzQXhpc1JpZ2h0IiwiY291bnQiLCJhcGkiLCJ0aWNrU2l6ZU91dGVyIiwib3V0ZXIiLCJheGVzTGlzdCIsInVwZGF0ZUF4ZXMiLCJheGlzUmFuZ2UiLCJjbGFzc05hbWUiLCJzZXRBeGlzIiwiZ2V0VGlja1ZhbHVlcyIsImdldEF4aXMiLCJub1RpY2tUZXh0Um90YXRlIiwiaXNYIiwiZ2V0QXhpc1RpY2tSb3RhdGUiLCJ4QXhpc1RpY2siLCJheGlzUGFyYW1zIiwiY2F0ZWdvcmllcyIsImlzU3RhY2tOb3JtYWxpemVkIiwidXBkYXRlWEF4aXNUaWNrVmFsdWVzIiwiZml0IiwibWFwVGFyZ2V0c1RvVW5pcXVlWHMiLCJnZW5lcmF0ZVRpY2tWYWx1ZXMiLCJnZXRJZCIsImdldFhBeGlzVGlja0Zvcm1hdCIsImN1cnJGb3JtYXQiLCJheGlzVGltZSIsImRlZmF1bHRBeGlzVGltZSIsImNhdGVnb3J5TmFtZSIsImdldExhYmVsT3B0aW9uQnlBeGlzSWQiLCJnZXRMYWJlbFRleHQiLCJvcHRpb24iLCJzZXRMYWJlbFRleHQiLCJnZXRMYWJlbFBvc2l0aW9uIiwiZGVmYXVsdFBvc2l0aW9uIiwicG9zaXRpb24iLCJoYXMiLCJpc0lubmVyIiwiaXNPdXRlciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldEF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0TGFiZWxQb3NpdGlvbkJ5SWQiLCJ4Rm9yQXhpc0xhYmVsIiwiZHhGb3JBeGlzTGFiZWwiLCJhbmNob3IiLCJkeUZvckF4aXNMYWJlbCIsInRpY2tSb3RhdGUiLCJnZXRIb3Jpem9udGFsQXhpc0hlaWdodCIsIm1heFRpY2tXaWR0aCIsImdldE1heFRpY2tXaWR0aCIsInhIZWlnaHQiLCJ3aXRob3V0UmVjb21wdXRlIiwiY3VycmVudFRpY2tNYXgiLCJtYXhXaWR0aCIsImZpbHRlclRhcmdldHNUb1Nob3ciLCJpc1lBeGlzIiwidGFyZ2V0c1RvU2hvdyIsImR1bW15IiwiY3VycmVudFRleHRXaWR0aCIsImdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93IiwiZGVmYXVsdFBhZGRpbmciLCJ4QXhpc1RpY2tSb3RhdGUiLCJ3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQiLCJnZXRDdXJyZW50UGFkZGluZ0xlZnQiLCJtYXhPdmVyZmxvdyIsImdldFhBeGlzVGlja01heE92ZXJmbG93IiwieEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3ciLCJ0aWNrVGV4dFdpZHRocyIsInJlbWFpbmluZyIsInRpY2tJbmRleCIsInJvdGF0ZWRUaWNrVGV4dFdpZHRoIiwiY29zIiwidGlja3NCZWZvcmVUaWNrVGV4dCIsImdldFhEb21haW5NYXgiLCJnZXRYQXhpc1BhZGRpbmciLCJmaXJzdFgiLCJnZXRYRG9tYWluTWluIiwibGFzdFgiLCJ0aW1lRGlmZiIsInJlbGF0aXZlVGlja1dpZHRoIiwidXBkYXRlTGFiZWxzIiwid2l0aFRyYW5zaXRpb24iLCJsYWJlbHMiLCJnZXRQYWRkaW5nIiwiZG9tYWluTGVuZ3RoIiwiY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmciLCJwaXhlbHMiLCJmb3JUaW1lU2VyaWVzIiwidGFyZ2V0Q291bnQiLCJ0aWNrVmFsdWUiLCJnZW5lcmF0ZVRyYW5zaXRpb25zIiwiZHVyYXRpb24iLCJheCIsImF4aXNTdWJYIiwicmVkcmF3IiwidHJhbnNpdGlvbnMiLCJpc0hpZGRlbiIsImlzSW5pdCIsIm9wYWNpdHkiLCIkYXhpcyIsInJlZHJhd0F4aXMiLCJ3dGgiLCJmbG93IiwieERvbWFpbkZvclpvb20iLCJoYXNab29tIiwidXBkYXRlWERvbWFpbiIsIlVwZGF0ZVhEb21haW4iLCJVcGRhdGVPcmdYRG9tYWluIiwiVHJpbVhEb21haW4iLCJvcmdEb21haW4iLCJheGlzU2NhbGUiLCJnZXRZRG9tYWluIiwiaGFzQXJjVHlwZSIsIlRyYW5zaXRpb24iLCJVcGRhdGVYQXhpcyIsIlkiLCJzZXRDdWxsaW5nIiwic3ViWSIsInN1YlkyIiwidG9DdWxsIiwiaW50ZXJ2YWxGb3JDdWxsaW5nIiwidGlja1NpemUiLCJjdWxsaW5nTWF4IiwiZGlzcGxheSIsImNvbnZlcnREYXRhIiwidXJsIiwiY29udmVydFVybFRvRGF0YSIsIm1pbWVUeXBlIiwiaGVhZGVycyIsImpzb24iLCJjb252ZXJ0SnNvblRvRGF0YSIsInJvd3MiLCJjb252ZXJ0Um93c1RvRGF0YSIsImNvbHVtbnMiLCJjb252ZXJ0Q29sdW1uc1RvRGF0YSIsIkVycm9yIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsIkpTT04iLCJwYXJzZSIsInNlbmQiLCJjb252ZXJ0Q3N2VHN2VG9EYXRhIiwicGFyc2VyIiwieHN2IiwiY29udmVydENzdlRvRGF0YSIsImQzQ3N2UGFyc2VSb3dzIiwiZDNDc3ZQYXJzZSIsImNvbnZlcnRUc3ZUb0RhdGEiLCJ0c3YiLCJkM1RzdlBhcnNlUm93cyIsImQzVHN2UGFyc2UiLCJrZXlzUGFyYW0iLCJ0YXJnZXRLZXlzIiwibmV3Um93cyIsIm5ld1JvdyIsImZpbmRWYWx1ZUluSnNvbiIsInRtcCIsIm9iamVjdCIsImNvbnZlcnRlZFBhdGgiLCJwYXRoQXJyYXkiLCJzb21lIiwiayIsInJvdyIsImoiLCJjb2wiLCJjb252ZXJ0RGF0YVRvVGFyZ2V0cyIsImFwcGVuZFhzIiwieHNEYXRhIiwiZGF0YUtleXMiLCJpZHMiLCJpc05vdFgiLCJ4cyIsInhLZXkiLCJnZXRYS2V5IiwicmF3WCIsImdlbmVyYXRlVGFyZ2V0WCIsImdldE90aGVyVGFyZ2V0WHMiLCJnZXRYVmFsdWVzT2ZYS2V5IiwiY29udmVydGVkSWQiLCJoYXNDYXRlZ29yeSIsInYxIiwidjIiLCJoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzIiwiaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyIsInNldFRhcmdldFR5cGUiLCJtYXBUb0lkcyIsImRhdGFLZXkiLCJleGlzdFZhbHVlIiwiaXNHcm91cGVkIiwieFZhbHVlcyIsImdldEluZGV4QnlYIiwiYmFzZWRYIiwiZmlsdGVyQnlYIiwiZ2V0WFZhbHVlIiwiaWRzRm9yWCIsImdldE90aGVyVGFyZ2V0WCIsImFkZFhzIiwiaXNNdWx0aXBsZVgiLCJoYXNUeXBlIiwiYWRkTmFtZSIsImdldEFsbFZhbHVlc09uSW5kZXgiLCJmaWx0ZXJOdWxsIiwiZ2V0VmFsdWVPbkluZGV4IiwidmFsdWVPbkluZGV4IiwidXBkYXRlVGFyZ2V0WCIsInVwZGF0ZVRhcmdldFhzIiwidXBkYXRlWHMiLCJnZXRQcmV2WCIsImdldE5leHRYIiwiZ2V0QmFzZVZhbHVlIiwiaXNBcmVhUmFuZ2VUeXBlIiwiZ2V0QXJlYVJhbmdlRGF0YSIsImlzQnViYmxlWlR5cGUiLCJnZXRCdWJibGVaRGF0YSIsImdldE1pbk1heFZhbHVlIiwiZ2V0TWluTWF4RGF0YSIsImNhY2hlS2V5IiwibWluTWF4RGF0YSIsIm1pbk1heCIsIm1pbkRhdGEiLCJnZXRGaWx0ZXJlZERhdGFCeVZhbHVlIiwibWF4RGF0YSIsImdldFRvdGFsUGVySW5kZXgiLCJzdW0iLCJnZXRUb3RhbERhdGFTdW0iLCJzdWJ0cmFjdEhpZGRlbiIsInRvdGFsIiwiZ2V0SGlkZGVuVG90YWxEYXRhU3VtIiwiZ2V0TWF4RGF0YUNvdW50IiwiZ2V0TWF4RGF0YUNvdW50VGFyZ2V0IiwibWFwVG9UYXJnZXRJZHMiLCJoYXNUYXJnZXQiLCJ2YWwiLCJpc1RhcmdldFRvU2hvdyIsInRhcmdldElkIiwiaXNMZWdlbmRUb1Nob3ciLCJhZGRIaWRkZW5UYXJnZXRJZHMiLCJ0YXJnZXRJZHMiLCJyZW1vdmVIaWRkZW5UYXJnZXRJZHMiLCJhZGRIaWRkZW5MZWdlbmRJZHMiLCJyZW1vdmVIaWRkZW5MZWdlbmRJZHMiLCJnZXRWYWx1ZXNBc0lkS2V5ZWQiLCJ5cyIsImNoZWNrVmFsdWVJblRhcmdldHMiLCJjaGVja2VyIiwiaGFzTXVsdGlUYXJnZXRzIiwiX2NoZWNrT3JkZXIiLCJvcmRlciIsInRvTG93ZXJDYXNlIiwiaXNPcmRlckRlc2MiLCJpc09yZGVyQXNjIiwib3JkZXJUYXJnZXRzIiwidGFyZ2V0c1ZhbHVlIiwib3JkZXJBc2MiLCJvcmRlckRlc2MiLCJ0MSIsInQyIiwicmVkdWNlciIsImFicyIsInQxU3VtIiwidDJTdW0iLCJmaWx0ZXJSZW1vdmVOdWxsIiwiZmlsdGVyQnlYRG9tYWluIiwieERvbWFpbiIsImhhc0RhdGFMYWJlbCIsImRhdGFMYWJlbHMiLCJnZXREYXRhTGFiZWxMZW5ndGgiLCJsZW5ndGhzIiwiZGF0YUxhYmVsRm9ybWF0IiwiaXNOb25lQXJjIiwiaXNBcmMiLCJmaW5kU2FtZVhPZlZhbHVlcyIsInRhcmdldFgiLCJzYW1lcyIsImZpbmRDbG9zZXN0RnJvbVRhcmdldHMiLCJjYW5kaWRhdGVzIiwiZmluZENsb3Nlc3QiLCJjbG9zZXN0IiwibWluRGlzdCIsImlzQmFyVHlwZSIsImdldFRhcmdldFNlbGVjdG9yU3VmZml4IiwiaXNXaXRoaW5CYXIiLCJkaXN0IiwieEluZGV4IiwieUluZGV4IiwiY2lyY2xlWSIsInNxcnQiLCJwb3ciLCJjb252ZXJ0VmFsdWVzVG9TdGVwIiwic3RlcFR5cGUiLCJjb252ZXJ0ZWQiLCJjb252ZXJ0VmFsdWVzVG9SYW5nZSIsInJhbmdlcyIsInVwZGF0ZURhdGFBdHRyaWJ1dGVzIiwiYXR0cnMiLCJ3aXRoTGVnZW5kIiwiZ2V0UmF0aW8iLCJhc1BlcmNlbnQiLCJyYXRpbyIsInNob3duIiwicGFkQW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0QW5nbGUiLCJkYXRhVmFsdWVzIiwiaGlkZGVuU3VtIiwiYWNjIiwiY3VyciIsInBhcnNlRmxvYXQiLCJ1cGRhdGVEYXRhSW5kZXhCeVgiLCJ0aWNrVmFsdWVNYXAiLCJvdXQiLCJ2YWx1ZUluZGV4IiwibG9hZCIsInJhd1RhcmdldHMiLCJ1cGRhdGVUYXJnZXRzIiwid2l0aFVwZGF0ZU9yZ1hEb21haW4iLCJ3aXRoVXBkYXRlWERvbWFpbiIsInVwZGF0ZVR5cGVzRWxlbWVudHMiLCJsb2FkRnJvbUFyZ3MiLCJ1bmxvYWQiLCJyYXdUYXJnZXRJZHMiLCJjdXN0b21Eb25lQ2IiLCJzZWxlY3RvclRhcmdldCIsInNldE92ZXJPdXQiLCJpc092ZXIiLCJzZXRPdmVyQ29sb3IiLCJjYWxsZWUiLCJsYXN0IiwiaXNXaXRoaW5TaGFwZSIsImRhdHVtIiwic2hvd0NpcmNsZUZvY3VzIiwiZXhwYW5kQ2lyY2xlc0JhcnMiLCJjYWxsT3Zlck91dEZvclRvdWNoIiwiZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uIiwiZHJhZyIsImQzRHJhZyIsImQzTW91c2UiLCJkcmFnc3RhcnQiLCJkcmFnZW5kIiwic2VsZWN0b3IiLCJnZW5lcmF0ZUNsYXNzIiwiY2xhc3NUZXh0IiwiY2xhc3NUZXh0cyIsImNsYXNzU2hhcGUiLCJjbGFzc1NoYXBlcyIsImdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MiLCJjbGFzc0xpbmUiLCJjbGFzc0xpbmVzIiwiY2xhc3NDaXJjbGUiLCJjbGFzc0NpcmNsZXMiLCJjbGFzc0JhciIsImNsYXNzQmFycyIsImNsYXNzQXJjIiwiY2xhc3NBcmNzIiwiY2xhc3NBcmVhIiwiY2xhc3NBcmVhcyIsImNsYXNzUmVnaW9uIiwiY2xhc3MiLCJjbGFzc0V2ZW50IiwiY2xhc3NUYXJnZXQiLCJhZGRpdGlvbmFsQ2xhc3NTdWZmaXgiLCJhZGRpdGlvbmFsQ2xhc3MiLCJjbGFzc0ZvY3VzIiwiY2xhc3NGb2N1c2VkIiwiY2xhc3NEZWZvY3VzZWQiLCJjbGFzc0NoYXJ0VGV4dCIsImNsYXNzQ2hhcnRMaW5lIiwiY2xhc3NDaGFydEJhciIsImNsYXNzQ2hhcnRBcmMiLCJjbGFzc0NoYXJ0UmFkYXIiLCJwZngiLCJzZWxlY3RvclRhcmdldHMiLCJpZHNWYWx1ZSIsInNlbGVjdG9yTGVnZW5kIiwic2VsZWN0b3JMZWdlbmRzIiwiY29sb3JpemVQYXR0ZXJuIiwicGF0dGVybiIsImNsb25lTm9kZSIsInNjaGVtZUNhdGVnb3J5MTAiLCJnZXRDb2xvckZyb21Dc3MiLCJib2R5Iiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidHJpbSIsIkJvb2xlYW4iLCJnZW5lcmF0ZUNvbG9yIiwiY29sb3JzIiwiZDNTY2FsZU9yZGluYWwiLCJvcmlnaW5hbENvbG9yUGF0dGVybiIsInRpbGVzIiwiY29sb3JpemVkUGF0dGVybnMiLCJwYXR0ZXJucyIsImlzTGluZSIsImlzVHlwZU9mIiwiZ2VuZXJhdGVMZXZlbENvbG9yIiwidGhyZXNob2xkIiwiYXNWYWx1ZSIsInVuaXQiLCJsIiwiVFlQRSIsIkFSRUEiLCJBUkVBX0xJTkVfUkFOR0UiLCJBUkVBX1NQTElORSIsIkFSRUFfU1BMSU5FX1JBTkdFIiwiQVJFQV9TVEVQIiwiQkFSIiwiQlVCQkxFIiwiRE9OVVQiLCJHQVVHRSIsIkxJTkUiLCJQSUUiLCJSQURBUiIsIlNDQVRURVIiLCJTUExJTkUiLCJTVEVQIiwiVFlQRV9CWV9DQVRFR09SWSIsIkFyZWEiLCJBcmVhUmFuZ2UiLCJBcmMiLCJMaW5lIiwiU3RlcCIsIlNwbGluZSIsImdldFlEb21haW5NaW5NYXgiLCJpc01pbiIsImRhdGFHcm91cHMiLCJpZHNJbkdyb3VwIiwiYmFzZUlkIiwiYmFzZUF4aXNJZCIsImF4aXNJZCIsIm1lZXRDb25kaXRpb24iLCJnZXRZRG9tYWluTWluIiwiZ2V0WURvbWFpbk1heCIsImlzSGlkZGVuVGFyZ2V0V2l0aFlEb21haW4iLCJ0YXJnZXRzQnlBeGlzSWQiLCJ5VGFyZ2V0cyIsInlNaW4iLCJ5TWF4IiwieURvbWFpbk1pbiIsInlEb21haW5NYXgiLCJjZW50ZXIiLCJpc1plcm9CYXNlZCIsImlzSW52ZXJ0ZWQiLCJzaG93SG9yaXpvbnRhbERhdGFMYWJlbCIsInNob3dWZXJ0aWNhbERhdGFMYWJlbCIsImlzQWxsUG9zaXRpdmUiLCJpc0FsbE5lZ2F0aXZlIiwieURvbWFpbkFicyIsImdldFhEb21haW5NaW5NYXgiLCJjb25maWdWYWx1ZSIsImRhdGFWYWx1ZSIsImdldFhEb21haW5QYWRkaW5nIiwibWF4RGF0YUNvdW50IiwieFBhZGRpbmciLCJnZXRYRG9tYWluIiwiZ2V0VGltZSIsIndpdGhUcmltIiwib3JnIiwiem9vbUVuYWJsZWQiLCJ1cGRhdGVTY2FsZUV4dGVudCIsImRvbWFpblZhbHVlIiwiaW52ZXJ0IiwidHJpbVhEb21haW4iLCJ6b29tRG9tYWluIiwiZ2V0Wm9vbURvbWFpbiIsImdldEZvcm1hdCIsInR5cGVWYWx1ZSIsImRlZmF1bHRWYWx1ZUZvcm1hdCIsImdldFlGb3JtYXQiLCJmb3JBcmMiLCJ5Rm9ybWF0IiwieTJGb3JtYXQiLCJkZWZhdWx0QXJjVmFsdWVGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiaW5pdExlZ2VuZCIsInVwZGF0ZUxlZ2VuZCIsIm9wdGlvbnoiLCJ3aXRoVHJhbnNmb3JtIiwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0iLCJ1cGRhdGVMZWdlbmRUZW1wbGF0ZSIsInVwZGF0ZUxlZ2VuZEVsZW1lbnQiLCJjbGFzc2VkIiwidXBkYXRlU2NhbGVzIiwidXBkYXRlU3ZnU2l6ZSIsInRyYW5zZm9ybUFsbCIsIndyYXBwZXIiLCJ0ZW1wbGF0ZSIsIkNPTE9SIiwiVElUTEUiLCJjaGlsZE5vZGVzIiwic2V0TGVnZW5kSXRlbSIsInVwZGF0ZVNpemVGb3JMZWdlbmQiLCJpbnNldExlZ2VuZFBvc2l0aW9uIiwiZ2V0Q3VycmVudFBhZGRpbmdUb3AiLCJnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSIsImdldEN1cnJlbnRQYWRkaW5nUmlnaHQiLCJOYU4iLCJ0cmFuc2Zvcm1MZWdlbmQiLCJ1cGRhdGVMZWdlbmRTdGVwIiwidXBkYXRlTGVnZW5kSXRlbVdpZHRoIiwidXBkYXRlTGVnZW5kSXRlbUhlaWdodCIsInVwZGF0ZUxlZ2VuZEl0ZW1Db2xvciIsImdldExlZ2VuZFdpZHRoIiwiZ2V0TGVnZW5kSGVpZ2h0Iiwib3BhY2l0eUZvckxlZ2VuZCIsIm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQiLCJ0b2dnbGVGb2N1c0xlZ2VuZCIsImZvY3VzIiwidGFyZ2V0SWR6IiwicmV2ZXJ0TGVnZW5kIiwic2hvd0xlZ2VuZCIsImhpZGVMZWdlbmQiLCJnZXRMZWdlbmRJdGVtVGV4dEJveCIsInRleHRFbGVtZW50IiwiZ2V0VGV4dFJlY3QiLCJpdGVtIiwiaXNUb3VjaCIsImhhc0dhdWdlIiwiaXRlbUNsYXNzIiwiYWx0S2V5IiwiaGlkZSIsInNob3ciLCJ0b2dnbGUiLCJyZXZlcnQiLCJoaWRlVG9vbHRpcCIsInVuZG9NYXJrT3ZlcmxhcHBlZCIsIm1hcmtPdmVybGFwcGVkIiwieEZvckxlZ2VuZCIsInlGb3JMZWdlbmQiLCJwb3NNaW4iLCJ0aWxlV2lkdGgiLCJtYXhIZWlnaHQiLCJ0b3RhbExlbmd0aCIsIm9mZnNldHMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwibWFyZ2lucyIsInN0ZXBzIiwiaXNMZWdlbmRSaWdodE9ySW5zZXQiLCJ1cGRhdGVQb3NpdGlvbnMiLCJpc0xhc3QiLCJib3giLCJpdGVtV2lkdGgiLCJpdGVtSGVpZ2h0IiwiaXRlbUxlbmd0aCIsImFyZWFMZW5ndGgiLCJ1cGRhdGVWYWx1ZXMiLCJpZDIiLCJ3aXRob3V0U3RlcCIsIm1heExlbmd0aCIsInhGb3JMZWdlbmRUZXh0IiwieEZvckxlZ2VuZFJlY3QiLCJ4MUZvckxlZ2VuZFRpbGUiLCJ4MkZvckxlZ2VuZFRpbGUiLCJ5Rm9yTGVnZW5kVGV4dCIsInlGb3JMZWdlbmRSZWN0IiwieUZvckxlZ2VuZFRpbGUiLCJ1c2VQb2ludCIsImNyZWF0ZUVsZW1lbnROUyIsImQzTmFtZXNwYWNlcyIsImhhc1ZhbGlkUG9pbnRUeXBlIiwiaWR4Iiwibm9kZU5hbWUiLCJyZWN0cyIsInBvaW50UiIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwibGV2ZWxDb2xvciIsInRyYW5zaXRpb25zVmFsdWUiLCJpbml0aWFsaXppbmciLCJnZXRXaXRoT3B0aW9uIiwiZHVyYXRpb25Gb3JFeGl0IiwiVHJhbnNpdGlvbkZvckV4aXQiLCJkdXJhdGlvbkZvckF4aXMiLCJUcmFuc2l0aW9uRm9yQXhpcyIsInVwZGF0ZVNpemVzIiwiTGVnZW5kIiwiRGltZW5zaW9uIiwidXBkYXRlRGltZW5zaW9uIiwidXBkYXRlVGV4dCIsInVwZGF0ZUNpcmNsZVkiLCJoYXNQb2ludFR5cGUiLCJ1cGRhdGVDaXJjbGUiLCJoYXNHcmlkIiwidXBkYXRlR3JpZCIsInVwZGF0ZVJlZ2lvbiIsInVwZGF0ZUJhciIsImhhc1R5cGVPZiIsInVwZGF0ZUxpbmUiLCJ1cGRhdGVBcmVhIiwiRXZlbnRSZWN0IiwiYmluZFpvb21FdmVudCIsInJlZHJhd0FyYyIsIlRyYW5zZm9ybSIsInJlZHJhd1JhZGFyIiwicmVkcmF3VGl0bGUiLCJnZW5lcmF0ZVJlZHJhd0xpc3QiLCJTdWJjaGFydCIsImNhbGxQbHVnaW5Ib29rIiwid2l0aFN1YmNoYXJ0IiwiZ2V0RHJhd1NoYXBlIiwicmVkcmF3U3ViY2hhcnQiLCJmbG93Rm4iLCJnZW5lcmF0ZUZsb3ciLCJ4diIsImlzVHJhbnNpdGlvbiIsInJlZHJhd0xpc3QiLCJnZXRSZWRyYXdMaXN0IiwiYWZ0ZXJSZWRyYXciLCJ3YWl0Rm9yRHJhdyIsImQzVHJhbnNpdGlvbiIsImN4IiwiY3kiLCJ4Rm9yVGV4dCIsInJlZHJhd0dyaWQiLCJyZWRyYXdSZWdpb24iLCJyZWRyYXdMaW5lIiwicmVkcmF3QXJlYSIsInJlZHJhd0JhciIsInVwZGF0ZUdyaWRGb2N1cyIsInJlZHJhd1RleHQiLCJyZWRyYXdDaXJjbGUiLCJ1cGRhdGVBbmRSZWRyYXciLCJ3aXRoVHJhbnNpdGlvbkZvckV4aXQiLCJ3aXRoVHJhbnNpdGlvbkZvckF4aXMiLCJyZWRyYXdXaXRob3V0UmVzY2FsZSIsIndpdGhZIiwid2l0aEV2ZW50UmVjdCIsImdldFNjYWxlIiwiZm9yVGltZXNlcmllcyIsImQzU2NhbGVUaW1lIiwiZ2V0WFNjYWxlIiwib2Zmc2V0IiwiZ2V0Q3VzdG9taXplZFNjYWxlIiwiZ2V0WVNjYWxlIiwiZ2V0WVNjYWxlQnlJZCIsImlzU3ViIiwiaXNZMiIsInNjYWxlVmFsdWUiLCJvZmZzZXRWYWx1ZSIsInJhdyIsIm9yZ1NjYWxlIiwieFN1YkRvbWFpbiIsInVwZGF0ZUFyYyIsInh4IiwieXYiLCJ5U2NhbGUiLCJzdWJ4eCIsInNldENvbnRhaW5lclNpemUiLCJnZXRDdXJyZW50V2lkdGgiLCJnZXRDdXJyZW50SGVpZ2h0IiwiZ2V0UGFyZW50V2lkdGgiLCJnZXRQYXJlbnRIZWlnaHQiLCJnZXRBeGlzU2l6ZSIsImdldEF4aXNXaWR0aEJ5QXhpc0lkIiwiYXhlc0xlbiIsImdldFRpdGxlUGFkZGluZyIsImF4aXNXaWR0aCIsIndpdGhvdXRUaWNrVGV4dE92ZXJmbG93IiwibGVnZW5kV2lkdGhPblJpZ2h0IiwieEF4aXNUaWNrVGV4dE92ZXJmbG93IiwiZ2V0UGFyZW50UmVjdFZhbHVlIiwib2Zmc2V0TmFtZSIsInBhcmVudCIsInRhZ05hbWUiLCJib2R5V2lkdGgiLCJvZmZzZXRXaWR0aCIsInBhcnNlSW50IiwiZ2V0U3ZnTGVmdCIsImhhc0xlZnRBeGlzUmVjdCIsImxlZnRBeGlzQ2xhc3MiLCJsZWZ0QXhpcyIsInN2Z1JlY3QiLCJjaGFydFJlY3QiLCJoYXNBcmMiLCJzdmdMZWZ0IiwiZ2V0RXZlbnRSZWN0V2lkdGgiLCJhbGxvd2VkWEF4aXNUeXBlcyIsIm5lZWRUb1JvdGF0ZVhBeGlzVGlja1RleHRzIiwieEF4aXNMZW5ndGgiLCJ0aWNrQ291bnRXaXRoUGFkZGluZyIsIndpdGhvdXRBeGlzIiwiYnJ1c2hTaXplIiwiZ2V0WEF4aXNDbGlwWCIsImdldFhBeGlzQ2xpcFkiLCJnZXRYQXhpc0NsaXBXaWR0aCIsImdldFhBeGlzQ2xpcEhlaWdodCIsImdldFlBeGlzQ2xpcFgiLCJnZXRZQXhpc0NsaXBZIiwiZ2V0WUF4aXNDbGlwV2lkdGgiLCJnZXRZQXhpc0NsaXBIZWlnaHQiLCJjdXJyTGVnZW5kIiwibGVnZW5kSGVpZ2h0Rm9yQm90dG9tIiwieEF4aXNIZWlnaHQiLCJzdWJjaGFydFhBeGlzSGVpZ2h0Iiwic3ViY2hhcnRIZWlnaHQiLCJnZXRHYXVnZUxhYmVsSGVpZ2h0IiwidXBkYXRlUmFkaXVzIiwidXBkYXRlWEF4aXNUaWNrQ2xpcCIsIm9wYWNpdHlGb3JUZXh0IiwiaW5pdFRleHQiLCJ1cGRhdGVUYXJnZXRzRm9yVGV4dCIsIm1haW5UZXh0VXBkYXRlIiwibWFpblRleHRFbnRlciIsImRhdGFGbiIsImxhYmVsaXNoRGF0YSIsImlzUmFkYXJUeXBlIiwidXBkYXRlVGV4dENvbG9yIiwibGFiZWxDb2xvcnMiLCJmb3JGbG93IiwiYmFzZSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImdlbmVyYXRlWFlGb3JUZXh0IiwiaW5kaWNlcyIsImZvclgiLCJwb2ludHMiLCJnZXR0ZXIiLCJnZXRYRm9yVGV4dCIsImdldFlGb3JUZXh0IiwiaXNBcmVhVHlwZSIsImdldENlbnRlcmVkVGV4dFBvcyIsImNlbnRlcmVkIiwiaXNQb3NpdGl2ZSIsImdldFRleHRQb3MiLCJ4UG9zIiwieVBvcyIsImJhc2VZIiwiaXNMaW5lVHlwZSIsImlzU2NhdHRlclR5cGUiLCJpc0J1YmJsZVR5cGUiLCJib3hIZWlnaHQiLCJ0ZXh0Tm9kZXMiLCJmaWx0ZXJlZFRleHROb2RlcyIsInRleHROb2RlIiwidHJhbnNsYXRlIiwiY2FsY0h5cG8iLCJjb29yZGluYXRlIiwiZmlsdGVyZWRUZXh0Tm9kZSIsIm5vZGVGb3JXaWR0aCIsIm92ZXJsYXBzWCIsImdldENvbXB1dGVkVGV4dExlbmd0aCIsIm92ZXJsYXBzWSIsImQzU2VsZWN0QWxsIiwicHJldmlvdXNTaWJsaW5nIiwiaXNOdW0iLCJpbml0VGl0bGUiLCJ5Rm9yVGl0bGUiLCJ4Rm9yVGl0bGUiLCJ0ZXh0UmVjdFdpZHRoIiwiaW5pdFRvb2x0aXAiLCJnZXRUb29sdGlwSFRNTCIsImJpbmRUb29sdGlwUmVzaXplUG9zIiwiZ2V0VG9vbHRpcENvbnRlbnQiLCJkZWZhdWx0VGl0bGVGb3JtYXQiLCJ0aXRsZUZvcm1hdCIsIm5hbWVGb3JtYXQiLCJ2YWx1ZUZvcm1hdCIsImdldFJvd1ZhbHVlIiwiZ2V0QmdDb2xvciIsImNvbnRlbnRzIiwidHBsU3RyIiwiaTIiLCJwYXJhbSIsImdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUiLCJDTEFTU19UT09MVElQIiwiaGlnaCIsImxvdyIsImNvbnRlbnRWYWx1ZSIsIkNMQVNTX1RPT0xUSVBfTkFNRSIsIk5BTUUiLCJWQUxVRSIsInRvb2x0aXBQb3NpdGlvbiIsImRhdGFUb1Nob3ciLCJ0V2lkdGgiLCJ0SGVpZ2h0IiwiY2hhcnRSaWdodCIsImNoYXJ0TGVmdCIsImRhdGFTY2FsZSIsInpvb21TY2FsZSIsInNob3dUb29sdGlwIiwic2VsZWN0ZWREYXRhIiwiZGF0YVN0ciIsInN0cmluZ2lmeSIsInByb3BlcnR5IiwiX2hhbmRsZUxpbmtlZENoYXJ0cyIsImZuUG9zIiwieFBvc0luUGVyY2VudCIsInJlc2l6ZUZ1bmN0aW9uIiwiY2hhcnRzIiwibGlua2VkTmFtZSIsImludGVybmFsIiwiaXNMaW5rZWQiLCJpc0luRG9tIiwiY29udGFpbnMiLCJpc05vdFNhbWVJbmRleCIsImdldFJhZGFyU2l6ZSIsInRyYW5zZm9ybU1haW4iLCJ4QXhpcyIsInlBeGlzIiwieTJBeGlzIiwidHJhbnNmb3JtQ29udGV4dCIsInNldENoYXJ0RWxlbWVudHMiLCJjaGVja0Zyb21EYXRhIiwiZXhjbHVkZSIsImRhdGFUeXBlIiwiaGFzTXVsdGlBcmNHYXVnZSIsImlzU3RlcFR5cGUiLCJpc1NwbGluZVR5cGUiLCJpc1BpZVR5cGUiLCJpc0dhdWdlVHlwZSIsImlzRG9udXRUeXBlIiwiaXNBcmNUeXBlIiwiaXNDaXJjbGVQb2ludCIsImlzQ2lyY2xlIiwibGluZURhdGEiLCJhcmNEYXRhIiwiYmFyRGF0YSIsImJhckxpbmVCdWJibGVEYXRhIiwiaXNJbnRlcnBvbGF0aW9uVHlwZSIsInNldE1pbk1heCIsImNhdGVnb3J5IiwidG8iLCJ0YWlsIiwibm90Zm91bmRJZHMiLCJvcmdEYXRhQ291bnQiLCJtaXNzaW5nIiwiYmFzZVRhcmdldCIsImJhc2VWYWx1ZSIsIndpdGhUcmltWERvbWFpbiIsIndpdGhVcGRhdGVYQXhpcyIsImdyaWRzIiwicmVtb3ZlR3JpZExpbmVzIiwiZ3JvdXBzIiwib3B0aW9uc1ZhbHVlIiwic2VsZWN0ZWQiLCJkYXRhUG9pbnQiLCJyZXNldE90aGVyIiwiZ2V0VG9nZ2xlIiwiaXNUYXJnZXRJZCIsImlzVGFyZ2V0SW5kZXgiLCJpc1NlbGVjdGVkIiwidW5zZWxlY3QiLCJ3aXRoaW5SYW5nZSIsInJlc3VsdERvbWFpbiIsInhTY2FsZSIsImdldFNlbGVjdGlvbiIsIm1vdmUiLCJ3aXRoRGltZW5zaW9uIiwic2V0Wm9vbVJlc2V0QnV0dG9uIiwiZW5hYmxlIiwiZW5hYmxlZCIsImVuYWJsZVR5cGUiLCJpbml0Wm9vbSIsInVuem9vbSIsInVwZGF0ZVRyYW5zZm9ybVNjYWxlIiwiZDNab29tSWRlbnRpdHkiLCJ1cGRhdGVab29tIiwicmVzZXRCdG4iLCJkM1pvb21UcmFuc2Zvcm0iLCJhbHREb21haW4iLCJzeCIsInN5IiwibXgiLCJteSIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJpc0luY2x1ZGVkIiwiaXNXaXRoaW4iLCJ0b2dnbGVQb2ludCIsInRvZ2dsZVBhdGgiLCJzZXREcmFnU3RhdHVzIiwiaXNEcmFnZ2luZyIsImZsb3dMZW5ndGgiLCJ1cGRhdGVYR3JpZCIsImVsZW1lbnRzIiwiaGlkZUdyaWRGb2N1cyIsInNldEZsb3dMaXN0IiwiZmxvd0luZGV4IiwiZ2V0Rmxvd1RyYW5zZm9ybSIsIndhaXQiLCJndCIsImVhc2UiLCJkM0Vhc2VMaW5lYXIiLCJpc1JlZ2lvbk9uWCIsImNsZWFuVXBGbG93IiwicmVnaW9uWCIsInJlZ2lvbldpZHRoIiwieEZ1bmMiLCJ5RnVuYyIsInJlZHJhd0V2ZW50UmVjdCIsInRyYW5zbGF0ZVgiLCJmbG93U3RhcnQiLCJmbG93RW5kIiwic2NhbGVYIiwiaW5pdEV2ZW50UmVjdCIsImV2ZW50UmVjdFVwZGF0ZSIsImdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMiLCJ4QXhpc1RpY2tWYWx1ZXMiLCJ1cGRhdGVQb2ludENsYXNzIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWCIsInVwZGF0ZUV2ZW50UmVjdCIsImJpbmRUb3VjaE9uRXZlbnRSZWN0Iiwic3RhcnRQeCIsImdldEV2ZW50UmVjdCIsImVsZW1lbnRGcm9tUG9pbnQiLCJnZXRJbmRleCIsInNlbGVjdFJlY3QiLCJjb250ZXh0Iiwic2VsZWN0UmVjdEZvck11bHRpcGxlWHMiLCJ1bnNlbGVjdFJlY3QiLCJzZWxlY3RSZWN0Rm9yU2luZ2xlIiwicHJldmVudERlZmF1bHQiLCJpc1ByZXZlbnRlZCIsInByZXZlbnRUaHJlc2hvbGQiLCJwcmV2ZW50RXZlbnQiLCJjdXJyZW50WFkiLCJ0b2dnbGVTaGFwZSIsImV2ZW50UmVjdERhdGEiLCJyZWN0VyIsInJlY3RYIiwiZ2V0UHJldk5leHRYIiwicHJldiIsIm5leHQiLCJ0aGlzWCIsImlzU2VsZWN0aW9uRW5hYmxlZCIsImlzU2VsZWN0aW9uR3JvdXBlZCIsImlzVG9vbHRpcEdyb3VwZWQiLCJzaG93R3JpZEZvY3VzIiwidW5leHBhbmRDaXJjbGVzIiwiZXhwYW5kQ2lyY2xlcyIsImV4cGFuZEJhcnMiLCJzYW1lWERhdGEiLCJ1bmV4cGFuZEJhcnMiLCJldmVudFJlY3RFbnRlciIsImNsaWNrSGFuZGxlckZvclNpbmdsZVgiLCJkMiIsImNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMiLCJpbml0QnJ1c2giLCJkM0JydXNoWSIsImQzQnJ1c2hYIiwibGFzdERvbWFpbiIsImJydXNoSGFuZGxlciIsInJlZHJhd0ZvckJydXNoIiwiZ2V0QnJ1c2hTaXplIiwidXBkYXRlUmVzaXplIiwidXBkYXRlIiwiZXh0ZW50IiwiZ2V0RXh0ZW50IiwiaW5pdFN1YmNoYXJ0IiwidmlzaWJpbGl0eSIsImNsaXBJZCIsImdldENsaXBQYXRoIiwiYXBwZW5kQ2xpcCIsInVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCIsImJhclVwZGF0ZSIsImJhckVudGVyIiwibGluZUVudGVyIiwidXBkYXRlQmFyRm9yU3ViY2hhcnQiLCJpbml0aWFsT3BhY2l0eSIsInJlZHJhd0JhckZvclN1YmNoYXJ0IiwiZHJhd0Jhck9uU3ViIiwidXBkYXRlTGluZUZvclN1YmNoYXJ0IiwicmVkcmF3TGluZUZvclN1YmNoYXJ0IiwiZHJhd0xpbmVPblN1YiIsInVwZGF0ZUFyZWFGb3JTdWJjaGFydCIsInJlZHJhd0FyZWFGb3JTdWJjaGFydCIsImRyYXdBcmVhT25TdWIiLCJkcmF3Iiwib25CcnVzaCIsInN1YlhBeGlzIiwiZ2VuZXJhdGVab29tIiwiaW5pdFpvb21CZWhhdmlvdXIiLCJiaW5kWm9vbU9uRXZlbnRSZWN0IiwiZDNab29tIiwib25ab29tU3RhcnQiLCJvblpvb20iLCJvblpvb21FbmQiLCJvcmdTY2FsZUV4dGVudCIsInJlc2NhbGUiLCJzb3VyY2VFdmVudCIsInN0YXJ0RXZlbnQiLCJpc01vdXNlbW92ZSIsImlzWm9vbU91dCIsIndoZWVsRGVsdGEiLCJkZWx0YSIsImlzZnVsbHlTaG93biIsImJlaGF2aW91ciIsInpvb21CZWhhdmlvdXIiLCJwcm9wIiwiY2xpY2tEaXN0YW5jZSIsInJlc2V0QnV0dG9uIiwib25jbGljayIsImluaXRDbGlwIiwiaXNJRTkiLCJhcHBWZXJzaW9uIiwiVVJMIiwiZ2V0QXhpc0NsaXBYIiwiZ2V0QXhpc0NsaXBZIiwiZ2V0QXhpc0NsaXBXaWR0aCIsImdldEF4aXNDbGlwSGVpZ2h0IiwibmV3WEF4aXNIZWlnaHQiLCJzZXRYQXhpc1RpY2tDbGlwV2lkdGgiLCJzZXRYQXhpc1RpY2tUZXh0Q2xpcFBhdGhXaWR0aCIsInNpblJvdGF0aW9uIiwiZ2V0R3JpZFRleHRBbmNob3IiLCJnZXRHcmlkVGV4dER4IiwiZ2V0R3JpZFRleHRYIiwic21vb3RoTGluZXMiLCJpbml0R3JpZCIsImluaXRHcmlkTGluZXMiLCJpbml0Rm9jdXNHcmlkIiwid2l0aG91dFVwZGF0ZSIsInhncmlkRGF0YSIsImdlbmVyYXRlR3JpZERhdGEiLCJ1cGRhdGVZR3JpZCIsImdyaWRWYWx1ZXMiLCJ1cGRhdGVYR3JpZExpbmVzIiwidXBkYXRlWUdyaWRMaW5lcyIsInhMaW5lcyIsImlzRnJvbnQiLCJmb2N1c0VsIiwiaXNFZGdlIiwieHkiLCJoaWRlQ2lyY2xlRm9jdXMiLCJ0aWNrTnVtIiwiZ3JpZERhdGEiLCJmaXJzdFllYXIiLCJnZXRGdWxsWWVhciIsImxhc3RZZWFyIiwiZ2V0R3JpZEZpbHRlclRvUmVtb3ZlIiwidG9SZW1vdmUiLCJpbml0UmVnaW9uIiwicmVnaW9uWSIsInJlZ2lvbkhlaWdodCIsImdldFJlZ2lvblhZIiwiY3VyclNjYWxlIiwiZ2V0UmVnaW9uU2l6ZSIsImlzV2lkdGgiLCJzZWxlY3RQb2ludCIsImNpcmNsZVgiLCJwb2ludFNlbGVjdFIiLCJ1bnNlbGVjdFBvaW50IiwibWV0aG9kIiwic2VsZWN0UGF0aCIsImQzUmdiIiwiYnJpZ2h0ZXIiLCJ1bnNlbGVjdFBhdGgiLCJ0aGF0IiwidG9nZ2xlZFNoYXBlIiwiaW5pdEJhciIsInVwZGF0ZVRhcmdldHNGb3JCYXIiLCJtYWluQmFyVXBkYXRlIiwibWFpbkJhckVudGVyIiwiZHJhd0JhciIsImdldEJhclciLCJiYXJUYXJnZXRzTnVtIiwicmVzdWx0IiwiZ2V0V2lkdGgiLCJnZXRCYXJzIiwic3VmZml4IiwiZ2VuZXJhdGVEcmF3QmFyIiwiYmFySW5kaWNlcyIsImdldFBvaW50cyIsImdlbmVyYXRlR2V0QmFyUG9pbnRzIiwiYmFyUmFkaXVzIiwiYmFyUmFkaXVzUmF0aW8iLCJnZXRSYWRpdXMiLCJpbmRleFgiLCJpbmRleFkiLCJpc05lZ2F0aXZlIiwicGF0aFJhZGl1cyIsImJhclciLCJnZXRJbmRpY2VzTWF4IiwiYmFyWCIsImdldFNoYXBlWCIsImJhclkiLCJnZXRTaGFwZVkiLCJiYXJPZmZzZXQiLCJnZXRTaGFwZU9mZnNldCIsInkwIiwiZ2V0U2hhcGVZTWluIiwicG9zWCIsInBvc1kiLCJzZWcwIiwic2VnMSIsImluaXRCdWJibGUiLCJnZXRCYXNlTGVuZ3RoIiwiYmFzZUxlbmd0aCIsImdldEJ1YmJsZVIiLCJtYXhSIiwibWlkIiwibWF4QXJlYSIsImluaXRMaW5lIiwidXBkYXRlVGFyZ2V0c0ZvckxpbmUiLCJtYWluTGluZVVwZGF0ZSIsIm1haW5MaW5lRW50ZXIiLCJleHRyYUxpbmVDbGFzc2VzIiwiZHJhd0xpbmUiLCJnZXRDdXJ2ZSIsImlzUm90YXRlZFN0ZXBUeXBlIiwiZ2V0SW50ZXJwb2xhdGUiLCJvcmdQb2ludCIsInBvaW50Um90YXRlZCIsIl9wb2ludCIsIl95IiwiX3QiLCJfY29udGV4dCIsImxpbmVUbyIsIl94IiwiZ2VuZXJhdGVEcmF3TGluZSIsImxpbmVJbmRpY2VzIiwibGluZUNvbm5lY3ROdWxsIiwiZ2VuZXJhdGVHZXRMaW5lUG9pbnRzIiwieFZhbHVlIiwieVZhbHVlIiwiZDNMaW5lIiwiZGVmaW5lZCIsIngwIiwibGluZVdpdGhSZWdpb25zIiwiY3VydmUiLCJpc1N1YlZhbHVlIiwibGluZU9mZnNldCIsIl9yZWdpb25zIiwieHAiLCJ5cCIsImRpZmZ4MiIsImRhc2hhcnJheSIsImlzV2l0aGluUmVnaW9ucyIsIndpdGhpblgiLCJ3aXRoaW5SZWdpb25zIiwicmVnIiwiZ2V0VmFsdWUiLCJkdCIsImdlbmVyYXRlTSIsInNXaXRoUmVnaW9uIiwiZDAiLCJkMSIsInRpbWVzZXJpZXNEaWZmIiwieERpZmYiLCJ4djAiLCJ4djEiLCJvdGhlckRpZmYiLCJwcmV2RGF0YSIsImhhc1ByZXZEYXRhIiwiZGQiLCJ1cGRhdGVBcmVhR3JhZGllbnQiLCJzdG9wcyIsImxpbmVhckdyYWRpZW50Iiwic3RvcENvbG9yIiwidXBkYXRlQXJlYUNvbG9yIiwiZHJhd0FyZWEiLCJnZW5lcmF0ZURyYXdBcmVhIiwiYXJlYUluZGljZXMiLCJnZW5lcmF0ZUdldEFyZWFQb2ludHMiLCJ2YWx1ZTAiLCJ2YWx1ZTEiLCJkM0FyZWEiLCJhcmVhT2Zmc2V0IiwiaXNXaXRoaW5TdGVwIiwic2hvdWxkRHJhd1BvaW50c0ZvckxpbmUiLCJsaW5lUG9pbnQiLCJnZXRUcmFuc2l0aW9uTmFtZSIsImhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyIsInBvaW50VHlwZSIsImluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlIiwib3BhY2l0eUZvckNpcmNsZSIsImluaXRDaXJjbGUiLCJnZW5lcmF0ZVBvaW50IiwidXBkYXRlVGFyZ2V0Rm9yQ2lyY2xlIiwibWFpbkNpcmNsZSIsIm1haW5DaXJjbGVFbnRlciIsImZvY3VzT25seSIsInBvc0F0dHIiLCJvcGFjaXR5U3R5bGVGbiIsIm1haW5DaXJjbGVzIiwicmFkYXJDaXJjbGVYIiwicmFkYXJDaXJjbGVZIiwiZ2V0U2hhcGVJbmRpY2VzIiwiZ2V0Q2lyY2xlcyIsInBvaW50RXhwYW5kZWRSIiwic2VsZWN0UiIsImlzV2l0aGluQ2lyY2xlIiwiaW5zZXJ0UG9pbnRJbmZvRGVmcyIsImNvcHlBdHRyIiwiZnJvbSIsImF0dHJpYnMiLCJhdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xvbmUiLCJmaWxsIiwic3Ryb2tlIiwiaW5uZXJIVE1MIiwicG9pbnRGcm9tRGVmcyIsInBvaW50Q2xhc3MiLCJwb2ludElkIiwiY3VzdG9tIiwic2l6ZUZuIiwiZmlsbFN0eWxlRm4iLCJ4UG9zRm4iLCJ5UG9zRm4iLCJ4UG9zRm4yIiwidHJhbnNpdGlvbk5hbWUiLCJyZWN0YW5nbGUiLCJyZWN0U2l6ZUZuIiwicmVjdFhQb3NGbiIsInR5cGVGaWx0ZXIiLCJoYXNYcyIsImluZCIsIl9fbWF4X18iLCJnZXRJbmRpY2VzIiwiYmFyUGFkZGluZyIsImhhbGZXaWR0aCIsInRhcmdldHNOdW0iLCJnZXRTaGFwZU9mZnNldERhdGEiLCJzaGFwZU9mZnNldFRhcmdldHMiLCJyb3dWYWx1ZXMiLCJyb3dWYWx1ZU1hcEJ5WFZhbHVlIiwiaW5kZXhNYXBCeVRhcmdldElkIiwiZGF0YVhBc051bWJlciIsImludGVycG9sYXRpb24iLCJnZXRJbnRlcnBvbGF0ZVR5cGUiLCJkM0N1cnZlQmFzaXMiLCJkM0N1cnZlQmFzaXNDbG9zZWQiLCJkM0N1cnZlQmFzaXNPcGVuIiwiZDNDdXJ2ZUJ1bmRsZSIsImQzQ3VydmVDYXJkaW5hbCIsImQzQ3VydmVDYXJkaW5hbENsb3NlZCIsImQzQ3VydmVDYXJkaW5hbE9wZW4iLCJkM0N1cnZlQ2F0bXVsbFJvbSIsImQzQ3VydmVDYXRtdWxsUm9tQ2xvc2VkIiwiZDNDdXJ2ZUNhdG11bGxSb21PcGVuIiwiZDNDdXJ2ZU1vbm90b25lWCIsImQzQ3VydmVNb25vdG9uZVkiLCJkM0N1cnZlTmF0dXJhbCIsImQzQ3VydmVMaW5lYXJDbG9zZWQiLCJkM0N1cnZlTGluZWFyIiwiZDNDdXJ2ZVN0ZXAiLCJkM0N1cnZlU3RlcEFmdGVyIiwiZDNDdXJ2ZVN0ZXBCZWZvcmUiLCJhcGlBeGlzIiwiYXBpQ2F0ZWdvcnkiLCJhcGlGbG93IiwiYXBpWEdyaWQiLCJhcGlZR3JpZCIsImFwaUdyb3VwIiwiYXBpUmVnaW9uIiwiYXBpU2VsZWN0aW9uIiwiYXBpWCIsImFwaVpvb20iLCJldmVudHJlY3QiLCJpbml0UGllIiwic3RhcnRpbmdBbmdsZSIsImQzUGllIiwic29ydFZhbHVlcyIsImdldElubmVyUmFkaXVzIiwic3ZnQXJjIiwiZ2V0U3ZnQXJjIiwic3ZnQXJjRXhwYW5kZWQiLCJnZXRTdmdBcmNFeHBhbmRlZCIsInVwZGF0ZUFuZ2xlIiwiZFZhbHVlIiwiZ1N0YXJ0IiwidG90YWxTdW0iLCJnRW5kIiwibWF4VmFsdWUiLCJnTWluIiwiZ01heCIsImdWYWx1ZSIsImlyIiwic2luZ2xlQXJjV2lkdGgiLCJkM0FyYyIsIm91dGVyUmFkaXVzIiwibmV3QXJjIiwidXBkYXRlZCIsImNlbnRyb2lkIiwicmF0ZSIsIm5ld1JhdGUiLCJleHBhbmRXaWR0aCIsImdldEFyYyIsInRyYW5zZm9ybUZvckFyY0xhYmVsIiwiY29udmVydFRvQXJjRGF0YSIsInRleHRGb3JBcmNMYWJlbCIsInNob3VsZFNob3dBcmNMYWJlbCIsImlzVW5kZXJUaHJlc2hvbGQiLCJtZWV0c0FyY0xhYmVsVGhyZXNob2xkIiwiZ2V0QXJjTGFiZWxGb3JtYXQiLCJ0ZXh0Rm9yR2F1Z2VNaW5NYXgiLCJpc01heCIsImV4cGFuZEFyYyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm5ld1RhcmdldElkcyIsInNob3VsZEV4cGFuZCIsImV4cGFuZER1cmF0aW9uIiwiZ2V0RXhwYW5kQ29uZmlnIiwic3ZnQXJjRXhwYW5kZWRTdWIiLCJ1bmV4cGFuZEFyYyIsImdldEFyY1RpdGxlIiwidXBkYXRlVGFyZ2V0c0ZvckFyYyIsIm1haW5QaWVVcGRhdGUiLCJtYWluUGllRW50ZXIiLCJpbml0QXJjIiwic2V0QXJjVGl0bGUiLCJoYXNJbnRlcmFjdGlvbiIsIm1haW5BcmMiLCJfY3VycmVudCIsInJlZHJhd011bHRpQXJjR2F1Z2UiLCJhdHRyVHdlZW4iLCJpbnRlcnBvbGF0ZSIsImQzSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWQiLCJiaW5kQXJjRXZlbnQiLCJyZWRyYXdBcmNUZXh0IiwiYXJjTGFiZWxMaW5lcyIsIm1haW5BcmNMYWJlbExpbmUiLCJsaW5lTGVuZ3RoIiwibGluZVRoaWNrbmVzcyIsImlubmVyTGluZUxlbmd0aCIsImxpbmVBbmdsZSIsImFyY0lubmVyUmFkaXVzIiwibGluZVBvc2l0aW9uaW5nQW5nbGUiLCJzZWxlY3RBcmMiLCJfdGhpcyIsInVuc2VsZWN0QXJjIiwiaXNNb3VzZSIsImdldEV2ZW50QXJjIiwiZXZlbnRBcmMiLCJoYW5kbGVyIiwiaXNGdWxsQ2lyY2xlIiwiYmFja2dyb3VuZEFyYyIsImluaXRHYXVnZSIsImFwcGVuZFRleHQiLCJnZXRQb3NpdGlvbiIsImlzQ2xvY2t3aXNlIiwiZWRnZSIsImZ1bmMiLCJpbml0UmFkYXIiLCJ1cGRhdGVUYXJnZXRzRm9yUmFkYXIiLCJnZW5lcmF0ZVJhZGFyUG9pbnRzIiwiZ2V0UmFkYXJQb3NpdGlvbiIsIl9zaXplIiwidXBkYXRlUmFkYXJMZXZlbCIsInVwZGF0ZVJhZGFyQXhlcyIsInVwZGF0ZVJhZGFyU2hhcGUiLCJnZW5lcmF0ZUdldFJhZGFyUG9pbnRzIiwiZGVwdGgiLCJzaG93VGV4dCIsInJhZGFyTGV2ZWxzIiwibGV2ZWxEYXRhIiwibGV2ZWxSYXRpbyIsImxldmVsVGV4dEZvcm1hdCIsImpvaW4iLCJsZXZlbEVudGVyIiwiYXhpc0VudGVyIiwiZmlyc3RDaGlsZCIsImJpbmRFdmVudCIsIm5vSW5kZXgiLCJhcmVhc0VudGVyIiwiQ2hhcnRJbnRlcm5hbCIsInN0b3JlIiwiYmVmb3JlSW5pdCIsImFmdGVySW5pdCIsImluaXRQYXJhbXMiLCJjbGFzc25hbWUiLCJpbml0VG9SZW5kZXIiLCJmb3JjZWQiLCJpc0xhenkiLCJsYXp5IiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJtdXRhdGlvbiIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImF0dHJpYnV0ZUZpbHRlciIsImNvbnZlcnRlZERhdGEiLCJpbml0V2l0aERhdGEiLCJkM1RpbWVQYXJzZSIsImQzVXRjUGFyc2UiLCJkM1RpbWVGb3JtYXQiLCJkM1V0Y0Zvcm1hdCIsImlzRHJhZ1pvb20iLCJpc1pvb21lZCIsInNwZWNpZmllciIsImdldE1pbGxpc2Vjb25kcyIsImdldFNlY29uZHMiLCJnZXRNaW51dGVzIiwiZ2V0SG91cnMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJyb3RhdGVkUGFkZGluZ1JpZ2h0IiwiaGFzQ29sb3JQYXR0ZXJucyIsImJpbmRSZXNpemUiLCJpbml0Q2hhcnRFbGVtZW50cyIsInNldEJhY2tncm91bmQiLCIkIiwiYmciLCJpbWdVcmwiLCJzaG93VGFyZ2V0cyIsIndpdGhPcHRpb25zIiwiZGVmVmFsIiwiZmx1c2giLCJhZGRFdmVudExpc3RlbmVyIiwicGhhc2UiLCJwcm90b3R5cGUiLCJkYXRhQ29udmVydCIsImRhdGFMb2FkIiwiY2xhc3NNb2R1bGUiLCJhcmNJbnRlcm5hbCIsImF4aXNJbnRlcm5hbCIsImxvYWRDb25maWciLCJyZWFkIiwidGhpc0NvbmZpZyIsImZpbmQiLCJyZXNpemUiLCJzb2Z0IiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmbGF0IiwibmFtZXMiLCJiNjRFbmNvZGVVbmljb2RlIiwiYnRvYSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1hdGNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibm9kZVRvU3ZnRGF0YVVybCIsInNlcmlhbGl6ZXIiLCJYTUxTZXJpYWxpemVyIiwiY3NzVGV4dCIsInhodG1sIiwibm9kZVhtbCIsInNlcmlhbGl6ZVRvU3RyaW5nIiwiY3JlYXRlVGV4dE5vZGUiLCJzdHlsZVhtbCIsImV4cG9ydCIsInN2Z0RhdGFVcmwiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwib25sb2FkIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsInNyYyIsInRhcmdldElkc1ZhbHVlIiwiZGVmb2N1cyIsImFyZ3NWYWx1ZSIsInNob3dIaWRlIiwiZXZlbnROYW1lIiwiQ2hhcnQiLCJiaW5kVGhpcyIsImFyZ1RoaXMiLCJpc0Z1bmMiLCJpc0NoaWxkIiwiaGFzQ2hpbGQiLCJhcGlDaGFydCIsImFwaUNvbG9yIiwiYXBpRGF0YSIsImFwaUV4cG9ydCIsImFwaUZvY3VzIiwiYXBpTGVnZW5kIiwiYXBpTG9hZCIsImFwaVNob3ciLCJhcGlUb29sdGlwIiwiZGVmYXVsdHMiLCJiYiIsInZlcnNpb24iLCJnZW5lcmF0ZSIsImluc3QiLCJpbnN0YW5jZSIsInBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQSx1REFBYTtBQUNiOztBQUVBOztBQUVBLGdCQUFnQixt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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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UTtBQUM3UTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsZ0ZBQWdGO0FBQ25GO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxtRkFBbUY7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5Rjs7QUFFekY7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9GQUFvRjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxREFBcUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHlHQUF5RztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0RhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBLHdDOzs7Ozs7QUNyQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7Ozs7OztBQ3RCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7OztBQzFEQSxVQUFVLG1CQUFPLENBQUMsRUFB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LEVBQU9BLElBQVA7QUFDQSxHQTVDUzs7QUE4Q1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkFKLFVBcEVVLG9CQW9FRHo2RCxPQXBFQyxFQW9FUztBQUtsQixXQUpJSixRQUFRLENBQUNJLE9BQUQsQ0FJWixLQUhDeTZELFNBQVEsR0FBR3o2RCxPQUdaLEdBQU95NkQsU0FBUDtBQUNBLEdBMUVTOztBQTRFVjs7Ozs7Ozs7Ozs7QUFXQUssVUFBUSxFQUFFLEVBdkZBOztBQXlGVjs7Ozs7Ozs7QUFRQUMsUUFBTSxFQUFFO0FBakdFLEM7QUFKWCIsImZpbGUiOiJiaWxsYm9hcmQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLWJydXNoXCIpLCByZXF1aXJlKFwiZDMtYXhpc1wiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtZWFzZVwiKSwgcmVxdWlyZShcImQzLWNvbG9yXCIpLCByZXF1aXJlKFwiZDMtc2hhcGVcIiksIHJlcXVpcmUoXCJkMy1pbnRlcnBvbGF0ZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJkMy10aW1lLWZvcm1hdFwiLCBcImQzLXNlbGVjdGlvblwiLCBcImQzLWJydXNoXCIsIFwiZDMtYXhpc1wiLCBcImQzLXNjYWxlXCIsIFwiZDMtZHN2XCIsIFwiZDMtZHJhZ1wiLCBcImQzLXRyYW5zaXRpb25cIiwgXCJkMy16b29tXCIsIFwiZDMtZWFzZVwiLCBcImQzLWNvbG9yXCIsIFwiZDMtc2hhcGVcIiwgXCJkMy1pbnRlcnBvbGF0ZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwiZDMtdGltZS1mb3JtYXRcIiksIHJlcXVpcmUoXCJkMy1zZWxlY3Rpb25cIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy10cmFuc2l0aW9uXCIpLCByZXF1aXJlKFwiZDMtem9vbVwiKSwgcmVxdWlyZShcImQzLWVhc2VcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIikpIDogZmFjdG9yeShyb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzhfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDhfXykge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuXG4vKiBlc2xpbnQgcHJlZmVyLWRlc3RydWN0dXJpbmc6IG9mZiAqL1xuXG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xuXG52YXIgc29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxudmFyIG92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXknKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2csXG4gICAgc2V0TG9nTGV2ZWwgPSBfcmVxdWlyZS5zZXRMb2dMZXZlbDtcblxudmFyIHNlbmRNZXNzYWdlID0gcmVxdWlyZSgnLi91dGlscy9zZW5kTWVzc2FnZScpO1xuXG52YXIgcmVsb2FkQXBwID0gcmVxdWlyZSgnLi91dGlscy9yZWxvYWRBcHAnKTtcblxudmFyIGNyZWF0ZVNvY2tldFVybCA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlU29ja2V0VXJsJyk7XG5cbnZhciBzdGF0dXMgPSB7XG4gIGlzVW5sb2FkaW5nOiBmYWxzZSxcbiAgY3VycmVudEhhc2g6ICcnXG59O1xudmFyIG9wdGlvbnMgPSB7XG4gIGhvdDogZmFsc2UsXG4gIGhvdFJlbG9hZDogdHJ1ZSxcbiAgbGl2ZVJlbG9hZDogZmFsc2UsXG4gIGluaXRpYWw6IHRydWUsXG4gIHVzZVdhcm5pbmdPdmVybGF5OiBmYWxzZSxcbiAgdXNlRXJyb3JPdmVybGF5OiBmYWxzZSxcbiAgdXNlUHJvZ3Jlc3M6IGZhbHNlXG59O1xudmFyIHNvY2tldFVybCA9IGNyZWF0ZVNvY2tldFVybChfX3Jlc291cmNlUXVlcnkpO1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gIHN0YXR1cy5pc1VubG9hZGluZyA9IHRydWU7XG59KTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBxcyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgb3B0aW9ucy5ob3RSZWxvYWQgPSBxcy5pbmRleE9mKCdob3RyZWxvYWQ9ZmFsc2UnKSA9PT0gLTE7XG59XG5cbnZhciBvblNvY2tldE1lc3NhZ2UgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIG9wdGlvbnMuaG90ID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLicpO1xuICB9LFxuICBsaXZlUmVsb2FkOiBmdW5jdGlvbiBsaXZlUmVsb2FkKCkge1xuICAgIG9wdGlvbnMubGl2ZVJlbG9hZCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIExpdmUgUmVsb2FkaW5nIGVuYWJsZWQuJyk7XG4gIH0sXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLicpOyAvLyBmaXhlcyAjMTA0Mi4gb3ZlcmxheSBkb2Vzbid0IGNsZWFyIGlmIGVycm9ycyBhcmUgZml4ZWQgYnV0IHdhcm5pbmdzIHJlbWFpbi5cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ0ludmFsaWQnKTtcbiAgfSxcbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xuICAgIHN0YXR1cy5jdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuICAnc3RpbGwtb2snOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBOb3RoaW5nIGNoYW5nZWQuJyk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdTdGlsbE9rJyk7XG4gIH0sXG4gICdsb2ctbGV2ZWwnOiBmdW5jdGlvbiBsb2dMZXZlbChsZXZlbCkge1xuICAgIHZhciBob3RDdHggPSByZXF1aXJlLmNvbnRleHQoJ3dlYnBhY2svaG90JywgZmFsc2UsIC9eXFwuXFwvbG9nJC8pO1xuXG4gICAgaWYgKGhvdEN0eC5rZXlzKCkuaW5kZXhPZignLi9sb2cnKSAhPT0gLTEpIHtcbiAgICAgIGhvdEN0eCgnLi9sb2cnKS5zZXRMb2dMZXZlbChsZXZlbCk7XG4gICAgfVxuXG4gICAgc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICB9LFxuICBvdmVybGF5OiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSB2YWx1ZS53YXJuaW5ncztcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZS5lcnJvcnM7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMudXNlUHJvZ3Jlc3MgPSBfcHJvZ3Jlc3M7XG4gICAgfVxuICB9LFxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmIChvcHRpb25zLnVzZVByb2dyZXNzKSB7XG4gICAgICBsb2cuaW5mbyhcIltXRFNdIFwiLmNvbmNhdChkYXRhLnBlcmNlbnQsIFwiJSAtIFwiKS5jb25jYXQoZGF0YS5tc2csIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1Byb2dyZXNzJywgZGF0YSk7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTWVzc2FnZSgnT2snKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICAnY29udGVudC1jaGFuZ2VkJzogZnVuY3Rpb24gY29udGVudENoYW5nZWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIENvbnRlbnQgYmFzZSBjaGFuZ2VkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICBzZWxmLmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9LFxuICB3YXJuaW5nczogZnVuY3Rpb24gd2FybmluZ3MoX3dhcm5pbmdzKSB7XG4gICAgbG9nLndhcm4oJ1tXRFNdIFdhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy4nKTtcblxuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaSh3YXJuaW5nKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdXYXJuaW5ncycsIHN0cmlwcGVkV2FybmluZ3MpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihzdHJpcHBlZFdhcm5pbmdzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfd2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgZXJyb3JzOiBmdW5jdGlvbiBlcnJvcnMoX2Vycm9ycykge1xuICAgIGxvZy5lcnJvcignW1dEU10gRXJyb3JzIHdoaWxlIGNvbXBpbGluZy4gUmVsb2FkIHByZXZlbnRlZC4nKTtcblxuICAgIHZhciBzdHJpcHBlZEVycm9ycyA9IF9lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaShlcnJvcik7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZSgnRXJyb3JzJywgc3RyaXBwZWRFcnJvcnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZEVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHN0cmlwcGVkRXJyb3JzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX2Vycm9ycyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xuICAgIHNlbmRNZXNzYWdlKCdDbG9zZScpO1xuICB9XG59O1xuc29ja2V0KHNvY2tldFVybCwgb25Tb2NrZXRNZXNzYWdlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICovXG5cbi8qIGVzbGludC1kaXNhYmxlXG4gIGNhbWVsY2FzZVxuKi9cbi8vIHRoaXMgU29ja0pTQ2xpZW50IGlzIGhlcmUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLCBpbiBjYXNlIGlubGluZSBtb2RlXG4vLyBpcyBvZmYgb3IgdGhlIGNsaWVudCBpcyBub3QgaW5qZWN0ZWQuIFRoaXMgd2lsbCBiZSBzd2l0Y2hlZCB0b1xuLy8gV2Vic29ja2V0Q2xpZW50IHdoZW4gaXQgYmVjb21lcyB0aGUgZGVmYXVsdFxuLy8gaW1wb3J0YW50OiB0aGUgcGF0aCB0byBTb2NrSlNDbGllbnQgaGVyZSBpcyBtYWRlIHRvIHdvcmsgaW4gdGhlICdjbGllbnQnXG4vLyBkaXJlY3RvcnksIGJ1dCBpcyB1cGRhdGVkIHZpYSB0aGUgd2VicGFjayBjb21waWxhdGlvbiB3aGVuIGNvbXBpbGVkIGZyb21cbi8vIHRoZSAnY2xpZW50LXNyYycgZGlyZWN0b3J5XG5cbnZhciBDbGllbnQgPSB0eXBlb2YgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbnJlcXVpcmUoJy4vY2xpZW50cy9Tb2NrSlNDbGllbnQnKTtcbnZhciByZXRyaWVzID0gMDtcbnZhciBjbGllbnQgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH0pO1xuICBjbGllbnQub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG5cbiAgICBjbGllbnQgPSBudWxsOyAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG5cbiAgICBpZiAocmV0cmllcyA8PSAxMCkge1xuICAgICAgLy8gRXhwb25lbnRpYWxseSBpbmNyZWFzZSB0aW1lb3V0IHRvIHJlY29ubmVjdC5cbiAgICAgIC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnMsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHJldHJ5SW5NcyA9IDEwMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICByZXRyaWVzICs9IDE7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc29ja2V0KHVybCwgaGFuZGxlcnMpO1xuICAgICAgfSwgcmV0cnlJbk1zKTtcbiAgICB9XG4gIH0pO1xuICBjbGllbnQub25NZXNzYWdlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvY2tldDsiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL0Jhc2VDbGllbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlQ2xpZW50KSB7XG4gIF9pbmhlcml0cyhTb2NrSlNDbGllbnQsIF9CYXNlQ2xpZW50KTtcblxuICBmdW5jdGlvbiBTb2NrSlNDbGllbnQodXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTb2NrSlNDbGllbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLnNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgICBfdGhpcy5zb2NrLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7Ly8gVE9ETzogdXNlIGxvZ2dlciB0byBsb2cgdGhlIGVycm9yIGV2ZW50IG9uY2UgY2xpZW50IGFuZCBjbGllbnQtc3JjXG4gICAgICAvLyBhcmUgcmVvcmdhbml6ZWQgdG8gaGF2ZSB0aGUgc2FtZSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrSlNDbGllbnQsIFt7XG4gICAga2V5OiBcIm9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW4oZikge1xuICAgICAgdGhpcy5zb2NrLm9ub3BlbiA9IGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25jbG9zZSA9IGY7XG4gICAgfSAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmKGUuZGF0YSk7XG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZS5yZXNvbHZlKCcuL1NvY2tKU0NsaWVudCcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2NrSlNDbGllbnQ7XG59KEJhc2VDbGllbnQpOyIsIi8qIHNvY2tqcy1jbGllbnQgdjEuNC4wIHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCJqc29uM1wiOjU4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2ZhY2FkZVwiOjcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6MjIsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwOidcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgMDtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gTWF0aC5tYXgodGhpcy5fdGltZW91dCwgKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwKTtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQgJiYgdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuT1BFTjtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgZGVidWcoJ2Nvbm5lY3RlZCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgIC8vIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fY2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uLCB3YXNDbGVhbiwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgdmFyIGZvcmNlRmFpbCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl9pcikge1xuICAgIGZvcmNlRmFpbCA9IHRydWU7XG4gICAgdGhpcy5faXIuY2xvc2UoKTtcbiAgICB0aGlzLl9pciA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFNvY2tKUyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCcpO1xuICB9XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NJTkc7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcblxuICAgIGlmIChmb3JjZUZhaWwpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xuICAgIH1cblxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZS53YXNDbGVhbiA9IHdhc0NsZWFuIHx8IGZhbHNlO1xuICAgIGUuY29kZSA9IGNvZGUgfHwgMTAwMDtcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9LmJpbmQodGhpcyksIDApO1xufTtcblxuLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuLy8gYW5kIFJGQyAyOTg4LlxuU29ja0pTLnByb3RvdHlwZS5jb3VudFJUTyA9IGZ1bmN0aW9uKHJ0dCkge1xuICAvLyBJbiBhIGxvY2FsIGVudmlyb25tZW50LCB3aGVuIHVzaW5nIElFOC85IGFuZCB0aGUgYGpzb25wLXBvbGxpbmdgXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXG4gIC8vIGZyb20gdGhlIG9wZW5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0byB0aGUgY2FsbCBvZiBgX2Rpc3BhdGNoT3BlbmApIGlzXG4gIC8vIGFyb3VuZCAyMDBtc2VjICh0aGUgbG93ZXIgYm91bmQgdXNlZCBpbiB0aGUgYXJ0aWNsZSBhYm92ZSkgYW5kIHRoaXNcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcbiAgLy8gbGFyZ2VyIHRoYW4gdGhhdCB1c2VkIGluIHRoZSBhcnRpY2xlLlxuICBpZiAocnR0ID4gMTAwKSB7XG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcbiAgfVxuICByZXR1cm4gMzAwICsgcnR0OyAvLyAzMDBtc2VjIDwgcnRvIDw9IDQwMG1zZWNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXF1aXJlKCcuL2lmcmFtZS1ib290c3RyYXAnKShTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXR1cm4gU29ja0pTO1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9ldmVudC9jbG9zZVwiOjIsXCIuL2V2ZW50L2V2ZW50XCI6NCxcIi4vZXZlbnQvZXZlbnR0YXJnZXRcIjo1LFwiLi9ldmVudC90cmFucy1tZXNzYWdlXCI6NixcIi4vaWZyYW1lLWJvb3RzdHJhcFwiOjgsXCIuL2luZm8tcmVjZWl2ZXJcIjoxMixcIi4vbG9jYXRpb25cIjoxMyxcIi4vc2hpbXNcIjoxNSxcIi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi91dGlscy9lc2NhcGVcIjo0NSxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvbG9nXCI6NDgsXCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiLi91dGlscy9yYW5kb21cIjo1MCxcIi4vdXRpbHMvdHJhbnNwb3J0XCI6NTEsXCIuL3V0aWxzL3VybFwiOjUyLFwiLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTgsXCJ1cmwtcGFyc2VcIjo2MX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBqc2NzOiBkaXNhYmxlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgRVMzICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KCkpO1xuXG4vLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbi8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG52YXIgZGVmaW5lUHJvcGVydHk7XG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgIH0pO1xuICAgIH07XG59IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xufVxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgaWYgKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHRvT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0KG8pO1xufTtcblxuLy9cbi8vIFV0aWxcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDkuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG5cbmZ1bmN0aW9uIHRvSW50ZWdlcihudW0pIHtcbiAgICB2YXIgbiA9ICtudW07XG4gICAgaWYgKG4gIT09IG4pIHsgLy8gaXNOYU5cbiAgICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICByZXR1cm4geCA+Pj4gMDtcbn1cblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIHZhciBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbi8vIEVTNSAxNS40LjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmRlZmluZVByb3BlcnRpZXMoQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuXG52YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH0sICd4Jyk7XG4gICAgfVxuICAgIHJldHVybiAhIW1ldGhvZCAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxudmFyIHN0cmluZ19zcGxpdCA9IFN0cmluZ1Byb3RvdHlwZS5zcGxpdDtcbmlmIChcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9PSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPT0gNCB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuXG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyAneCcgOiAnJykgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSAgICAgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIHN0cmluZyArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdm9pZCAwID9cbiAgICAgICAgICAgICAgICAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KCcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXG4gIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3dlYnNvY2tldCcpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpKVxuXG4gIC8vIHBvbGxpbmcgdHJhbnNwb3J0c1xuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nJylcbl07XG5cbn0se1wiLi90cmFuc3BvcnQvZXZlbnRzb3VyY2VcIjoyMCxcIi4vdHJhbnNwb3J0L2h0bWxmaWxlXCI6MjEsXCIuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nXCI6MjMsXCIuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXBcIjoyNixcIi4vdHJhbnNwb3J0L3dlYnNvY2tldFwiOjM4LFwiLi90cmFuc3BvcnQveGRyLXBvbGxpbmdcIjozOSxcIi4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmdcIjo0MCxcIi4vdHJhbnNwb3J0L3hoci1wb2xsaW5nXCI6NDEsXCIuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nXCI6NDJ9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG5cbiAgaWYgKCF0aGlzLnhocikge1xuICAgIGRlYnVnKCdubyB4aHInKTtcbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICdubyB4aHIgc3VwcG9ydCcpO1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAvLyB0YWIgZ2V0cyBjbG9zZWQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzUyODBcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgdGhpcy54aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMudGltZW91dCAmJiAndGltZW91dCcgaW4gdGhpcy54aHIpIHtcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWcoJ3hociB0aW1lb3V0Jyk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2V4Y2VwdGlvbicsIGUpO1xuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xuICAgIGRlYnVnKCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAvLyBNb3ppbGxhIGRvY3Mgc2F5cyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9YTUxIdHRwUmVxdWVzdCA6XG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG5cbiAgICB0aGlzLnhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgdmFyIHRleHQsIHN0YXR1cztcbiAgICAgIGRlYnVnKCdyZWFkeVN0YXRlJywgeC5yZWFkeVN0YXRlKTtcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSByZXR1cm5zIHRoaXMgZm9yIGEgYmFkIHBvcnRcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMDA1IHx8IHN0YXR1cyA9PT0gMTIwMjkpIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgc2VsZi54aHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgLy8gSUUgbmVlZHMgdGhpcyBmaWVsZCB0byBiZSBhIGZ1bmN0aW9uXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XG4gIGlmICh0aGlzLnhoci5vbnRpbWVvdXQpIHtcbiAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIVhIUjtcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XG4gIGRlYnVnKCdvdmVycmlkaW5nIHhtbGh0dHByZXF1ZXN0Jyk7XG4gIFhIUiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtheG9dKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xufVxuXG52YXIgY29ycyA9IGZhbHNlO1xudHJ5IHtcbiAgY29ycyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYSFIoKTtcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxufVxuXG5BYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMgPSBjb3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIERyaXZlciA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbmlmIChEcml2ZXIpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBXZWJTb2NrZXRCcm93c2VyRHJpdmVyKHVybCkge1xuXHRcdHJldHVybiBuZXcgRHJpdmVyKHVybCk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9ldmVudHNvdXJjZScsIEV2ZW50U291cmNlUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFFdmVudFNvdXJjZURyaXZlcjtcbn07XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjI5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSHRtbGZpbGVSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvaHRtbGZpbGUnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgO1xuXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xufVxuXG5pbmhlcml0cyhIdG1sRmlsZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG59O1xuXG5IdG1sRmlsZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2h0bWxmaWxlJztcbkh0bWxGaWxlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxGaWxlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjozMCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgZGVidWcoJ21pc21hdGNoZWQgd2luZG93IGlkJywgaWZyYW1lTWVzc2FnZS53aW5kb3dJZCwgdGhpcy53aW5kb3dJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgY2FzZSAncyc6XG4gICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04zLnN0cmluZ2lmeShbXG4gICAgICB2ZXJzaW9uXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxuICAgICwgdGhpcy50cmFuc1VybFxuICAgICwgdGhpcy5iYXNlVXJsXG4gICAgXSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0JzpcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjJzpcbiAgICB2YXIgY2RhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNkYXRhID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XG4gICAgd2luZG93SWQ6IHRoaXMud2luZG93SWRcbiAgLCB0eXBlOiB0eXBlXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xuICB9KSwgdGhpcy5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZSc7XG5JZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi91dGlscy91cmxcIjo1MixcIi4uL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbGliL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiLi9yZWNlaXZlci9qc29ucFwiOjMxLFwiLi9zZW5kZXIvanNvbnBcIjozMyxcImluaGVyaXRzXCI6NTd9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcbn1cblxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgdGhpcy51cmwgPSB1cmw7XG59XG5cbmluaGVyaXRzKEJ1ZmZlcmVkU2VuZGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gIGlmICghdGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFNjaGVkdWxlKCk7XG4gIH1cbn07XG5cbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbi8vIG5ldyBtZXNzYWdlIGlzIGJlaW5nIHNlbmQuIElmIHRoZSBzZW5kaW5nIGNvbm5lY3Rpb24gd2FzIHN0YXJ0ZWRcbi8vIGJlZm9yZSByZWNlaXZpbmcgb25lLCBpdCBpcyBwb3NzaWJsZSB0byBzYXR1cmF0ZSB0aGUgbmV0d29yayBhbmRcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbi8vIHNlbmRpbmcgbWVzc2FnZXMgYnkgc29tZSBzbWFsbCB0aW1lLCBpbiBvcmRlciB0byBsZXQgcmVjZWl2aW5nXG4vLyBjb25uZWN0aW9uIGJlIHN0YXJ0ZWQgYmVmb3JlaGFuZC4gVGhpcyBpcyBvbmx5IGEgaGFsZm1lYXN1cmUgYW5kXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4vLyBzdGFibGUgb24gc2xvdyBuZXR3b3Jrcy5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGVXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRyZWY7XG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnc2VuZFN0b3AnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gIH07XG4gIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgc2VsZi5zZW5kU2NoZWR1bGUoKTtcbiAgfSwgMjUpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlJywgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGlzLnNlbmRCdWZmZXIuam9pbignLCcpICsgJ10nO1xuICAgIHRoaXMuc2VuZFN0b3AgPSB0aGlzLnNlbmRlcih0aGlzLnVybCwgcGF5bG9hZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIH1cbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAodGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFN0b3AoKTtcbiAgICB0aGlzLnNlbmRTdG9wID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xuICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gIH1cblxuICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlmcmFtZUluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoe30sIGluZm8pO1xuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRyYW5zcG9ydC5lbmFibGVkKGlmcmFtZUluZm8pICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gIH07XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS0nICsgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZmFjYWRlVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuLi9pZnJhbWVcIjoyMixcImluaGVyaXRzXCI6NTd9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpwb2xsaW5nJyk7XG59XG5cbmZ1bmN0aW9uIFBvbGxpbmcoUmVjZWl2ZXIsIHJlY2VpdmVVcmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcocmVjZWl2ZVVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gIHRoaXMucmVjZWl2ZVVybCA9IHJlY2VpdmVVcmw7XG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gIHRoaXMuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbn1cblxuaW5oZXJpdHMoUG9sbGluZywgRXZlbnRFbWl0dGVyKTtcblxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY2hlZHVsZVJlY2VpdmVyJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XG5cbiAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcblxuICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ2Nsb3NlJywgY29kZSwgcmVhc29uLCBzZWxmLnBvbGxJc0Nsb3NpbmcpO1xuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuXG4gICAgaWYgKCFzZWxmLnBvbGxJc0Nsb3NpbmcpIHtcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICBzZWxmLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5wb2xsSXNDbG9zaW5nID0gdHJ1ZTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEJ1ZmZlcmVkU2VuZGVyID0gcmVxdWlyZSgnLi9idWZmZXJlZC1zZW5kZXInKVxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIFNlbmRlclJlY2VpdmVyKHRyYW5zVXJsLCB1cmxTdWZmaXgsIHNlbmRlckZ1bmMsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcbiAgZGVidWcocG9sbFVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XG5cbiAgdGhpcy5wb2xsID0gbmV3IFBvbGxpbmcoUmVjZWl2ZXIsIHBvbGxVcmwsIEFqYXhPYmplY3QpO1xuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygncG9sbCBtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcbiAgdGhpcy5wb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ3BvbGwgY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYucG9sbCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcblxuU2VuZGVyUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICAgIHRoaXMucG9sbCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vYnVmZmVyZWQtc2VuZGVyXCI6MjUsXCIuL3BvbGxpbmdcIjoyNyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZXMgPSB0aGlzLmVzID0gbmV3IEV2ZW50U291cmNlRHJpdmVyKHVybCk7XG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGVjb2RlVVJJKGUuZGF0YSkpO1xuICB9O1xuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgIHZhciByZWFzb24gPSAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIHZhciBlcyA9IHRoaXMuZXM7XG4gIGlmIChlcykge1xuICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgIGVzLmNsb3NlKCk7XG4gICAgdGhpcy5lcyA9IG51bGw7XG4gIH1cbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNhZmFyaSBhbmQgY2hyb21lIDwgMTUgY3Jhc2ggaWYgd2UgY2xvc2Ugd2luZG93IGJlZm9yZVxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0sIDIwMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG59XG5cbkh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkIHx8IGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbGZpbGVSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6anNvbnAnKTtcbn1cblxuZnVuY3Rpb24gSnNvbnBSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KScpKTtcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmIChnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICB0aGlzLl9hYm9ydChlcnIpO1xuICB9XG59O1xuXG5Kc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XG4gIHRoaXMuX2NsZWFudXAoKTtcblxuICBpZiAodGhpcy5hYm9ydGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ25ldHdvcmsnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xuICBkZWJ1ZygnX2Fib3J0JywgZXJyKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XG4gICAgdGhpcy5zY3JpcHQyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgIC8vIHRoZSBzY3JpcHQuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NyaXB0RXJyb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lcnJvclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubG9hZGVkT2theSkge1xuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xuICAgIH1cbiAgfSwgSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG5cbiAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XG4gIH07XG5cbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAvLyBVc2UgbG9hZGVkT2theSB0byBkZXRlcm1pbmUgaWYgYWN0dWFsbHkgZXJyb3JlZFxuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcbiAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgLy8gT25lIGNhbid0IHJlbHkgb24gcHJvcGVyIG9yZGVyIGZvciBvbnJlYWR5c3RhdGVjaGFuZ2UuIEluIG9yZGVyIHRvXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAvLyBzY3JpcHQgb2JqZWN0LiBMYXRlciwgb25yZWFkeXN0YXRlY2hhbmdlLCBtYW51YWxseSBleGVjdXRlIHRoaXNcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgLy8gICBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jID09PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXG4gICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xuICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgc2NyaXB0MiA9IHRoaXMuc2NyaXB0MiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgaWYgKHNjcmlwdDIpIHtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOnhocicpO1xufVxuXG5mdW5jdGlvbiBYaHJSZWNlaXZlcih1cmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcblxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLl9jaHVua0hhbmRsZXIoc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLnhvID0gbnVsbDtcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhoclJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICBkZWJ1ZygnX2NodW5rSGFuZGxlcicsIHN0YXR1cyk7XG4gIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKHRoaXMuYnVmZmVyUG9zaXRpb24pO1xuICAgIGlkeCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICBpZiAobXNnKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAodGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcbiAgICB0aGlzLnhvID0gbnVsbDtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjpqc29ucCcpO1xufVxuXG52YXIgZm9ybSwgYXJlYTtcblxuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gIGRlYnVnKCdjcmVhdGVJZnJhbWUnLCBpZCk7XG4gIHRyeSB7XG4gICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCI+Jyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICBkZWJ1ZygnY3JlYXRlRm9ybScpO1xuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICBmb3JtLmFjY2VwdENoYXJzZXQgPSAnVVRGLTgnO1xuXG4gIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgYXJlYS5uYW1lID0gJ2QnO1xuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgaWYgKCFmb3JtKSB7XG4gICAgY3JlYXRlRm9ybSgpO1xuICB9XG4gIHZhciBpZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIGZvcm0udGFyZ2V0ID0gaWQ7XG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuXG4gIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUoaWQpO1xuICBpZnJhbWUuaWQgPSBpZDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB0cnkge1xuICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc2VyaW91c2x5IGJyb2tlbiBicm93c2VycyBnZXQgaGVyZVxuICB9XG4gIGZvcm0uc3VibWl0KCk7XG5cbiAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcbiAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFuaW5nIHVwJywgaWQpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgfSwgNTAwKTtcbiAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgIC8vIGZhaWxlZCB0byBzdWJtaXQgb3VyIGZvcm0uXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGlkLCBpZnJhbWUucmVhZHlTdGF0ZSwgZSk7XG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSQ29yc09iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG59XG5cbmluaGVyaXRzKFhIUkNvcnNPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkNvcnNPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkICYmIFhockRyaXZlci5zdXBwb3J0c0NPUlM7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gIDtcblxuZnVuY3Rpb24gWEhSRmFrZSgvKiBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyAqLykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCAne30nKTtcbiAgfSwgWEhSRmFrZS50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcblxuWEhSRmFrZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudG8pO1xufTtcblxuWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJGYWtlO1xuXG59LHtcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSTG9jYWxPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQgLyosIG9wdHMgKi8pIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcbiAgICBub0NyZWRlbnRpYWxzOiB0cnVlXG4gIH0pO1xufVxuXG5pbmhlcml0cyhYSFJMb2NhbE9iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSTG9jYWxPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIFdlYnNvY2tldERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3dlYnNvY2tldCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcbiAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XG4gIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICB9XG4gIHRoaXMudXJsID0gdXJsO1xuXG4gIHRoaXMud3MgPSBuZXcgV2Vic29ja2V0RHJpdmVyKHRoaXMudXJsLCBbXSwgb3B0aW9ucyk7XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlIGV2ZW50JywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICB9O1xuICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICBzZWxmLndzLmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvciBldmVudCcsIGUpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xufVxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcbiAgdGhpcy53cy5zZW5kKG1zZyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh3cykge1xuICAgIHdzLmNsb3NlKCk7XG4gIH1cbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIGlmICh3cykge1xuICAgIHdzLm9ubWVzc2FnZSA9IHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gbnVsbDtcbiAgfVxuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMud3MgPSBudWxsO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2VuYWJsZWQnKTtcbiAgcmV0dXJuICEhV2Vic29ja2V0RHJpdmVyO1xufTtcbldlYlNvY2tldFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4vLyBub3QgdmVyeSBzdGFibGUgb3ZlciBTU0wuIE1vc3QgbGlrZWx5IGEgd3MgY29ubmVjdGlvbiByZXF1aXJlcyBhXG4vLyBzZXBhcmF0ZSBTU0wgY29ubmVjdGlvbiwgaW4gd2hpY2ggY2FzZSAyIHJvdW5kIHRyaXBzIGFyZSBhblxuLy8gYWJzb2x1dGUgbWludW11bS5cbldlYlNvY2tldFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2RyaXZlci93ZWJzb2NrZXRcIjoxOSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCIuL3hkci1zdHJlYW1pbmdcIjo0MCxcImluaGVyaXRzXCI6NTd9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbi8vIEFjY29yZGluZyB0bzpcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcbi8vICAgaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG5cbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5jb29raWVfbmVlZGVkIHx8IGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gWERST2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lU2NoZW1lO1xufTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCJpbmhlcml0c1wiOjU3fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL29wZXJhL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuLCBpc0tvbnF1ZXJvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9rb25xdWVyb3IvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8vICMxODcgd3JhcCBkb2N1bWVudC5kb21haW4gaW4gdHJ5L2NhdGNoIGJlY2F1c2Ugb2YgV1A4IGZyb20gZmlsZTovLy9cbiwgaGFzRG9tYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04zLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xuICAgICAgZXh0cmFMb29rdXAgPSB1bnJvbGxMb29rdXAoZXh0cmFFc2NhcGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYUVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgIH0pO1xuICB9XG59O1xuXG59LHtcImpzb24zXCI6NTh9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG52YXIgb25VbmxvYWQgPSB7fVxuICAsIGFmdGVyVW5sb2FkID0gZmFsc2VcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcbiAgLCBpc0Nocm9tZVBhY2thZ2VkQXBwID0gZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF0dGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAvLyBBY2NvcmRpbmcgdG86IGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGdldHMgZGVsaXZlcmVkIG9ubHkgdG8gJ2RvY3VtZW50Jywgbm90ICd3aW5kb3cnLlxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgLy8gSSBnZXQgJ3dpbmRvdycgZm9yIGllOC5cbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBpZiAoaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHJhbmRvbS5zdHJpbmcoOCk7XG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xuICAgIGlmIChhZnRlclVubG9hZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MsIDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiwgdW5sb2FkRGVsOiBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cblxuLCB0cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWZ0ZXJVbmxvYWQgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzKCk7XG59O1xuXG4vLyAndW5sb2FkJyBhbG9uZSBpcyBub3QgcmVsaWFibGUgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZSwgYnV0IHdlXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXG5pZiAoIWlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgbW9kdWxlLmV4cG9ydHMuYXR0YWNoRXZlbnQoJ3VubG9hZCcsIHVubG9hZFRyaWdnZXJlZCk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vcmFuZG9tXCI6NTB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV1ByZWZpeDogJ19qcCdcbiwgY3VycmVudFdpbmRvd0lkOiBudWxsXG5cbiwgcG9sbHV0ZUdsb2JhbE5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEobW9kdWxlLmV4cG9ydHMuV1ByZWZpeCBpbiBnbG9iYWwpKSB7XG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcbiAgICB9XG4gIH1cblxuLCBwb3N0TWVzc2FnZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIGlmIChnbG9iYWwucGFyZW50ICE9PSBnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICAgICAgd2luZG93SWQ6IG1vZHVsZS5leHBvcnRzLmN1cnJlbnRXaW5kb3dJZFxuICAgICAgLCB0eXBlOiB0eXBlXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgIH0pLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4sIGNyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3VuYXR0YWNoJyk7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgbWFrZXMgY2hyb21lIGZpcmUgb25iZWZvcmV1bmxvYWQgZXZlbnRcbiAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgIC8vIG9udW5sb2FkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgZXJyKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgLy8gYG9ubG9hZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSBzY3JpcHRzIG9uIHRoZSBpZnJhbWUgYXJlXG4gICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9O1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxuXG4vKiBlc2xpbnQgbm8tdW5kZWY6IFwib2ZmXCIsIG5ldy1jYXA6IFwib2ZmXCIgKi9cbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgIHZhciBkb2MgPSBuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgaWZyYW1lO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1ttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdvYmplY3QnKSAmJiAoIWJyb3dzZXIuaXNLb25xdWVyb3IoKSk7XG59XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vYnJvd3NlclwiOjQ0LFwiLi9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHM7XG5cbiAgdHJ5IHtcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9XG5cbiwgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBjcnlwdG86dHJ1ZSAqL1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyBUaGlzIHN0cmluZyBoYXMgbGVuZ3RoIDMyLCBhIHBvd2VyIG9mIDIsIHNvIHRoZSBtb2R1bHVzIGRvZXNuJ3QgaW50cm9kdWNlIGFcbi8vIGJpYXMuXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmc6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXQucHVzaChfcmFuZG9tU3RyaW5nQ2hhcnMuc3Vic3RyKGJ5dGVzW2ldICUgbWF4LCAxKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH1cblxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICB9XG5cbiwgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbihtYXgpIHtcbiAgICB2YXIgdCA9ICgnJyArIChtYXggLSAxKSkubGVuZ3RoO1xuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XG4gICAgcmV0dXJuIChwICsgdGhpcy5udW1iZXIobWF4KSkuc2xpY2UoLXQpO1xuICB9XG59O1xuXG59LHtcImNyeXB0b1wiOjQzfV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp0cmFuc3BvcnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHJldHVybiB7XG4gICAgZmlsdGVyVG9FbmFibGVkOiBmdW5jdGlvbih0cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKSB7XG4gICAgICB2YXIgdHJhbnNwb3J0cyA9IHtcbiAgICAgICAgbWFpbjogW11cbiAgICAgICwgZmFjYWRlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnRzV2hpdGVsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xuICAgICAgfVxuXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgaWYgKCF0cmFucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy50cmFuc3BvcnROYW1lID09PSAnd2Vic29ja2V0JyAmJiBpbmZvLndlYnNvY2tldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zcG9ydHNXaGl0ZWxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0LmluZGV4T2YodHJhbnMudHJhbnNwb3J0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMuZW5hYmxlZChpbmZvKSkge1xuICAgICAgICAgIGRlYnVnKCdlbmFibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xuICAgICAgICAgIGlmICh0cmFucy5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHMuZmFjYWRlLnB1c2godHJhbnMuZmFjYWRlVHJhbnNwb3J0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gICAgfVxuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTV9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dXJsJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvcnQgPSBwLnBvcnQ7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcbiAgICB9XG5cbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcbiAgfVxuXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5nZXRPcmlnaW4oYSkgPT09IHRoaXMuZ2V0T3JpZ2luKGIpO1xuICAgIGRlYnVnKCdzYW1lJywgYSwgYiwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoYS5zcGxpdCgnOicpWzBdID09PSBiLnNwbGl0KCc6JylbMF0pO1xuICB9XG5cbiwgYWRkUGF0aDogZnVuY3Rpb24gKHVybCwgcGF0aCkge1xuICAgIHZhciBxcyA9IHVybC5zcGxpdCgnPycpO1xuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcbiAgfVxuXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XG4gICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICgnPycgKyBxKSA6ICgnJicgKyBxKSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwidXJsLXBhcnNlXCI6NjF9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9ICcxLjQuMCc7XG5cbn0se31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwtP1xcZD9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cblxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWycjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJywgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLCAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJywgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLCAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JywgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLCAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJywgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ107XG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblxuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXG5cbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCAvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgLy8gSXMgZmlyZWZveCA+PSB2MzE/XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG59XG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTsgLy8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGlmIChtYXRjaCA9PT0gJyVjJykge1xuICAgICAgLy8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICh0eXBlb2YgY29uc29sZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnNvbGUpKSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS5sb2cgJiYgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcblxuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIFN3YWxsb3dcbiAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblxuXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICAvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG4gICAgLy8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG52YXIgZm9ybWF0dGVycyA9IG1vZHVsZS5leHBvcnRzLmZvcm1hdHRlcnM7XG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcbiAgfVxufTtcblxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9jb21tb25cIjo1Nn1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG5cbn0se1wibXNcIjo1NH1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgaWYgKGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgbG9jYXRpb24gPSBnbG9iYWwgJiYgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jYXRpb24gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wicXVlcnlzdHJpbmdpZnlcIjo1OSxcInJlcXVpcmVzLXBvcnRcIjo2MH1dfSx7fSxbMV0pKDEpXG59KTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2NranMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VDbGllbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDbGllbnQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VDbGllbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBuZWVkcyBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlQ2xpZW50O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJyksXG4gICAgQWxsSHRtbEVudGl0aWVzID0gX3JlcXVpcmUuQWxsSHRtbEVudGl0aWVzO1xuXG52YXIgZW50aXRpZXMgPSBuZXcgQWxsSHRtbEVudGl0aWVzKCk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheUlmcmFtZShvbklmcmFtZUxvYWQpIHtcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcbiAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgaWZyYW1lLnN0eWxlLnpJbmRleCA9IDk5OTk5OTk5OTk7XG4gIGlmcmFtZS5vbmxvYWQgPSBvbklmcmFtZUxvYWQ7XG4gIHJldHVybiBpZnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcbiAgdmFyIGRpdiA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2JztcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICBkaXYuc3R5bGUudG9wID0gMDtcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gMDtcbiAgZGl2LnN0eWxlLmJvdHRvbSA9IDA7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC44NSknO1xuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XG4gIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gJ2xhcmdlJztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XG4gIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gJzEuMic7XG4gIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0ZSBpZnJhbWUgYW5kLCB3aGVuIGl0IGlzIHJlYWR5LCBhIGRpdiBpbnNpZGUgaXQuXG5cblxuICBvdmVybGF5SWZyYW1lID0gY3JlYXRlT3ZlcmxheUlmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgb3ZlcmxheURpdiA9IGFkZE92ZXJsYXlEaXZUbyhvdmVybGF5SWZyYW1lKTsgLy8gTm93IHdlIGNhbiB0YWxrIVxuXG4gICAgbGFzdE9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICB9KTsgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXlJZnJhbWUpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBpZiAoIW92ZXJsYXlEaXYpIHtcbiAgICAvLyBJdCBpcyBub3QgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIHJldHVybjtcbiAgfSAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG5cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXlJZnJhbWUpO1xuICBvdmVybGF5RGl2ID0gbnVsbDtcbiAgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG59IC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuXG5cbmZ1bmN0aW9uIHNob3dNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMoZnVuY3Rpb24gKGRpdikge1xuICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNcIi5jb25jYXQoY29sb3JzLnJlZCwgXCJcXFwiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPlwiKS5jb25jYXQoYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2VzWzBdKSkpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsZWFyOiBjbGVhcixcbiAgc2hvd01lc3NhZ2U6IHNob3dNZXNzYWdlXG59OyIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MXG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL1xuXG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLCAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59XG52YXIgX29wZW5UYWdzID0ge1xuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxuICAnMic6ICdvcGFjaXR5OjAuNScsIC8vIGRpbVxuICAnMyc6ICc8aT4nLCAvLyBpdGFsaWNcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxuICAnOCc6ICdkaXNwbGF5Om5vbmUnLCAvLyBoaWRkZW5cbiAgJzknOiAnPGRlbD4nIC8vIGRlbGV0ZVxufVxudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JywgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn1cblxuO1swLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPidcbn0pXG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MICh0ZXh0KSB7XG4gIC8vIFJldHVybnMgdGhlIHRleHQgaWYgdGhlIHN0cmluZyBoYXMgbm8gQU5TSSBlc2NhcGUgY29kZS5cbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspKm0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXVxuICAgIGlmIChvdCkge1xuICAgICAgLy8gSWYgY3VycmVudCBzZXF1ZW5jZSBoYXMgYmVlbiBvcGVuZWQsIGNsb3NlIGl0LlxuICAgICAgaWYgKCEhfmFuc2lDb2Rlcy5pbmRleE9mKHNlcSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3RcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICAgIHJldHVybiAnPC9zcGFuPidcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKVxuICAgICAgcmV0dXJuIG90WzBdID09PSAnPCcgPyBvdCA6ICc8c3BhbiBzdHlsZT1cIicgKyBvdCArICc7XCI+J1xuICAgIH1cblxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXVxuICAgIGlmIChjdCkge1xuICAgICAgLy8gUG9wIHNlcXVlbmNlXG4gICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgIHJldHVybiBjdFxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfSlcblxuICAvLyBNYWtlIHN1cmUgdGFncyBhcmUgY2xvc2VkLlxuICB2YXIgbCA9IGFuc2lDb2Rlcy5sZW5ndGhcbiAgOyhsID4gMCkgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKVxuXG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpXG4gIH1cblxuICB2YXIgX2ZpbmFsQ29sb3JzID0ge31cbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGxcbiAgICBpZiAoIWhleCkge1xuICAgICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhleCkgfHwgaGV4Lmxlbmd0aCA9PT0gMCB8fCBoZXguc29tZShmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnXG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYW4gQXJyYXkgYW5kIGVhY2ggaXRlbSBjb3VsZCBvbmx5IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgaWYgKCFoZXhbMF0pIHtcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF1cbiAgICAgIH1cbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSAxIHx8ICFoZXhbMV0pIHtcbiAgICAgICAgaGV4ID0gW2hleFswXV1cbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pXG4gICAgICB9XG5cbiAgICAgIGhleCA9IGhleC5zbGljZSgwLCAyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgfVxuICAgIF9maW5hbENvbG9yc1trZXldID0gaGV4XG4gIH1cbiAgX3NldFRhZ3MoX2ZpbmFsQ29sb3JzKVxufVxuXG4vKipcbiAqIFJlc2V0IGNvbG9ycy5cbiAqL1xuYW5zaUhUTUwucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIF9zZXRUYWdzKF9kZWZDb2xvcnMpXG59XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fVxuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnb3BlbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9vcGVuVGFncyB9XG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY2xvc2VUYWdzIH1cbiAgfSlcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFnc1xuICBhbnNpSFRNTC50YWdzLmNsb3NlID0gX2Nsb3NlVGFnc1xufVxuXG5mdW5jdGlvbiBfc2V0VGFncyAoY29sb3JzKSB7XG4gIC8vIHJlc2V0IGFsbFxuICBfb3BlblRhZ3NbJzAnXSA9ICdmb250LXdlaWdodDpub3JtYWw7b3BhY2l0eToxO2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzBdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzFdXG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF1cbiAgLy8gZGFyayBncmV5XG4gIF9vcGVuVGFnc1snOTAnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5kYXJrZ3JleVxuXG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV1cbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnXG4gICAgX29wZW5UYWdzW2NvZGVdID0gJ2NvbG9yOiMnICsgb3JpQ29sb3JcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSlcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yXG4gIH1cbn1cblxuYW5zaUhUTUwucmVzZXQoKVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeG1sX2VudGl0aWVzXzEgPSByZXF1aXJlKFwiLi94bWwtZW50aXRpZXNcIik7XG5leHBvcnRzLlhtbEVudGl0aWVzID0geG1sX2VudGl0aWVzXzEuWG1sRW50aXRpZXM7XG52YXIgaHRtbDRfZW50aXRpZXNfMSA9IHJlcXVpcmUoXCIuL2h0bWw0LWVudGl0aWVzXCIpO1xuZXhwb3J0cy5IdG1sNEVudGl0aWVzID0gaHRtbDRfZW50aXRpZXNfMS5IdG1sNEVudGl0aWVzO1xudmFyIGh0bWw1X2VudGl0aWVzXzEgPSByZXF1aXJlKFwiLi9odG1sNS1lbnRpdGllc1wiKTtcbmV4cG9ydHMuSHRtbDVFbnRpdGllcyA9IGh0bWw1X2VudGl0aWVzXzEuSHRtbDVFbnRpdGllcztcbmV4cG9ydHMuQWxsSHRtbEVudGl0aWVzID0gaHRtbDVfZW50aXRpZXNfMS5IdG1sNUVudGl0aWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQUxQSEFfSU5ERVggPSB7XG4gICAgJyZsdCc6ICc8JyxcbiAgICAnJmd0JzogJz4nLFxuICAgICcmcXVvdCc6ICdcIicsXG4gICAgJyZhcG9zJzogJ1xcJycsXG4gICAgJyZhbXAnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhcG9zOyc6ICdcXCcnLFxuICAgICcmYW1wOyc6ICcmJ1xufTtcbnZhciBDSEFSX0lOREVYID0ge1xuICAgIDYwOiAnbHQnLFxuICAgIDYyOiAnZ3QnLFxuICAgIDM0OiAncXVvdCcsXG4gICAgMzk6ICdhcG9zJyxcbiAgICAzODogJ2FtcCdcbn07XG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG52YXIgWG1sRW50aXRpZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG1sRW50aXRpZXMoKSB7XG4gICAgfVxuICAgIFhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bPD5cIicmXS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgaWYgKHMuY2hhckF0KDEpID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigyKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IENIQVJfSU5ERVhbY107XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ2h0ID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sRW50aXRpZXM7XG59KCkpO1xuZXhwb3J0cy5YbWxFbnRpdGllcyA9IFhtbEVudGl0aWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FlbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICAgICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIG51bUluZGV4W2NdID0gYTtcbiAgICAgICAgaSsrO1xuICAgIH1cbn0pKCk7XG52YXIgSHRtbDRFbnRpdGllcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge1xuICAgIH1cbiAgICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgICAgICAgIHZhciBjaHI7XG4gICAgICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICByZXN1bHQgKz0gYWxwaGEgPyBcIiZcIiArIGFscGhhICsgXCI7XCIgOiBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDRFbnRpdGllcztcbn0oKSk7XG5leHBvcnRzLkh0bWw0RW50aXRpZXMgPSBIdG1sNEVudGl0aWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG52YXIgSHRtbDVFbnRpdGllcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge1xuICAgIH1cbiAgICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgICAgICAgIHZhciBjaHI7XG4gICAgICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sNUVudGl0aWVzO1xufSgpKTtcbmV4cG9ydHMuSHRtbDVFbnRpdGllcyA9IEh0bWw1RW50aXRpZXM7XG5mdW5jdGlvbiBjcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciBpID0gRU5USVRJRVMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGUgPSBFTlRJVElFU1tpXTtcbiAgICAgICAgdmFyIGFscGhhID0gZVswXTtcbiAgICAgICAgdmFyIGNoYXJzID0gZVsxXTtcbiAgICAgICAgdmFyIGNociA9IGNoYXJzWzBdO1xuICAgICAgICB2YXIgYWRkQ2hhciA9IChjaHIgPCAzMiB8fCBjaHIgPiAxMjYpIHx8IGNociA9PT0gNjIgfHwgY2hyID09PSA2MCB8fCBjaHIgPT09IDM4IHx8IGNociA9PT0gMzQgfHwgY2hyID09PSAzOTtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gdm9pZCAwO1xuICAgICAgICBpZiAoYWRkQ2hhcikge1xuICAgICAgICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyc1sxXSkge1xuICAgICAgICAgICAgdmFyIGNocjIgPSBjaGFyc1sxXTtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgICAgIGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICBhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XG5cbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBUUkFDRSA9ICd0cmFjZSc7XG52YXIgU0lMRU5UID0gJ3NpbGVudCc7IC8vIGRlcHJlY2F0ZWRcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBhdCBtYWpvciByZWxlYXNlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMTgyNVxuXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIElORk86XG4gICAgY2FzZSBXQVJOOlxuICAgIGNhc2UgRVJST1I6XG4gICAgY2FzZSBERUJVRzpcbiAgICBjYXNlIFRSQUNFOlxuICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgV0FSTklORzpcbiAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgbG9nLnNldExldmVsKCd3YXJuJyk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIE5PTkU6XG4gICAgY2FzZSBTSUxFTlQ6XG4gICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbG9nLmVycm9yKFwiW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCAnXCIuY29uY2F0KGxldmVsLCBcIidcIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsXG59OyIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRNc2c7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2c7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBfcmVmMikge1xuICB2YXIgaG90UmVsb2FkID0gX3JlZi5ob3RSZWxvYWQsXG4gICAgICBob3QgPSBfcmVmLmhvdCxcbiAgICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG4gIHZhciBpc1VubG9hZGluZyA9IF9yZWYyLmlzVW5sb2FkaW5nLFxuICAgICAgY3VycmVudEhhc2ggPSBfcmVmMi5jdXJyZW50SGFzaDtcblxuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcblxuICAgIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZSgnd2VicGFjay9ob3QvZW1pdHRlcicpO1xuXG4gICAgaG90RW1pdHRlci5lbWl0KCd3ZWJwYWNrSG90VXBkYXRlJywgY3VycmVudEhhc2gpO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXCJ3ZWJwYWNrSG90VXBkYXRlXCIuY29uY2F0KGN1cnJlbnRIYXNoKSwgJyonKTtcbiAgICB9XG4gIH0gLy8gYWxsb3cgcmVmcmVzaGluZyB0aGUgcGFnZSBvbmx5IGlmIGxpdmVSZWxvYWQgaXNuJ3QgZGlzYWJsZWRcbiAgZWxzZSBpZiAobGl2ZVJlbG9hZCkge1xuICAgICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmOyAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcblxuICAgICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xuXG4gICAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgICAvLyBpZiBwYXJlbnQgZXF1YWxzIGN1cnJlbnQgd2luZG93IHdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3Qgd2hpY2ggd291bGQgY29udGludWUgZm9yZXZlciwgc28gdHJpZ2dlciBhIHJlbG9hZCBhbnl3YXlzXG4gICAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWxvYWRBcHA7IiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIHNlbGYgKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSA9IHJlcXVpcmUoJy4vZ2V0Q3VycmVudFNjcmlwdFNvdXJjZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVTb2NrZXRVcmwocmVzb3VyY2VRdWVyeSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciB1cmxQYXJ0cztcblxuICBpZiAodHlwZW9mIHJlc291cmNlUXVlcnkgPT09ICdzdHJpbmcnICYmIHJlc291cmNlUXVlcnkgIT09ICcnKSB7XG4gICAgLy8gSWYgdGhpcyBidW5kbGUgaXMgaW5saW5lZCwgdXNlIHRoZSByZXNvdXJjZSBxdWVyeSB0byBnZXQgdGhlIGNvcnJlY3QgdXJsLlxuICAgIC8vIGZvcm1hdCBpcyBsaWtlIGA/aHR0cDovLzAuMC4wLjA6ODA5NiZzb2NrUG9ydD04MDk3JnNvY2tIb3N0PWxvY2FsaG9zdGBcbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShyZXNvdXJjZVF1ZXJ5IC8vIHN0cmlwIGxlYWRpbmcgYD9gIGZyb20gcXVlcnkgc3RyaW5nIHRvIGdldCBhIHZhbGlkIFVSTFxuICAgIC5zdWJzdHIoMSkgLy8gcmVwbGFjZSBmaXJzdCBgJmAgd2l0aCBgP2AgdG8gaGF2ZSBhIHZhbGlkIHF1ZXJ5IHN0cmluZ1xuICAgIC5yZXBsYWNlKCcmJywgJz8nKSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICB2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShzY3JpcHRIb3N0IHx8ICcvJywgdHJ1ZSwgdHJ1ZSk7XG4gIH0gLy8gVXNlIHBhcmFtZXRlciB0byBhbGxvdyBwYXNzaW5nIGxvY2F0aW9uIGluIHVuaXQgdGVzdHNcblxuXG4gIGlmICh0eXBlb2YgY3VycmVudExvY2F0aW9uID09PSAnc3RyaW5nJyAmJiBjdXJyZW50TG9jYXRpb24gIT09ICcnKSB7XG4gICAgY3VycmVudExvY2F0aW9uID0gdXJsLnBhcnNlKGN1cnJlbnRMb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudExvY2F0aW9uID0gc2VsZi5sb2NhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBnZXRTb2NrZXRVcmwodXJsUGFydHMsIGN1cnJlbnRMb2NhdGlvbik7XG59XG4vKlxuICogR2V0cyBzb2NrZXQgVVJMIGJhc2VkIG9uIFNjcmlwdCBTb3VyY2UvTG9jYXRpb25cbiAqIChzY3JpcHRTcmM6IFVSTCwgbG9jYXRpb246IFVSTCkgLT4gVVJMXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTb2NrZXRVcmwodXJsUGFydHMsIGxvYykge1xuICB2YXIgYXV0aCA9IHVybFBhcnRzLmF1dGgsXG4gICAgICBxdWVyeSA9IHVybFBhcnRzLnF1ZXJ5O1xuICB2YXIgaG9zdG5hbWUgPSB1cmxQYXJ0cy5ob3N0bmFtZSxcbiAgICAgIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2wsXG4gICAgICBwb3J0ID0gdXJsUGFydHMucG9ydDtcblxuICBpZiAoIXBvcnQgfHwgcG9ydCA9PT0gJzAnKSB7XG4gICAgcG9ydCA9IGxvYy5wb3J0O1xuICB9IC8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcbiAgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcblxuXG4gIGlmICgoaG9zdG5hbWUgPT09ICcwLjAuMC4wJyB8fCBob3N0bmFtZSA9PT0gJzo6JykgJiYgbG9jLmhvc3RuYW1lICYmIGxvYy5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IDApIHtcbiAgICBob3N0bmFtZSA9IGxvYy5ob3N0bmFtZTtcbiAgfSAvLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXG4gIC8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuICAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnlcbiAgLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXG5cblxuICBpZiAoaG9zdG5hbWUgJiYgaG9zdG5hbWUgIT09ICcxMjcuMC4wLjEnICYmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonIHx8IHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpKSB7XG4gICAgcHJvdG9jb2wgPSBsb2MucHJvdG9jb2w7XG4gIH0gLy8gYWxsIG9mIHRoZXNlIHNvY2sgdXJsIHBhcmFtcyBhcmUgb3B0aW9uYWxseSBwYXNzZWQgaW4gdGhyb3VnaFxuICAvLyByZXNvdXJjZVF1ZXJ5LCBzbyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBpZlxuICAvLyB0aGV5IGFyZSBub3QgcHJvdmlkZWRcblxuXG4gIHZhciBzb2NrSG9zdCA9IHF1ZXJ5LnNvY2tIb3N0IHx8IGhvc3RuYW1lO1xuICB2YXIgc29ja1BhdGggPSBxdWVyeS5zb2NrUGF0aCB8fCAnL3NvY2tqcy1ub2RlJztcbiAgdmFyIHNvY2tQb3J0ID0gcXVlcnkuc29ja1BvcnQgfHwgcG9ydDtcblxuICBpZiAoc29ja1BvcnQgPT09ICdsb2NhdGlvbicpIHtcbiAgICBzb2NrUG9ydCA9IGxvYy5wb3J0O1xuICB9XG5cbiAgcmV0dXJuIHVybC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBhdXRoOiBhdXRoLFxuICAgIGhvc3RuYW1lOiBzb2NrSG9zdCxcbiAgICBwb3J0OiBzb2NrUG9ydCxcbiAgICAvLyBJZiBzb2NrUGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgICAvLyBxdWVyeSBwYXJhbSBzbyBpdCBoYXMgdG8gYmUgcGFyc2VkIG91dCBvZiB0aGUgcXVlcnlzdHJpbmcgaW4gb3JkZXIgZm9yIHRoZVxuICAgIC8vIGNsaWVudCB0byBvcGVuIHRoZSBzb2NrZXQgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gICAgcGF0aG5hbWU6IHNvY2tQYXRoXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNvY2tldFVybDsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG5cblxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlOyIsInZhciBtYXAgPSB7XG5cdFwiLi9sb2dcIjogMzFcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzMDsiLCJ2YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcblx0dmFyIHNob3VsZExvZyA9XG5cdFx0KGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XG5cdHJldHVybiBzaG91bGRMb2c7XG59XG5cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG5cdHJldHVybiBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdGxvZ0ZuKG1zZyk7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwid2FybmluZ1wiKSB7XG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IobXNnKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XG52YXIgZ3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kIHx8IGR1bW15O1xuLyogZXNsaW50LWVuYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cblxubW9kdWxlLmV4cG9ydHMuZ3JvdXAgPSBsb2dHcm91cChncm91cCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcblxubW9kdWxlLmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbihsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0dmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblx0dmFyIHN0YWNrID0gZXJyLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH0gZWxzZSBpZiAoc3RhY2suaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcblx0XHRyZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gc3RhY2s7XG5cdH1cbn07XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2JpbGxib2FyZC5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyotLSBDaGFydCAtLSovXFxuLmJiIHN2ZyB7XFxuICBmb250OiAxMHB4IHNhbnMtc2VyaWY7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7IH1cXG5cXG4uYmIgcGF0aCwgLmJiIGxpbmUge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzAwMDsgfVxcblxcbi5iYiB0ZXh0LCAuYmIgLmJiLWJ1dHRvbiB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLWxlZ2VuZC1pdGVtLXRpbGUsXFxuLmJiLXhncmlkLWZvY3VzLFxcbi5iYi15Z3JpZC1mb2N1cyxcXG4uYmIteWdyaWQsXFxuLmJiLWV2ZW50LXJlY3QsXFxuLmJiLWJhcnMgcGF0aCB7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7IH1cXG5cXG4uYmItY2hhcnQtYXJjIC5iYi1nYXVnZS12YWx1ZSB7XFxuICBmaWxsOiAjMDAwOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyBwYXRoIHtcXG4gIHN0cm9rZTogI2ZmZjsgfVxcblxcbi5iYi1jaGFydC1hcmMgcmVjdCB7XFxuICBzdHJva2U6ICNmZmY7XFxuICBzdHJva2Utd2lkdGg6IDE7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHRleHQge1xcbiAgZmlsbDogI2ZmZjtcXG4gIGZvbnQtc2l6ZTogMTNweDsgfVxcblxcbi8qLS0gQXhpcyAtLSovXFxuLmJiLWF4aXMge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLyotLSBHcmlkIC0tKi9cXG4uYmItZ3JpZCBsaW5lIHtcXG4gIHN0cm9rZTogI2FhYTsgfVxcblxcbi5iYi1ncmlkIHRleHQge1xcbiAgZmlsbDogI2FhYTsgfVxcblxcbi5iYi14Z3JpZCwgLmJiLXlncmlkIHtcXG4gIHN0cm9rZS1kYXNoYXJyYXk6IDMgMzsgfVxcblxcbi8qLS0gVGV4dCBvbiBDaGFydCAtLSovXFxuLmJiLXRleHQuYmItZW1wdHkge1xcbiAgZmlsbDogIzgwODA4MDtcXG4gIGZvbnQtc2l6ZTogMmVtOyB9XFxuXFxuLyotLSBMaW5lIC0tKi9cXG4uYmItbGluZSB7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gUG9pbnQgLS0qL1xcbi5iYi1jaXJjbGUuX2V4cGFuZGVkXyB7XFxuICBzdHJva2Utd2lkdGg6IDFweDtcXG4gIHN0cm9rZTogd2hpdGU7IH1cXG5cXG4uYmItc2VsZWN0ZWQtY2lyY2xlIHtcXG4gIGZpbGw6IHdoaXRlO1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4vKi0tIEJhciAtLSovXFxuLmJiLWJhciB7XFxuICBzdHJva2Utd2lkdGg6IDA7IH1cXG4gIC5iYi1iYXIuX2V4cGFuZGVkXyB7XFxuICAgIGZpbGwtb3BhY2l0eTogMC43NTsgfVxcblxcbi8qLS0gRm9jdXMgLS0qL1xcbi5iYi10YXJnZXQuYmItZm9jdXNlZCwgLmJiLWNpcmNsZXMuYmItZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAxOyB9XFxuXFxuLmJiLXRhcmdldC5iYi1mb2N1c2VkIHBhdGguYmItbGluZSwgLmJiLXRhcmdldC5iYi1mb2N1c2VkIHBhdGguYmItc3RlcCwgLmJiLWNpcmNsZXMuYmItZm9jdXNlZCBwYXRoLmJiLWxpbmUsIC5iYi1jaXJjbGVzLmJiLWZvY3VzZWQgcGF0aC5iYi1zdGVwIHtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQsIC5iYi1jaXJjbGVzLmJiLWRlZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAwLjMgIWltcG9ydGFudDsgfVxcbiAgLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQgLnRleHQtb3ZlcmxhcHBpbmcsIC5iYi1jaXJjbGVzLmJiLWRlZm9jdXNlZCAudGV4dC1vdmVybGFwcGluZyB7XFxuICAgIG9wYWNpdHk6IC4wNSAhaW1wb3J0YW50OyB9XFxuXFxuLyotLSBSZWdpb24gLS0qL1xcbi5iYi1yZWdpb24ge1xcbiAgZmlsbDogc3RlZWxibHVlO1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gWm9vbSByZWdpb24gLS0qL1xcbi5iYi16b29tLWJydXNoIHtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIEJydXNoIC0tKi9cXG4uYmItYnJ1c2ggLmV4dGVudCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBTZWxlY3QgLSBEcmFnIC0tKi9cXG4vKi0tIExlZ2VuZCAtLSovXFxuLmJiLWxlZ2VuZC1pdGVtIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLWxlZ2VuZC1pdGVtLWhpZGRlbiB7XFxuICBvcGFjaXR5OiAwLjE1OyB9XFxuXFxuLmJiLWxlZ2VuZC1iYWNrZ3JvdW5kIHtcXG4gIG9wYWNpdHk6IDAuNzU7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZTogbGlnaHRncmF5O1xcbiAgc3Ryb2tlLXdpZHRoOiAxOyB9XFxuXFxuLyotLSBUaXRsZSAtLSovXFxuLmJiLXRpdGxlIHtcXG4gIGZvbnQ6IDE0cHggc2Fucy1zZXJpZjsgfVxcblxcbi8qLS0gVG9vbHRpcCAtLSovXFxuLmJiLXRvb2x0aXAtY29udGFpbmVyIHtcXG4gIHotaW5kZXg6IDEwO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItdG9vbHRpcCB7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgZW1wdHktY2VsbHM6IHNob3c7XFxuICBvcGFjaXR5OiAwLjk7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7XFxuICAtbW96LWJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7XFxuICBib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3OyB9XFxuICAuYmItdG9vbHRpcCB0ciB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNDQ0M7IH1cXG4gIC5iYi10b29sdGlwIHRoIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2FhYTtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBwYWRkaW5nOiAycHggNXB4O1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBjb2xvcjogI0ZGRjsgfVxcbiAgLmJiLXRvb2x0aXAgdGQge1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIHBhZGRpbmc6IDNweCA2cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZG90dGVkICM5OTk7IH1cXG4gICAgLmJiLXRvb2x0aXAgdGQgPiBzcGFuLCAuYmItdG9vbHRpcCB0ZCA+IHN2ZyB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgIGhlaWdodDogMTBweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDZweDsgfVxcbiAgLmJiLXRvb2x0aXAudmFsdWUge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgfVxcblxcbi8qLS0gQXJlYSAtLSovXFxuLmJiLWFyZWEge1xcbiAgc3Ryb2tlLXdpZHRoOiAwO1xcbiAgb3BhY2l0eTogMC4yOyB9XFxuXFxuLyotLSBBcmMgLS0qL1xcbi5iYi1jaGFydC1hcmNzLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDEuM2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdGl0bGUge1xcbiAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXG4gIGZvbnQtc2l6ZTogMi43ZW07IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1iYWNrZ3JvdW5kIHtcXG4gIGZpbGw6ICNlMGUwZTA7XFxuICBzdHJva2U6ICNmZmY7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS11bml0IHtcXG4gIGZpbGw6ICMwMDA7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1tYXgge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLW1pbiB7XFxuICBmaWxsOiAjNzc3OyB9XFxuXFxuLyotLSBSYWRhciAtLSovXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItbGV2ZWxzIHBvbHlnb24ge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyB0ZXh0IHtcXG4gIGZpbGw6ICM4NDgyODI7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1heGlzIGxpbmUge1xcbiAgc3Ryb2tlOiAjODQ4MjgyO1xcbiAgc3Ryb2tlLXdpZHRoOiAuNXB4OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyB0ZXh0IHtcXG4gIGZvbnQtc2l6ZTogMS4xNWVtO1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItc2hhcGVzIHBvbHlnb24ge1xcbiAgZmlsbC1vcGFjaXR5OiAuMjtcXG4gIHN0cm9rZS13aWR0aDogMXB4OyB9XFxuXFxuLyotLSBCdXR0b24gLS0qL1xcbi5iYi1idXR0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxMHB4O1xcbiAgcmlnaHQ6IDEwcHg7IH1cXG4gIC5iYi1idXR0b24gLmJiLXpvb20tcmVzZXQge1xcbiAgICBmb250LXNpemU6IDExcHg7XFxuICAgIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zNl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzdfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDBfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQxX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Ml9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ0X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDZfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180OF9fOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIENTUyBjbGFzcyBuYW1lcyBkZWZpbml0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0YXJjOiBcImJiLWFyY1wiLFxyXG5cdGFyY0xhYmVsTGluZTogXCJiYi1hcmMtbGFiZWwtbGluZVwiLFxyXG5cdGFyY3M6IFwiYmItYXJjc1wiLFxyXG5cdGFyZWE6IFwiYmItYXJlYVwiLFxyXG5cdGFyZWFzOiBcImJiLWFyZWFzXCIsXHJcblx0YXhpczogXCJiYi1heGlzXCIsXHJcblx0YXhpc1g6IFwiYmItYXhpcy14XCIsXHJcblx0YXhpc1hMYWJlbDogXCJiYi1heGlzLXgtbGFiZWxcIixcclxuXHRheGlzWTogXCJiYi1heGlzLXlcIixcclxuXHRheGlzWTI6IFwiYmItYXhpcy15MlwiLFxyXG5cdGF4aXNZMkxhYmVsOiBcImJiLWF4aXMteTItbGFiZWxcIixcclxuXHRheGlzWUxhYmVsOiBcImJiLWF4aXMteS1sYWJlbFwiLFxyXG5cdGJhcjogXCJiYi1iYXJcIixcclxuXHRiYXJzOiBcImJiLWJhcnNcIixcclxuXHRicnVzaDogXCJiYi1icnVzaFwiLFxyXG5cdGJ1dHRvbjogXCJiYi1idXR0b25cIixcclxuXHRidXR0b25ab29tUmVzZXQ6IFwiYmItem9vbS1yZXNldFwiLFxyXG5cdGNoYXJ0OiBcImJiLWNoYXJ0XCIsXHJcblx0Y2hhcnRBcmM6IFwiYmItY2hhcnQtYXJjXCIsXHJcblx0Y2hhcnRBcmNzOiBcImJiLWNoYXJ0LWFyY3NcIixcclxuXHRjaGFydEFyY3NCYWNrZ3JvdW5kOiBcImJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZFwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlTWF4OiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4XCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VNaW46IFwiYmItY2hhcnQtYXJjcy1nYXVnZS1taW5cIixcclxuXHRjaGFydEFyY3NHYXVnZVVuaXQ6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS11bml0XCIsXHJcblx0Y2hhcnRBcmNzVGl0bGU6IFwiYmItY2hhcnQtYXJjcy10aXRsZVwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlVGl0bGU6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS10aXRsZVwiLFxyXG5cdGNoYXJ0QmFyOiBcImJiLWNoYXJ0LWJhclwiLFxyXG5cdGNoYXJ0QmFyczogXCJiYi1jaGFydC1iYXJzXCIsXHJcblx0Y2hhcnRDaXJjbGVzOiBcImJiLWNoYXJ0LWNpcmNsZXNcIixcclxuXHRjaGFydExpbmU6IFwiYmItY2hhcnQtbGluZVwiLFxyXG5cdGNoYXJ0TGluZXM6IFwiYmItY2hhcnQtbGluZXNcIixcclxuXHRjaGFydFJhZGFyOiBcImJiLWNoYXJ0LXJhZGFyXCIsXHJcblx0Y2hhcnRSYWRhcnM6IFwiYmItY2hhcnQtcmFkYXJzXCIsXHJcblx0Y2hhcnRUZXh0OiBcImJiLWNoYXJ0LXRleHRcIixcclxuXHRjaGFydFRleHRzOiBcImJiLWNoYXJ0LXRleHRzXCIsXHJcblx0Y2lyY2xlOiBcImJiLWNpcmNsZVwiLFxyXG5cdGNpcmNsZXM6IFwiYmItY2lyY2xlc1wiLFxyXG5cdGNvbG9yUGF0dGVybjogXCJiYi1jb2xvci1wYXR0ZXJuXCIsXHJcblx0Y29sb3JTY2FsZTogXCJiYi1jb2xvcnNjYWxlXCIsXHJcblx0ZGVmb2N1c2VkOiBcImJiLWRlZm9jdXNlZFwiLFxyXG5cdGRyYWdhcmVhOiBcImJiLWRyYWdhcmVhXCIsXHJcblx0ZW1wdHk6IFwiYmItZW1wdHlcIixcclxuXHRldmVudFJlY3Q6IFwiYmItZXZlbnQtcmVjdFwiLFxyXG5cdGV2ZW50UmVjdHM6IFwiYmItZXZlbnQtcmVjdHNcIixcclxuXHRldmVudFJlY3RzTXVsdGlwbGU6IFwiYmItZXZlbnQtcmVjdHMtbXVsdGlwbGVcIixcclxuXHRldmVudFJlY3RzU2luZ2xlOiBcImJiLWV2ZW50LXJlY3RzLXNpbmdsZVwiLFxyXG5cdGZvY3VzZWQ6IFwiYmItZm9jdXNlZFwiLFxyXG5cdGdhdWdlVmFsdWU6IFwiYmItZ2F1Z2UtdmFsdWVcIixcclxuXHRncmlkOiBcImJiLWdyaWRcIixcclxuXHRncmlkTGluZXM6IFwiYmItZ3JpZC1saW5lc1wiLFxyXG5cdGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcclxuXHRsZWdlbmRJdGVtOiBcImJiLWxlZ2VuZC1pdGVtXCIsXHJcblx0bGVnZW5kSXRlbUV2ZW50OiBcImJiLWxlZ2VuZC1pdGVtLWV2ZW50XCIsXHJcblx0bGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxyXG5cdGxlZ2VuZEl0ZW1IaWRkZW46IFwiYmItbGVnZW5kLWl0ZW0taGlkZGVuXCIsXHJcblx0bGVnZW5kSXRlbVBvaW50OiBcImJiLWxlZ2VuZC1pdGVtLXBvaW50XCIsXHJcblx0bGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxyXG5cdGxldmVsOiBcImJiLWxldmVsXCIsXHJcblx0bGV2ZWxzOiBcImJiLWxldmVsc1wiLFxyXG5cdGxpbmU6IFwiYmItbGluZVwiLFxyXG5cdGxpbmVzOiBcImJiLWxpbmVzXCIsXHJcblx0cmVnaW9uOiBcImJiLXJlZ2lvblwiLFxyXG5cdHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlOiBcImJiLXNlbGVjdGVkLWNpcmNsZVwiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlczogXCJiYi1zZWxlY3RlZC1jaXJjbGVzXCIsXHJcblx0c2hhcGU6IFwiYmItc2hhcGVcIixcclxuXHRzaGFwZXM6IFwiYmItc2hhcGVzXCIsXHJcblx0c3RhbmZvcmRFbGVtZW50czogXCJiYi1zdGFuZm9yZC1lbGVtZW50c1wiLFxyXG5cdHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXHJcblx0c3RhbmZvcmRMaW5lczogXCJiYi1zdGFuZm9yZC1saW5lc1wiLFxyXG5cdHN0YW5mb3JkUmVnaW9uOiBcImJiLXN0YW5mb3JkLXJlZ2lvblwiLFxyXG5cdHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXHJcblx0dGFyZ2V0OiBcImJiLXRhcmdldFwiLFxyXG5cdHRleHQ6IFwiYmItdGV4dFwiLFxyXG5cdHRleHRzOiBcImJiLXRleHRzXCIsXHJcblx0dGl0bGU6IFwiYmItdGl0bGVcIixcclxuXHR0b29sdGlwOiBcImJiLXRvb2x0aXBcIixcclxuXHR0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXHJcblx0dG9vbHRpcE5hbWU6IFwiYmItdG9vbHRpcC1uYW1lXCIsXHJcblx0eGdyaWQ6IFwiYmIteGdyaWRcIixcclxuXHR4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXHJcblx0eGdyaWRMaW5lOiBcImJiLXhncmlkLWxpbmVcIixcclxuXHR4Z3JpZExpbmVzOiBcImJiLXhncmlkLWxpbmVzXCIsXHJcblx0eGdyaWRzOiBcImJiLXhncmlkc1wiLFxyXG5cdHlncmlkOiBcImJiLXlncmlkXCIsXHJcblx0eWdyaWRGb2N1czogXCJiYi15Z3JpZC1mb2N1c1wiLFxyXG5cdHlncmlkTGluZTogXCJiYi15Z3JpZC1saW5lXCIsXHJcblx0eWdyaWRMaW5lczogXCJiYi15Z3JpZC1saW5lc1wiLFxyXG5cdHlncmlkczogXCJiYi15Z3JpZHNcIixcclxuXHR6b29tQnJ1c2g6IFwiYmItem9vbS1icnVzaFwiLFxyXG5cdHpvb21SZWN0OiBcImJiLXpvb20tcmVjdFwiLFxyXG5cdEVYUEFOREVEOiBcIl9leHBhbmRlZF9cIixcclxuXHRTRUxFQ1RFRDogXCJfc2VsZWN0ZWRfXCIsXHJcblx0SU5DTFVERUQ6IFwiX2luY2x1ZGVkX1wiLFxyXG5cdFRleHRPdmVybGFwcGluZzogXCJ0ZXh0LW92ZXJsYXBwaW5nXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbnR5cGUgVCA9IGQzU2VsZWN0aW9uIHwgbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBFbGVtZW50cyBjbGFzcy5cclxuICogQGNsYXNzIEVsZW1lbnRzXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0Y29uc3QgZWxlbWVudDoge1xyXG5cdFx0XHRba2V5OiBzdHJpbmddOiBUIHwge1trZXk6IHN0cmluZ106IFR9XHJcblx0XHR9ID0ge1xyXG5cdFx0XHRjaGFydDogbnVsbCxcclxuXHRcdFx0bWFpbjogbnVsbCxcclxuXHRcdFx0c3ZnOiBudWxsLFxyXG5cdFx0XHRheGlzOiB7IC8vIGF4ZXNcclxuXHRcdFx0XHR4OiBudWxsLFxyXG5cdFx0XHRcdHk6IG51bGwsXHJcblx0XHRcdFx0eTI6IG51bGwsXHJcblx0XHRcdFx0c3ViWDogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRkZWZzOiBudWxsLFxyXG5cdFx0XHR0b29sdGlwOiBudWxsLFxyXG5cdFx0XHRsZWdlbmQ6IG51bGwsXHJcblx0XHRcdHRpdGxlOiBudWxsLFxyXG5cdFx0XHRzdWJjaGFydDoge1xyXG5cdFx0XHRcdG1haW46IG51bGwsIC8vICQkLmNvbnRleHRcclxuXHRcdFx0XHRiYXI6IG51bGwsIC8vICQkLmNvbnRleHRCYXJcclxuXHRcdFx0XHRsaW5lOiBudWxsLCAvLyAkJC5jb250ZXh0TGluZVxyXG5cdFx0XHRcdGFyZWE6IG51bGwgLy8gJCQuY29udGV4dEFyZWFcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGFyY3M6IG51bGwsXHJcblx0XHRcdGJhcjogbnVsbCwgLy8gbWFpbkJhcixcclxuXHRcdFx0bGluZTogbnVsbCwgLy8gbWFpbkxpbmUsXHJcblx0XHRcdGFyZWE6IG51bGwsIC8vIG1haW5BcmVhLFxyXG5cdFx0XHRjaXJjbGU6IG51bGwsIC8vIG1haW5DaXJjbGUsXHJcblx0XHRcdHJhZGFyczogbnVsbCxcclxuXHRcdFx0dGV4dDogbnVsbCwgLy8gbWFpblRleHQsXHJcblx0XHRcdGdyaWQ6IHtcclxuXHRcdFx0XHRtYWluOiBudWxsLCAvLyBncmlkIChhbHNvIGZvY3VzKVxyXG5cdFx0XHRcdHg6IG51bGwsIC8vIHhncmlkLFxyXG5cdFx0XHRcdHk6IG51bGwsIC8vIHlncmlkLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0XHRtYWluOiBudWxsLCAvLyBncmlkTGluZXNcclxuXHRcdFx0XHR4OiBudWxsLCAvLyB4Z3JpZExpbmVzLFxyXG5cdFx0XHRcdHk6IG51bGwsIC8vIHlncmlkTGluZXNcclxuXHRcdFx0fSxcclxuXHRcdFx0cmVnaW9uOiB7XHJcblx0XHRcdFx0bWFpbjogbnVsbCwgLy8gcmVnaW9uXHJcblx0XHRcdFx0bGlzdDogbnVsbCAvLyBtYWluUmVnaW9uXHJcblx0XHRcdH0sXHJcblx0XHRcdGV2ZW50UmVjdDogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZWxlbWVudDtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogU3RhdGUgY2xhc3MuXHJcbiAqIEBjbGFzcyBTdGF0ZVxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZSB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0d2lkdGgyOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IDAsXHJcblx0XHRcdGhlaWdodDI6IDAsXHJcblx0XHRcdG1hcmdpbjoge1xyXG5cdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRyaWdodDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtYXJnaW4yOiB7XHJcblx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdG1hcmdpbjM6IHtcclxuXHRcdFx0XHR0b3A6IDAsXHJcblx0XHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0cmlnaHQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0YXJjV2lkdGg6IDAsXHJcblx0XHRcdGFyY0hlaWdodDogMCxcclxuXHJcblx0XHRcdGhhc0F4aXM6IGZhbHNlLFxyXG5cdFx0XHRoYXNSYWRhcjogZmFsc2UsXHJcblxyXG5cdFx0XHRjdXJyZW50OiB7XHJcblx0XHRcdFx0d2lkdGg6IDAsXHJcblx0XHRcdFx0aGVpZ2h0OiAwLFxyXG5cdFx0XHRcdGRhdGFNYXg6IDAsXHJcblxyXG5cdFx0XHRcdG1heFRpY2tXaWR0aHM6IHtcclxuXHRcdFx0XHRcdHg6IHtzaXplOiAwLCB0aWNrczogPG51bWJlcltdPiBbXSwgY2xpcFBhdGg6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0XHR5OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcclxuXHRcdFx0XHRcdHkyOiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifVxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIGN1cnJlbnQgdXNlZCBjaGFydCB0eXBlIGxpc3RcclxuXHRcdFx0XHR0eXBlczogPHN0cmluZ1tdPiBbXSxcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIGxlZ2VuZFxyXG5cdFx0XHRpc0xlZ2VuZFJpZ2h0OiBmYWxzZSxcclxuXHRcdFx0aXNMZWdlbmRJbnNldDogZmFsc2UsXHJcblx0XHRcdGlzTGVnZW5kVG9wOiBmYWxzZSxcclxuXHRcdFx0aXNMZWdlbmRMZWZ0OiBmYWxzZSxcclxuXHRcdFx0bGVnZW5kU3RlcDogMCxcclxuXHRcdFx0bGVnZW5kSXRlbVdpZHRoOiAwLFxyXG5cdFx0XHRsZWdlbmRJdGVtSGVpZ2h0OiAwLFxyXG5cdFx0XHRsZWdlbmRIYXNSZW5kZXJlZDogZmFsc2UsXHJcblxyXG5cdFx0XHRheGlzOiB7XHJcblx0XHRcdFx0eDoge1xyXG5cdFx0XHRcdFx0cGFkZGluZzoge2xlZnQ6IDAsIHJpZ2h0OiAwfSxcclxuXHRcdFx0XHRcdHRpY2tDb3VudDogMFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHJvdGF0ZWRQYWRkaW5nOiB7XHJcblx0XHRcdFx0bGVmdDogMzAsXHJcblx0XHRcdFx0cmlnaHQ6IDAsXHJcblx0XHRcdFx0dG9wOiA1XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR3aXRob3V0RmFkZUluOiB7fSxcclxuXHRcdFx0aW5wdXRUeXBlOiBcIlwiLFxyXG5cclxuXHRcdFx0ZGF0ZXRpbWVJZDogXCJcIixcclxuXHJcblx0XHRcdC8vIGNsaXAgaWQgc3RyaW5nXHJcblx0XHRcdGNsaXA6IHtcclxuXHRcdFx0XHRpZDogXCJcIixcclxuXHRcdFx0XHRpZFhBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdGlkWUF4aXM6IFwiXCIsXHJcblx0XHRcdFx0aWRYQXhpc1RpY2tUZXh0czogXCJcIixcclxuXHRcdFx0XHRpZEdyaWQ6IFwiXCIsXHJcblx0XHRcdFx0aWRTdWJjaGFydDogXCJcIiwgLy8gY2xpcElkRm9yU3ViY2hhcnRcclxuXHRcdFx0XHRwYXRoOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhYQXhpczogXCJcIixcclxuXHRcdFx0XHRwYXRoWUF4aXM6IFwiXCIsXHJcblx0XHRcdFx0cGF0aFhBeGlzVGlja1RleHRzOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhHcmlkOiBcIlwiXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBzdGF0dXNcclxuXHRcdFx0ZHJhZ1N0YXJ0OiBudWxsLFxyXG5cdFx0XHRkcmFnZ2luZzogZmFsc2UsXHJcblx0XHRcdGZsb3dpbmc6IGZhbHNlLFxyXG5cdFx0XHRjYW5jZWxDbGljazogZmFsc2UsXHJcblx0XHRcdG1vdXNlb3ZlcjogZmFsc2UsXHJcblx0XHRcdHJlbmRlcmVkOiBmYWxzZSxcclxuXHRcdFx0dHJhbnNpdGluZzogZmFsc2UsXHJcblx0XHRcdGhhc05lZ2F0aXZlVmFsdWU6IGZhbHNlLFxyXG5cdFx0XHRoYXNQb3NpdGl2ZVZhbHVlOiB0cnVlLFxyXG5cclxuXHRcdFx0b3JnQXJlYU9wYWNpdHk6IFwiMC4yXCIsXHJcblxyXG5cdFx0XHQvLyBJRCBzdHJpbmdzXHJcblx0XHRcdGhpZGRlblRhcmdldElkczogPHN0cmluZ1tdPiBbXSxcclxuXHRcdFx0aGlkZGVuTGVnZW5kSWRzOiA8c3RyaW5nW10+IFtdLFxyXG5cdFx0XHRmb2N1c2VkVGFyZ2V0SWRzOiA8c3RyaW5nW10+IFtdLFxyXG5cdFx0XHRkZWZvY3VzZWRUYXJnZXRJZHM6IDxzdHJpbmdbXT4gW10sXHJcblxyXG5cdFx0XHQvLyB2YWx1ZSBmb3IgQXJjXHJcblx0XHRcdHJhZGl1czogMCxcclxuXHRcdFx0aW5uZXJSYWRpdXM6IDAsXHJcblx0XHRcdGlubmVyUmFkaXVzUmF0aW86IDAsXHJcblx0XHRcdGdhdWdlQXJjV2lkdGg6IDAsXHJcblx0XHRcdHJhZGl1c0V4cGFuZGVkOiAwLFxyXG5cclxuXHRcdFx0Ly8geGdyaWQgYXR0cmlidXRlXHJcblx0XHRcdHhncmlkQXR0cjoge1xyXG5cdFx0XHRcdHgxOiA8bnVtYmVyIHwgbnVsbD4gbnVsbCxcclxuXHRcdFx0XHR4MjogPG51bWJlciB8IG51bGw+IG51bGwsXHJcblx0XHRcdFx0eTE6IDxudW1iZXIgfCBudWxsPiBudWxsLFxyXG5cdFx0XHRcdHkyOiA8bnVtYmVyIHwgbnVsbD4gbnVsbFxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBFbGVtZW50IGZyb20gXCIuL0VsZW1lbnRcIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCIuL1N0YXRlXCI7XHJcblxyXG4vLyBtYXBwaW5nXHJcbmNvbnN0IGNsYXNzZXMgPSB7XHJcblx0ZWxlbWVudDogRWxlbWVudCxcclxuXHRzdGF0ZTogU3RhdGVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBzdG9yZSBjbGFzcy5cclxuICogQGNsYXNzIFN0b3JlXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JlIHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdE9iamVjdC5rZXlzKGNsYXNzZXMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdHRoaXNbdl0gPSBuZXcgY2xhc3Nlc1t2XSgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRnZXRTdG9yZShuYW1lOiBzdHJpbmcpOiBFbGVtZW50IHwgU3RhdGUge1xyXG5cdFx0cmV0dXJuIHRoaXNbbmFtZV07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtDaGFydFR5cGVzfSBmcm9tIFwiLi4vLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBkYXRhIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgZGF0YSBpZCB2YWx1ZVxyXG5cdCAqIEBuYW1lIGRhdGHigKRpZENvbnZlcnRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKGlkKSB7IHJldHVybiBpZDsgfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIGlkQ29udmVydGVyOiBmdW5jdGlvbihpZCkge1xyXG5cdCAqICAgICAgIC8vIHdoZW4gaWQgaXMgJ2RhdGExJywgY29udmVydHMgdG8gYmUgJ2RhdGEyJ1xyXG5cdCAqICAgICAgIC8vICdkYXRhMicgc2hvdWxkIGJlIGdpdmVuIGFzIHRoZSBpbml0aWFsIGRhdGEgdmFsdWVcclxuXHQgKiAgICAgICBpZiAoaWQgPT09IFwiZGF0YTFcIikge1xyXG5cdCAqICAgICAgICAgIHJldHVybiBcImRhdGEyXCI7XHJcblx0ICogICAgICAgfSBlbHNlIHtcclxuXHQgKiAgICAgICAgICByZXR1cm4gaWQ7XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9pZENvbnZlcnRlcjogaWQgPT4gaWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjdXN0b20gZGF0YSBuYW1lLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRuYW1lc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFOYW1lKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgbmFtZXM6IHtcclxuXHQgKiAgICAgZGF0YTE6IFwiRGF0YSBOYW1lIDFcIixcclxuXHQgKiAgICAgZGF0YTI6IFwiRGF0YSBOYW1lIDJcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX25hbWVzOiA8e1trZXk6IHN0cmluZ106IHN0cmluZ30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY3VzdG9tIGRhdGEgY2xhc3MuPGJyPjxicj5cclxuXHQgKiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBlbGVtZW50IGcgZm9yIHRoZSBkYXRhIGhhcyBhbiBhZGRpdGlvbmFsIGNsYXNzIHRoYXQgaGFzIHRoZSBwcmVmaXggJ2JiLXRhcmdldC0nIChlZy4gYmItdGFyZ2V0LWFkZGl0aW9uYWwtZGF0YTEtY2xhc3MpLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRjbGFzc2VzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBjbGFzc2VzOiB7XHJcblx0ICogICAgIGRhdGExOiBcImFkZGl0aW9uYWwtZGF0YTEtY2xhc3NcIixcclxuXHQgKiAgICAgZGF0YTI6IFwiYWRkaXRpb25hbC1kYXRhMi1jbGFzc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfY2xhc3NlczogPHtba2V5OiBzdHJpbmddOiBzdHJpbmd9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNoYXJ0IHR5cGUgYXQgb25jZS48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIHR5cGUgd2lsbCBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGRhdGEuIFRoaXMgc2V0dGluZyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgZGF0YS50eXBlcy48YnI+PGJyPlxyXG5cdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqIC0gYXJlYVxyXG5cdCAqIC0gYXJlYS1saW5lLXJhbmdlXHJcblx0ICogLSBhcmVhLXNwbGluZVxyXG5cdCAqIC0gYXJlYS1zcGxpbmUtcmFuZ2VcclxuXHQgKiAtIGFyZWEtc3RlcFxyXG5cdCAqIC0gYmFyXHJcblx0ICogLSBidWJibGVcclxuXHQgKiAtIGRvbnV0XHJcblx0ICogLSBnYXVnZVxyXG5cdCAqIC0gbGluZVxyXG5cdCAqIC0gcGllXHJcblx0ICogLSByYWRhclxyXG5cdCAqIC0gc2NhdHRlclxyXG5cdCAqIC0gc3BsaW5lXHJcblx0ICogLSBzdGVwXHJcblx0ICogQG5hbWUgZGF0YeKApHR5cGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgbGluZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHR5cGU6IFwiYmFyXCJcclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV90eXBlOiA8Q2hhcnRUeXBlc3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNoYXJ0IHR5cGUgZm9yIGVhY2ggZGF0YS48YnI+XHJcblx0ICogVGhpcyBzZXR0aW5nIG92ZXJ3cml0ZXMgZGF0YS50eXBlIHNldHRpbmcuXHJcblx0ICogLSAqKk5PVEU6KiogYHJhZGFyYCB0eXBlIGNhbid0IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgdHlwZXMuXHJcblx0ICogQG5hbWUgZGF0YeKApHR5cGVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICB0eXBlczoge1xyXG5cdCAqICAgICBkYXRhMTogXCJiYXJcIixcclxuXHQgKiAgICAgZGF0YTI6IFwic3BsaW5lXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV90eXBlczogPHtba2V5OiBzdHJpbmddOiBDaGFydFR5cGVzfT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqICBUaGlzIG9wdGlvbiBjaGFuZ2VzIHRoZSBvcmRlciBvZiBzdGFja2luZyBkYXRhIGFuZCBwaWVjZXMgb2YgcGllL2RvbnV0LlxyXG5cdCAqICAtIElmIGBudWxsYCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgdGhlIG9yZGVyIHRoZSBkYXRhIGxvYWRlZC5cclxuXHQgKiAgLSBJZiBmdW5jdGlvbiBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgdXNlZCBhcyBbQXJyYXkuc29ydCBjb21wYXJlRnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjUGFyYW1ldGVycyk8YnI+PGJyPlxyXG5cdCAqXHJcblx0ICogICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqICAtIGBkZXNjYDogSW4gZGVzY2VuZGluZyBvcmRlclxyXG5cdCAqICAtIGBhc2NgOiBJbiBhc2NlbmRpbmcgb3JkZXJcclxuXHQgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGxvYWQgb3JkZXJcclxuXHQgKiAgLSBgZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IC4uLiB9YDogQXJyYXkuc29ydCBjb21wYXJlRnVuY3Rpb25cclxuXHQgKiBAbmFtZSBkYXRh4oCkb3JkZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd8RnVuY3Rpb258bnVsbH1cclxuXHQgKiBAZGVmYXVsdCBkZXNjXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU9yZGVyKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgLy8gaW4gZGVzY2VuZGluZyBvcmRlciAoZGVmYXVsdClcclxuXHQgKiAgIG9yZGVyOiBcImRlc2NcIlxyXG5cdCAqXHJcblx0ICogICAvLyBpbiBhc2NlbmRpbmcgb3JkZXJcclxuXHQgKiAgIG9yZGVyOiBcImFzY1wiXHJcblx0ICpcclxuXHQgKiAgIC8vIGtlZXBzIGRhdGEgaW5wdXQgb3JkZXJcclxuXHQgKiAgIG9yZGVyOiBudWxsXHJcblx0ICpcclxuXHQgKiAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxyXG5cdCAqICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcclxuXHQgKiAgICAgICAvLyBwYXJhbSBkYXRhIHBhc3NlZCBmb3JtYXRcclxuXHQgKiAgICAgICB7XHJcblx0ICogICAgICAgICAgaWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogW1xyXG5cdCAqICAgICAgICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn0sXHJcblx0ICogICAgICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgICAgIF1cclxuXHQgKiAgICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfb3JkZXI6IDxcImRlc2NcInxcImFzY1wifEZ1bmN0aW9ufG51bGw+IFwiZGVzY1wiLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY29sb3IgY29udmVydGVyIGZ1bmN0aW9uLjxicj48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gc2hvdWxkIGEgZnVuY3Rpb24gYW5kIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgY29sb3IgKGUuZy4gJyNmZjAwMDAnKSBhbmQgZCB0aGF0IGhhcyBkYXRhIHBhcmFtZXRlcnMgbGlrZSBpZCwgdmFsdWUsIGluZGV4LCBldGMuIEFuZCBpdCBtdXN0IHJldHVybiBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgY29sb3IgKGUuZy4gJyMwMGZmMDAnKS5cclxuXHQgKiBAbmFtZSBkYXRh4oCkY29sb3JcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhQ29sb3IpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBjb2xvcjogZnVuY3Rpb24oY29sb3IsIGQpIHsgLi4uIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9jb2xvcjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY29sb3IgZm9yIGVhY2ggZGF0YS5cclxuXHQgKiBAbmFtZSBkYXRh4oCkY29sb3JzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBjb2xvcnM6IHtcclxuXHQgKiAgICAgZGF0YTE6IFwiI2ZmMDAwMFwiLFxyXG5cdCAqICAgICBkYXRhMjogZnVuY3Rpb24oZCkge1xyXG5cdCAqICAgICAgICByZXR1cm4gXCIjMDAwXCI7XHJcblx0ICogICAgIH1cclxuXHQgKiAgICAgLi4uXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfY29sb3JzOiA8e1trZXk6IHN0cmluZ106IHN0cmluZ3woKCkgPT4gc3RyaW5nKTt9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSBlYWNoIGRhdGEgd2hlbiB0aGUgY2hhcnQgYXBwZWFycy48YnI+PGJyPlxyXG5cdCAqIElmIHRydWUgc3BlY2lmaWVkLCBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlbi4gSWYgbXVsdGlwbGUgaWRzIHNwZWNpZmllZCBhcyBhbiBhcnJheSwgdGhvc2Ugd2lsbCBiZSBoaWRkZW4uXHJcblx0ICogQG5hbWUgZGF0YeKApGhpZGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufEFycmF5fVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAvLyBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlblxyXG5cdCAqICAgaGlkZTogdHJ1ZVxyXG5cdCAqXHJcblx0ICogICAvLyBzcGVjaWZpZWQgZGF0YSB3aWxsIGJlIGhpZGRlblxyXG5cdCAqICAgaGlkZTogW1wiZGF0YTFcIiwgLi4uXVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2hpZGU6IDxzdHJpbmdbXXxib29sZWFuPiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogRmlsdGVyIHZhbHVlcyB0byBiZSBzaG93blxyXG5cdCAqIFRoZSBkYXRhIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSByZXR1cm5lZCBieSBgLmRhdGEoKWAuXHJcblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJcclxuXHQgKiBAbmFtZSBkYXRh4oCkZmlsdGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAvLyBmaWx0ZXIgZm9yIGlkIHZhbHVlXHJcblx0ICogICBmaWx0ZXI6IGZ1bmN0aW9uKHYpIHtcclxuXHQgKiAgICAgIC8vIHY6IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogW1xyXG5cdCAqICAgICAgLy8gICAgICB7eDogMCwgdmFsdWU6IDEzMCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDB9LCAuLi5dXHJcblx0ICogICAgICAvLyAgICB9LCAuLi5dXHJcblx0ICogICAgICByZXR1cm4gdi5pZCAhPT0gXCJkYXRhMVwiO1xyXG5cdCAqICAgfVxyXG5cdCAqL1xyXG5cdGRhdGFfZmlsdGVyOiA8KCgpID0+IGJvb2xlYW4pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgY2xpY2sgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XHJcblx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIGVhY2ggZGF0YSBwb2ludCBjbGlja2VkIGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFuZCBlbGVtZW50IGFzIHRoZSBhcmd1bWVudHMuXHJcblx0ICogLSBgZGAgaXMgdGhlIGRhdGEgY2xpY2tlZCBhbmQgZWxlbWVudCBpcyB0aGUgZWxlbWVudCBjbGlja2VkLlxyXG5cdCAqIC0gYGVsZW1lbnRgIGlzIHRoZSBjdXJyZW50IGludGVyYWN0aW5nIHN2ZyBlbGVtZW50LlxyXG5cdCAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cclxuXHQgKiBAbmFtZSBkYXRh4oCkb25jbGlja1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25jbGljazogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG5cdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vbmNsaWNrOiAoKSA9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XHJcblx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIG1vdXNlIGN1cnNvciBvciB2aWEgdG91Y2ggbW92ZXMgb250byBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYW5kIGBlbGVtZW50YCBhcyB0aGUgYXJndW1lbnQuXHJcblx0ICogLSBgZGAgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG9udG8uXHJcblx0ICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcblx0ICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbm92ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIG9ub3ZlcjogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG5cdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNH1cclxuXHQgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfb25vdmVyOiAoKSA9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG91dCBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuXHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvdXQgZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFzIHRoZSBhcmd1bWVudC5cclxuXHQgKiAtIGBkYCBpcyB0aGUgZGF0YSB3aGVyZSBtb3VzZSBjdXJzb3IgbW92ZXMgb3V0LlxyXG5cdCAqIC0gYGVsZW1lbnRgIGlzIHRoZSBjdXJyZW50IGludGVyYWN0aW5nIHN2ZyBlbGVtZW50LlxyXG5cdCAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cclxuXHQgKiBAbmFtZSBkYXRh4oCkb25vdXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIG9ub3V0OiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0fVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vbm91dDogKCkgPT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIGZvciBtaW5pbXVtIGRhdGFcclxuXHQgKiAtICoqTk9URToqKiBGb3IgJ2FyZWEtbGluZS1yYW5nZScgYW5kICdhcmVhLXNwbGluZS1yYW5nZScsIGBtaWRgIGRhdGEgd2lsbCBiZSB0YWtlbiBmb3IgdGhlIGNvbXBhcmlzb25cclxuXHQgKiBAbmFtZSBkYXRh4oCkb25taW5cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Pbk1pbk1heENhbGxiYWNrKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIG9ubWluOiBmdW5jdGlvbihkYXRhKSB7XHJcblx0ICogICAgLy8gZGF0YSAtIGV4KSBbe3g6IDMsIHZhbHVlOiA0MDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAzfSwgLi4uIF1cclxuXHQgKiAgICAuLi5cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGRhdGFfb25taW46IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1heGltdW0gZGF0YVxyXG5cdCAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbm1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgb25tYXg6IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHQgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxyXG5cdCAqICAgIC4uLlxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0ZGF0YV9vbm1heDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBMb2FkIGEgQ1NWIG9yIEpTT04gZmlsZSBmcm9tIGEgVVJMLiBOT1RFIHRoYXQgdGhpcyB3aWxsIG5vdCB3b3JrIGlmIGxvYWRpbmcgdmlhIHRoZSBcImZpbGU6Ly9cIiBwcm90b2NvbCBhcyB0aGUgbW9zdCBicm93c2VycyB3aWxsIGJsb2NrIFhNTEhUVFBSZXF1ZXN0cy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkdXJsXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkxvYWREYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3VybDogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogWEhSIGhlYWRlciB2YWx1ZVxyXG5cdCAqIC0gKipOT1RFOioqIFNob3VsZCBiZSB1c2VkIHdpdGggYGRhdGEudXJsYCBvcHRpb25cclxuXHQgKiBAbmFtZSBkYXRh4oCkaGVhZGVyc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9zZXRSZXF1ZXN0SGVhZGVyXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIHVybDogXCIvZGF0YS90ZXN0LmNzdlwiLFxyXG5cdCAqICAgICBoZWFkZXJzOiB7XHJcblx0ICogICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC94bWxcIixcclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9oZWFkZXJzOiA8b2JqZWN0fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBQYXJzZSBhIEpTT04gb2JqZWN0IGZvciBkYXRhLiBTZWUgYWxzbyBkYXRhLmtleXMuXHJcblx0ICogQG5hbWUgZGF0YeKApGpzb25cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIFtkYXRh4oCka2V5c10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cylcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5KU09ORGF0YSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAganNvbjogW1xyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMS5jb21cIiwgdXBsb2FkOiAyMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA0MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlNC5jb21cIiwgdXBsb2FkOiA0MDAsIGRvd25sb2FkOiAxMDAsIHRvdGFsOiA1MDB9XHJcblx0ICogICAgIF0sXHJcblx0ICogICAgIGtleXM6IHtcclxuXHQgKiAgICAgICAvLyB4OiBcIm5hbWVcIiwgLy8gaXQncyBwb3NzaWJsZSB0byBzcGVjaWZ5ICd4JyB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHQgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2pzb246IDxvYmplY3RbXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogTG9hZCBkYXRhIGZyb20gYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5LCB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGRhdGEgbmFtZXMsIHRoZSBmb2xsb3dpbmcgY29udGFpbmluZyByZWxhdGVkIGRhdGEgaW4gdGhhdCBvcmRlci5cclxuXHQgKiBAbmFtZSBkYXRh4oCkcm93c1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLlJvd09yaWVudGVkRGF0YSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHJvd3M6IFtcclxuXHQgKiAgICAgW1wiQVwiLCBcIkJcIiwgXCJDXCJdLFxyXG5cdCAqICAgICBbOTAsIDEyMCwgMzAwXSxcclxuXHQgKiAgICAgWzQwLCAxNjAsIDI0MF0sXHJcblx0ICogICAgIFs1MCwgMjAwLCAyOTBdLFxyXG5cdCAqICAgICBbMTIwLCAxNjAsIDIzMF0sXHJcblx0ICogICAgIFs4MCwgMTMwLCAzMDBdLFxyXG5cdCAqICAgICBbOTAsIDIyMCwgMzIwXVxyXG5cdCAqICAgXVxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxyXG5cdCAqIC8vIC0gYW4gYXJyYXkgb2YgW2hpZ2gsIG1pZCwgbG93XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuXHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICdoaWdoJywgJ21pZCcgYW5kICdsb3cnIGtleSB2YWx1ZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHJvd3M6IFtcclxuXHQgKiAgICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXHJcblx0ICogICAgICBbXHJcblx0ICogICAgICAgIC8vIG9yIHtoaWdoOjE1MCwgbWlkOiAxNDAsIGxvdzogMTEwfSwgMTIwXHJcblx0ICogICAgICAgIFsxNTAsIDE0MCwgMTEwXSwgMTIwXHJcblx0ICogICAgICBdLFxyXG5cdCAqICAgICAgW1sxNTUsIDEzMCwgMTE1XSwgNTVdLFxyXG5cdCAqICAgICAgW1sxNjAsIDEzNSwgMTIwXSwgNjBdXHJcblx0ICogICBdLFxyXG5cdCAqICAgdHlwZXM6IHtcclxuXHQgKiAgICAgICBkYXRhMTogXCJhcmVhLWxpbmUtcmFuZ2VcIixcclxuXHQgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICpcclxuXHQgKiAvLyBmb3IgJ2J1YmJsZScgdHlwZSwgZGF0YSBjYW4gY29udGFpbiBkaW1lbnNpb24gdmFsdWU6XHJcblx0ICogLy8gLSBhbiBhcnJheSBvZiBbeSwgel0gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcblx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAneScgYW5kICd6JyBrZXkgdmFsdWVcclxuXHQgKiAvLyAneScgaXMgZm9yIHkgYXhpcyBjb29yZGluYXRpb24gYW5kICd6JyBpcyB0aGUgYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHJvd3M6IFtcclxuXHQgKiAgICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXHJcblx0ICogICAgICBbXHJcblx0ICogICAgICAgIC8vIG9yIHt5OjEwLCB6OiAxNDB9LCAxMjBcclxuXHQgKiAgICAgICAgWzEwLCAxNDBdLCAxMjBcclxuXHQgKiAgICAgIF0sXHJcblx0ICogICAgICBbWzEwMCwgMzBdLCA1NV0sXHJcblx0ICogICAgICBbWzUwLCAxMDBdLCA2MF1cclxuXHQgKiAgIF0sXHJcblx0ICogICB0eXBlczoge1xyXG5cdCAqICAgICAgIGRhdGExOiBcImJ1YmJsZVwiLFxyXG5cdCAqICAgICAgIGRhdGEyOiBcImxpbmVcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3Jvd3M6IDwoc3RyaW5nfG51bWJlcilbXVtdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggZWFjaCBlbGVtZW50IGNvbnRhaW5pbmcgYW4gYXJyYXkgY29uc2lzdGluZyBvZiBhIGRhdHVtIG5hbWUgYW5kIGFzc29jaWF0ZWQgZGF0YSB2YWx1ZXMuXHJcblx0ICogQG5hbWUgZGF0YeKApGNvbHVtbnNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Db2x1bW5PcmllbnRlZERhdGEpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBjb2x1bW5zOiBbXHJcblx0ICogICAgICBbXCJkYXRhMVwiLCAzMCwgMjAsIDUwLCA0MCwgNjAsIDUwXSxcclxuXHQgKiAgICAgIFtcImRhdGEyXCIsIDIwMCwgMTMwLCA5MCwgMjQwLCAxMzAsIDIyMF0sXHJcblx0ICogICAgICBbXCJkYXRhM1wiLCAzMDAsIDIwMCwgMTYwLCA0MDAsIDI1MCwgMjUwXVxyXG5cdCAqICAgXVxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxyXG5cdCAqIC8vIC0gYW4gYXJyYXkgb2YgW2hpZ2gsIG1pZCwgbG93XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuXHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICdoaWdoJywgJ21pZCcgYW5kICdsb3cnIGtleSB2YWx1ZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgIFtcImRhdGExXCIsXHJcblx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9XHJcblx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdLFxyXG5cdCAqICAgICAgICAgIFsxNTAsIDE0MCwgMTEwXVxyXG5cdCAqICAgICAgXVxyXG5cdCAqICAgXSxcclxuXHQgKiAgIHR5cGU6IFwiYXJlYS1saW5lLXJhbmdlXCJcclxuXHQgKiB9XHJcblx0ICpcclxuXHQgKiAvLyBmb3IgJ2J1YmJsZScgdHlwZSwgZGF0YSBjYW4gY29udGFpbiBkaW1lbnNpb24gdmFsdWU6XHJcblx0ICogLy8gLSBhbiBhcnJheSBvZiBbeSwgel0gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcblx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAneScgYW5kICd6JyBrZXkgdmFsdWVcclxuXHQgKiAvLyAneScgaXMgZm9yIHkgYXhpcyBjb29yZGluYXRpb24gYW5kICd6JyBpcyB0aGUgYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgIFtcImRhdGExXCIsXHJcblx0ICogICAgICAgICAgWzEwLCAxNDBdLCAgLy8gb3Ige3k6MTAsIHo6IDE0MH1cclxuXHQgKiAgICAgICAgICBbMTAwLCAzMF0sXHJcblx0ICogICAgICAgICAgWzUwLCAxMDBdXHJcblx0ICogICAgICBdXHJcblx0ICogICBdLFxyXG5cdCAqICAgdHlwZTogXCJidWJibGVcIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2NvbHVtbnM6IDwoc3RyaW5nfG51bWJlcilbXVtdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBVc2VkIGlmIGxvYWRpbmcgSlNPTiB2aWEgZGF0YS51cmwuXHJcblx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAgIC0ganNvblxyXG5cdCAqICAgLSBjc3ZcclxuXHQgKiAgIC0gdHN2XHJcblx0ICogQG5hbWUgZGF0YeKApG1pbWVUeXBlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IGNzdlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgICBtaW1lVHlwZTogXCJqc29uXCJcclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9taW1lVHlwZTogPFwiY3N2XCJ8XCJqc29uXCJ8XCJ0c3ZcIj4gXCJjc3ZcIixcclxuXHJcblx0LyoqXHJcblx0ICogQ2hvb3NlIHdoaWNoIEpTT04gb2JqZWN0IGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuXHJcblx0ICogLSAqKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuXHJcblx0ICogQG5hbWUgZGF0YeKApGtleXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIGpzb246IFtcclxuXHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogMjAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNDAwfSxcclxuXHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTIuY29tXCIsIHVwbG9hZDogMTAwLCBkb3dubG9hZDogMzAwLCB0b3RhbDogNDAwfSxcclxuXHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTMuY29tXCIsIHVwbG9hZDogMzAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNTAwfSxcclxuXHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTQuY29tXCIsIHVwbG9hZDogNDAwLCBkb3dubG9hZDogMTAwLCB0b3RhbDogNTAwfVxyXG5cdCAqICAgICBdLFxyXG5cdCAqICAgICBrZXlzOiB7XHJcblx0ICogICAgICAgLy8geDogXCJuYW1lXCIsIC8vIGl0J3MgcG9zc2libGUgdG8gc3BlY2lmeSAneCcgd2hlbiBjYXRlZ29yeSBheGlzXHJcblx0ICogICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXHJcblx0ICogICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9rZXlzOiA8e3g/OiBzdHJpbmc7IHZhbHVlPzogc3RyaW5nW119fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGV4dCBsYWJlbCB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGVyZSdzIG5vIGRhdGEgdG8gc2hvdy5cclxuXHQgKiAtIGV4LiBUb2dnbGluZyBhbGwgdmlzaWJsZSBkYXRhIHRvIG5vdCBiZSBzaG93biwgdW5sb2FkaW5nIGFsbCBjdXJyZW50IGRhdGEsIGV0Yy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkZW1wdHnigKRsYWJlbOKApHRleHRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgXCJcIlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgZW1wdHk6IHtcclxuXHQgKiAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICB0ZXh0OiBcIk5vIERhdGFcIlxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfZW1wdHlfbGFiZWxfdGV4dDogXCJcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBjb2xvciBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBjb2xvciBvZiB0aGUgZGF0YSB2YWx1ZXNcclxuXHQgKiBAbmFtZSBjb2xvclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gY29sb3IgY29sb3Igb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fEZ1bmN0aW9ufSBbY29sb3Iub25vdmVyXSBTZXQgdGhlIGNvbG9yIHZhbHVlIGZvciBlYWNoIGRhdGEgcG9pbnQgd2hlbiBtb3VzZS90b3VjaCBvbm92ZXIgZXZlbnQgb2NjdXJzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl8bnVsbH0gW2NvbG9yLnBhdHRlcm49W11dIFNldCBjdXN0b20gY29sb3IgcGF0dGVybi4gUGFzc2luZyBgbnVsbGAgd2lsbCBub3Qgc2V0IGEgY29sb3IgZm9yIHRoZXNlIGVsZW1lbnRzLCB3aGljaCByZXF1aXJlcyB0aGUgdXNhZ2Ugb2YgY3VzdG9tIENTUy1iYXNlZCB0aGVtaW5nIHRvIHdvcmsuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbG9yLnRpbGVzXSBpZiBkZWZpbmVkLCBhbGxvd3MgdXNlIHN2ZydzIHBhdHRlcm5zIHRvIGZpbGwgZGF0YSBhcmVhLiBJdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFtTVkdQYXR0ZXJuRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR1BhdHRlcm5FbGVtZW50KS5cclxuXHQgKiAgLSAqKk5PVEU6KiogVGhlIHBhdHRlcm4gZWxlbWVudCdzIGlkIHdpbGwgYmUgZGVmaW5lZCBhcyBgYmItY29sb3JpemUtcGF0dGVybi0kQ09MT1ItVkFMVUVgLjxicj5cclxuXHQgKiAgICBleC4gV2hlbiBjb2xvciBwYXR0ZXJuIHZhbHVlIGlzIGBbJ3JlZCcsICcjZmZmJ11gIGFuZCBkZWZpbmVkIDIgcGF0dGVybnMsdGhlbiBpZHMgZm9yIHBhdHRlcm4gZWxlbWVudHMgYXJlOjxicj5cclxuXHQgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLXJlZGBcclxuXHQgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLWZmZmBcclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gW2NvbG9yLnRocmVzaG9sZF0gY29sb3IgdGhyZXNob2xkIGZvciBnYXVnZSBhbmQgdG9vbHRpcCBjb2xvclxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3IudGhyZXNob2xkLnVuaXRdIElmIHNldCB0byBgdmFsdWVgLCB0aGUgdGhyZXNob2xkIHdpbGwgYmUgYmFzZWQgb24gdGhlIGRhdGEgdmFsdWUuIE90aGVyd2lzZSBpdCdsbCBiZSBiYXNlZCBvbiBlcXVhdGlvbiBvZiB0aGUgYHRocmVzaG9sZC5tYXhgIG9wdGlvbiB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge0FycmF5fSBbY29sb3IudGhyZXNob2xkLnZhbHVlc10gVGhyZXNob2xkIHZhbHVlcyBmb3IgZWFjaCBzdGVwc1xyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY29sb3IudGhyZXNob2xkLm1heD0xMDBdIFRoZSBiYXNlIHZhbHVlIHRvIGRldGVybWluZSB0aHJlc2hvbGQgc3RlcCB2YWx1ZSBjb25kaXRpb24uIFdoZW4gdGhlIGdpdmVuIHZhbHVlIGlzIDE1IGFuZCBtYXggMTAsIHRoZW4gdGhlIHZhbHVlIGZvciB0aHJlc2hvbGQgaXMgYDE1KjEwMC8xMGAuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgY29sb3I6IHtcclxuXHQgKiAgICAgIHBhdHRlcm46IFtcIiMxZjc3YjRcIiwgXCIjYWVjN2U4XCIsIC4uLl0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFNldCBjb2xvcnMnIHBhdHRlcm5zXHJcblx0ICogICAgICAvLyBpdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFNWR1BhdHRlcm5FbGVtZW50XHJcblx0ICogICAgICB0aWxlczogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgICB2YXIgcGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0dGVyblwiKTtcclxuXHQgKiAgICAgICAgIHZhciBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xyXG5cdCAqICAgICAgICAgdmFyIGNpcmNsZTEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJwYXR0ZXJuVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcclxuXHQgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIzMlwiKTtcclxuXHQgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMzJcIik7XHJcblx0ICpcclxuXHQgKiAgICAgICAgIGcuc3R5bGUuZmlsbCA9IFwiIzAwMFwiO1xyXG5cdCAqICAgICAgICAgZy5zdHlsZS5vcGFjaXR5ID0gXCIwLjJcIjtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBcIjNcIik7XHJcblx0ICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN5XCIsIFwiM1wiKTtcclxuXHQgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiclwiLCBcIjNcIik7XHJcblx0ICpcclxuXHQgKiAgICAgICAgIGcuYXBwZW5kQ2hpbGQoY2lyY2xlMSk7XHJcblx0ICogICAgICAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGcpO1xyXG5cdCAqXHJcblx0ICogICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZm9yIHRocmVzaG9sZCB1c2FnZSwgcGF0dGVybiB2YWx1ZXMgc2hvdWxkIGJlIHNldCBmb3IgZWFjaCBzdGVwc1xyXG5cdCAqICAgICAgcGF0dGVybjogW1wiZ3JleVwiLCBcImdyZWVuXCIsIFwieWVsbG93XCIsIFwib3JhbmdlXCIsIFwicmVkXCJdLFxyXG5cdCAqICAgICAgdGhyZXNob2xkOiB7XHJcblx0ICogICAgICAgICAgdW5pdDogXCJ2YWx1ZVwiLFxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyAyMCA9PiAnZ3JlZW4nLCB2YWx1ZSBpcyA0MCA9PiAnb3JhbmdlJyB3aWxsIGJlIHNldC5cclxuXHQgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwLCA0MCwgNTBdLFxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gdGhlIGVxdWF0aW9uIGZvciBtYXg6XHJcblx0ICogICAgICAgICAgLy8gLSB1bml0ID09ICd2YWx1ZSc6IG1heCA9PiAzMFxyXG5cdCAqICAgICAgICAgIC8vIC0gdW5pdCAhPSAndmFsdWUnOiBtYXggPT4gdmFsdWUqMTAwLzMwXHJcblx0ICogICAgICAgICAgbWF4OiAzMFxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2V0IGFsbCBkYXRhIHRvICdyZWQnXHJcblx0ICogICAgICBvbm92ZXI6IFwicmVkXCIsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgY29sb3IgZm9yIGRhdGFcclxuXHQgKiAgICAgIG9ub3Zlcjoge1xyXG5cdCAqICAgICAgICAgIGRhdGExOiBcInJlZFwiLFxyXG5cdCAqICAgICAgICAgIGRhdGEyOiBcInllbGxvd1wiXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyB3aWxsIHBhc3MgZGF0YSBvYmplY3QgdG8gdGhlIGNhbGxiYWNrXHJcblx0ICogICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQpIHtcclxuXHQgKiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gXCJkYXRhMVwiID8gXCJyZWRcIiA6IFwiZ3JlZW5cIjtcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGNvbG9yX3BhdHRlcm46IDwoc3RyaW5nfG51bGwpW10+IFtdLFxyXG5cdGNvbG9yX3RpbGVzOiA8KCgpID0+IFtdKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRjb2xvcl90aHJlc2hvbGQ6IDx7dW5pdD86IHN0cmluZzsgdmFsdWVzPzogbnVtYmVyW107IG1heDogbnVtYmVyO30+IHt9LFxyXG5cdGNvbG9yX29ub3ZlcjogPHN0cmluZ3xvYmplY3R8dW5kZWZpbmVkPiB1bmRlZmluZWRcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogaW50ZXJhY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbnRlcmFjdGlvbiBvcHRpb25zXHJcblx0ICogQG5hbWUgaW50ZXJhY3Rpb25cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGludGVyYWN0aW9uIEludGVyc2VjdGlvbiBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcmFjdGlvbi5lbmFibGVkPXRydWVdIEluZGljYXRlIGlmIHRoZSBjaGFydCBzaG91bGQgaGF2ZSBpbnRlcmFjdGlvbnMuPGJyPlxyXG5cdCAqICAgICBJZiBgZmFsc2VgIGlzIHNldCwgYWxsIG9mIGludGVyYWN0aW9ucyAoc2hvd2luZy9oaWRpbmcgdG9vbHRpcCwgc2VsZWN0aW9uLCBtb3VzZSBldmVudHMsIGV0Yykgd2lsbCBiZSBkaXNhYmxlZC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcmFjdGlvbi5icmlnaHRlbj10cnVlXSBNYWtlIGJyaWdodGVyIGZvciB0aGUgc2VsZWN0ZWQgYXJlYSAoZXguICdwaWUnIHR5cGUgZGF0YSBzZWxlY3RlZCBhcmVhKVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS5tb3VzZT10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSBtb3VzZSBpbnRlcmFjdGlvblxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaD10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSAgdG91Y2ggaW50ZXJhY3Rpb25cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW58bnVtYmVyfSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0PWZhbHNlXSBlbmFibGUgb3IgZGlzYWJsZSB0byBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0IG9uIHRvdWNoc3RhcnQgJiB0b3VjaG1vdmUgZXZlbnQuIEl0J3MgdXN1YWxseSB1c2VkIHRvIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nLlxyXG5cdCAqIEBzZWUgW0RlbW86IHRvdWNoLnByZXZlbnREZWZhdWx0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uUHJldmVudFNjcm9sbE9uVG91Y2gpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBpbnRlcmFjdGlvbjoge1xyXG5cdCAqICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG5cdCAqICAgIGJyaWdodGVuOiBmYWxzZSxcclxuXHQgKiAgICBpbnB1dFR5cGU6IHtcclxuXHQgKiAgICAgICAgbW91c2U6IHRydWUsXHJcblx0ICogICAgICAgIHRvdWNoOiBmYWxzZVxyXG5cdCAqXHJcblx0ICogICAgICAgIC8vIG9yIGRlY2xhcmUgcHJldmVudERlZmF1bHQgZXhwbGljaXRseS5cclxuXHQgKiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRvdWNoIGlucHV0VHlwZSBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcclxuXHQgKiAgICAgICAgdG91Y2g6IHtcclxuXHQgKiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAgIC8vIG9yIHRocmVzaG9sZCBwaXhlbCB2YWx1ZSAocGl4ZWwgbW92ZWQgZnJvbSB0b3VjaHN0YXJ0IHRvIHRvdWNobW92ZSlcclxuXHQgKiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiA1XHJcblx0ICogICAgICAgIH1cclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGludGVyYWN0aW9uX2VuYWJsZWQ6IHRydWUsXHJcblx0aW50ZXJhY3Rpb25fYnJpZ2h0ZW46IHRydWUsXHJcblx0aW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlOiB0cnVlLFxyXG5cdGludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaDogPGJvb2xlYW58e3ByZXZlbnREZWZhdWx0PzogYm9vbGVhbnxudW1iZXJ9PiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBsZWdlbmQgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBMZWdlbmQgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGxlZ2VuZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gbGVnZW5kIExlZ2VuZCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWdlbmQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGVnZW5kLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xlZ2VuZC5oaWRlPWZhbHNlXSBIaWRlIGxlZ2VuZFxyXG5cdCAqICBJZiB0cnVlIGdpdmVuLCBhbGwgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLiBJZiBzdHJpbmcgb3IgYXJyYXkgZ2l2ZW4sIG9ubHkgdGhlIGxlZ2VuZCB0aGF0IGhhcyB0aGUgaWQgd2lsbCBiZSBoaWRkZW4uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtsZWdlbmQuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIGxlZ2VuZCBpdGVtcy5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xGdW5jdGlvbn0gW2xlZ2VuZC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCBpdGVtJ3MgdGVtcGxhdGUuPGJyPlxyXG5cdCAqICAtIElmIHNldCBgc3RyaW5nYCB2YWx1ZSwgd2l0aGluIHRlbXBsYXRlIHRoZSAnY29sb3InIGFuZCAndGl0bGUnIGNhbiBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XHJcblx0ICogICAgLSB7PUNPTE9SfTogZGF0YSBjb2xvciB2YWx1ZVxyXG5cdCAqICAgIC0gez1USVRMRX06IGRhdGEgdGl0bGUgdmFsdWVcclxuXHQgKiAgLSBJZiBzZXQgYGZ1bmN0aW9uYCB2YWx1ZSwgd2lsbCBwYXNzIGZvbGxvd2luZyBhcmd1bWVudHMgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uOlxyXG5cdCAqICAgLSB0aXRsZSB7c3RyaW5nfTogZGF0YSdzIGlkIHZhbHVlXHJcblx0ICogICAtIGNvbG9yIHtzdHJpbmd9OiBjb2xvciBzdHJpbmdcclxuXHQgKiAgIC0gZGF0YSB7QXJyYXl9OiBkYXRhIGFycmF5XHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtsZWdlbmQucG9zaXRpb249Ym90dG9tXSBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIGxlZ2VuZC48YnI+XHJcblx0ICogIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiBgYm90dG9tYCwgYHJpZ2h0YCBhbmQgYGluc2V0YCBhcmUgc3VwcG9ydGVkLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbbGVnZW5kLmluc2V0PXthbmNob3I6ICd0b3AtbGVmdCcseDogMTAseTogMCxzdGVwOiB1bmRlZmluZWR9XSBDaGFuZ2UgaW5zZXQgbGVnZW5kIGF0dHJpYnV0ZXMuPGJyPlxyXG5cdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCB0aGF0IGhhcyB0aGUga2V5cyBgYW5jaG9yYCwgYHhgLCBgeWAgYW5kIGBzdGVwYC5cclxuXHQgKiAgLSAqKmFuY2hvcioqIGRlY2lkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQ6XHJcblx0ICogICAtIHRvcC1sZWZ0XHJcblx0ICogICAtIHRvcC1yaWdodFxyXG5cdCAqICAgLSBib3R0b20tbGVmdFxyXG5cdCAqICAgLSBib3R0b20tcmlnaHRcclxuXHQgKiAgLSAqKngqKiBhbmQgKip5Kio6XHJcblx0ICogICAtIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBiYXNlZCBvbiB0aGUgYW5jaG9yLlxyXG5cdCAqICAtICoqc3RlcCoqOlxyXG5cdCAqICAgLSBkZWZpbmVzIHRoZSBtYXggc3RlcCB0aGUgbGVnZW5kIGhhcyAoZS5nLiBJZiAyIHNldCBhbmQgbGVnZW5kIGhhcyAzIGxlZ2VuZCBpdGVtLCB0aGUgbGVnZW5kIDIgY29sdW1ucykuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGVnZW5kLmVxdWFsbHk9ZmFsc2VdIFNldCB0byBhbGwgaXRlbXMgaGF2ZSBzYW1lIHdpZHRoIHNpemUuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGVnZW5kLnBhZGRpbmc9MF0gU2V0IHBhZGRpbmcgdmFsdWVcclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25jbGljaz11bmRlZmluZWRdIFNldCBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdmVyPXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9ub3V0PXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG91dCBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2xlZ2VuZC5pdGVtLnRpbGUud2lkdGg9MTBdIFNldCB3aWR0aCBvZiBpdGVtIHRpbGUgZWxlbWVudFxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS5oZWlnaHQ9MTBdIFNldCBoZWlnaHQgb2YgaXRlbSB0aWxlIGVsZW1lbnRcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWdlbmQudXNlUG9pbnQ9ZmFsc2VdIFdoZXRoZXIgdG8gdXNlIGN1c3RvbSBwb2ludHMgaW4gbGVnZW5kLlxyXG5cdCAqIEBzZWUgW0RlbW86IHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFBvc2l0aW9uKVxyXG5cdCAqIEBzZWUgW0RlbW86IGNvbnRlbnRzLnRlbXBsYXRlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFRlbXBsYXRlMSlcclxuXHQgKiBAc2VlIFtEZW1vOiB1c2VQb2ludF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC51c2VQb2ludClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBsZWdlbmQ6IHtcclxuXHQgKiAgICAgIHNob3c6IHRydWUsXHJcblx0ICogICAgICBoaWRlOiB0cnVlLFxyXG5cdCAqICAgICAgLy9vciBoaWRlOiBcImRhdGExXCJcclxuXHQgKiAgICAgIC8vb3IgaGlkZTogW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxyXG5cdCAqICAgICAgY29udGVudHM6IHtcclxuXHQgKiAgICAgICAgICBiaW5kdG86IFwiI2xlZ2VuZFwiLCAgIC8vIDx1bCBpZD0nbGVnZW5kJz48L3VsPlxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gd2lsbCBiZSBhczogPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiMxZjc3YjQnPmRhdGExPC9saT5cclxuXHQgKiAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6ez1DT0xPUn0nPns9VElUTEV9PC9saT5cIlxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gb3IgdXNpbmcgZnVuY3Rpb25cclxuXHQgKiAgICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oaWQsIGNvbG9yLCBkYXRhKSB7XHJcblx0ICogICAgICAgICAgICAgICAvLyBpZiB5b3Ugd2FudCBvbWl0IHNvbWUgbGVnZW5kLCByZXR1cm4gZmFsc3kgdmFsdWVcclxuXHQgKiAgICAgICAgICAgICAgIGlmIChpZCAhPT0gXCJkYXRhMVwiKSB7XHJcblx0ICogICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjpcIisgY29sb3IgK1wiPlwiKyBpZCArXCI8L2xpPlwiO1xyXG5cdCAqICAgICAgICAgICAgICAgfVxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBwb3NpdGlvbjogXCJib3R0b21cIiwgIC8vIGJvdHRvbSwgcmlnaHQsIGluc2V0XHJcblx0ICogICAgICBpbnNldDoge1xyXG5cdCAqICAgICAgICAgIGFuY2hvcjogXCJ0b3AtcmlnaHRcIiAgLy8gdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodFxyXG5cdCAqICAgICAgICAgIHg6IDIwLFxyXG5cdCAqICAgICAgICAgIHk6IDEwLFxyXG5cdCAqICAgICAgICAgIHN0ZXA6IDJcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBlcXVhbGx5OiBmYWxzZSxcclxuXHQgKiAgICAgIHBhZGRpbmc6IDEwLFxyXG5cdCAqICAgICAgaXRlbToge1xyXG5cdCAqICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxyXG5cdCAqICAgICAgICAgIG9ub3ZlcjogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcblx0ICogICAgICAgICAgb25vdXQ6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gc2V0IHRpbGUncyBzaXplXHJcblx0ICogICAgICAgICAgdGlsZToge1xyXG5cdCAqICAgICAgICAgICAgICB3aWR0aDogMjAsXHJcblx0ICogICAgICAgICAgICAgIGhlaWdodDogMTVcclxuXHQgKiAgICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgdXNlUG9pbnQ6IHRydWVcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGxlZ2VuZF9zaG93OiB0cnVlLFxyXG5cdGxlZ2VuZF9oaWRlOiBmYWxzZSxcclxuXHRsZWdlbmRfY29udGVudHNfYmluZHRvOiA8c3RyaW5nfEhUTUxFbGVtZW50fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTogPHN0cmluZ3woKCkgPT4gc3RyaW5nKXx1bmRlZmluZWQ+dW5kZWZpbmVkLFxyXG5cdGxlZ2VuZF9wb3NpdGlvbjogPFwiYm90dG9tXCJ8XCJyaWdodFwifFwiaW5zZXRcIj4gXCJib3R0b21cIixcclxuXHRsZWdlbmRfaW5zZXRfYW5jaG9yOiA8XCJ0b3AtbGVmdFwifFwidG9wLXJpZ2h0XCJ8XCJib3R0b20tbGVmdFwifFwiYm90dG9tLXJpZ2h0XCI+IFwidG9wLWxlZnRcIixcclxuXHRsZWdlbmRfaW5zZXRfeDogMTAsXHJcblx0bGVnZW5kX2luc2V0X3k6IDAsXHJcblx0bGVnZW5kX2luc2V0X3N0ZXA6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2l0ZW1fb25jbGljazogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGxlZ2VuZF9pdGVtX29ub3ZlcjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGxlZ2VuZF9pdGVtX29ub3V0OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2VxdWFsbHk6IGZhbHNlLFxyXG5cdGxlZ2VuZF9wYWRkaW5nOiAwLFxyXG5cdGxlZ2VuZF9pdGVtX3RpbGVfd2lkdGg6IDEwLFxyXG5cdGxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0OiAxMCxcclxuXHRsZWdlbmRfdXNlUG9pbnQ6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHRpdGxlIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHRpdGxlIG9wdGlvbnNcclxuXHQgKiBAbmFtZSB0aXRsZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gdGl0bGUgVGl0bGUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZS50ZXh0XSBUaXRsZSB0ZXh0LiBJZiBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsgYWxsb3dpbmcgbXVsdGlsaW5lIHRpdGxlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGl0bGUucGFkZGluZy50b3A9MF0gVG9wIHBhZGRpbmcgdmFsdWUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnJpZ2h0PTBdIFJpZ2h0IHBhZGRpbmcgdmFsdWUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aXRsZS5wYWRkaW5nLmJvdHRvbT0wXSBCb3R0b20gcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RpdGxlLnBhZGRpbmcubGVmdD0wXSBMZWZ0IHBhZGRpbmcgdmFsdWUuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZS5wb3NpdGlvbj1jZW50ZXJdIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiAnY2VudGVyJywgJ3JpZ2h0JyBhbmQgJ2xlZnQnLlxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUaXRsZS5NdWx0aWxpbmVkVGl0bGUpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgdGl0bGU6IHtcclxuXHQgKiAgICAgIHRleHQ6IFwiVGl0bGUgVGV4dFwiLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBvciBNdWx0aWxpbmUgdGl0bGUgdGV4dFxyXG5cdCAqICAgICAgdGV4dDogXCJNYWluIHRpdGxlIHRleHRcXG5TdWIgdGl0bGUgdGV4dFwiLFxyXG5cdCAqXHJcblx0ICogICAgICBwYWRkaW5nOiB7XHJcblx0ICogICAgICAgICAgdG9wOiAxMCxcclxuXHQgKiAgICAgICAgICByaWdodDogMTAsXHJcblx0ICogICAgICAgICAgYm90dG9tOiAxMCxcclxuXHQgKiAgICAgICAgICBsZWZ0OiAxMFxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHR0aXRsZV90ZXh0OiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHRpdGxlX3BhZGRpbmc6IHtcclxuXHRcdHRvcDogMCxcclxuXHRcdHJpZ2h0OiAwLFxyXG5cdFx0Ym90dG9tOiAwLFxyXG5cdFx0bGVmdDogMFxyXG5cdH0sXHJcblx0dGl0bGVfcG9zaXRpb246IDxcImNlbnRlclwifFwicmlnaHRcInxcImxlZnRcIj4gXCJjZW50ZXJcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB0b29sdGlwIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVG9vbHRpcCBvcHRpb25zXHJcblx0ICogQG5hbWUgdG9vbHRpcFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gdG9vbHRpcCBUb29sdGlwIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgdG9vbHRpcC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0b29sdGlwLmRvTm90SGlkZT1mYWxzZV0gTWFrZSB0b29sdGlwIGtlZXAgc2hvd2luZyBub3QgaGlkaW5nIG9uIGludGVyYWN0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAuZ3JvdXBlZD10cnVlXSBTZXQgaWYgdG9vbHRpcCBpcyBncm91cGVkIG9yIG5vdCBmb3IgdGhlIGRhdGEgcG9pbnRzLlxyXG5cdCAqICAgLSAqKk5PVEU6KiogVGhlIG92ZXJsYXBwZWQgZGF0YSBwb2ludHMgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgZ3JvdXBlZCBldmVuIGlmIHNldCBmYWxzZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0b29sdGlwLmxpbmtlZD1mYWxzZV0gU2V0IGlmIHRvb2x0aXBzIG9uIGFsbCB2aXNpYmxlIGNoYXJ0cyB3aXRoIGxpa2UgeCBwb2ludHMgYXJlIHNob3duIHRvZ2V0aGVyIHdoZW4gb25lIGlzIHNob3duLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdG9vbHRpcC5saW5rZWQubmFtZT1cIlwiXSBHcm9waW5nIG5hbWUgZm9yIGxpbmtlZCB0b29sdGlwLjxicj5JZiBzcGVjaWZpZWQsIGxpbmtlZCB0b29sdGlwIHdpbGwgYmUgZ3JvcGVkIGludGVyYWN0aW5nIHRvIGJlIHdvcmtlZCBvbmx5IHdpdGggdGhlIHNhbWUgbmFtZS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQudGl0bGVdIFNldCBmb3JtYXQgZm9yIHRoZSB0aXRsZSBvZiB0b29sdGlwLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQubmFtZV0gU2V0IGZvcm1hdCBmb3IgdGhlIG5hbWUgb2YgZWFjaCBkYXRhIGluIHRvb2x0aXAuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgbmFtZSwgcmF0aW8sIGlkIGFuZCBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LiByYXRpbyB3aWxsIGJlIHVuZGVmaW5lZCBpZiB0aGUgY2hhcnQgaXMgbm90IGRvbnV0L3BpZS9nYXVnZS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQudmFsdWVdIFNldCBmb3JtYXQgZm9yIHRoZSB2YWx1ZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxyXG5cdCAqICBJZiB1bmRlZmluZWQgcmV0dXJuZWQsIHRoZSByb3cgb2YgdGhhdCB2YWx1ZSB3aWxsIGJlIHNraXBwZWQuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAucG9zaXRpb25dIFNldCBjdXN0b20gcG9zaXRpb24gZnVuY3Rpb24gZm9yIHRoZSB0b29sdGlwLjxicj5cclxuXHQgKiAgVGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIHBvc2l0aW9uIGJ5IHJldHVybmluZyBvYmplY3QgdGhhdCBoYXMgdG9wIGFuZCBsZWZ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258b2JqZWN0fSBbdG9vbHRpcC5jb250ZW50c10gU2V0IGN1c3RvbSBIVE1MIGZvciB0aGUgdG9vbHRpcC48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBkYXRhLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCBhbmQgY29sb3Igb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gSWYgdG9vbHRpcC5ncm91cGVkIGlzIHRydWUsIGRhdGEgaW5jbHVkZXMgbXVsdGlwbGUgZGF0YSBwb2ludHMuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt0b29sdGlwLmNvbnRlbnRzLmJpbmR0bz11bmRlZmluZWRdIFNldCBDU1Mgc2VsZWN0b3Igb3IgZWxlbWVudCByZWZlcmVuY2UgdG8gYmluZCB0b29sdGlwLlxyXG5cdCAqICAtICoqTk9URToqKiBXaGVuIGlzIHNwZWNpZmllZCwgd2lsbCBub3QgYmUgdXBkYXRpbmcgdG9vbHRpcCdzIHBvc2l0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdG9vbHRpcC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCB0b29sdGlwJ3MgdGVtcGxhdGUuPGJyPjxicj5cclxuXHQgKiAgV2l0aGluIHRlbXBsYXRlLCBiZWxvdyBzeW50YXggd2lsbCBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XHJcblx0ICogICAgLSAqKnt7IC4uLiB9fSoqOiB0aGUgZG91Ymx5IGN1cmx5IGJyYWNrZXRzIGluZGljYXRlIGxvb3AgYmxvY2sgZm9yIGRhdGEgcm93cy5cclxuXHQgKiAgICAtICoqez1DTEFTU19UT09MVElQfSoqOiBkZWZhdWx0IHRvb2x0aXAgY2xhc3MgbmFtZSBgYmItdG9vbHRpcGAuXHJcblx0ICogICAgLSAqKns9Q0xBU1NfVE9PTFRJUF9OQU1FfSoqOiBkZWZhdWx0IHRvb2x0aXAgZGF0YSBjbGFzcyBuYW1lIChleC4gYGJiLXRvb2x0aXAtbmFtZS1kYXRhMWApXHJcblx0ICogICAgLSAqKns9VElUTEV9Kio6IHRpdGxlIHZhbHVlLlxyXG5cdCAqICAgIC0gKip7PUNPTE9SfSoqOiBkYXRhIGNvbG9yLlxyXG5cdCAqICAgIC0gKip7PVZBTFVFfSoqOiBkYXRhIHZhbHVlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdG9vbHRpcC5jb250ZW50cy50ZXh0PXVuZGVmaW5lZF0gU2V0IGFkZGl0aW9uYWwgdGV4dCBjb250ZW50IHdpdGhpbiBkYXRhIGxvb3AsIHVzaW5nIHRlbXBsYXRlIHN5bnRheC5cclxuXHQgKiAgLSAqKk5PVEU6KiogSXQgc2hvdWxkIGNvbnRhaW4gYHsga2V5OiBBcnJheSwgLi4uIH1gIHZhbHVlXHJcblx0ICogICAgLSAna2V5JyBuYW1lIGlzIHVzZWQgYXMgc3Vic3RpdHV0aW9uIHdpdGhpbiB0ZW1wbGF0ZSBhcyAnez1LRVl9J1xyXG5cdCAqICAgIC0gVGhlIHZhbHVlIGFycmF5IGxlbmd0aCBzaG91bGQgbWF0Y2ggd2l0aCB0aGUgZGF0YSBsZW5ndGhcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0b29sdGlwLmluaXQuc2hvdz1mYWxzZV0gU2hvdyB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3Rvb2x0aXAuaW5pdC54PTBdIFNldCB4IEF4aXMgaW5kZXggdG8gYmUgc2hvd24gYXQgdGhlIGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdG9vbHRpcC5pbml0LnBvc2l0aW9uPXt0b3A6IFwiMHB4XCIsbGVmdDogXCI1MHB4XCJ9XSBTZXQgdGhlIHBvc2l0aW9uIG9mIHRvb2x0aXAgYXQgdGhlIGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd10gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIHNob3duLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZV0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5vbnNob3duXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBzaG93blxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZGVuXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd8RnVuY3Rpb258bnVsbH0gW3Rvb2x0aXAub3JkZXI9bnVsbF0gU2V0IHRvb2x0aXAgZGF0YSBkaXNwbGF5IG9yZGVyLjxicj48YnI+XHJcblx0ICogICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqICAtIGBkZXNjYDogSW4gZGVzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXHJcblx0ICogIC0gYGFzY2A6IEluIGFzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXHJcblx0ICogIC0gYG51bGxgOiBJdCBrZWVwcyB0aGUgZGF0YSBkaXNwbGF5IG9yZGVyPGJyPlxyXG5cdCAqICAgICAqKk5PVEU6KiogV2hlbiBgZGF0YS5ncm91cHNgIGlzIHNldCwgdGhlIG9yZGVyIHdpbGwgZm9sbG93IGFzIHRoZSBzdGFja2VkIGdyYXBoIG9yZGVyLjxicj5cclxuXHQgKiAgICAgIElmIHdhbnQgdG8gb3JkZXIgYXMgZGF0YSBib3VuZCwgc2V0IGFueSB2YWx1ZSByYXRoZXIgdGhhbiBhc2MsIGRlc2Mgb3IgbnVsbC4gKGV4LiBlbXB0eSBzdHJpbmcgXCJcIilcclxuXHQgKiAgLSBgZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IC4uLiB9YDogW0FycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpXHJcblx0ICogQHNlZSBbRGVtbzogSGlkZSBUb29sdGlwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5IaWRlVG9vbHRpcClcclxuXHQgKiBAc2VlIFtEZW1vOiBUb29sdGlwIEdyb3VwaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwR3JvdXBpbmcpXHJcblx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBGb3JtYXRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBGb3JtYXQpXHJcblx0ICogQHNlZSBbRGVtbzogTGlua2VkIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkxpbmtlZFRvb2x0aXBzKVxyXG5cdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgVGVtcGxhdGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBUZW1wbGF0ZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICB0b29sdGlwOiB7XHJcblx0ICogICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICAgZG9Ob3RIaWRlOiB0cnVlLFxyXG5cdCAqICAgICAgZ3JvdXBlZDogZmFsc2UsXHJcblx0ICogICAgICBmb3JtYXQ6IHtcclxuXHQgKiAgICAgICAgICB0aXRsZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gXCJEYXRhIFwiICsgeDsgfSxcclxuXHQgKiAgICAgICAgICBuYW1lOiBmdW5jdGlvbihuYW1lLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiBuYW1lOyB9LFxyXG5cdCAqICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkLCBpbmRleCkgeyByZXR1cm4gcmF0aW87IH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodCwgZWxlbWVudCkge1xyXG5cdCAqICAgICAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiAwfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgY29udGVudHM6IGZ1bmN0aW9uKGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xyXG5cdCAqICAgICAgICAgIHJldHVybiAuLi4gLy8gZm9ybWF0dGVkIGh0bWwgYXMgeW91IHdhbnRcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBzcGVjaWZ5IHRvb2x0aXAgY29udGVudHMgdXNpbmcgdGVtcGxhdGVcclxuXHQgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcclxuXHQgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XHJcblx0ICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPjwvbGk+XHJcblx0ICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTJcIj48c3Bhbj41MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+PC9saT5cclxuXHQgKiAgICAgICAvLyA8L3VsPlxyXG5cdCAqICAgICAgIGNvbnRlbnRzOiB7XHJcblx0ICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxyXG5cdCAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXHJcblx0ICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+PGJyPicgK1xyXG5cdCAqICAgICAgXHRcdFx0JzxzcGFuIHN0eWxlPWNvbG9yOns9Q09MT1J9Pns9TkFNRX08L3NwYW4+PC9saT4nICtcclxuXHQgKiAgICAgIFx0XHQnfX08L3VsPidcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIHdpdGggYWRkaXRpb25hbCB0ZXh0IHZhbHVlXHJcblx0ICogICAgICAgLy8gLSBleGFtcGxlIG9mIEhUTUwgcmV0dXJuZWQ6XHJcblx0ICogICAgICAgLy8gPHVsIGNsYXNzPVwiYmItdG9vbHRpcFwiPlxyXG5cdCAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGExXCI+PHNwYW4+MjUwPC9zcGFuPjxicj5jb21tZW50MTxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPnRleHQxPC9saT5cclxuXHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj5jb21tZW50MjxzcGFuIHN0eWxlPVwiY29sb3I6I2ZhNzE3MVwiPmRhdGEyPC9zcGFuPnRleHQyPC9saT5cclxuXHQgKiAgICAgICAvLyA8L3VsPlxyXG5cdCAqICAgICAgIGNvbnRlbnRzOiB7XHJcblx0ICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxyXG5cdCAqICAgICAgXHR0ZXh0OiB7XHJcblx0ICogICAgICBcdFx0Ly8gYSkgJ2tleScgbmFtZSBpcyB1c2VkIGFzIHN1YnN0aXR1dGlvbiB3aXRoaW4gdGVtcGxhdGUgYXMgJ3s9S0VZfSdcclxuXHQgKiAgICAgIFx0XHQvLyBiKSB0aGUgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxyXG5cdCAqICAgICAgXHRcdFZBUjE6IFtcInRleHQxXCIsIFwidGV4dDJcIl0sXHJcblx0ICogICAgICBcdFx0VkFSMjogW1wiY29tbWVudDFcIiwgXCJjb21tZW50MlwiXSxcclxuXHQgKiAgICAgIFx0fSxcclxuXHQgKiAgICAgIFx0dGVtcGxhdGU6ICc8dWwgY2xhc3M9ez1DTEFTU19UT09MVElQfT57eycgK1xyXG5cdCAqICAgICAgXHRcdFx0JzxsaSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPjxzcGFuPns9VkFMVUV9PC9zcGFuPns9VkFSMn08YnI+JyArXHJcblx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj57PVZBUjF9PC9saT4nICtcclxuXHQgKiAgICAgIFx0XHQnfX08L3VsPidcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc29ydCB0b29sdGlwIGRhdGEgdmFsdWUgZGlzcGxheSBpbiBhc2NlbmRpbmcgb3JkZXJcclxuXHQgKiAgICAgIG9yZGVyOiBcImFzY1wiLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzcGVjaWZ5aW5nIHNvcnQgZnVuY3Rpb25cclxuXHQgKiAgICAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XHJcblx0ICogICAgICAgICAvLyBwYXJhbSBkYXRhIHBhc3NlZCBmb3JtYXRcclxuXHQgKiAgICAgICAgIHt4OiA1LCB2YWx1ZTogMjUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNSwgbmFtZTogXCJkYXRhMVwifVxyXG5cdCAqICAgICAgICAgICAuLi5cclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNob3cgYXQgdGhlIGluaXRpYWxpemF0aW9uXHJcblx0ICogICAgICBpbml0OiB7XHJcblx0ICogICAgICAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgICAgICB4OiAyLFxyXG5cdCAqICAgICAgICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgICAgICAgIHRvcDogXCIxNTBweFwiLFxyXG5cdCAqICAgICAgICAgICAgICBsZWZ0OiBcIjI1MHB4XCJcclxuXHQgKiAgICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBmaXJlcyBwcmlvciB0b29sdGlwIGlzIHNob3duXHJcblx0ICogICAgICBvbnNob3c6IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcblx0ICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxyXG5cdCAqXHJcblx0ICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG5cdCAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxyXG5cdCAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBmaXJlcyBwcmlvciB0b29sdGlwIGlzIGhpZGRlblxyXG5cdCAqICAgICAgb25oaWRlOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG5cdCAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuXHQgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuXHQgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZmlyZXMgYWZ0ZXIgdG9vbHRpcCBpcyBzaG93blxyXG5cdCAqICAgICAgb25zaG93bjogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuXHQgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcblx0ICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcblx0ICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGZpcmVzIGFmdGVyIHRvb2x0aXAgaXMgaGlkZGVuXHJcblx0ICogICAgICBvbmhpZGRlbjogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuXHQgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcblx0ICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcblx0ICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIExpbmsgYW55IHRvb2x0aXBzIHdoZW4gbXVsdGlwbGUgY2hhcnRzIGFyZSBvbiB0aGUgc2NyZWVuIHdoZXJlIHNhbWUgeCBjb29yZGluYXRlcyBhcmUgYXZhaWxhYmxlXHJcblx0ICogICAgICAvLyBVc2VmdWwgZm9yIHRpbWVzZXJpZXMgY29ycmVsYXRpb25cclxuXHQgKiAgICAgIGxpbmtlZDogdHJ1ZSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gU3BlY2lmeSBuYW1lIHRvIGludGVyYWN0IHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBvbmx5LlxyXG5cdCAqICAgICAgbGlua2VkOiB7XHJcblx0ICogICAgICAgICAgbmFtZTogXCJzb21lLWdyb3VwXCJcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHRvb2x0aXBfc2hvdzogdHJ1ZSxcclxuXHR0b29sdGlwX2RvTm90SGlkZTogZmFsc2UsXHJcblx0dG9vbHRpcF9ncm91cGVkOiB0cnVlLFxyXG5cdHRvb2x0aXBfZm9ybWF0X3RpdGxlOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0dG9vbHRpcF9mb3JtYXRfbmFtZTogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHRvb2x0aXBfZm9ybWF0X3ZhbHVlOiA8KCgpID0+IG51bWJlcil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0dG9vbHRpcF9wb3NpdGlvbjogPCgoKSA9PiB7dG9wOiBudW1iZXI7IGxlZnQ6IG51bWJlcjt9KXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR0b29sdGlwX2NvbnRlbnRzOiA8XHJcblx0XHRcdCgoKSA9PiBzdHJpbmcpfHtiaW5kdG86IHN0cmluZzsgdGVtcGxhdGU6IHN0cmluZzsgdGV4dD86IHtba2V5OiBzdHJpbmddOiBzdHJpbmdbXX19XHJcblx0XHQ+IHt9LFxyXG5cdHRvb2x0aXBfaW5pdF9zaG93OiBmYWxzZSxcclxuXHR0b29sdGlwX2luaXRfeDogMCxcclxuXHR0b29sdGlwX2luaXRfcG9zaXRpb246IHtcclxuXHRcdHRvcDogXCIwcHhcIixcclxuXHRcdGxlZnQ6IFwiNTBweFwiXHJcblx0fSxcclxuXHR0b29sdGlwX2xpbmtlZDogZmFsc2UsXHJcblx0dG9vbHRpcF9saW5rZWRfbmFtZTogXCJcIixcclxuXHR0b29sdGlwX29uc2hvdzogKCkgPT4ge30sXHJcblx0dG9vbHRpcF9vbmhpZGU6ICgpID0+IHt9LFxyXG5cdHRvb2x0aXBfb25zaG93bjogKCkgPT4ge30sXHJcblx0dG9vbHRpcF9vbmhpZGRlbjogKCkgPT4ge30sXHJcblx0dG9vbHRpcF9vcmRlcjogPHN0cmluZ3xGdW5jdGlvbnxudWxsPiBudWxsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIEF4aXMgYmFzZWQgY2hhcnQgZGF0YSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNwZWNpZnkgdGhlIGtleSBvZiB4IHZhbHVlcyBpbiB0aGUgZGF0YS48YnI+PGJyPlxyXG5cdCAqIFdlIGNhbiBzaG93IHRoZSBkYXRhIHdpdGggbm9uLWluZGV4IHggdmFsdWVzIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHRoZSB0eXBlIG9mIHggYXhpcyBpcyB0aW1lc2VyaWVzLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgb24gY2F0ZWdvcnkgYXhpcywgdGhlIHZhbHVlcyBvZiB0aGUgZGF0YSBvbiB0aGUga2V5IHdpbGwgYmUgdXNlZCBmb3IgY2F0ZWdvcnkgbmFtZXMuXHJcblx0ICogQG5hbWUgZGF0YeKApHhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICB4OiBcImRhdGVcIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3g6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNwZWNpZnkgdGhlIGtleXMgb2YgdGhlIHggdmFsdWVzIGZvciBlYWNoIGRhdGEuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCBpZiB3ZSB3YW50IHRvIHNob3cgdGhlIGRhdGEgdGhhdCBoYXMgZGlmZmVyZW50IHggdmFsdWVzLlxyXG5cdCAqIEBuYW1lIGRhdGHigKR4c1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgeHM6IHtcclxuXHQgKiAgICAgIGRhdGExOiBcIngxXCIsXHJcblx0ICogICAgICBkYXRhMjogXCJ4MlwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfeHM6IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBmb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIHN0cmluZyBzcGVjaWZlZCBhcyB4LlxyXG5cdCAqIEBuYW1lIGRhdGHigKR4Rm9ybWF0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0ICVZLSVtLSVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgeDogXCJ4XCIsXHJcblx0ICogICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgICBbXCJ4XCIsIFwiMDEwMTIwMTlcIiwgXCIwMjAxMjAxOVwiLCBcIjAzMDEyMDE5XCJdLFxyXG5cdCAqICAgICAgICBbXCJkYXRhMVwiLCAzMCwgMjAwLCAxMDBdXHJcblx0ICogICAgXSxcclxuXHQgKiAgICAvLyBGb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIGFzIGRhdGV0aW1lIGZvciBnaXZlbiAneCcgc3RyaW5nIHZhbHVlXHJcblx0ICogICAgeEZvcm1hdDogXCIlbSVkJVlcIlxyXG5cdCAqIH0sXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgIHg6IHtcclxuXHQgKiAgICAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxyXG5cdCAqL1xyXG5cdGRhdGFfeEZvcm1hdDogXCIlWS0lbS0lZFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbG9jYWx0aW1lIGZvcm1hdCB0byBwYXJzZSB4IGF4aXMuXHJcblx0ICogQG5hbWUgZGF0YeKApHhMb2NhbHRpbWVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHhMb2NhbHRpbWU6IGZhbHNlXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfeExvY2FsdGltZTogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBvbiB4IGF4aXMuXHJcblx0ICogQG5hbWUgZGF0YeKApHhTb3J0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICB4U29ydDogZmFsc2VcclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV94U29ydDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGdyb3VwcyBmb3IgdGhlIGRhdGEgZm9yIHN0YWNraW5nLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRncm91cHNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCBbXVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgZ3JvdXBzOiBbXHJcblx0ICogICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXHJcblx0ICogICAgIFtcImRhdGEzXCJdXHJcblx0ICogICBdXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfZ3JvdXBzOiA8c3RyaW5nW11bXT4gW10sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB5IGF4aXMgdGhlIGRhdGEgcmVsYXRlZCB0by4geSBhbmQgeTIgY2FuIGJlIHVzZWQuXHJcblx0ICogLSAqKk5PVEU6KiogSWYgYWxsIGRhdGEgaXMgcmVsYXRlZCB0byBvbmUgb2YgdGhlIGF4ZXMsIHRoZSBkb21haW4gb2YgYXhpcyB3aXRob3V0IHJlbGF0ZWQgZGF0YSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBkb21haW4gZnJvbSB0aGUgYXhpcyB3aXRoIHJlbGF0ZWQgZGF0YVxyXG5cdCAqIEBuYW1lIGRhdGHigKRheGVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBheGVzOiB7XHJcblx0ICogICAgIGRhdGExOiBcInlcIixcclxuXHQgKiAgICAgZGF0YTI6IFwieTJcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2F4ZXM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsYWJlbHMgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGRhdGHigKRsYWJlbHNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkYXRhLmxhYmVscz1mYWxzZV0gU2hvdyBvciBoaWRlIGxhYmVscyBvbiBlYWNoIGRhdGEgcG9pbnRzXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZGF0YS5sYWJlbHMuY2VudGVyZWQ9ZmFsc2VdIENlbnRlcml6ZSBsYWJlbHMgb24gYGJhcmAgc2hhcGUuICgqKk5PVEU6Kiogd29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZGF0YS5sYWJlbHMuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZ1bmN0aW9uIGZvciBkYXRhIGxhYmVscy48YnI+XHJcblx0ICogVGhlIGZvcm1hdHRlciBmdW5jdGlvbiByZWNlaXZlcyA0IGFyZ3VtZW50cyBzdWNoIGFzIHYsIGlkLCBpLCBqIGFuZCBpdCBtdXN0IHJldHVybiBhIHN0cmluZyB0aGF0IHdpbGwgYmUgc2hvd24gYXMgdGhlIGxhYmVsLiBUaGUgYXJndW1lbnRzIGFyZTo8YnI+XHJcblx0ICogIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcblx0ICogIC0gYGlkYCBpcyB0aGUgaWQgb2YgdGhlIGRhdGEgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxyXG5cdCAqICAtIGBpYCBpcyB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxyXG5cdCAqICAtIGBqYCBpcyB0aGUgc3ViIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi48YnI+PGJyPlxyXG5cdCAqIEZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgZGVmaW5lZCBmb3IgZWFjaCBkYXRhIGJ5IHNwZWNpZnlpbmcgYXMgYW4gb2JqZWN0IGFuZCBEMyBmb3JtYXR0ZXIgZnVuY3Rpb24gY2FuIGJlIHNldCAoZXguIGQzLmZvcm1hdCgnJCcpKVxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfG9iamVjdH0gW2RhdGEubGFiZWxzLmNvbG9yc10gU2V0IGxhYmVsIHRleHQgY29sb3JzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZGF0YS5sYWJlbHMucG9zaXRpb25dIFNldCBlYWNoIGRhdGFzZXQgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkYXRhLmxhYmVscy5wb3NpdGlvbi55PTBdIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbClcclxuXHQgKiBAc2VlIFtEZW1vOiBsYWJlbCBjb2xvcnNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbENvbG9ycylcclxuXHQgKiBAc2VlIFtEZW1vOiBsYWJlbCBmb3JtYXRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbEZvcm1hdClcclxuXHQgKiBAc2VlIFtEZW1vOiBsYWJlbCBvdmVybGFwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxPdmVybGFwKVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxQb3NpdGlvbilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGxhYmVsczogdHJ1ZSxcclxuXHQgKlxyXG5cdCAqICAgLy8gb3Igc2V0IHNwZWNpZmljIG9wdGlvbnNcclxuXHQgKiAgIGxhYmVsczoge1xyXG5cdCAqICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHYsIGlkLCBpLCBqKSB7IC4uLiB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIGl0J3MgcG9zc2libGUgdG8gc2V0IGZvciBlYWNoIGRhdGFcclxuXHQgKiAgICAgZm9ybWF0OiB7XHJcblx0ICogICAgICAgICBkYXRhMTogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXHJcblx0ICogICAgICAgICAuLi5cclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBhbGlnbiB0ZXh0IHRvIGNlbnRlciBvZiB0aGUgJ2Jhcicgc2hhcGUgKHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXHJcblx0ICogICAgIGNlbnRlcmVkOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAgIC8vIGFwcGx5IGZvciBhbGwgbGFiZWwgdGV4dHNcclxuXHQgKiAgICAgY29sb3JzOiBcInJlZFwiLFxyXG5cdCAqXHJcblx0ICogICAgIC8vIG9yIHNldCBkaWZmZXJlbnQgY29sb3JzIHBlciBkYXRhc2V0XHJcblx0ICogICAgIC8vIGZvciBub3Qgc3BlY2lmaWVkIGRhdGFzZXQsIHdpbGwgaGF2ZSB0aGUgZGVmYXVsdCBjb2xvciB2YWx1ZVxyXG5cdCAqICAgICBjb2xvcnM6IHtcclxuXHQgKiAgICAgICAgZGF0YTE6IFwieWVsbG93XCIsXHJcblx0ICogICAgICAgIGRhdGEzOiBcImdyZWVuXCJcclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBzZXQgeCwgeSBjb29yZGluYXRlIHBvc2l0aW9uXHJcblx0ICogICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgIHg6IC0xMCxcclxuXHQgKiAgICAgICAgeTogMTBcclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgeCwgeSBjb29yZGluYXRlIHBvc2l0aW9uIGJ5IGVhY2ggZGF0YXNldFxyXG5cdCAqICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICBkYXRhMToge3g6IDUsIHk6IDV9LFxyXG5cdCAqICAgICAgICBkYXRhMjoge3g6IDEwLCB5OiAtMjB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9sYWJlbHM6XHJcblx0XHQ8Ym9vbGVhbiB8IHtcclxuXHRcdFx0Y2VudGVyZWQ/OiBib29sZWFuO1xyXG5cdFx0XHRmb3JtYXQ/OiBGdW5jdGlvbjtcclxuXHRcdFx0Y29sb3JzPzogc3RyaW5nfHtba2V5OiBzdHJpbmddOiBzdHJpbmd9O1xyXG5cdFx0XHRwb3NpdGlvbj86IHtba2V5OiBzdHJpbmddOiBudW1iZXJ9fHtba2V5OiBzdHJpbmddOiB7eD86IG51bWJlcjsgeT86IG51bWJlcjt9fVxyXG5cdFx0fT4ge30sXHJcblx0ZGF0YV9sYWJlbHNfY29sb3JzOiA8c3RyaW5nfG9iamVjdHx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRkYXRhX2xhYmVsc19wb3NpdGlvbjoge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERlZmluZSByZWdpb25zIGZvciBlYWNoIGRhdGEuPGJyPlxyXG5cdCAqIFRoZSB2YWx1ZXMgbXVzdCBiZSBhbiBhcnJheSBmb3IgZWFjaCBkYXRhIGFuZCBpdCBzaG91bGQgaW5jbHVkZSBhbiBvYmplY3QgdGhhdCBoYXMgYHN0YXJ0YCwgYGVuZGAgYW5kIGBzdHlsZWAuXHJcblx0ICogLSBUaGUgb2JqZWN0IHR5cGUgc2hvdWxkIGJlIGFzOlxyXG5cdCAqICAgLSBzdGFydCB7bnVtYmVyfTogU3RhcnQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBzdGFydCB3aWxsIGJlIHRoZSBmaXJzdCBkYXRhIHBvaW50LlxyXG5cdCAqICAgLSBbZW5kXSB7bnVtYmVyfTogRW5kIGRhdGEgcG9pbnQgbnVtYmVyLiBJZiBub3Qgc2V0LCB0aGUgZW5kIHdpbGwgYmUgdGhlIGxhc3QgZGF0YSBwb2ludC5cclxuXHQgKiAgIC0gW3N0eWxlLmRhc2hhcnJheT1cIjIgMlwiXSB7b2JqZWN0fTogVGhlIGZpcnN0IG51bWJlciBzcGVjaWZpZXMgYSBkaXN0YW5jZSBmb3IgdGhlIGZpbGxlZCBhcmVhLCBhbmQgdGhlIHNlY29uZCBhIGRpc3RhbmNlIGZvciB0aGUgdW5maWxsZWQgYXJlYS5cclxuXHQgKiAtICoqTk9URToqKiBDdXJyZW50bHkgdGhpcyBvcHRpb24gc3VwcG9ydHMgb25seSBsaW5lIGNoYXJ0IGFuZCBkYXNoZWQgc3R5bGUuIElmIHRoaXMgb3B0aW9uIHNwZWNpZmllZCwgdGhlIGxpbmUgd2lsbCBiZSBkYXNoZWQgb25seSBpbiB0aGUgcmVnaW9ucy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkcmVnaW9uc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcmVnaW9uczoge1xyXG5cdCAqICAgICBkYXRhMTogW3tcclxuXHQgKiAgICAgICAgIHN0YXJ0OiAxLFxyXG5cdCAqICAgICAgICAgZW5kOiAyLFxyXG5cdCAqICAgICAgICAgc3R5bGU6IHtcclxuXHQgKiAgICAgICAgICAgICBkYXNoYXJyYXk6IFwiNSAyXCJcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgfSwge1xyXG5cdCAqICAgICAgICAgc3RhcnQ6IDNcclxuXHQgKiAgICAgfV0sXHJcblx0ICogICAgIC4uLlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3JlZ2lvbnM6IDx7c3RhcnQ/OiBudW1iZXI7IGVuZD86IG51bWJlcjsgc3R5bGU/OiB7ZGFzaGFycmF5OiBzdHJpbmc7fX1bXT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgc3RhY2tpbmcgdG8gYmUgbm9ybWFsaXplZFxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIEZvciBzdGFja2luZywgJ1tkYXRhLmdyb3Vwc10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0Z3JvdXBzKScgb3B0aW9uIHNob3VsZCBiZSBzZXRcclxuXHQgKiAgIC0geSBBeGlzIHdpbGwgYmUgc2V0IGluIHBlcmNlbnRhZ2UgdmFsdWUgKDAgfiAxMDAlKVxyXG5cdCAqICAgLSBNdXN0IGhhdmUgcG9zdGl2ZSB2YWx1ZXNcclxuXHQgKiBAbmFtZSBkYXRh4oCkc3RhY2vigKRub3JtYWxpemVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YVN0YWNrTm9ybWFsaXplZClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHN0YWNrOiB7XHJcblx0ICogICAgICBub3JtYWxpemU6IHRydWVcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9zdGFja19ub3JtYWxpemU6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGRhdGEuc2VsZWN0aW9uIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGRhdGEgc2VsZWN0aW9uIGVuYWJsZWQ8YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0cnVlLCB3ZSBjYW4gc2VsZWN0IHRoZSBkYXRhIHBvaW50cyBhbmQgZ2V0L3NldCBpdHMgc3RhdGUgb2Ygc2VsZWN0aW9uIGJ5IEFQSSAoZS5nLiBzZWxlY3QsIHVuc2VsZWN0LCBzZWxlY3RlZCkuXHJcblx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGVuYWJsZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YVNlbGVjdGlvbilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICBzZWxlY3Rpb246IHtcclxuXHQgKiAgICAgICBlbmFibGVkOiB0cnVlXHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3NlbGVjdGlvbl9lbmFibGVkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGdyb3VwZWQgc2VsZWN0aW9uIGVuYWJsZWQuPGJyPjxicj5cclxuXHQgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgbXVsdGlwbGUgZGF0YSBwb2ludHMgdGhhdCBoYXZlIHNhbWUgeCB2YWx1ZSB3aWxsIGJlIHNlbGVjdGVkIGJ5IG9uZSBzZWxlY3Rpb24uXHJcblx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGdyb3VwZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgc2VsZWN0aW9uOiB7XHJcblx0ICogICAgICAgZ3JvdXBlZDogdHJ1ZVxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZDogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIGZvciBlYWNoIGRhdGEgcG9pbnQgdG8gZGV0ZXJtaW5lIGlmIGl0J3Mgc2VsZWN0YWJsZSBvciBub3QuPGJyPjxicj5cclxuXHQgKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIGQgYXMgYW4gYXJndW1lbnQgYW5kIGl0IGhhcyBzb21lIHBhcmFtZXRlcnMgbGlrZSBpZCwgdmFsdWUsIGluZGV4LiBUaGlzIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gYm9vbGVhbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkaXNzZWxlY3RhYmxlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgc2VsZWN0aW9uOiB7XHJcblx0ICogICAgICAgaXNzZWxlY3RhYmxlOiBmdW5jdGlvbihkKSB7IC4uLiB9XHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGU6ICgpID0+IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBtdWx0aXBsZSBkYXRhIHBvaW50cyBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBtdWx0aWxlIGRhdGEgcG9pbnRzIGNhbiBoYXZlIHRoZSBzZWxlY3RlZCBzdGF0ZSBhdCB0aGUgc2FtZSB0aW1lLiBJZiBmYWxzZSBzZXQsIG9ubHkgb25lIGRhdGEgcG9pbnQgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgdW5zZWxlY3RlZCB3aGVuIHRoZSBuZXcgZGF0YSBwb2ludCBpcyBzZWxlY3RlZC5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkbXVsdGlwbGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICBzZWxlY3Rpb246IHtcclxuXHQgKiAgICAgICBtdWx0aXBsZTogZmFsc2VcclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX211bHRpcGxlOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbmFibGUgdG8gc2VsZWN0IGRhdGEgcG9pbnRzIGJ5IGRyYWdnaW5nLlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBkYXRhIHBvaW50cyBjYW4gYmUgc2VsZWN0ZWQgYnkgZHJhZ2dpbmcuXHJcblx0ICogLSAqKk5PVEU6KiogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIHNjcm9sbGluZyBvbiB0aGUgY2hhcnQgd2lsbCBiZSBkaXNhYmxlZCBiZWNhdXNlIGRyYWdnaW5nIGV2ZW50IHdpbGwgaGFuZGxlIHRoZSBldmVudC5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZHJhZ2dhYmxlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHNlbGVjdGlvbjoge1xyXG5cdCAqICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSBzZWxlY3Rpb24uXHJcblx0ICogQG5hbWUgZGF0YeKApG9uc2VsZWN0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIG9uc2VsZWN0ZWQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuXHQgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cclxuXHQgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vbnNlbGVjdGVkOiAoKSA9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgdW4tc2VsZWN0aW9uLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbnVuc2VsZWN0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIG9udW5zZWxlY3RlZDogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG5cdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29udW5zZWxlY3RlZDogKCkgPT4ge31cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHggYXhpcyBlbGVtZW50XHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRjbGlwUGF0aFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBzZWUgW0RlbW9dKClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHQgKiBjbGlwUGF0aDogZmFsc2VcclxuXHQgKi9cclxuXHRheGlzX3hfY2xpcFBhdGg6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB4IGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHNob3c6IGZhbHNlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdHlwZSBvZiB4IGF4aXMuPGJyPjxicj5cclxuXHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAtIHRpbWVzZXJpZXNcclxuXHQgKiAtIGNhdGVnb3J5XHJcblx0ICogLSBpbmRleGVkXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0eXBlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IGluZGV4ZWRcclxuXHQgKiBAc2VlIFtEZW1vOiBpbmRleGVkXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxyXG5cdCAqIEBzZWUgW0RlbW86IHRpbWVzZXJpZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5UaW1lc2VyaWVzQ2hhcnQpXHJcblx0ICogQHNlZSBbRGVtbzogY2F0ZWdvcnldKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkNhdGVnb3J5RGF0YSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3R5cGU6IDxcImluZGV4ZWRcInxcInRpbWVzZXJpZXNcInxcImNhdGVnb3J5XCI+IFwiaW5kZXhlZFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgaG93IHRvIHRyZWF0IHRoZSB0aW1lem9uZSBvZiB4IHZhbHVlcy48YnI+XHJcblx0ICogSWYgdHJ1ZSwgdHJlYXQgeCB2YWx1ZSBhcyBsb2NhbHRpbWUuIElmIGZhbHNlLCBjb252ZXJ0IHRvIFVUQyBpbnRlcm5hbGx5LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkbG9jYWx0aW1lXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGxvY2FsdGltZTogZmFsc2VcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X2xvY2FsdGltZTogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXHJcblx0ICogVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRjYXRlZ29yaWVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgW11cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgY2F0ZWdvcmllczogW1wiQ2F0ZWdvcnkgMVwiLCBcIkNhdGVnb3J5IDJcIiwgLi4uXVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfY2F0ZWdvcmllczogPHN0cmluZ1tdPiBbXSxcclxuXHJcblx0LyoqXHJcblx0ICogY2VudGVyaXplIHRpY2tzIG9uIGNhdGVnb3J5IGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY2VudGVyZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjZW50ZXJlZDogdHJ1ZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2NlbnRlcmVkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogQSBmdW5jdGlvbiB0byBmb3JtYXQgdGljayB2YWx1ZS4gRm9ybWF0IHN0cmluZyBpcyBhbHNvIGF2YWlsYWJsZSBmb3IgdGltZXNlcmllcyBkYXRhLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZvcm1hdFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufHN0cmluZ31cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIFtEMydzIHRpbWUgc3BlY2lmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXQjbG9jYWxlX2Zvcm1hdClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcywgYSAnZGF0ZXRpbWUnIG9iamVjdCBpcyBnaXZlbiBhcyBwYXJhbWV0ZXJcclxuXHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgcmV0dXJuIHguZ2V0RnVsbFllYXIoKTtcclxuXHQgKiAgICAgICB9XHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBmb3IgY2F0ZWdvcnksIGluZGV4KE51bWJlcikgYW5kIGNhdGVnb3J5TmFtZShTdHJpbmcpIGFyZSBnaXZlbiBhcyBwYXJhbWV0ZXJcclxuXHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKGluZGV4LCBjYXRlZ29yeU5hbWUpIHtcclxuXHQgKiAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5TmFtZS5zdWJzdHIoMCwgMTApO1xyXG5cdCAqICAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgICAgLy8gZm9yIHRpbWVzZXJpZXMgZm9ybWF0IHNwZWNpZmllclxyXG5cdCAqICAgICAgICBmb3JtYXQ6IFwiJVktJW0tJWQgJUg6JU06JVNcIlxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2Zvcm1hdDogPEZ1bmN0aW9ufHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0dGluZyBmb3IgY3VsbGluZyB0aWNrcy48YnI+PGJyPlxyXG5cdCAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxyXG5cdCAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLngudGljay5jdWxsaW5nLm1heC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjdWxsaW5nXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdFxyXG5cdCAqIC0gdHJ1ZSBmb3IgaW5kZXhlZCBheGlzIGFuZCB0aW1lc2VyaWVzIGF4aXNcclxuXHQgKiAtIGZhbHNlIGZvciBjYXRlZ29yeSBheGlzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2N1bGxpbmc6IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjdWxsaW5n4oCkbWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDEwXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjdWxsaW5nOiB7XHJcblx0ICogICAgICAgICAgIG1heDogNVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja19jdWxsaW5nX21heDogMTAsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBudW1iZXIgb2YgeCBheGlzIHRpY2tzIHRvIHNob3cuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBoaWRlcyB0aWNrIGxpbmVzIHRvZ2V0aGVyIHdpdGggdGljayB0ZXh0LiBJZiB0aGlzIG9wdGlvbiBpcyB1c2VkIG9uIHRpbWVzZXJpZXMgYXhpcywgdGhlIHRpY2tzIHBvc2l0aW9uIHdpbGwgYmUgZGV0ZXJtaW5lZCBwcmVjaXNlbHkgYW5kIG5vdCBuaWNlbHkgcG9zaXRpb25lZCAoZS5nLiBpdCB3aWxsIGhhdmUgcm91Z2ggc2Vjb25kIHZhbHVlKS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjb3VudFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGNvdW50OiA1XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfY291bnQ6IDxudW1iZXJ8dW5kZWZpbmVkPnVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkc2hvd1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIHggQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgICAgeDogMTAsXHJcblx0ICogICAgICAgICAgIHk6IDEwXHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcblx0LyoqXHJcblx0ICogRml0IHggYXhpcyB0aWNrcy5cclxuXHQgKiAtICoqdHJ1ZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgbmljZWx5IHRvIGhhdmUgc2FtZSBpbnRlcnZhbHMuXHJcblx0ICogLSAqKmZhbHNlKio6IHRpY2tzIHdpbGwgYmUgcG9zaXRpb25lZCBhY2NvcmRpbmcgdG8geCB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZml0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrRml0dGluZylcclxuXHQgKiBAc2VlIFtEZW1vOiBmb3IgdGltZXNlcmllcyB6b29tXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tUaW1lc2VyaWVzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgZml0OiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2ZpdDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSB4IHZhbHVlcyBvZiB0aWNrcyBtYW51YWxseS48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aG9zZSB2YWx1ZXMuPGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIHdvcmtzIHdpdGggYHRpbWVzZXJpZXNgIGRhdGEgYW5kIHRoZSB4IHZhbHVlcyB3aWxsIGJlIHBhcnNlZCBhY2NvZGluZyB0byB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYW5kIGRhdGEueEZvcm1hdCBvcHRpb24uXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdmFsdWVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdmFsdWVzOiBbMSwgMiwgNCwgOCwgMTYsIDMyLCAuLi5dLFxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcblx0ICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcclxuXHQgKiAgICAgICBcdHJldHVybiBbIC4uLiBdO1xyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja192YWx1ZXM6IDwoc3RyaW5nfERhdGV8bnVtYmVyKVtdfCgoKT0+IG51bWJlcltdKXxudWxsPiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBSb3RhdGUgeCBheGlzIHRpY2sgdGV4dCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGZvciAnY2F0ZWdvcnknIGFuZCAndGltZXNlcmllcycgdHlwZSBheGlzLlxyXG5cdCAqIC0gKipOT1RFOioqIFRoZSBjb25kaXRpb25zIHdoZXJlIGBhdXRvcm90YXRlYCBpcyBlbmFibGVkIGFyZTpcclxuXHQgKiAgIC0gYXhpcy54LnR5cGU9J2NhdGVnb3J5JyBvciAndGltZXNlcmllc1xyXG5cdCAqICAgLSBheGlzLngudGljay5tdWx0aWxpbmU9ZmFsc2VcclxuXHQgKiAgIC0gYXhpcy54LnRpY2suY3VsbGluZz1mYWxzZVxyXG5cdCAqICAgLSBheGlzLngudGljay5maXQ9dHJ1ZVxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGF1dG9yb3RhdGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrQXV0b3JvdGF0ZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHJvdGF0ZTogMTUsXHJcblx0ICogICAgICAgYXV0b3JvdGF0ZTogdHJ1ZSxcclxuXHQgKiAgICAgICBtdWx0aWxpbmU6IGZhbHNlLFxyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlLFxyXG5cdCAqICAgICAgIGZpdDogdHJ1ZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2F1dG9yb3RhdGU6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBSb3RhdGUgeCBheGlzIHRpY2sgdGV4dC5cclxuXHQgKiAtIElmIHlvdSBzZXQgbmVnYXRpdmUgdmFsdWUsIGl0IHdpbGwgcm90YXRlIHRvIG9wcG9zaXRlIGRpcmVjdGlvbi5cclxuXHQgKiAtIEFwcGxpZWQgd2hlbiBbYGF4aXMucm90YXRlZGBdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHJvdGF0ZWQpIG9wdGlvbiBpcyBgZmFsc2VgLlxyXG5cdCAqIC0gQXMgbG9uZyBhcyBgYXhpc194X3RpY2tfZml0YCBpcyBzZXQgdG8gYHRydWVgIGl0IHdpbGwgY2FsY3VsYXRlIGFuIG92ZXJmbG93IGZvciB0aGUgeTIgYXhpcyBhbmQgYWRkIHRoaXMgdmFsdWUgdG8gdGhlIHJpZ2h0IHBhZGRpbmcuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkcm90YXRlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDBcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5Sb3RhdGVYQXhpc1RpY2tUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgcm90YXRlOiA2MFxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3JvdGF0ZTogMCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB4IGF4aXMgb3V0ZXIgdGljay5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRvdXRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgb3V0ZXI6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfb3V0ZXI6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrIHRleHQgdG8gYmUgbXVsdGlsaW5lXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbmQgJ2F4aXMueC50aWNrLndpZHRoJyBvcHRpb24gaXMgaWdub3JlZC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRtdWx0aWxpbmVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tNdWx0aWxpbmUpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBtdWx0aWxpbmU6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBleGFtcGxlIG9mIGxpbmUgYnJlYWsgd2l0aCAnXFxuJ1xyXG5cdCAqIC8vIEluIHRoaXMgY2FzZSwgJ2F4aXMueC50aWNrLndpZHRoJyBpcyBpZ25vcmVkXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHg6IFwieFwiLFxyXG5cdCAqICAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgICAgW1wieFwiLCBcImxvbmdcXG50ZXh0XCIsIFwiQW5vdGhlclxcbkxvbmdcXG5UZXh0XCJdLFxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICBdLFxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja19tdWx0aWxpbmU6IHRydWUsXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGljayB3aWR0aFxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR3aWR0aFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCBudWxsXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB3aWR0aDogNTBcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja193aWR0aDogPG51bWJlcnxudWxsPiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdG8gZGlzcGxheSBzeXN0ZW0gdG9vbHRpcCh2aWEgJ3RpdGxlJyBhdHRyaWJ1dGUpIGZvciB0aWNrIHRleHRcclxuXHQgKiAtICoqTk9URToqKiBPbmx5IGF2YWlsYWJsZSBmb3IgY2F0ZWdvcnkgYXhpcyB0eXBlIChgYXhpcy54LnR5cGU9J2NhdGVnb3J5J2ApXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdG9vbHRpcFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRvb2x0aXA6IHRydWVcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja190b29sdGlwOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1heCB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRtYXhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXggU2V0IHRoZSBtYXggdmFsdWVcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXguZml0PWZhbHNlXSBXaGVuIHNwZWNpZmllZCBgbWF4LnZhbHVlYCBpcyBncmVhdGVyIHRoYW4gdGhlIGJvdW5kIGRhdGEgdmFsdWUsIHNldHRpbmcgYHRydWVgIHdpbGwgbWFrZSB4IGF4aXMgbWF4IHRvIGJlIGZpdHRlZCB0byB0aGUgYm91bmQgZGF0YSBtYXggdmFsdWUuXHJcblx0ICogLSAqKk5PVEU6KiogSWYgdGhlIGJvdW5kIGRhdGEgbWF4IHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYG1heC52YWx1ZWAsIHRoZSB4IGF4aXMgbWF4IHdpbGwgYmUgbGltaXRlZCBhcyB0aGUgZ2l2ZW4gYG1heC52YWx1ZWAuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXgudmFsdWVdIFNldCB0aGUgbWF4IHZhbHVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIG1heDogMTAwLFxyXG5cdCAqXHJcblx0ICogICAgIG1heDoge1xyXG5cdCAqICAgICAgIC8vICdmaXQ9dHJ1ZScgd2lsbCBtYWtlIHggYXhpcyBtYXggdG8gYmUgbGltaXRlZCBhcyB0aGUgYm91bmQgZGF0YSB2YWx1ZSBtYXggd2hlbiAnbWF4LnZhbHVlJyBpcyBncmVhdGVyLlxyXG5cdCAqICAgICAgIC8vIC0gd2hlbiBib3VuZCBkYXRhIG1heCBpcyAnMTAnIGFuZCBtYXgudmFsdWU6ICcxMDAnID09PiAgeCBheGlzIG1heCB3aWxsIGJlICcxMCdcclxuXHQgKiAgICAgICAvLyAtIHdoZW4gYm91bmQgZGF0YSBtYXggaXMgJzEwMDAnIGFuZCBtYXgudmFsdWU6ICcxMDAnID09PiB4IGF4aXMgbWF4IHdpbGwgYmUgJzEwMCdcclxuXHQgKiAgICAgICBmaXQ6IHRydWUsXHJcblx0ICogICAgICAgdmFsdWU6IDEwMFxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9tYXg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBtaW4gdmFsdWUgb2YgeCBheGlzIHJhbmdlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkbWluXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gbWluIFNldCB0aGUgbWluIHZhbHVlXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbWluLmZpdD1mYWxzZV0gV2hlbiBzcGVjaWZpZWQgYG1pbi52YWx1ZWAgaXMgbG93ZXIgdGhhbiB0aGUgYm91bmQgZGF0YSB2YWx1ZSwgc2V0dGluZyBgdHJ1ZWAgd2lsbCBtYWtlIHggYXhpcyBtaW4gdG8gYmUgZml0dGVkIHRvIHRoZSBib3VuZCBkYXRhIG1pbiB2YWx1ZS5cclxuXHQgKiAtICoqTk9URToqKiBJZiB0aGUgYm91bmQgZGF0YSBtaW4gdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgYG1pbi52YWx1ZWAsIHRoZSB4IGF4aXMgbWluIHdpbGwgYmUgbGltaXRlZCBhcyB0aGUgZ2l2ZW4gYG1pbi52YWx1ZWAuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW4udmFsdWVdIFNldCB0aGUgbWluIHZhbHVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIG1pbjogLTEwMCxcclxuXHQgKlxyXG5cdCAqICAgICBtaW46IHtcclxuXHQgKiAgICAgICAvLyAnZml0PXRydWUnIHdpbGwgbWFrZSB4IGF4aXMgbWluIHRvIGJlIGxpbWl0ZWQgYXMgdGhlIGJvdW5kIGRhdGEgdmFsdWUgbWluIHdoZW4gJ21pbi52YWx1ZScgaXMgbG93ZXIuXHJcblx0ICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWluIGlzICctMTAnIGFuZCBtaW4udmFsdWU6ICctMTAwJyA9PT4gIHggYXhpcyBtaW4gd2lsbCBiZSAnLTEwJ1xyXG5cdCAqICAgICAgIC8vIC0gd2hlbiBib3VuZCBkYXRhIG1pbiBpcyAnLTEwMDAnIGFuZCBtaW4udmFsdWU6ICctMTAwJyA9PT4geCBheGlzIG1pbiB3aWxsIGJlICctMTAwJ1xyXG5cdCAqICAgICAgIGZpdDogdHJ1ZSxcclxuXHQgKiAgICAgICB2YWx1ZTogLTEwMFxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9taW46IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBwYWRkaW5nIGZvciB4IGF4aXMuPGJyPjxicj5cclxuXHQgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSByYW5nZSBvZiB4IGF4aXMgd2lsbCBpbmNyZWFzZS9kZWNyZWFzZSBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlcy5cclxuXHQgKiBJZiBubyBwYWRkaW5nIGlzIG5lZWRlZCBpbiB0aGUgcmFnZSBvZiB4IGF4aXMsIDAgc2hvdWxkIGJlIHNldC5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgVGhlIHBhZGRpbmcgdmFsdWVzIGFyZW4ndCBiYXNlZCBvbiBwaXhlbHMuIEl0IGRpZmZlcnMgYWNjb3JkaW5nIGF4aXMgdHlwZXM8YnI+XHJcblx0ICogICAtICoqY2F0ZWdvcnk6KiogVGhlIHVuaXQgb2YgdGljayB2YWx1ZVxyXG5cdCAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxYCwgaXMgc2FtZSBhcyB0aGUgd2lkdGggb2YgMSB0aWNrIHdpZHRoXHJcblx0ICogICAtICoqdGltZXNlcmllczoqKiBOdW1lcmljIHRpbWUgdmFsdWVcclxuXHQgKiAgICAgZXguIHRoZSBnaXZlbiB2YWx1ZSBgMTAwMCo2MCo2MCoyNGAsIHdoaWNoIGlzIG51bWVyaWMgdGltZSBlcXVpdmFsZW50IG9mIGEgZGF5LCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHBhZGRpbmdcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R8bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHBhZGRpbmc6IHtcclxuXHQgKiAgICAgICAvLyB3aGVuIGF4aXMgdHlwZSBpcyAnY2F0ZWdvcnknXHJcblx0ICogICAgICAgbGVmdDogMSwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIHRpY2sncyB3aWR0aFxyXG5cdCAqICAgICAgIHJpZ2h0OiAwLjUgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiB0aWNrJ3Mgd2lkdGhcclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICd0aW1lc2VyaWVzJ1xyXG5cdCAqICAgICAgIGxlZnQ6IDEwMDAqNjAqNjAqMjQsICAvLyBzZXQgbGVmdCBwYWRkaW5nIHdpZHRoIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSBkYXkgdGljaydzIHdpZHRoXHJcblx0ICogICAgICAgcmlnaHQ6IDEwMDAqNjAqNjAqMTIgICAvLyBzZXQgcmlnaHQgcGFkZGluZyB3aWR0aCBhcyBoYWxmIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSBkYXkgdGljaydzIHdpZHRoXHJcblx0ICogICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcblx0ICogICAgIHBhZGRpbmc6IDEwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9wYWRkaW5nOiA8bnVtYmVyfHtsZWZ0PzogbnVtYmVyOyByaWdodD86IG51bWJlcjt9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGhlaWdodCBvZiB4IGF4aXMuPGJyPjxicj5cclxuXHQgKiBUaGUgaGVpZ2h0IG9mIHggYXhpcyBjYW4gYmUgc2V0IG1hbnVhbGx5IGJ5IHRoaXMgb3B0aW9uLiBJZiB5b3UgbmVlZCBtb3JlIHNwYWNlIGZvciB4IGF4aXMsIHBsZWFzZSB1c2UgdGhpcyBvcHRpb24gZm9yIHRoYXQuIFRoZSB1bml0IGlzIHBpeGVsLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkaGVpZ2h0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBoZWlnaHQ6IDIwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9oZWlnaHQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkZWZhdWx0IGV4dGVudCBmb3Igc3ViY2hhcnQgYW5kIHpvb20uIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGV4dGVudFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICAvLyBleHRlbnQgcmFuZ2UgYXMgYSBwaXhlbCB2YWx1ZVxyXG5cdCAqICAgICBleHRlbnQ6IFswLCAyMDBdLFxyXG5cdCAqXHJcblx0ICogICAgIC8vIHdoZW4gYXhpcyBpcyAndGltZXNlcmllcycsIHBhcnNhYmxlIGRhdGV0aW1lIHN0cmluZ1xyXG5cdCAqICAgICBleHRlbnQ6IFtcIjIwMTktMDMtMDFcIiwgXCIyMDE5LTAzLTA1XCJdLFxyXG5cdCAqXHJcblx0ICogICAgIC8vIHJldHVybiBleHRlbnQgdmFsdWVcclxuXHQgKiAgICAgZXh0ZW50OiBmdW5jdGlvbihkb21haW4sIHNjYWxlKSB7XHJcblx0ICogICAgXHQgdmFyIGV4dGVudCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24odikge1xyXG5cdCAqICAgICBcdCAgICByZXR1cm4gc2NhbGUodik7XHJcblx0ICogICAgIFx0IH0pO1xyXG5cdCAqXHJcblx0ICogICBcdCAvLyBpdCBzaG91bGQgcmV0dXJuIGEgZm9ybWF0IG9mIGFycmF5XHJcblx0ICogICBcdCAvLyBleCkgWzAsIDU4NF1cclxuXHQgKiAgICAgXHQgcmV0dXJuIGV4dGVudDtcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfZXh0ZW50OiA8KG51bWJlcnxzdHJpbmcpW118RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsYWJlbCBvbiB4IGF4aXMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNldCB4IGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uXHJcblx0ICogYHN0cmluZ2AgYW5kIGBvYmplY3RgIGNhbiBiZSBwYXNzZWQgYW5kIHdlIGNhbiBjaGFuZ2UgdGhlIHBvaXNpdG9uIGJ5IHBhc3Npbmcgb2JqZWN0IHRoYXQgaGFzIHBvc2l0aW9uIGtleS48YnI+XHJcblx0ICogQXZhaWxhYmxlIHBvc2l0aW9uIGRpZmZlcnMgYWNjb3JkaW5nIHRvIHRoZSBheGlzIGRpcmVjdGlvbiAodmVydGljYWwgb3IgaG9yaXpvbnRhbCkuXHJcblx0ICogSWYgc3RyaW5nIHNldCwgdGhlIHBvc2l0aW9uIHdpbGwgYmUgdGhlIGRlZmF1bHQuXHJcblx0ICpcclxuXHQgKiAgLSAqKklmIGl0J3MgaG9yaXpvbnRhbCBheGlzOioqXHJcblx0ICogICAgLSBpbm5lci1yaWdodCBbZGVmYXVsdF1cclxuXHQgKiAgICAtIGlubmVyLWNlbnRlclxyXG5cdCAqICAgIC0gaW5uZXItbGVmdFxyXG5cdCAqICAgIC0gb3V0ZXItcmlnaHRcclxuXHQgKiAgICAtIG91dGVyLWNlbnRlclxyXG5cdCAqICAgIC0gb3V0ZXItbGVmdFxyXG5cdCAqICAtICoqSWYgaXQncyB2ZXJ0aWNhbCBheGlzOioqXHJcblx0ICogICAgLSBpbm5lci10b3AgW2RlZmF1bHRdXHJcblx0ICogICAgLSBpbm5lci1taWRkbGVcclxuXHQgKiAgICAtIGlubmVyLWJvdHRvbVxyXG5cdCAqICAgIC0gb3V0ZXItdG9wXHJcblx0ICogICAgLSBvdXRlci1taWRkbGVcclxuXHQgKiAgICAtIG91dGVyLWJvdHRvbVxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkbGFiZWxcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBsYWJlbDogXCJZb3VyIFggQXhpc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWCBBeGlzXCIsXHJcblx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLWNlbnRlclwiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X2xhYmVsOiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeCBBeGlzLlxyXG5cdCAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHggQXhpcyB2YWx1ZSBpZiBkb21haW4gb3B0aW9uIGlzbid0IHNldC5cclxuXHQgKlxyXG5cdCAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcclxuXHQgKlxyXG5cdCAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiB8IGRvbWFpbiB8IEFycmF5IHwgLSB8IFNldCB0aGUgZG9tYWluIHZhbHVlIHxcclxuXHQgKiB8IHRpY2sub3V0ZXIgfCBib29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XHJcblx0ICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XHJcblx0ICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XHJcblx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRheGVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxyXG5cdCAqIEBzZWUgW0RlbW86IERvbWFpbl0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzRG9tYWluKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogeDoge1xyXG5cdCAqICAgIGF4ZXM6IFtcclxuXHQgKiAgICAgIHtcclxuXHQgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geCBBeGlzIGRvbWFpbiB2YWx1ZVxyXG5cdCAqICAgICAgICBkb21haW46IFswLCAxMDAwXSxcclxuXHQgKiAgICAgICAgdGljazoge1xyXG5cdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcclxuXHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgY291bnQ6IDIsXHJcblx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cclxuXHQgKiAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIC4uLlxyXG5cdCAqICAgIF1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X2F4ZXM6IDxvYmplY3RbXT5bXVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB5IEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHkgYXhpcyBlbGVtZW50XHJcblx0ICogLSAqKk5PVEUqKjogYGNsaXAtcGF0aGAgYXR0cmlidXRlIGZvciB5IEF4aXMgaXMgc2V0IG9ubHkgd2hlbiBgYXhpcy55LmlubmVyYCBvcHRpb24gaXMgdHJ1ZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGNsaXBQYXRoXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXHJcblx0ICogY2xpcFBhdGg6IGZhbHNlXHJcblx0ICovXHJcblx0YXhpc195X2NsaXBQYXRoOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeSBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkc2hvd1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHR5cGUgb2YgeSBheGlzLjxicj48YnI+XHJcblx0ICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogICAtIHRpbWVzZXJpZXNcclxuXHQgKiAgIC0gaW5kZXhlZFxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdHlwZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCBcImluZGV4ZWRcIlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdHlwZTogPFwiaW5kZXhlZFwifFwiY2F0ZWdvcnlcInxcImluZGV4ZWRcInx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1heCB2YWx1ZSBvZiB5IGF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApG1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgbWF4OiAxMDAwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9tYXg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBtaW4gdmFsdWUgb2YgeSBheGlzLlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkbWluXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBtaW46IDEwMDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeSBheGlzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBzZXQsIHRoZSBkaXJlY3Rpb24gd2lsbCBiZSBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGludmVydGVkXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBpbnZlcnRlZDogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfaW52ZXJ0ZWQ6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2VudGVyIHZhbHVlIG9mIHkgYXhpcy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGNlbnRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgY2VudGVyOiAwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9jZW50ZXI6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgeSBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRpbm5lclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgaW5uZXI6IHRydWVcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X2lubmVyOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVsIG9uIHkgYXhpcy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc2V0IHkgYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi4gVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRsYWJlbFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAc2VlIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkgZm9yIHBvc2l0aW9uIHN0cmluZyB2YWx1ZS5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgbGFiZWw6IFwiWW91ciBZIEF4aXNcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICAgdGV4dDogXCJZb3VyIFkgQXhpc1wiLFxyXG5cdCAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1taWRkbGVcIlxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9sYWJlbDogPHN0cmluZ3xvYmplY3Q+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZm9ybWF0dGVyIGZvciB5IGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBkMy5mb3JtYXQgb2JqZWN0IGFzIHdlbGwgYXMgYSBmdW5jdGlvbiB5b3UgZGVmaW5lLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGZvcm1hdFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcblx0ICogICAgICAgICAgIHJldHVybiB4LmdldEZ1bGxZZWFyKCk7XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX2Zvcm1hdDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcblx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGN1bGxpbmdcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX2N1bGxpbmc6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjdWxsaW5n4oCkbWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IHtcclxuXHQgKiAgICAgICAgICAgbWF4OiA1XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX2N1bGxpbmdfbWF4OiA1LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IHkgYXhpcyBvdXRlciB0aWNrLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApG91dGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBvdXRlcjogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHkgYXhpcyB0aWNrIHZhbHVlcyBtYW51YWxseS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR2YWx1ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBudWxsXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXSxcclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxyXG5cdCAqICAgICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfdmFsdWVzOiA8bnVtYmVyW118KCgpPT4gbnVtYmVyW10pfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZSB5IGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG5cdCAqIC0gQXBwbGllZCB3aGVuIFtgYXhpcy5yb3RhdGVkYF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0cm90YXRlZCkgb3B0aW9uIGlzIGB0cnVlYC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRyb3RhdGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgcm90YXRlOiA2MFxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX3JvdGF0ZTogMCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzLjxicj48YnI+XHJcblx0ICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGNvdW50XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY291bnQ6IDVcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIGxpbmUuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkc2hvd1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBheGlzIHRpY2sgc3RlcChpbnRlcnZhbCkgc2l6ZS5cclxuXHQgKiAtICoqTk9URToqKiBXaWxsIGJlIGlnbm9yZWQgaWYgYGF4aXMueS50aWNrLmNvdW50YCBvciBgYXhpcy55LnRpY2sudmFsdWVzYCBvcHRpb25zIGFyZSBzZXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkc3RlcFNpemVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuU3RlcFNpemVGb3JZQXhpcylcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIC8vIHRpY2sgdmFsdWUgd2lsbCBzdGVwIGFzIGluZGljYXRlZCBpbnRlcnZhbCB2YWx1ZS5cclxuXHQgKiAgICAgICAvLyBleCkgJ3N0ZXBTaXplPTE1JyA9PT4gWzAsIDE1LCAzMCwgNDUsIDYwXVxyXG5cdCAqICAgICAgIHN0ZXBTaXplOiAxNVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX3N0ZXBTaXplOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5IGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRleHTigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIHkgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgICAgeDogMTAsXHJcblx0ICogICAgICAgICAgIHk6IDEwXHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzLjxicj48YnI+XHJcblx0ICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRpbWVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gdGltZSB0aW1lIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0aW1lLnZhbHVlXSBEMydzIHRpbWUgaW50ZXJ2YWwgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lI2ludGVydmFscylcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRpbWU6IHtcclxuXHQgKiAgICAgICAgICAvLyB0aWNrcyBhdCAxNS1taW51dGUgaW50ZXJ2YWxzXHJcblx0ICogICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCN0aW1lX3RpY2tzXHJcblx0ICogICAgICAgICAgdmFsdWU6IGQzLnRpbWVNaW51dGUuZXZlcnkoMTUpXHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdC8vIEBUT0RPOiBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0XHJcblx0YXhpc195X3RpY2tfdGltZV92YWx1ZTogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgcGFkZGluZyBmb3IgeSBheGlzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzZXQgcGFkZGluZyBmb3IgeSBheGlzIHRvIGNyZWF0ZSBtb3JlIHNwYWNlIG9uIHRoZSBlZGdlIG9mIHRoZSBheGlzLlxyXG5cdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IGFuZCBpdCBjYW4gaW5jbHVkZSB0b3AgYW5kIGJvdHRvbS4gdG9wLCBib3R0b20gd2lsbCBiZSB0cmVhdGVkIGFzIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIEdpdmVuIHZhbHVlcyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgeSBBeGlzIGRvbWFpbiB2YWx1ZSBmb3IgcGFkZGluZ1xyXG5cdCAqICAgLSBGb3IgYXJlYSBhbmQgYmFyIHR5cGUgY2hhcnRzLCBbYXJlYS56ZXJvYmFzZWRdKCMuYXJlYSkgb3IgW2Jhci56ZXJvYmFzZWRdKCMuYmFyKSBvcHRpb25zIHNob3VsZCBiZSBzZXQgdG8gJ2ZhbHNlYCB0byBnZXQgcGFkZGVkIGJvdHRvbS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHBhZGRpbmdcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R8bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHBhZGRpbmc6IHtcclxuXHQgKiAgICAgICB0b3A6IDAsXHJcblx0ICogICAgICAgYm90dG9tOiAwXHJcblx0ICogICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcblx0ICogICAgIHBhZGRpbmc6IDEwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9wYWRkaW5nOiA8bnVtYmVyfHt0b3A/OiBudW1iZXI7IGJvdHRvbT86IG51bWJlcjt9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeSBheGlzLjxicj48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gc2V0IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB5IGF4aXMgd2hlbiB0aGVyZSBpcyBubyBkYXRhIG9uIGluaXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRkZWZhdWx0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIGRlZmF1bHQ6IFswLCAxMDAwXVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfZGVmYXVsdDogPG51bWJlcltdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5IEF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geSBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxyXG5cdCAqXHJcblx0ICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxyXG5cdCAqXHJcblx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxyXG5cdCAqIHwgdGljay5vdXRlciB8IGJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcclxuXHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcclxuXHQgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcclxuXHQgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGF4ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcblx0ICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiB5OiB7XHJcblx0ICogICAgYXhlczogW1xyXG5cdCAqICAgICAge1xyXG5cdCAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB5IEF4aXMgZG9tYWluIHZhbHVlXHJcblx0ICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxyXG5cdCAqICAgICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICBjb3VudDogMixcclxuXHQgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxyXG5cdCAqICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgLi4uXHJcblx0ICogICAgXVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfYXhlczogPG9iamVjdFtdPiBbXVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB5MiBBeGlzICBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzLlxyXG5cdCAqIC0gKipOT1RFKio6XHJcblx0ICogICAtIFdoZW4gc2V0IHRvIGBmYWxzZWAgd2lsbCBub3QgZ2VuZXJhdGUgeTIgYXhpcyBub2RlLiBJbiB0aGlzIGNhc2UsIGFsbCAneTInIGF4aXMgcmVsYXRlZCBmdW5jdGlvbmFsaXR5IHdvbid0IHdvcmsgcHJvcGVybHkuXHJcblx0ICogICAtIElmIG5lZWQgdG8gdXNlICd5MicgcmVsYXRlZCBvcHRpb25zIHdoaWxlIHkyIGlzbid0IHZpc2libGUsIHNldCB0aGUgdmFsdWUgYHRydWVgIGFuZCBjb250cm9sIHZpc2liaWxpdHkgYnkgY3NzIGRpc3BsYXkgcHJvcGVydHkuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkc2hvd1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHNob3c6IHRydWVcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9zaG93OiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1heCB2YWx1ZSBvZiB5MiBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApG1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIG1heDogMTAwMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1pbiB2YWx1ZSBvZiB5MiBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApG1pblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIG1pbjogLTEwMDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9taW46IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoYW5nZSB0aGUgZGlyZWN0aW9uIG9mIHkyIGF4aXMuPGJyPjxicj5cclxuXHQgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApGludmVydGVkXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgaW52ZXJ0ZWQ6IHRydWVcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9pbnZlcnRlZDogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeTIgYXhpcy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRjZW50ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBjZW50ZXI6IDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9jZW50ZXI6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgeTIgYXhpcyBpbnNpZGUgb2YgdGhlIGNoYXJ0LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApGlubmVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgaW5uZXI6IHRydWVcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9pbm5lcjogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsYWJlbCBvbiB5MiBheGlzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzZXQgeTIgYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi4gVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkbGFiZWxcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQHNlZSBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpIGZvciBwb3NpdGlvbiBzdHJpbmcgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBsYWJlbDogXCJZb3VyIFkyIEF4aXNcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIGxhYmVsOiB7XHJcblx0ICogICAgICAgIHRleHQ6IFwiWW91ciBZMiBBeGlzXCIsXHJcblx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLW1pZGRsZVwiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9sYWJlbDogPHN0cmluZ3xvYmplY3Q+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZm9ybWF0dGVyIGZvciB5MiBheGlzIHRpY2sgdGV4dC48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkuZm9ybWF0LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRmb3JtYXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBmb3JtYXQ6IGQzLmZvcm1hdChcIiQsXCIpXHJcblx0ICogICAgICAgLy9vciBmb3JtYXQ6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiJFwiICsgZDsgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19mb3JtYXQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0dGluZyBmb3IgY3VsbGluZyB0aWNrcy48YnI+PGJyPlxyXG5cdCAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxyXG5cdCAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLnkudGljay5jdWxsaW5nLm1heC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY3VsbGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19jdWxsaW5nOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG51bWJlciBvZiB0aWNrIHRleHRzIHdpbGwgYmUgYWRqdXN0ZWQgdG8gbGVzcyB0aGFuIHRoaXMgdmFsdWUuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgNVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IHtcclxuXHQgKiAgICAgICAgICAgbWF4OiA1XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19jdWxsaW5nX21heDogNSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMgb3V0ZXIgdGljay5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkb3V0ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBvdXRlcjogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfb3V0ZXI6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB5MiBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR2YWx1ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBudWxsXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF0sXHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBhbiBBcnJheSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWRcclxuXHQgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG5cdCAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja192YWx1ZXM6IDxudW1iZXJbXXwoKCk9PiBudW1iZXJbXSl8bnVsbD4gbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogUm90YXRlIHkyIGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG5cdCAqIC0gQXBwbGllZCB3aGVuIFtgYXhpcy5yb3RhdGVkYF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0cm90YXRlZCkgb3B0aW9uIGlzIGB0cnVlYC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkcm90YXRlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDBcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICByb3RhdGU6IDYwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3JvdGF0ZTogMCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cclxuXHQgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY291bnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY291bnQ6IDVcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfY291bnQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgbGluZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkc2hvd1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGF4aXMgdGljayBzdGVwKGludGVydmFsKSBzaXplLlxyXG5cdCAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55Mi50aWNrLmNvdW50YCBvciBgYXhpcy55Mi50aWNrLnZhbHVlc2Agb3B0aW9ucyBhcmUgc2V0LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzdGVwU2l6ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5TdGVwU2l6ZUZvcllBeGlzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIC8vIHRpY2sgdmFsdWUgd2lsbCBzdGVwIGFzIGluZGljYXRlZCBpbnRlcnZhbCB2YWx1ZS5cclxuXHQgKiAgICAgICAvLyBleCkgJ3N0ZXBTaXplPTE1JyA9PT4gWzAsIDE1LCAzMCwgNDUsIDYwXVxyXG5cdCAqICAgICAgIHN0ZXBTaXplOiAxNVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19zdGVwU2l6ZTogPG51bWJlcnxudWxsPiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgeTIgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR0ZXh04oCkcG9zaXRpb25cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge3g6IDAsIHk6MH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICAgICB4OiAxMCxcclxuXHQgKiAgICAgICAgICAgeTogMTBcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHBhZGRpbmcgZm9yIHkyIGF4aXMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNldCBwYWRkaW5nIGZvciB5MiBheGlzIHRvIGNyZWF0ZSBtb3JlIHNwYWNlIG9uIHRoZSBlZGdlIG9mIHRoZSBheGlzLlxyXG5cdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IGFuZCBpdCBjYW4gaW5jbHVkZSB0b3AgYW5kIGJvdHRvbS4gdG9wLCBib3R0b20gd2lsbCBiZSB0cmVhdGVkIGFzIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIEdpdmVuIHZhbHVlcyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgeTIgQXhpcyBkb21haW4gdmFsdWUgZm9yIHBhZGRpbmdcclxuXHQgKiAgIC0gRm9yIGFyZWEgYW5kIGJhciB0eXBlIGNoYXJ0cywgW2FyZWEuemVyb2Jhc2VkXSgjLmFyZWEpIG9yIFtiYXIuemVyb2Jhc2VkXSgjLmJhcikgb3B0aW9ucyBzaG91bGQgYmUgc2V0IHRvICdmYWxzZWAgdG8gZ2V0IHBhZGRlZCBib3R0b20uXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkcGFkZGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdHxudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHBhZGRpbmc6IHtcclxuXHQgKiAgICAgICB0b3A6IDEwMCxcclxuXHQgKiAgICAgICBib3R0b206IDEwMFxyXG5cdCAqICAgICB9XHJcblx0ICpcclxuXHQgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcblx0ICogICAgIHBhZGRpbmc6IDEwXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfcGFkZGluZzogPG51bWJlcnx7dG9wPzogbnVtYmVyOyBib3R0b20/OiBudW1iZXI7fT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkZWZhdWx0IHJhbmdlIG9mIHkyIGF4aXMuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkyIGF4aXMgd2hlbiB0aGVyZSBpcyBubyBkYXRhIG9uIGluaXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkZGVmYXVsdFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfZGVmYXVsdDogdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5MiBBeGlzLlxyXG5cdCAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHkyIEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXHJcblx0ICpcclxuXHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XHJcblx0ICpcclxuXHQgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XHJcblx0ICogfCB0aWNrLm91dGVyIHwgYm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxyXG5cdCAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxyXG5cdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxyXG5cdCAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApGF4ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcblx0ICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiB5Mjoge1xyXG5cdCAqICAgIGF4ZXM6IFtcclxuXHQgKiAgICAgIHtcclxuXHQgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geTIgQXhpcyBkb21haW4gdmFsdWVcclxuXHQgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXHJcblx0ICogICAgICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXHJcblx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcblx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIGNvdW50OiAyLFxyXG5cdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXHJcblx0ICogICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICAuLi5cclxuXHQgKiAgICBdXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfYXhlczogW11cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogV2luZG93IG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLXVuZGVmICovXHJcbmV4cG9ydCB7d2luIGFzIHdpbmRvdywgZG9jIGFzIGRvY3VtZW50fTtcclxuXHJcbmNvbnN0IHdpbiA9ICgoKSA9PiB7XHJcblx0Y29uc3QgZGVmID0gbyA9PiB0eXBlb2YgbyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvO1xyXG5cclxuXHRyZXR1cm4gZGVmKHNlbGYpIHx8IGRlZih3aW5kb3cpIHx8IGRlZihnbG9iYWwpIHx8IGRlZihnbG9iYWxUaGlzKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XHJcbn0pKCk7XHJcbi8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMsIG5vLXVuZGVmICovXHJcblxyXG5jb25zdCBkb2MgPSB3aW4gJiYgd2luLmRvY3VtZW50O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHtldmVudCBhcyBkM0V2ZW50fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7YnJ1c2hTZWxlY3Rpb24gYXMgZDNCcnVzaFNlbGVjdGlvbn0gZnJvbSBcImQzLWJydXNoXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxuZXhwb3J0IHtcclxuXHRhc0hhbGZQaXhlbCxcclxuXHRicnVzaEVtcHR5LFxyXG5cdGNhbGxGbixcclxuXHRjYXBpdGFsaXplLFxyXG5cdGNlaWwxMCxcclxuXHRjb252ZXJ0SW5wdXRUeXBlLFxyXG5cdGRpZmZEb21haW4sXHJcblx0ZW5kYWxsLFxyXG5cdGVtdWxhdGVFdmVudCxcclxuXHRleHRlbmQsXHJcblx0Z2V0QnJ1c2hTZWxlY3Rpb24sXHJcblx0Z2V0Qm91bmRpbmdSZWN0LFxyXG5cdGdldENzc1J1bGVzLFxyXG5cdGdldE1pbk1heCxcclxuXHRnZXRPcHRpb24sXHJcblx0Z2V0UGF0aEJveCxcclxuXHRnZXRSYW5kb20sXHJcblx0Z2V0UmFuZ2UsXHJcblx0Z2V0UmVjdFNlZ0xpc3QsXHJcblx0Z2V0VHJhbnNsYXRpb24sXHJcblx0Z2V0VW5pcXVlLFxyXG5cdGhhc1ZhbHVlLFxyXG5cdGlzQXJyYXksXHJcblx0aXNib29sZWFuLFxyXG5cdGlzRGVmaW5lZCxcclxuXHRpc0VtcHR5LFxyXG5cdGlzRnVuY3Rpb24sXHJcblx0aXNOdW1iZXIsXHJcblx0aXNPYmplY3QsXHJcblx0aXNPYmplY3RUeXBlLFxyXG5cdGlzU3RyaW5nLFxyXG5cdGlzVGFiVmlzaWJsZSxcclxuXHRpc1VuZGVmaW5lZCxcclxuXHRpc1ZhbHVlLFxyXG5cdG1lcmdlQXJyYXksXHJcblx0bWVyZ2VPYmosXHJcblx0bm90RW1wdHksXHJcblx0cGFyc2VEYXRlLFxyXG5cdHNhbml0aXNlLFxyXG5cdHNldFRleHRWYWx1ZSxcclxuXHRzb3J0VmFsdWUsXHJcblx0dG9BcnJheSxcclxuXHR0cGxQcm9jZXNzXHJcbn07XHJcblxyXG5jb25zdCBpc1ZhbHVlID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdiB8fCB2ID09PSAwO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIjtcclxuY29uc3QgaXNTdHJpbmcgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcclxuY29uc3QgaXNOdW1iZXIgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcclxuY29uc3QgaXNVbmRlZmluZWQgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIjtcclxuY29uc3QgaXNEZWZpbmVkID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCI7XHJcbmNvbnN0IGlzYm9vbGVhbiA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIjtcclxuY29uc3QgY2VpbDEwID0gKHY6IGFueSk6IG51bWJlciA9PiBNYXRoLmNlaWwodiAvIDEwKSAqIDEwO1xyXG5jb25zdCBhc0hhbGZQaXhlbCA9IChuOiBhbnkpOiBudW1iZXIgPT4gTWF0aC5jZWlsKG4pICsgMC41O1xyXG5jb25zdCBkaWZmRG9tYWluID0gKGQ6IG51bWJlcltdKTogbnVtYmVyID0+IGRbMV0gLSBkWzBdO1xyXG5jb25zdCBpc09iamVjdFR5cGUgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIjtcclxuY29uc3QgaXNFbXB0eSA9IChvOiBhbnkpOiBib29sZWFuID0+IChcclxuXHRpc1VuZGVmaW5lZChvKSB8fCBvID09PSBudWxsIHx8XHJcblx0KGlzU3RyaW5nKG8pICYmIG8ubGVuZ3RoID09PSAwKSB8fFxyXG5cdChpc09iamVjdFR5cGUobykgJiYgIShvIGluc3RhbmNlb2YgRGF0ZSkgJiYgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwKSB8fFxyXG5cdChpc051bWJlcihvKSAmJiBpc05hTihvKSlcclxuKTtcclxuY29uc3Qgbm90RW1wdHkgPSAobzogYW55KTogYm9vbGVhbiA9PiAhaXNFbXB0eShvKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBpcyBhcnJheVxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgRGF0YSB0byBiZSBjaGVja2VkXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaXNBcnJheSA9IChhcnI6IGFueSk6IGJvb2xlYW4gPT4gQXJyYXkuaXNBcnJheShhcnIpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGlzIG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIERhdGEgdG8gYmUgY2hlY2tlZFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGlzT2JqZWN0ID0gKG9iajogYW55KTogYm9vbGVhbiA9PiBvYmogJiYgIW9iai5ub2RlVHlwZSAmJiBpc09iamVjdFR5cGUob2JqKSAmJiAhaXNBcnJheShvYmopO1xyXG5cclxuLyoqXHJcbiAqIEdldCBzcGVjaWZpZWQga2V5IHZhbHVlIGZyb20gb2JqZWN0XHJcbiAqIElmIGRlZmF1bHQgdmFsdWUgaXMgZ2l2ZW4sIHdpbGwgcmV0dXJuIGlmIGdpdmVuIGtleSB2YWx1ZSBub3QgZm91bmRcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgU291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB2YWx1ZVxyXG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBEZWZhdWx0IHZhbHVlXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0T3B0aW9uKG9wdGlvbnM6IG9iamVjdCwga2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZSk6IGFueSB7XHJcblx0cmV0dXJuIGlzRGVmaW5lZChvcHRpb25zW2tleV0pID8gb3B0aW9uc1trZXldIDogZGVmYXVsdFZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgZXhpc3QgaW4gdGhlIGdpdmVuIG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGljdCBUYXJnZXQgb2JqZWN0IHRvIGJlIGNoZWNrZWRcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBiZSBjaGVja2VkXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaGFzVmFsdWUoZGljdDogb2JqZWN0LCB2YWx1ZTogYW55KTogYm9vbGVhbiB7XHJcblx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdE9iamVjdC5rZXlzKGRpY3QpLmZvckVhY2goa2V5ID0+IChkaWN0W2tleV0gPT09IHZhbHVlKSAmJiAoZm91bmQgPSB0cnVlKSk7XHJcblxyXG5cdHJldHVybiBmb3VuZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAqIEBwYXJhbSB7Kn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWU6IGZuIGlzIGZ1bmN0aW9uLCBmYWxzZTogZm4gaXMgbm90IGZ1bmN0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxsRm4oZm4sIC4uLmFyZ3MpOiBib29sZWFuIHtcclxuXHRjb25zdCBpc0ZuID0gaXNGdW5jdGlvbihmbik7XHJcblxyXG5cdGlzRm4gJiYgZm4uY2FsbCguLi5hcmdzKTtcclxuXHRyZXR1cm4gaXNGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgZnVuY3Rpb24gYWZ0ZXIgYWxsIHRyYW5zaXRpb25zIGVuZHNcclxuICogQHBhcmFtIHtkMy50cmFuc2l0aW9ufSB0cmFuc2l0aW9uIFRyYW5zaXRpb25cclxuICogQHBhcmFtIHtGdWNudGlvbn0gY2IgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGVuZGFsbCh0cmFuc2l0aW9uLCBjYjogRnVuY3Rpb24pOiB2b2lkIHtcclxuXHRsZXQgbiA9IDA7XHJcblxyXG5cdHRyYW5zaXRpb25cclxuXHRcdC5lYWNoKCgpID0+ICsrbilcclxuXHRcdC5vbihcImVuZFwiLCBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdCEtLW4gJiYgY2IuYXBwbHkodGhpcywgLi4uYXJncyk7XHJcblx0XHR9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2UgdGFnIHNpZ24gdG8gaHRtbCBlbnRpdHlcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUYXJnZXQgc3RyaW5nIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzYW5pdGlzZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0cmV0dXJuIGlzU3RyaW5nKHN0cikgP1xyXG5cdFx0c3RyLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpIDogc3RyO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRleHQgdmFsdWUuIElmIHRoZXJlJ3MgbXVsdGlsaW5lIGFkZCBub2Rlcy5cclxuICogQHBhcmFtIHtkM1NlbGVjdGlvbn0gbm9kZSBUZXh0IG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dCB2YWx1ZSBzdHJpbmdcclxuICogQHBhcmFtIHtBcnJheX0gZHkgZHkgdmFsdWUgZm9yIG11bHRpbGluZWQgdGV4dFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRvTWlkZGxlIFRvIGJlIGFsaW5nbmVkIHZlcnRpY2FsbHkgbWlkZGxlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUZXh0VmFsdWUoXHJcblx0bm9kZTogZDNTZWxlY3Rpb24sXHJcblx0dGV4dDogc3RyaW5nLFxyXG5cdGR5OiBudW1iZXJbXSA9IFstMSwgMV0sXHJcblx0dG9NaWRkbGU6IGJvb2xlYW4gPSBmYWxzZVxyXG4pIHtcclxuXHRpZiAoIW5vZGUgfHwgIWlzU3RyaW5nKHRleHQpKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZiAodGV4dC5pbmRleE9mKFwiXFxuXCIpID09PSAtMSkge1xyXG5cdFx0bm9kZS50ZXh0KHRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjb25zdCBkaWZmID0gW25vZGUudGV4dCgpLCB0ZXh0XS5tYXAodiA9PiB2LnJlcGxhY2UoL1tcXHNcXG5dL2csIFwiXCIpKTtcclxuXHJcblx0XHRpZiAoZGlmZlswXSAhPT0gZGlmZlsxXSkge1xyXG5cdFx0XHRjb25zdCBtdWx0aWxpbmUgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG5cdFx0XHRjb25zdCBsZW4gPSB0b01pZGRsZSA/IG11bHRpbGluZS5sZW5ndGggLSAxIDogMTtcclxuXHJcblx0XHRcdC8vIHJlc2V0IHBvc3NpYmxlIHRleHRcclxuXHRcdFx0bm9kZS5odG1sKFwiXCIpO1xyXG5cclxuXHRcdFx0bXVsdGlsaW5lLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRub2RlLmFwcGVuZChcInRzcGFuXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgYCR7aSA9PT0gMCA/IGR5WzBdICogbGVuIDogZHlbMV19ZW1gKVxyXG5cdFx0XHRcdFx0LnRleHQodik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFN1YnN0aXR1dGlvbiBvZiBTVkdQYXRoU2VnIEFQSSBwb2x5ZmlsbFxyXG4gKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gcGF0aCBUYXJnZXQgc3ZnIGVsZW1lbnRcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVjdFNlZ0xpc3QocGF0aDogU1ZHR3JhcGhpY3NFbGVtZW50KToge3g6IG51bWJlciwgeTogbnVtYmVyfVtdIHtcclxuXHQvKlxyXG5cdCAqIHNlZzEgLS0tLS0tLS0tLSBzZWcyXHJcblx0ICogICB8ICAgICAgICAgICAgICAgfFxyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcclxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XHJcblx0ICogc2VnMCAtLS0tLS0tLS0tIHNlZzNcclxuXHQgKiAqL1xyXG5cdGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IHBhdGguZ2V0QkJveCgpO1xyXG5cclxuXHRyZXR1cm4gW1xyXG5cdFx0e3gsIHk6IHkgKyBoZWlnaHR9LCAvLyBzZWcwXHJcblx0XHR7eCwgeX0sIC8vIHNlZzFcclxuXHRcdHt4OiB4ICsgd2lkdGgsIHl9LCAvLyBzZWcyXHJcblx0XHR7eDogeCArIHdpZHRoLCB5OiB5ICsgaGVpZ2h0fSAvLyBzZWczXHJcblx0XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBzdmcgYm91bmRpbmcgcGF0aCBib3ggZGltZW5zaW9uXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSBwYXRoIFRhcmdldCBzdmcgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGF0aEJveChcclxuXHRwYXRoOiBTVkdHcmFwaGljc0VsZW1lbnRcclxuKToge3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0ge1xyXG5cdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0Y29uc3QgaXRlbXMgPSBnZXRSZWN0U2VnTGlzdChwYXRoKTtcclxuXHRjb25zdCB4ID0gaXRlbXNbMF0ueDtcclxuXHRjb25zdCB5ID0gTWF0aC5taW4oaXRlbXNbMF0ueSwgaXRlbXNbMV0ueSk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBicnVzaCBzZWxlY3Rpb24gYXJyYXlcclxuICogQHBhcmFtIHtvYmplY3R9ICRlbCBTZWxlY3Rpb24gb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtkMy5icnVzaFNlbGVjdGlvbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEJydXNoU2VsZWN0aW9uKHskZWx9KSB7XHJcblx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xyXG5cdGNvbnN0IG1haW4gPSAkZWwuc3ViY2hhcnQubWFpbiB8fCAkZWwubWFpbjtcclxuXHRsZXQgc2VsZWN0aW9uO1xyXG5cclxuXHQvLyBjaGVjayBmcm9tIGV2ZW50XHJcblx0aWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiYnJ1c2hcIikge1xyXG5cdFx0c2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uO1xyXG5cdC8vIGNoZWNrIGZyb20gYnJ1c2ggYXJlYSBzZWxlY3Rpb25cclxuXHR9IGVsc2UgaWYgKG1haW4gJiYgKHNlbGVjdGlvbiA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5ub2RlKCkpKSB7XHJcblx0XHRzZWxlY3Rpb24gPSBkM0JydXNoU2VsZWN0aW9uKHNlbGVjdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc2VsZWN0aW9uO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGJvdW5kaW5nQ2xpZW50UmVjdC5cclxuICogQ2FjaGUgdGhlIGV2YWx1YXRlZCB2YWx1ZSBvbmNlIGl0IHdhcyBjYWxsZWQuXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgVGFyZ2V0IGVsZW1lbnRcclxuICogQHJldHVybnMge29iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGdldEJvdW5kaW5nUmVjdCA9IChub2RlKToge1xyXG5cdGxlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLFxyXG5cdHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlclxyXG59ID0+IG5vZGUucmVjdCB8fCAobm9kZS5yZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcblxyXG4vKipcclxuICogUmV0cnVuIHJhbmRvbSBudW1iZXJcclxuICogQHBhcmFtIHtib29sZWFufSBhc1N0ciBDb252ZXJ0IHJldHVybmVkIHZhbHVlIGFzIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfHN0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFJhbmRvbShhc1N0cjogYm9vbGVhbiA9IHRydWUpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdGNvbnN0IHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRyZXR1cm4gYXNTdHIgPyBTdHJpbmcocmFuZCkgOiByYW5kO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYnJ1c2ggaXMgZW1wdHlcclxuICogQHBhcmFtIHtvYmplY3R9IGN0eCBCdXJzaCBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYnJ1c2hFbXB0eShjdHgpOiBib29sZWFuIHtcclxuXHRjb25zdCBzZWxlY3Rpb24gPSBnZXRCcnVzaFNlbGVjdGlvbihjdHgpO1xyXG5cclxuXHRpZiAoc2VsZWN0aW9uKSB7XHJcblx0XHQvLyBicnVzaCBzZWxlY3RlZCBhcmVhXHJcblx0XHQvLyB0d28tZGltZW5zaW9uYWw6IFtbeDAsIHkwXSwgW3gxLCB5MV1dXHJcblx0XHQvLyBvbmUtZGltZW5zaW9uYWw6IFt4MCwgeDFdIG9yIFt5MCwgeTFdXHJcblx0XHRyZXR1cm4gc2VsZWN0aW9uWzBdID09PSBzZWxlY3Rpb25bMV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dGVuZCB0YXJnZXQgZnJvbSBzb3VyY2Ugb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3RcclxuICogQHJldHVybnMge29iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQgPSB7fSwgc291cmNlKTogb2JqZWN0IHtcclxuXHRpZiAoaXNBcnJheShzb3VyY2UpKSB7XHJcblx0XHRzb3VyY2UuZm9yRWFjaCh2ID0+IGV4dGVuZCh0YXJnZXQsIHYpKTtcclxuXHR9XHJcblxyXG5cdC8vIGV4Y2x1ZGUgbmFtZSB3aXRoIG9ubHkgbnVtYmVyc1xyXG5cdGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcclxuXHRcdGlmICgvXlxcZCskLy50ZXN0KHApKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gZmlyc3QgbGV0dGVyIGNhcGl0YWxpemVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGFyZ2V0IHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjYXBpdGFsaXplZCBzdHJpbmdcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdG8gYXJyYXlcclxuICogQHBhcmFtIHtvYmplY3R9IHYgVGFyZ2V0IHRvIGJlIGNvbnZlcnRlZFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0FycmF5ID0gKHY6IENTU1N0eWxlRGVjbGFyYXRpb24gfCBhbnkpOiBhbnkgPT4gW10uc2xpY2UuY2FsbCh2KTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgY3NzIHJ1bGVzIGZvciBzcGVjaWZpZWQgc3R5bGVzaGVldHNcclxuICogQHBhcmFtIHtBcnJheX0gc3R5bGVTaGVldHMgVGhlIHN0eWxlc2hlZXRzIHRvIGdldCB0aGUgcnVsZXMgZnJvbVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDc3NSdWxlcyhzdHlsZVNoZWV0czogYW55W10pIHtcclxuXHRsZXQgcnVsZXMgPSBbXTtcclxuXHJcblx0c3R5bGVTaGVldHMuZm9yRWFjaChzaGVldCA9PiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRpZiAoc2hlZXQuY3NzUnVsZXMgJiYgc2hlZXQuY3NzUnVsZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cnVsZXMgPSBydWxlcy5jb25jYXQodG9BcnJheShzaGVldC5jc3NSdWxlcykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIHJlYWRpbmcgcnVsZXMgZnJvbSAke3NoZWV0LmhyZWZ9OiAke2UudG9TdHJpbmcoKX1gKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHJ1bGVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgU1ZHTWF0cml4IG9mIGFuIFNWR0dFbGVtZW50XHJcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbm9kZSBOb2RlIGVsZW1lbnRcclxuICogQHJldHVybnMge1NWR01hdHJpeH0gbWF0cml4XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBnZXRUcmFuc2xhdGlvbiA9IG5vZGUgPT4ge1xyXG5cdGNvbnN0IHRyYW5zZm9ybSA9IG5vZGUgPyBub2RlLnRyYW5zZm9ybSA6IG51bGw7XHJcblx0Y29uc3QgYmFzZVZhbCA9IHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0uYmFzZVZhbDtcclxuXHJcblx0cmV0dXJuIGJhc2VWYWwgJiYgYmFzZVZhbC5udW1iZXJPZkl0ZW1zID9cclxuXHRcdGJhc2VWYWwuZ2V0SXRlbSgwKS5tYXRyaXggOlxyXG5cdFx0e2E6IDAsIGI6IDAsIGM6IDAsIGQ6IDAsIGU6IDAsIGY6IDB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgdmFsdWUgZnJvbSBhcnJheVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIFNvdXJjZSBkYXRhXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gVW5pcXVlIGFycmF5IHZhbHVlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRVbmlxdWUoZGF0YTogYW55W10pOiBhbnlbXSB7XHJcblx0Y29uc3QgaXNEYXRlID0gZGF0YVswXSBpbnN0YW5jZW9mIERhdGU7XHJcblx0Y29uc3QgZCA9IChpc0RhdGUgPyBkYXRhLm1hcChOdW1iZXIpIDogZGF0YSlcclxuXHRcdC5maWx0ZXIoKHYsIGksIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2KSA9PT0gaSk7XHJcblxyXG5cdHJldHVybiBpc0RhdGUgPyBkLm1hcCh2ID0+IG5ldyBEYXRlKHYpKSA6IGQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBhcnJheVxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgU291cmNlIGFycmF5XHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXJyYXkoYXJyOiBhbnlbXSk6IGFueVtdIHtcclxuXHRyZXR1cm4gYXJyICYmIGFyci5sZW5ndGggPyBhcnIucmVkdWNlKChwLCBjKSA9PiBwLmNvbmNhdChjKSkgOiBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIG9iamVjdCByZXR1cm5pbmcgbmV3IG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3RcclxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdE4gU291cmNlIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBtZXJnZWQgdGFyZ2V0IG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VPYmoodGFyZ2V0OiBvYmplY3QsIC4uLm9iamVjdE4pOiBhbnkge1xyXG5cdGlmICghb2JqZWN0Ti5sZW5ndGggfHwgKG9iamVjdE4ubGVuZ3RoID09PSAxICYmICFvYmplY3ROWzBdKSkge1xyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHNvdXJjZSA9IG9iamVjdE4uc2hpZnQoKTtcclxuXHJcblx0aWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xyXG5cdFx0T2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XHJcblxyXG5cdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHRcdFx0IXRhcmdldFtrZXldICYmICh0YXJnZXRba2V5XSA9IHt9KTtcclxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlT2JqKHRhcmdldFtrZXldLCB2YWx1ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBpc0FycmF5KHZhbHVlKSA/XHJcblx0XHRcdFx0XHR2YWx1ZS5jb25jYXQoKSA6IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBtZXJnZU9iaih0YXJnZXQsIC4uLm9iamVjdE4pO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydCB2YWx1ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHZhbHVlIHRvIGJlIHNvcnRlZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQXNjIHRydWU6IGFzYywgZmFsc2U6IGRlc2NcclxuICogQHJldHVybnMge251bWJlcnxzdHJpbmd8RGF0ZX0gc29ydGVkIGRhdGVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvcnRWYWx1ZShkYXRhOiBhbnlbXSwgaXNBc2MgPSB0cnVlKTogYW55W10ge1xyXG5cdGxldCBmbjtcclxuXHJcblx0aWYgKGRhdGFbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRmbiA9IGlzQXNjID8gKGEsIGIpID0+IGEgLSBiIDogKGEsIGIpID0+IGIgLSBhO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpZiAoaXNBc2MgJiYgIWRhdGEuZXZlcnkoaXNOYU4pKSB7XHJcblx0XHRcdGZuID0gKGEsIGIpID0+IGEgLSBiO1xyXG5cdFx0fSBlbHNlIGlmICghaXNBc2MpIHtcclxuXHRcdFx0Zm4gPSAoYSwgYikgPT4gKGEgPiBiICYmIC0xKSB8fCAoYSA8IGIgJiYgMSkgfHwgKGEgPT09IGIgJiYgMCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YS5jb25jYXQoKS5zb3J0KGZuKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBtaW4vbWF4IHZhbHVlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdtaW4nIG9yICdtYXgnXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgQXJyYXkgZGF0YSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfERhdGV8dW5kZWZpbmVkfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWluTWF4KHR5cGU6IFwibWluXCIgfCBcIm1heFwiLCBkYXRhOiBudW1iZXJbXSB8IERhdGVbXSB8IGFueSk6IG51bWJlciB8IERhdGUgfCB1bmRlZmluZWQgfCBhbnkge1xyXG5cdGxldCByZXMgPSBkYXRhLmZpbHRlcih2ID0+IG5vdEVtcHR5KHYpKTtcclxuXHJcblx0aWYgKHJlcy5sZW5ndGgpIHtcclxuXHRcdGlmIChpc051bWJlcihyZXNbMF0pKSB7XHJcblx0XHRcdHJlcyA9IE1hdGhbdHlwZV0oLi4ucmVzKTtcclxuXHRcdH0gZWxzZSBpZiAocmVzWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRyZXMgPSBzb3J0VmFsdWUocmVzLCB0eXBlID09PSBcIm1pblwiKVswXTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCByYW5nZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcCBTdGVwIG51bWJlclxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBnZXRSYW5nZSA9IChzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc3RlcCA9IDEpOiBudW1iZXJbXSA9PiB7XHJcblx0Y29uc3QgcmVzOiBudW1iZXJbXSA9IFtdO1xyXG5cdGNvbnN0IG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXApKSB8IDA7XHJcblxyXG5cdGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG47IGkrKykge1xyXG5cdFx0cmVzLnB1c2goc3RhcnQgKyBpICogc3RlcCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLy8gZW11bGF0ZSBldmVudFxyXG5jb25zdCBlbXVsYXRlRXZlbnQgPSB7XHJcblx0bW91c2U6ICgoKSA9PiB7XHJcblx0XHRjb25zdCBnZXRQYXJhbXMgPSAoKSA9PiAoe1xyXG5cdFx0XHRidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIHNjcmVlblg6IDAsIHNjcmVlblk6IDAsIGNsaWVudFg6IDAsIGNsaWVudFk6IDBcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcclxuXHRcdFx0bmV3IE1vdXNlRXZlbnQoXCJ0XCIpO1xyXG5cclxuXHRcdFx0cmV0dXJuIChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcclxuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zKSk7XHJcblx0XHRcdH07XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8vIFBvbHlmaWxscyBET000IE1vdXNlRXZlbnRcclxuXHRcdFx0cmV0dXJuIChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcclxuXHRcdFx0XHRjb25zdCBtb3VzZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50XCIpO1xyXG5cclxuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9pbml0TW91c2VFdmVudFxyXG5cdFx0XHRcdG1vdXNlRXZlbnQuaW5pdE1vdXNlRXZlbnQoXHJcblx0XHRcdFx0XHRldmVudFR5cGUsXHJcblx0XHRcdFx0XHRwYXJhbXMuYnViYmxlcyxcclxuXHRcdFx0XHRcdHBhcmFtcy5jYW5jZWxhYmxlLFxyXG5cdFx0XHRcdFx0d2luZG93LFxyXG5cdFx0XHRcdFx0MCwgLy8gdGhlIGV2ZW50J3MgbW91c2UgY2xpY2sgY291bnRcclxuXHRcdFx0XHRcdHBhcmFtcy5zY3JlZW5YLCBwYXJhbXMuc2NyZWVuWSxcclxuXHRcdFx0XHRcdHBhcmFtcy5jbGllbnRYLCBwYXJhbXMuY2xpZW50WSxcclxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChtb3VzZUV2ZW50KTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KSgpLFxyXG5cdHRvdWNoOiAoZWw6IFNWR0VsZW1lbnQgfCBIVE1MRWxlbWVudCwgZXZlbnRUeXBlOiBzdHJpbmcsIHBhcmFtczogYW55KSA9PiB7XHJcblx0XHRjb25zdCB0b3VjaE9iaiA9IG5ldyBUb3VjaChtZXJnZU9iaih7XHJcblx0XHRcdGlkZW50aWZpZXI6IERhdGUubm93KCksXHJcblx0XHRcdHRhcmdldDogZWwsXHJcblx0XHRcdHJhZGl1c1g6IDIuNSxcclxuXHRcdFx0cmFkaXVzWTogMi41LFxyXG5cdFx0XHRyb3RhdGlvbkFuZ2xlOiAxMCxcclxuXHRcdFx0Zm9yY2U6IDAuNVxyXG5cdFx0fSwgcGFyYW1zKSk7XHJcblxyXG5cdFx0ZWwuZGlzcGF0Y2hFdmVudChuZXcgVG91Y2hFdmVudChldmVudFR5cGUsIHtcclxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcclxuXHRcdFx0YnViYmxlczogdHJ1ZSxcclxuXHRcdFx0c2hpZnRLZXk6IHRydWUsXHJcblx0XHRcdHRvdWNoZXM6IFt0b3VjaE9ial0sXHJcblx0XHRcdHRhcmdldFRvdWNoZXM6IFtdLFxyXG5cdFx0XHRjaGFuZ2VkVG91Y2hlczogW3RvdWNoT2JqXVxyXG5cdFx0fSkpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSAgJiByZXR1cm4gYm91bmQgc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cGwgVGVtcGxhdGUgc3RyaW5nXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIERhdGEgdmFsdWUgdG8gYmUgcmVwbGFjZWRcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRwbFByb2Nlc3ModHBsOiBzdHJpbmcsIGRhdGE6IG9iamVjdCk6IHN0cmluZyB7XHJcblx0bGV0IHJlcyA9IHRwbDtcclxuXHJcblx0Zm9yIChjb25zdCB4IGluIGRhdGEpIHtcclxuXHRcdHJlcyA9IHJlcy5yZXBsYWNlKG5ldyBSZWdFeHAoYHs9JHt4fX1gLCBcImdcIiksIGRhdGFbeF0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwYXJzZWQgZGF0ZSB2YWx1ZVxyXG4gKiAoSXQgbXVzdCBiZSBjYWxsZWQgaW4gJ0NoYXJ0SW50ZXJuYWwnIGNvbnRleHQpXHJcbiAqIEBwYXJhbSB7RGF0ZXxzdHJpbmd8bnVtYmVyfSBkYXRlIFZhbHVlIG9mIGRhdGUgdG8gYmUgcGFyc2VkXHJcbiAqIEByZXR1cm5zIHtEYXRlfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGU6IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCBhbnkpOiBEYXRlIHtcclxuXHRsZXQgcGFyc2VkRGF0ZTtcclxuXHJcblx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRwYXJzZWREYXRlID0gZGF0ZTtcclxuXHR9IGVsc2UgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXR9ID0gdGhpcztcclxuXHJcblx0XHRwYXJzZWREYXRlID0gZm9ybWF0LmRhdGFUaW1lKGNvbmZpZy5kYXRhX3hGb3JtYXQpKGRhdGUpO1xyXG5cdH0gZWxzZSBpZiAoaXNOdW1iZXIoZGF0ZSkgJiYgIWlzTmFOKGRhdGUpKSB7XHJcblx0XHRwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFwYXJzZWREYXRlIHx8IGlzTmFOKCtwYXJzZWREYXRlKSkge1xyXG5cdFx0Y29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSB4ICcke2RhdGV9JyB0byBEYXRlIG9iamVjdGApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBhcnNlZERhdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gaWYgdGhlIGN1cnJlbnQgZG9jIGlzIHZpc2libGUgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNUYWJWaXNpYmxlKCk6IGJvb2xlYW4ge1xyXG5cdHJldHVybiAhZG9jdW1lbnQuaGlkZGVuO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGlucHV0IHR5cGVcclxuICogQHBhcmFtIHtib29sZWFufSBtb3VzZSBDb25maWcgdmFsdWU6IGludGVyYWN0aW9uLmlucHV0VHlwZS5tb3VzZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRvdWNoIENvbmZpZyB2YWx1ZTogaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFwibW91c2VcIiB8IFwidG91Y2hcIiB8IG51bGxcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRJbnB1dFR5cGUobW91c2U6IGJvb2xlYW4sIHRvdWNoOiBib29sZWFuKTogXCJtb3VzZVwiIHwgXCJ0b3VjaFwiIHwgbnVsbCB7XHJcblx0bGV0IGlzTW9iaWxlID0gZmFsc2U7XHJcblxyXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQnJvd3Nlcl9kZXRlY3Rpb25fdXNpbmdfdGhlX3VzZXJfYWdlbnQjTW9iaWxlX1RhYmxldF9vcl9EZXNrdG9wXHJcblx0aWYgKC9Nb2JpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSAmJiB0b3VjaCkge1xyXG5cdFx0Ly8gU29tZSBFZGdlIGRlc2t0b3AgcmV0dXJuIHRydWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzIwNDE3MDc0L1xyXG5cdFx0Y29uc3QgaGFzVG91Y2hQb2ludHMgPSB3aW5kb3cubmF2aWdhdG9yICYmIFwibWF4VG91Y2hQb2ludHNcIiBpbiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xyXG5cclxuXHRcdC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL3RvdWNoZXZlbnRzLmpzXHJcblx0XHQvLyBPbiBJRTExIHdpdGggSUU5IGVtdWxhdGlvbiBtb2RlLCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSBpcyByZXR1cm5pbmcgdHJ1ZVxyXG5cdFx0Y29uc3QgaGFzVG91Y2ggPSAoXCJvbnRvdWNobW92ZVwiIGluIHdpbmRvdyB8fCAod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkpO1xyXG5cclxuXHRcdGlzTW9iaWxlID0gaGFzVG91Y2hQb2ludHMgfHwgaGFzVG91Y2g7XHJcblx0fVxyXG5cclxuXHRjb25zdCBoYXNNb3VzZSA9IG1vdXNlICYmICFpc01vYmlsZSA/IChcIm9ubW91c2VvdmVyXCIgaW4gd2luZG93KSA6IGZhbHNlO1xyXG5cclxuXHRyZXR1cm4gKGhhc01vdXNlICYmIFwibW91c2VcIikgfHwgKGlzTW9iaWxlICYmIFwidG91Y2hcIikgfHwgbnVsbDtcclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB4IGZyb20gXCIuL3hcIjtcclxuaW1wb3J0IHkgZnJvbSBcIi4veVwiO1xyXG5pbXBvcnQgeTIgZnJvbSBcIi4veTJcIjtcclxuXHJcbmltcG9ydCB7bWVyZ2VPYmp9IGZyb20gXCIuLi8uLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIHkgQXhpcyAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IG1lcmdlT2JqKHtcclxuXHQvKipcclxuXHQgKiBTd2l0Y2ggeCBhbmQgeSBheGlzIHBvc2l0aW9uLlxyXG5cdCAqIEBuYW1lIGF4aXPigKRyb3RhdGVkXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgcm90YXRlZDogdHJ1ZVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3JvdGF0ZWQ6IGZhbHNlXHJcbn0sIHgsIHksIHkyKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZ3JpZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxudHlwZSBMaW5lcyA9IHt2YWx1ZT86IG51bWJlcjsgdGV4dD86IHN0cmluZzsgY2xhc3M/OiBzdHJpbmc7IHBvc2l0aW9uPzogc3RyaW5nfVtdO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCByZWxhdGVkIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBncmlkXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zyb250PWZhbHNlXSBTZXQgJ2dyaWQgJiBmb2N1cyBsaW5lcycgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGdyaWQgbGluZXMgYW5kIGNoYXJ0IGVsZW1lbnRzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB4IEdyaWQgeCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt4LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt4LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB4IGF4aXMuPGJyPlxyXG5cdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy4gdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzIGFyZSBvcHRpb25hbC4gRm9yIHBvc2l0aW9uLCBzdGFydCwgbWlkZGxlIGFuZCBlbmQgKGRlZmF1bHQpIGFyZSBhdmFpbGFibGUuXHJcblx0ICogIElmIHggYXhpcyBpcyBjYXRlZ29yeSBheGlzLCB2YWx1ZSBjYW4gYmUgY2F0ZWdvcnkgbmFtZS4gSWYgeCBheGlzIGlzIHRpbWVzZXJpZXMgYXhpcywgdmFsdWUgY2FuIGJlIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlci5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0geSBHcmlkIHkgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbeS5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cclxuXHQgKiBAcHJvcGVydHkge0FycmF5fSBbeS5saW5lcz1bXV0gU2hvdyBhZGRpdGlvbmFsIGdyaWQgbGluZXMgYWxvbmcgeSBheGlzLjxicj5cclxuXHQgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBhcnJheSBpbmNsdWRpbmcgb2JqZWN0IHRoYXQgaGFzIHZhbHVlLCB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt5LnRpY2tzPTEwXSBOdW1iZXIgb2YgeSBncmlkcyB0byBiZSBzaG93bi5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZm9jdXMgR3JpZCBmb2N1cyBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb2N1cy5lZGdlPWZhbHNlXSBTaG93IGVkZ2VkIGZvY3VzIGdyaWQgbGluZS48YnI+KipOT1RFOioqIEF2YWlsYWJsZSB3aGVuIFtgdG9vbHRpcC5ncm91cGVkPWZhbHNlYF0oIy50b29sdGlwKSBvcHRpb24gaXMgc2V0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZvY3VzLnNob3c9dHJ1ZV0gU2hvdyBncmlkIGxpbmUgd2hlbiBmb2N1cy5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb2N1cy55PWZhbHNlXSBTaG93IHkgY29vcmRpbmF0ZSBmb2N1cyBncmlkIGxpbmUuPGJyPioqTk9URToqKiBBdmFpbGFibGUgd2hlbiBbYHRvb2x0aXAuZ3JvdXBlZD1mYWxzZWBdKCMudG9vbHRpcCkgb3B0aW9uIGlzIHNldC5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gbGluZXMgR3JpZCBsaW5lcyBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaW5lcy5mcm9udD10cnVlXSBTZXQgZ3JpZCBsaW5lcyB0byBiZSBwb3NpdGlvbmVkIG92ZXIgY2hhcnQgZWxlbWVudHMuXHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuR3JpZExpbmVzKVxyXG5cdCAqIEBzZWUgW0RlbW86IFggR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxYR3JpZExpbmVzKVxyXG5cdCAqIEBzZWUgW0RlbW86IFkgR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxZR3JpZExpbmVzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZ3JpZDoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICBsaW5lczogW1xyXG5cdCAqICAgICAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCBvbiAyXCJ9LFxyXG5cdCAqICAgICAgIHt2YWx1ZTogNSwgdGV4dDogXCJMYWJlbCBvbiA1XCIsIGNsYXNzOiBcImxhYmVsLTVcIn0sXHJcblx0ICogICAgICAge3ZhbHVlOiA2LCB0ZXh0OiBcIkxhYmVsIG9uIDZcIiwgcG9zaXRpb246IFwic3RhcnRcIn1cclxuXHQgKiAgICAgXVxyXG5cdCAqICAgfSxcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgbGluZXM6IFtcclxuXHQgKiAgICAgICB7dmFsdWU6IDEwMCwgdGV4dDogXCJMYWJlbCBvbiAxMDBcIn0sXHJcblx0ICogICAgICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgb24gMjAwXCIsIGNsYXNzOiBcImxhYmVsLTIwMFwifSxcclxuXHQgKiAgICAgICB7dmFsdWU6IDMwMCwgdGV4dDogXCJMYWJlbCBvbiAzMDBcIiwgcG9zaXRpb246ICdtaWRkbGUnfVxyXG5cdCAqICAgICBdLFxyXG5cdCAqICAgICB0aWNrczogNVxyXG5cdCAqICAgfSxcclxuXHQgKiAgIGZyb250OiB0cnVlLFxyXG5cdCAqICAgZm9jdXM6IHtcclxuXHQgKiAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBCZWxvdyBvcHRpb25zIGFyZSBhdmFpbGFibGUgd2hlbiAndG9vbHRpcC5ncm91cGVkPWZhbHNlJyBvcHRpb24gaXMgc2V0XHJcblx0ICogICAgICBlZGdlOiB0cnVlLFxyXG5cdCAqICAgICAgeTogdHJ1ZVxyXG5cdCAqICAgfSxcclxuXHQgKiAgIGxpbmVzOiB7XHJcblx0ICogICAgICBmcm9udDogZmFsc2VcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0Z3JpZF94X3Nob3c6IGZhbHNlLFxyXG5cdGdyaWRfeF90eXBlOiBcInRpY2tcIixcclxuXHRncmlkX3hfbGluZXM6IDxMaW5lcz4gW10sXHJcblx0Z3JpZF95X3Nob3c6IGZhbHNlLFxyXG5cdGdyaWRfeV9saW5lczogPExpbmVzPiBbXSxcclxuXHRncmlkX3lfdGlja3M6IDEwLFxyXG5cdGdyaWRfZm9jdXNfZWRnZTogZmFsc2UsXHJcblx0Z3JpZF9mb2N1c19zaG93OiB0cnVlLFxyXG5cdGdyaWRfZm9jdXNfeTogZmFsc2UsXHJcblx0Z3JpZF9mcm9udDogZmFsc2UsXHJcblx0Z3JpZF9saW5lc19mcm9udDogdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBwb2ludCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBwb2ludCBvcHRpb25zXHJcblx0ICogQG5hbWUgcG9pbnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHBvaW50IFBvaW50IG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50LnNob3c9dHJ1ZV0gV2hldGhlciB0byBzaG93IGVhY2ggcG9pbnQgaW4gbGluZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxGdW5jdGlvbn0gW3BvaW50LnI9Mi41XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludC5cclxuXHQgKiAgLSAqKk5PVEU6KiogRGlzYWJsZWQgZm9yICdidWJibGUnIHR5cGVcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwb2ludC5mb2N1cy5leHBhbmQuZW5hYmxlZD10cnVlXSBXaGV0aGVyIHRvIGV4cGFuZCBlYWNoIHBvaW50IG9uIGZvY3VzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcG9pbnQuZm9jdXMuZXhwYW5kLnI9cG9pbnQucioxLjc1XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBmb2N1cy5cclxuXHQgKiAgLSAqKk5PVEU6KiogRm9yICdidWJibGUnIHR5cGUsIHRoZSBkZWZhdWx0IGlzIGBidWJibGVTaXplKjEuMTVgXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcG9pbnQuZm9jdXMub25seT1mYWxzZV0gU2hvdyBwb2ludCBvbmx5IHdoZW4gaXMgZm9jdXNlZC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BvaW50LnNlbnNpdGl2aXR5PTEwXSBUaGUgc2Vuc3Rpdml0eSB2YWx1ZSBmb3IgaW50ZXJhY3Rpb24gYm91bmRhcnkuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwb2ludC5zZWxlY3Qucj1wb2ludC5yKjRdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIHNlbGVjdGVkLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cclxuXHQgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXHJcblx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAgIC0gY2lyY2xlXHJcblx0ICogICAtIHJlY3RhbmdsZVxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtwb2ludC5wYXR0ZXJuPVtdXSBUaGUgdHlwZSBvZiBwb2ludCBvciBzdmcgc2hhcGUgYXMgc3RyaW5nLCB0byBiZSBkcmF3biBmb3IgZWFjaCBsaW5lXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gVGhpcyBpcyBhbiBgZXhwZXJpbWVudGFsYCBmZWF0dXJlIGFuZCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxyXG5cdCAqICAgLSBJZiBjaGFydCBoYXMgJ2J1YmJsZScgdHlwZSwgb25seSBjaXJjbGUgY2FuIGJlIHVzZWQuXHJcblx0ICogICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxyXG5cdCAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogICAtIGNpcmNsZVxyXG5cdCAqICAgLSByZWN0YW5nbGVcclxuXHQgKiAgIC0gc3ZnIHNoYXBlIHRhZyBpbnRlcnByZXRlZCBhcyBzdHJpbmc8YnI+XHJcblx0ICogICAgIChleC4gYDxwb2x5Z29uIHBvaW50cz0nMi41IDAgMCA1IDUgNSc+PC9wb2x5Z29uPmApXHJcblx0ICogQHNlZSBbRGVtbzogcG9pbnQgdHlwZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1BvaW50LlJlY3RhbmdsZVBvaW50cylcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBwb2ludDoge1xyXG5cdCAqICAgICAgc2hvdzogZmFsc2UsXHJcblx0ICogICAgICByOiA1LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBvciBjdXN0b21pemUgdGhlIHJhZGl1c1xyXG5cdCAqICAgICAgcjogZnVuY3Rpb24oZCkge1xyXG5cdCAqICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgICAgIHJldHVybiByO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgZm9jdXM6IHtcclxuXHQgKiAgICAgICAgICBleHBhbmQ6IHtcclxuXHQgKiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuXHQgKiAgICAgICAgICAgICAgcjogMVxyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgb25seTogdHJ1ZVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHNlbGVjdDoge1xyXG5cdCAqICAgICAgICAgIHI6IDNcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGhhdmluZyBsb3dlciB2YWx1ZSwgbWVhbnMgaG93IGNsb3NlciB0byBiZSBmb3IgaW50ZXJhY3Rpb25cclxuXHQgKiAgICAgIHNlbnNpdGl2aXR5OiAzLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyB2YWxpZCB2YWx1ZXMgYXJlIFwiY2lyY2xlXCIgb3IgXCJyZWN0YW5nbGVcIlxyXG5cdCAqICAgICAgdHlwZTogXCJyZWN0YW5nbGVcIixcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gb3IgaW5kaWNhdGUgYXMgcGF0dGVyblxyXG5cdCAqICAgICAgcGF0dGVybjogW1xyXG5cdCAqICAgICAgICBcImNpcmNsZVwiLFxyXG5cdCAqICAgICAgICBcInJlY3RhbmdsZVwiLFxyXG5cdCAqICAgICAgICBcIjxwb2x5Z29uIHBvaW50cz0nMCA2IDQgMCAtNCAwJz48L3BvbHlnb24+XCJcclxuXHQgKiAgICAgXSxcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHBvaW50X3Nob3c6IHRydWUsXHJcblx0cG9pbnRfcjogMi41LFxyXG5cdHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcclxuXHRwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZDogdHJ1ZSxcclxuXHRwb2ludF9mb2N1c19leHBhbmRfcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRwb2ludF9mb2N1c19vbmx5OiBmYWxzZSxcclxuXHRwb2ludF9wYXR0ZXJuOiA8c3RyaW5nW10+IFtdLFxyXG5cdHBvaW50X3NlbGVjdF9yOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHBvaW50X3R5cGU6IFwiY2lyY2xlXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHN1YmNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAbmFtZSBzdWJjaGFydFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gc3ViY2hhcnQgU3ViY2hhcnQgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbc3ViY2hhcnQuc2hvdz1mYWxzZV0gU2hvdyBzdWIgY2hhcnQgb24gdGhlIGJvdHRvbSBvZiB0aGUgY2hhcnQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcy5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzdWJjaGFydC5heGlzLngudGljay5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayBsaW5lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnRleHQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgdGV4dC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3N1YmNoYXJ0LnNpemUuaGVpZ2h0XSBDaGFuZ2UgdGhlIGhlaWdodCBvZiB0aGUgc3ViY2hhcnQuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3N1YmNoYXJ0Lm9uYnJ1c2hdIFNldCBjYWxsYmFjayBmb3IgYnJ1c2ggZXZlbnQuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGN1cnJlbnQgem9vbWVkIHggZG9tYWluLlxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5TdWJDaGFydClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBzdWJjaGFydDoge1xyXG5cdCAqICAgICAgYXhpczoge1xyXG5cdCAqICAgICAgXHR4OiB7XHJcblx0ICogICAgICBcdCAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgIFx0ICAgIHRpY2s6IHtcclxuXHQgKiAgICAgIFx0ICAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgIFx0ICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgXHQgICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgICBcdCAgICAgIH1cclxuXHQgKiAgICAgIFx0ICAgIH1cclxuXHQgKiAgICAgIFx0fVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHNob3c6IHRydWUsXHJcblx0ICogICAgICBzaXplOiB7XHJcblx0ICogICAgICAgICAgaGVpZ2h0OiAyMFxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIG9uYnJ1c2g6IGZ1bmN0aW9uKGRvbWFpbikgeyAuLi4gfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0c3ViY2hhcnRfc2hvdzogZmFsc2UsXHJcblx0c3ViY2hhcnRfc2l6ZV9oZWlnaHQ6IDYwLFxyXG5cdHN1YmNoYXJ0X2F4aXNfeF9zaG93OiB0cnVlLFxyXG5cdHN1YmNoYXJ0X2F4aXNfeF90aWNrX3Nob3c6IHRydWUsXHJcblx0c3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG5cdHN1YmNoYXJ0X29uYnJ1c2g6ICgpID0+IHt9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHpvb20gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgem9vbSBvcHRpb25zXHJcblx0ICogQG5hbWUgem9vbVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gem9vbSBab29tIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3pvb20uZW5hYmxlZD1mYWxzZV0gRW5hYmxlIHpvb21pbmcuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tLmVuYWJsZWQudHlwZT0nd2hlZWwnXSBTZXQgem9vbSBpbnRlcmFjdGlvbiB0eXBlLlxyXG5cdCAqICAtICoqQXZhaWxhYmxlIHR5cGVzOioqXHJcblx0ICogICAgLSB3aGVlbFxyXG5cdCAqICAgIC0gZHJhZ1xyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3pvb20ucmVzY2FsZT1mYWxzZV0gRW5hYmxlIHRvIHJlc2NhbGUgYWZ0ZXIgem9vbWluZy48YnI+XHJcblx0ICogIElmIHRydWUgc2V0LCB5IGRvbWFpbiB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSB6b29tZWQgcmVnaW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt6b29tLmV4dGVudD1bMSwgMTBdXSBDaGFuZ2Ugem9vbSBleHRlbnQuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ8RGF0ZX0gW3pvb20ueC5taW5dIFNldCB4IEF4aXMgbWluaW11bSB6b29tIHJhbmdlXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ8RGF0ZX0gW3pvb20ueC5tYXhdIFNldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tc3RhcnQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIHN0YXJ0cy48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbSBldmVudC5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb209dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY2hhcnQgaXMgem9vbWluZy48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb21lbmQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIGVuZHMuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHpvb21lZCBkb21haW4uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufG9iamVjdH0gW3pvb20ucmVzZXRCdXR0b249dHJ1ZV0gU2V0IHRvIGRpc3BsYXkgem9vbSByZXNldCBidXR0b24gZm9yICdkcmFnJyB0eXBlIHpvb21cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5yZXNldEJ1dHRvbi5vbmNsaWNrXSBTZXQgY2FsbGJhY2sgd2hlbiBjbGlja3MgdGhlIHJlc2V0IGJ1dHRvbi4gVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSByZXNldCBidXR0b24gZWxlbWVudCByZWZlcmVuY2UgYXMgYXJndW1lbnQuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tLnJlc2V0QnV0dG9uLnRleHQ9J1Jlc2V0IFpvb20nXSBUZXh0IHZhbHVlIGZvciB6b29tIHJlc2V0IGJ1dHRvbi5cclxuXHQgKiBAc2VlIFtEZW1vOnpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5ab29tKVxyXG5cdCAqIEBzZWUgW0RlbW86ZHJhZyB6b29tXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uRHJhZ1pvb20pXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgem9vbToge1xyXG5cdCAqICAgICAgZW5hYmxlZDoge1xyXG5cdCAqICAgICAgICAgIHR5cGU6IFwiZHJhZ1wiXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgcmVzY2FsZTogdHJ1ZSxcclxuXHQgKiAgICAgIGV4dGVudDogWzEsIDEwMF0gIC8vIGVuYWJsZSBtb3JlIHpvb21pbmdcclxuXHQgKiAgICAgIHg6IHtcclxuXHQgKiAgICAgICAgICBtaW46IC0xLCAgLy8gc2V0IG1pbiByYW5nZVxyXG5cdCAqICAgICAgICAgIG1heDogMTAgIC8vIHNldCBtYXggcmFuZ2VcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBvbnpvb21zdGFydDogZnVuY3Rpb24oZXZlbnQpIHsgLi4uIH0sXHJcblx0ICogICAgICBvbnpvb206IGZ1bmN0aW9uKGRvbWFpbikgeyAuLi4gfSxcclxuXHQgKiAgICAgIG9uem9vbWVuZDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzaG93IHJlc2V0IGJ1dHRvbiB3aGVuIGlzIHpvb21lZC1pblxyXG5cdCAqICAgICAgcmVzZXRCdXR0b246IHRydWUsXHJcblx0ICpcclxuXHQgKiAgICAgIHJlc2V0QnV0dG9uOiB7XHJcblx0ICogICAgICAgICAgLy8gb25jbGljayBjYWxsYmFjayB3aGVuIHJlc2V0IGJ1dHRvbiBpcyBjbGlja2VkXHJcblx0ICogICAgICAgICAgb25jbGljazogZnVuY3Rpb24oYnV0dG9uKSB7XHJcblx0ICogICAgICAgICAgICBidXR0b247IC8vIFJlc2V0IGJ1dHRvbiBlbGVtZW50IHJlZmVyZW5jZVxyXG5cdCAqICAgICAgICAgICAgLi4uXHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgICAgIC8vIGN1c3RvbWl6ZWQgdGV4dCB2YWx1ZSBmb3IgcmVzZXQgem9vbSBidXR0b25cclxuXHQgKiAgICAgICAgICB0ZXh0OiBcIlVuem9vbVwiXHJcblx0ICogICAgICB9XHJcblx0ICogIH1cclxuXHQgKi9cclxuXHR6b29tX2VuYWJsZWQ6IDx7dHlwZTogXCJ3aGVlbFwiIHwgXCJkcmFnXCJ9fGJvb2xlYW58dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0em9vbV9leHRlbnQ6IDxudW1iZXJbXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR6b29tX3ByaXZpbGVnZWQ6IGZhbHNlLFxyXG5cdHpvb21fcmVzY2FsZTogZmFsc2UsXHJcblx0em9vbV9vbnpvb206IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR6b29tX29uem9vbXN0YXJ0OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0em9vbV9vbnpvb21lbmQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR6b29tX3Jlc2V0QnV0dG9uOiA8e3RleHQ6IHN0cmluZzt9fGJvb2xlYW4+IHRydWUsXHJcblx0em9vbV94X21pbjogPE51bWJlcnxEYXRlfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHpvb21feF9tYXg6IDxOdW1iZXJ8RGF0ZXx1bmRlZmluZWQ+IHVuZGVmaW5lZFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBhcmVhIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGFyZWEgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGFyZWFcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGFyZWEgQXJlYSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcmVhLnplcm9iYXNlZD10cnVlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYXJlYSBjaGFydC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcmVhLmFib3ZlPWZhbHNlXSBTZXQgYmFja2dyb3VuZCBhcmVhIGFib3ZlIHRoZSBkYXRhIGNoYXJ0IGxpbmUuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufG9iamVjdH0gW2FyZWEubGluZWFyR3JhZGllbnQ9ZmFsc2VdIFNldCB0aGUgbGluZWFyIGdyYWRpZW50IG9uIGFyZWEuPGJyPjxicj5cclxuXHQgKiBPciBjdXN0b21pemUgYnkgZ2l2aW5nIGJlbG93IG9iamVjdCB2YWx1ZTpcclxuXHQgKiAgLSB4IHtBcnJheX06IGB4MWAsIGB4MmAgdmFsdWVcclxuXHQgKiAgLSB5IHtBcnJheX06IGB5MWAsIGB5MmAgdmFsdWVcclxuXHQgKiAgLSBzdG9wcyB7QXJyYXl9OiBFYWNoIGl0ZW0gc2hvdWxkIGJlIGhhdmluZyBgW29mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XWAgdmFsdWVzLlxyXG5cdCAqIEBzZWUgW01ETidzICZsdDtsaW5lYXJHcmFkaWVudD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L2xpbmVhckdyYWRpZW50KSwgWyZsdDtzdG9wPl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3RvcClcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxyXG5cdCAqIEBzZWUgW0RlbW86IGFib3ZlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5BYm92ZSlcclxuXHQgKiBAc2VlIFtEZW1vOiBsaW5lYXJHcmFkaWVudF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuTGluZWFyR3JhZGllbnQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgYXJlYToge1xyXG5cdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZSxcclxuXHQgKiAgICAgIGFib3ZlOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyB3aWxsIGdlbmVyYXRlIGZvbGx3aW5nIGxpbmVhckdyYWRpZW50OlxyXG5cdCAqICAgICAgLy8gPGxpbmVhckdyYWRpZW50IHgxPVwiMFwiIHgyPVwiMFwiIHkxPVwiMFwiIHkyPVwiMVwiPlxyXG5cdCAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjFcIj48L3N0b3A+XHJcblx0ICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMFwiPjwvc3RvcD5cclxuXHQgKiAgICAgIC8vIDwvbGluZWFyR3JhZGllbnQ+XHJcblx0ICogICAgICBsaW5lYXJHcmFkaWVudDogdHJ1ZSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gT3IgY3VzdG9taXplZCBncmFkaWVudFxyXG5cdCAqICAgICAgbGluZWFyR3JhZGllbnQ6IHtcclxuXHQgKiAgICAgIFx0eDogWzAsIDBdLCAgLy8geDEsIHgyIGF0dHJpYnV0ZXNcclxuXHQgKiAgICAgIFx0eTogWzAsIDBdLCAgLy8geTEsIHkyIGF0dHJpYnV0ZXNcclxuXHQgKiAgICAgIFx0c3RvcHM6IFtcclxuXHQgKiAgICAgIFx0ICAvLyBvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eVxyXG5cdCAqICAgICAgXHQgIFswLCBcIiM3Y2I1ZWNcIiwgMV0sXHJcblx0ICpcclxuXHQgKiAgICAgIFx0ICAvLyBzZXR0aW5nICdudWxsJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBzZXQgaXRzIG9yaWdpbmFsIGRhdGEgY29sb3JcclxuXHQgKiAgICAgIFx0ICBbMC41LCBudWxsLCAwXSxcclxuXHQgKlxyXG5cdCAqICAgICAgXHQgIC8vIHNldHRpbmcgJ2Z1bmN0aW9uJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBwYXNzIGRhdGEgaWQgYXMgYXJndW1lbnQuXHJcblx0ICogICAgICBcdCAgLy8gSXQgc2hvdWxkIHJldHVybiBjb2xvciBzdHJpbmcgb3IgbnVsbCB2YWx1ZVxyXG5cdCAqICAgICAgXHQgIFsxLCBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImJsdWVcIjsgfSwgMF0sXHJcblx0ICogICAgICBcdF1cclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGFyZWFfemVyb2Jhc2VkOiB0cnVlLFxyXG5cdGFyZWFfYWJvdmU6IGZhbHNlLFxyXG5cdGFyZWFfbGluZWFyR3JhZGllbnQ6IDxcclxuXHRcdFx0Ym9vbGVhbnx7eD86IG51bWJlcltdOyB5PzogbnVtYmVyW107IHN0b3BzPzogW251bWJlciwgc3RyaW5nfEZ1bmN0aW9ufG51bGwsIG51bWJlcl19XHJcblx0XHQ+IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGJhciBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBiYXIgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGJhclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gYmFyIEJhciBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci5wYWRkaW5nPTBdIFRoZSBwYWRkaW5nIHBpeGVsIHZhbHVlIGJldHdlZW4gZWFjaCBiYXIuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIucmFkaXVzXSBTZXQgdGhlIHJhZGl1cyBvZiBiYXIgZWRnZSBpbiBwaXhlbC5cclxuXHQgKiAtICoqTk9URToqKiBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci5yYWRpdXMucmF0aW9dIFNldCB0aGUgcmFkaXVzIHJhdGlvIG9mIGJhciBlZGdlIGluIHJlbGF0aXZlIHRoZSBiYXIncyB3aWR0aC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci5zZW5zaXRpdml0eT0yXSBUaGUgc2Vuc3Rpdml0eSBvZmZzZXQgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLndpZHRoXSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci53aWR0aC5yYXRpbz0wLjZdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0IGJ5IHJhdGlvLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLndpZHRoLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lXSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBmb3IgaW5kaWNhdGVkIGRhdGFzZXQgb25seS5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcclxuXHQgKiAgIC0gQmFycyBhcmUgY2VudGVyZWQgYWNjb2RpbmcgaXRzIHRvdGFsIHdpZHRoIHZhbHVlXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWUucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtiYXIuemVyb2Jhc2VkPXRydWVdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBiYXIgY2hhcnQuXHJcblx0ICogQHNlZSBbRGVtbzogYmFyIHBhZGRpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyUGFkZGluZylcclxuXHQgKiBAc2VlIFtEZW1vOiBiYXIgcmFkaXVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclJhZGl1cylcclxuXHQgKiBAc2VlIFtEZW1vOiBiYXIgd2lkdGhdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyV2lkdGgpXHJcblx0ICogQHNlZSBbRGVtbzogYmFyIHdpZHRoIHZhcmlhbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyV2lkdGhWYXJpYW50KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGJhcjoge1xyXG5cdCAqICAgICAgcGFkZGluZzogMSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gdGhlICdyYWRpdXMnIG9wdGlvbiBjYW4gYmUgdXNlZCBvbmx5IGZvciBub24tc3RhY2tpbmcgYmFyc1xyXG5cdCAqICAgICAgcmFkaXVzOiAxMCxcclxuXHQgKiAgICAgIC8vIG9yXHJcblx0ICogICAgICByYWRpdXM6IHtcclxuXHQgKiAgICAgICAgICByYXRpbzogMC41XHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHdpbGwgbm90IGhhdmUgb2Zmc2V0IGJldHdlZW4gZWFjaCBiYXIgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXHJcblx0ICogICAgICBzZW5zaXRpdml0eTogMCxcclxuXHQgKlxyXG5cdCAqICAgICAgd2lkdGg6IDEwLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBvclxyXG5cdCAqICAgICAgd2lkdGg6IHtcclxuXHQgKiAgICAgICAgICByYXRpbzogMC4yLFxyXG5cdCAqICAgICAgICAgIG1heDogMjBcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yIHNwZWNpZnkgd2lkdGggcGVyIGRhdGFzZXRcclxuXHQgKiAgICAgIHdpZHRoOiB7XHJcblx0ICogICAgICAgICAgZGF0YTE6IDIwLFxyXG5cdCAqICAgICAgICAgIGRhdGEyOiB7XHJcblx0ICogICAgICAgICAgICAgIHJhdGlvOiAwLjIsXHJcblx0ICogICAgICAgICAgICAgIG1heDogMjBcclxuXHQgKiAgICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRiYXJfcGFkZGluZzogMCxcclxuXHRiYXJfcmFkaXVzOiA8bnVtYmVyfHtyYXRpbzogbnVtYmVyfXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRiYXJfcmFkaXVzX3JhdGlvOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGJhcl9zZW5zaXRpdml0eTogMixcclxuXHRiYXJfd2lkdGg6IDxudW1iZXJ8e3JhdGlvPzogbnVtYmVyOyBtYXg/OiBudW1iZXI7fXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRiYXJfd2lkdGhfcmF0aW86IDAuNixcclxuXHRiYXJfd2lkdGhfbWF4OiB1bmRlZmluZWQsXHJcblx0YmFyX3plcm9iYXNlZDogdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBidWJibGUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgYnViYmxlIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBidWJibGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGJ1YmJsZSBidWJibGUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ8RnVuY3Rpb259IFtidWJibGUubWF4Uj0zNV0gU2V0IHRoZSBtYXggYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZS56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBidWJibGUgY2hhcnQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgYnViYmxlOiB7XHJcblx0ICogICAgICAvLyBleCkgSWYgMTAwIGlzIHRoZSBoaWdoZXN0IHZhbHVlIGFtb25nIGRhdGEgYm91bmQsIHRoZSByZXByZXNlbnRhdGlvbiBidWJibGUgb2YgMTAwIHdpbGwgaGF2ZSByYWRpdXMgb2YgNTAuXHJcblx0ICogICAgICAvLyBBbmQgdGhlIGxlc3NlciB3aWxsIGhhdmUgcmFkaXVzIHJlbGF0aXZlbHkgZnJvbSB0aGEgbWF4IHZhbHVlLlxyXG5cdCAqICAgICAgbWF4UjogNTAsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yIHNldCByYWRpdXMgY2FsbGJhY2tcclxuXHQgKiAgICAgIG1heFI6IGZ1bmN0aW9uKGQpIHtcclxuXHQgKiAgICAgICAgICAvLyBleC4gb2YgZCBwYXJhbSAtIHt4OiBGcmkgT2N0IDA2IDIwMTcgMDA6MDA6MDAgR01UKzA5MDAsIHZhbHVlOiA4MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDV9XHJcblx0ICogICAgICAgICAgLi4uXHJcblx0ICogICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlICogMik7XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0YnViYmxlX21heFI6IDxudW1iZXJ8KCgpID0+IG51bWJlcik+IDM1LFxyXG5cdGJ1YmJsZV96ZXJvYmFzZWQ6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGxpbmUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgbGluZSBvcHRpb25zXHJcblx0ICogQG5hbWUgbGluZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gbGluZSBMaW5lIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpbmUuY29ubmVjdE51bGw9ZmFsc2VdIFNldCBpZiBudWxsIGRhdGEgcG9pbnQgd2lsbCBiZSBjb25uZWN0ZWQgb3Igbm90Ljxicj5cclxuXHQgKiAgSWYgdHJ1ZSBzZXQsIHRoZSByZWdpb24gb2YgbnVsbCBkYXRhIHdpbGwgYmUgY29ubmVjdGVkIHdpdGhvdXQgYW55IGRhdGEgcG9pbnQuIElmIGZhbHNlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBub3QgYmUgY29ubmVjdGVkIGFuZCBnZXQgZW1wdHkuXHJcblx0ICogQHByb3BlcnR5IHtBcnJheX0gICBbbGluZS5jbGFzc2VzPXVuZGVmaW5lZF0gSWYgc2V0LCB1c2VkIHRvIHNldCBhIGNzcyBjbGFzcyBvbiBlYWNoIGxpbmUuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGluZS5zdGVwLnR5cGU9c3RlcF0gQ2hhbmdlIHN0ZXAgdHlwZSBmb3Igc3RlcCBjaGFydC48YnI+XHJcblx0ICogKipBdmFpbGFibGUgdmFsdWVzOioqXHJcblx0ICogLSBzdGVwXHJcblx0ICogLSBzdGVwLWJlZm9yZVxyXG5cdCAqIC0gc3RlcC1hZnRlclxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxBcnJheX0gW2xpbmUucG9pbnQ9dHJ1ZV0gU2V0IHRvIGZhbHNlIHRvIG5vdCBkcmF3IHBvaW50cyBvbiBsaW5lY2hhcnRzLiBPciBwYXNzIGFuIGFycmF5IG9mIGxpbmUgaWRzIHRvIGRyYXcgcG9pbnRzIGZvci5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaW5lLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGxpbmUgY2hhcnQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgbGluZToge1xyXG5cdCAqICAgICAgY29ubmVjdE51bGw6IHRydWUsXHJcblx0ICogICAgICBjbGFzc2VzOiBbXHJcblx0ICogICAgICAgICAgXCJsaW5lLWNsYXNzMVwiLFxyXG5cdCAqICAgICAgICAgIFwibGluZS1jbGFzczJcIlxyXG5cdCAqICAgICAgXSxcclxuXHQgKiAgICAgIHN0ZXA6IHtcclxuXHQgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuXHQgKiAgICAgIHBvaW50OiBmYWxzZSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuXHQgKiAgICAgIHBvaW50OiBbXHJcblx0ICogICAgICAgICAgXCJkYXRhMVwiLCBcImRhdGEzXCJcclxuXHQgKiAgICAgIF0sXHJcblx0ICpcclxuXHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGxpbmVfY29ubmVjdE51bGw6IGZhbHNlLFxyXG5cdGxpbmVfc3RlcF90eXBlOiA8XCJzdGVwXCJ8XCJzdGVwLWJlZm9yZVwifFwic3RlcC1hZnRlclwiPiBcInN0ZXBcIixcclxuXHRsaW5lX3plcm9iYXNlZDogZmFsc2UsXHJcblx0bGluZV9jbGFzc2VzOiA8c3RyaW5nW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGluZV9wb2ludDogPHN0cmluZ1tdfGJvb2xlYW4+IHRydWVcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHNwbGluZSBvcHRpb25zXHJcblx0ICogLSAqKkF2YWlsYWJsZSBpbnRlcnBvbGF0aW9uIHR5cGUgdmFsdWVzOioqXHJcblx0ICogIC0gYmFzaXMgKGQzLmN1cnZlQmFzaXMpXHJcblx0ICogIC0gYmFzaXMtY2xvc2VkIChkMy5jdXJ2ZUJhc2lzQ2xvc2VkKVxyXG5cdCAqICAtIGJhc2lzLW9wZW4gKGQzLmN1cnZlQmFzaXNPcGVuKVxyXG5cdCAqICAtIGJ1bmRsZSAoZDMuY3VydmVCdW5kbGUpXHJcblx0ICogIC0gY2FyZGluYWwgKGQzLmN1cnZlQ2FyZGluYWwpXHJcblx0ICogIC0gY2FyZGluYWwtY2xvc2VkIChkMy5jdXJ2ZUNhcmRpbmFsQ2xvc2VkKVxyXG5cdCAqICAtIGNhcmRpbmFsLW9wZW4gKGQzLmN1cnZlQ2FyZGluYWxPcGVuKVxyXG5cdCAqICAtIGNhdG11bGwtcm9tIChkMy5jdXJ2ZUNhdG11bGxSb20pXHJcblx0ICogIC0gY2F0bXVsbC1yb20tY2xvc2VkIChkMy5jdXJ2ZUNhdG11bGxSb21DbG9zZWQpXHJcblx0ICogIC0gY2F0bXVsbC1yb20tb3BlbiAoZDMuY3VydmVDYXRtdWxsUm9tT3BlbilcclxuXHQgKiAgLSBtb25vdG9uZS14IChkMy5jdXJ2ZU1vbm90b25lWClcclxuXHQgKiAgLSBtb25vdG9uZS15IChkMy5jdXJ2ZU1vbm90b25lWSlcclxuXHQgKiAgLSBuYXR1cmFsIChkMy5jdXJ2ZU5hdHVyYWwpXHJcblx0ICogIC0gbGluZWFyLWNsb3NlZCAoZDMuY3VydmVMaW5lYXJDbG9zZWQpXHJcblx0ICogIC0gbGluZWFyIChkMy5jdXJ2ZUxpbmVhcilcclxuXHQgKiAgLSBzdGVwIChkMy5jdXJ2ZVN0ZXApXHJcblx0ICogIC0gc3RlcC1hZnRlciAoZDMuY3VydmVTdGVwQWZ0ZXIpXHJcblx0ICogIC0gc3RlcC1iZWZvcmUgKGQzLmN1cnZlU3RlcEJlZm9yZSlcclxuXHQgKiBAbmFtZSBzcGxpbmVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHNwbGluZSBTcGxpbmUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHNwbGluZS5pbnRlcnBvbGF0aW9uIFNwbGluZSBpbnRlcnBvbGF0aW9uIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3BsaW5lLmludGVycG9sYXRpb24udHlwZT1cImNhcmRpbmFsXCJdIEludGVycG9sYXRpb24gdHlwZVxyXG5cdCAqIEBzZWUgW0ludGVycG9sYXRpb24gKGQzIHY0KV0oaHR0cDovL2JsLm9ja3Mub3JnL2VtbWFzYXVuZGVycy9jMjVhMTQ3OTcwZGVmMmIwMmQ4YzdjMjcxOWRjNzUwMilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBzcGxpbmU6IHtcclxuXHQgKiAgICAgIGludGVycG9sYXRpb246IHtcclxuXHQgKiAgICAgICAgICB0eXBlOiBcImNhcmRpbmFsXCJcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGU6IFwiY2FyZGluYWxcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBkb251dCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBkb251dCBvcHRpb25zXHJcblx0ICogQG5hbWUgZG9udXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGRvbnV0IERvbnV0IG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvbnV0LmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggZG9udXQgcGllY2UuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2RvbnV0LmxhYmVsLmZvcm1hdF0gU2V0IGZvcm1hdHRlciBmb3IgdGhlIGxhYmVsIG9uIGVhY2ggZG9udXQgcGllY2UuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfEZ1bmN0aW9ufSBbZG9udXQubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvbnV0LmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgZG9udXQgcGllY2VzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQuZXhwYW5kLnJhdGU9MC45OF0gU2V0IGV4cGFuZCByYXRlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgZXhwYW5kIHRyYW5zaXRpb24gdGltZSBpbiBtcy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LndpZHRoXSBTZXQgd2lkdGggb2YgZG9udXQgY2hhcnQuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtkb251dC50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZG9udXQgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LnBhZEFuZ2xlPTBdIFNldCBwYWRkaW5nIGJldHdlZW4gZGF0YS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LnN0YXJ0aW5nQW5nbGU9MF0gU2V0IHN0YXJ0aW5nIGFuZ2xlIHdoZXJlIGRhdGEgZHJhd3MuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgZG9udXQ6IHtcclxuXHQgKiAgICAgIGxhYmVsOiB7XHJcblx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcblx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XHJcblx0ICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG5cdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcclxuXHQgKlxyXG5cdCAqICAgICAgICAgIC8vIHNldCByYXRpbyBjYWxsYmFjay4gU2hvdWxkIHJldHVybiByYXRpbyB2YWx1ZVxyXG5cdCAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcclxuXHQgKiAgICAgICAgICBcdC4uLlxyXG5cdCAqICAgICAgICAgIFx0cmV0dXJuIHJhdGlvO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxyXG5cdCAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcblx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxyXG5cdCAqXHJcblx0ICogICAgICBleHBhbmQ6IHtcclxuXHQgKiAgICAgIFx0Ly8gc2V0IGR1cmF0aW9uIG9mIGV4cGFuZCB0cmFuc2l0aW9uIHRvIDUwMG1zLlxyXG5cdCAqICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gc2V0IGV4cGFuZCBhcmVhIHJhdGVcclxuXHQgKiAgICAgICAgICByYXRlOiAxXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICB3aWR0aDogMTAsXHJcblx0ICogICAgICBwYWRBbmdsZTogMC4yLFxyXG5cdCAqICAgICAgc3RhcnRpbmdBbmdsZTogMSxcclxuXHQgKiAgICAgIHRpdGxlOiBcIkRvbnV0IFRpdGxlXCJcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gdGl0bGUgd2l0aCBsaW5lIGJyZWFrXHJcblx0ICogICAgICB0aXRsZTogXCJUaXRsZTFcXG5UaXRsZTJcIlxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0ZG9udXRfbGFiZWxfc2hvdzogdHJ1ZSxcclxuXHRkb251dF9sYWJlbF9mb3JtYXQ6IDwoKCkgPT4gbnVtYmVyfHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0ZG9udXRfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxyXG5cdGRvbnV0X2xhYmVsX3JhdGlvOiA8bnVtYmVyfCgoKSA9PiBudW1iZXIpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGRvbnV0X3dpZHRoOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGRvbnV0X3RpdGxlOiBcIlwiLFxyXG5cdGRvbnV0X2V4cGFuZDogPGJvb2xlYW58e3JhdGU/OiBudW1iZXI7IGR1cmF0aW9uPzogbnVtYmVyO30+IHt9LFxyXG5cdGRvbnV0X2V4cGFuZF9yYXRlOiAwLjk4LFxyXG5cdGRvbnV0X2V4cGFuZF9kdXJhdGlvbjogNTAsXHJcblx0ZG9udXRfcGFkQW5nbGU6IDAsXHJcblx0ZG9udXRfc3RhcnRpbmdBbmdsZTogMFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBnYXVnZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBnYXVnZSBvcHRpb25zXHJcblx0ICogQG5hbWUgZ2F1Z2VcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGdhdWdlIEdhdWdlIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dhdWdlLmZ1bGxDaXJjbGU9ZmFsc2VdIFNob3cgZnVsbCBjaXJjbGUgYXMgZG9udXQuIFdoZW4gc2V0IHRvICd0cnVlJywgdGhlIG1heCBsYWJlbCB3aWxsIG5vdCBiZSBzaG93ZWQgZHVlIHRvIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBzYW1lIGxvY2F0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dhdWdlLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGdhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtnYXVnZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBnYXVnZS4gTGFiZWwgdGV4dCBjYW4gYmUgbXVsdGlsaW5lZCB3aXRoIGBcXG5gIGNoYXJhY3Rlci5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZXh0ZW50c10gU2V0IGN1c3RvbWl6ZWQgbWluL21heCBsYWJlbCB0ZXh0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dhdWdlLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgZ2F1Z2UuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtnYXVnZS5leHBhbmQucmF0ZT0wLjk4XSBTZXQgZXhwYW5kIHJhdGUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtnYXVnZS5leHBhbmQuZHVyYXRpb249NTBdIFNldCB0aGUgZXhwYW5kIHRyYW5zaXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtnYXVnZS5taW49MF0gU2V0IG1pbiB2YWx1ZSBvZiB0aGUgZ2F1Z2UuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtnYXVnZS5tYXg9MTAwXSBTZXQgbWF4IHZhbHVlIG9mIHRoZSBnYXVnZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2dhdWdlLnN0YXJ0aW5nQW5nbGU9LTEgKiBNYXRoLlBJIC8gMl0gU2V0IHN0YXJ0aW5nIGFuZ2xlIHdoZXJlIGRhdGEgZHJhd3MuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXVnZS50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZ2F1Z2UgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2dhdWdlLnVuaXRzXSBTZXQgdW5pdHMgb2YgdGhlIGdhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ2F1Z2Uud2lkdGhdIFNldCB3aWR0aCBvZiBnYXVnZSBjaGFydC5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2dhdWdlLnR5cGU9XCJzaW5nbGVcIl0gU2V0IHR5cGUgb2YgZ2F1Z2UgdG8gYmUgZGlzcGxheWVkLjxicj48YnI+XHJcblx0ICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogLSBzaW5nbGVcclxuXHQgKiAtIG11bHRpXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXVnZS5hcmNzLm1pbldpZHRoPTVdIFNldCBtaW5pbWFsIHdpZHRoIG9mIGdhdWdlIGFyY3MgdW50aWwgdGhlIGlubmVyUmFkaXVzIGRpc2FwcGVhcnMuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgZ2F1Z2U6IHtcclxuXHQgKiAgICAgIGZ1bGxDaXJjbGU6IGZhbHNlLFxyXG5cdCAqICAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcclxuXHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbykge1xyXG5cdCAqICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblx0ICpcclxuXHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcclxuXHQgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgZXh0ZW50czogZnVuY3Rpb24odmFsdWUsIGlzTWF4KSB7XHJcblx0ICogICAgICAgICAgICAgIHJldHVybiAoaXNNYXggPyBcIk1heDpcIiA6IFwiTWluOlwiKSArIHZhbHVlO1xyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcblx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxyXG5cdCAqXHJcblx0ICogICAgICBleHBhbmQ6IHtcclxuXHQgKiAgICAgIFx0Ly8gc2V0IGR1cmF0aW9uIG9mIGV4cGFuZCB0cmFuc2l0aW9uIHRvIDUwMG1zLlxyXG5cdCAqICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gc2V0IGV4cGFuZCBhcmVhIHJhdGVcclxuXHQgKiAgICAgICAgICByYXRlOiAxXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICBtaW46IC0xMDAsXHJcblx0ICogICAgICBtYXg6IDIwMCxcclxuXHQgKiAgICAgIHR5cGU6IFwic2luZ2xlXCIgIC8vIG9yICdtdWx0aSdcclxuXHQgKiAgICAgIHRpdGxlOiBcIlRpdGxlIFRleHRcIixcclxuXHQgKiAgICAgIHVuaXRzOiBcIiVcIixcclxuXHQgKiAgICAgIHdpZHRoOiAxMCxcclxuXHQgKiAgICAgIGFyY3M6IHtcclxuXHQgKiAgICAgICAgICBtaW5XaWR0aDogNVxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0Z2F1Z2VfZnVsbENpcmNsZTogZmFsc2UsXHJcblx0Z2F1Z2VfbGFiZWxfc2hvdzogdHJ1ZSxcclxuXHRnYXVnZV9sYWJlbF9mb3JtYXQ6IDwoKCkgPT4gc3RyaW5nKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRnYXVnZV9sYWJlbF9leHRlbnRzOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0Z2F1Z2VfbWluOiAwLFxyXG5cdGdhdWdlX21heDogMTAwLFxyXG5cdGdhdWdlX3R5cGU6IFwic2luZ2xlXCIsXHJcblx0Z2F1Z2Vfc3RhcnRpbmdBbmdsZTogLTEgKiBNYXRoLlBJIC8gMixcclxuXHRnYXVnZV90aXRsZTogXCJcIixcclxuXHRnYXVnZV91bml0czogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRnYXVnZV93aWR0aDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRnYXVnZV9hcmNzX21pbldpZHRoOiA1LFxyXG5cdGdhdWdlX2V4cGFuZDogPGJvb2xlYW58e2R1cmF0aW9uOiBudW1iZXJ9PiB7fSxcclxuXHRnYXVnZV9leHBhbmRfcmF0ZTogMC45OCxcclxuXHRnYXVnZV9leHBhbmRfZHVyYXRpb246IDUwXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBwaWUgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHBpZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gcGllIFBpZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwaWUubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZWFjaCBwaWUgcGllY2UuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3BpZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BpZS5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfEZ1bmN0aW9ufSBbcGllLmxhYmVsLnJhdGlvPXVuZGVmaW5lZF0gU2V0IHJhdGlvIG9mIGxhYmVscyBwb3NpdGlvbi5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW58b2JqZWN0fSBbcGllLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgcGllIHBpZWNlcy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BpZS5leHBhbmQucmF0ZT0wLjk4XSBTZXQgZXhwYW5kIHJhdGUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaWUuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgZXhwYW5kIHRyYW5zaXRpb24gdGltZSBpbiBtcy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxvYmplY3R9IFtwaWUuaW5uZXJSYWRpdXM9MF0gU2V0cyB0aGUgaW5uZXIgcmFkaXVzIG9mIHBpZSBhcmMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaWUucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGllLnBhZGRpbmc9MF0gU2V0cyB0aGUgZ2FwIGJldHdlZW4gcGllIGFyY3MuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGRvbnV0IERvbnV0IG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQuc3RhcnRpbmdBbmdsZT0wXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBwaWU6IHtcclxuXHQgKiAgICAgIGxhYmVsOiB7XHJcblx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcblx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XHJcblx0ICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG5cdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcclxuXHQgKlxyXG5cdCAqICAgICAgICAgIC8vIHNldCByYXRpbyBjYWxsYmFjay4gU2hvdWxkIHJldHVybiByYXRpbyB2YWx1ZVxyXG5cdCAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcclxuXHQgKiAgICAgICAgICAgICAgLi4uXHJcblx0ICogICAgICAgICAgICAgIHJldHVybiByYXRpbztcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcclxuXHQgKiAgICAgICAgICByYXRpbzogMC41XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxyXG5cdCAqICAgICAgZXhwYW5kOiBmYWxzZSxcclxuXHQgKlxyXG5cdCAqICAgICAgZXhwYW5kOiB7XHJcblx0ICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cclxuXHQgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG5cdCAqXHJcblx0ICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXHJcblx0ICogICAgICAgICAgcmF0ZTogMVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgaW5uZXJSYWRpdXM6IDAsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgaW5uZXJSYWRpdXMgZm9yIGVhY2ggZGF0YVxyXG5cdCAqICAgICAgaW5uZXJSYWRpdXM6IHtcclxuXHQgKiAgICAgIFx0ZGF0YTE6IDEwLFxyXG5cdCAqICAgICAgXHRkYXRhMjogMFxyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogICAgICBwYWRBbmdsZTogMC4xLFxyXG5cdCAqICAgICAgcGFkZGluZzogMCxcclxuXHQgKiAgICAgIHN0YXJ0aW5nQW5nbGU6IDFcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHBpZV9sYWJlbF9zaG93OiB0cnVlLFxyXG5cdHBpZV9sYWJlbF9mb3JtYXQ6IDwoKCkgPT4gbnVtYmVyfHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cGllX2xhYmVsX3RocmVzaG9sZDogMC4wNSxcclxuXHRwaWVfbGFiZWxfcmF0aW86IDwoKCkgPT4gbnVtYmVyKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRwaWVfZXhwYW5kOiA8Ym9vbGVhbnx7cmF0ZT86IG51bWJlcjsgZHVyYXRpb24/OiBudW1iZXI7fT4ge30sXHJcblx0cGllX2V4cGFuZF9yYXRlOiAwLjk4LFxyXG5cdHBpZV9leHBhbmRfZHVyYXRpb246IDUwLFxyXG5cdHBpZV9pbm5lclJhZGl1czogPG51bWJlcnx7W2tleTogc3RyaW5nXTogbnVtYmVyfT4gMCxcclxuXHRwaWVfcGFkQW5nbGU6IDAsXHJcblx0cGllX3BhZGRpbmc6IDAsXHJcblx0cGllX3N0YXJ0aW5nQW5nbGU6IDBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHJhZGFyIG9wdGlvbnNcclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrLlxyXG5cdCAqIEBuYW1lIHJhZGFyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSByYWRhciBSYWRhciBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGFyLmF4aXMubWF4PXVuZGVmaW5lZF0gVGhlIG1heCB2YWx1ZSBvZiBheGlzLiBJZiBub3QgZ2l2ZW4sIGl0J2xsIHRha2UgdGhlIG1heCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBkYXRhLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhZGFyLmF4aXMubGluZS5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIGxpbmUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRhci5heGlzLnRleHQucG9zaXRpb24ueD0wXSB4IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGFyLmF4aXMudGV4dC5wb3NpdGlvbi55PTBdIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhZGFyLmF4aXMudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIHRleHQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmFkYXIuZGlyZWN0aW9uLmNsb2Nrd2lzZT1mYWxzZV0gU2V0IHRoZSBkaXJlY3Rpb24gdG8gYmUgZHJhd24uXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRhci5sZXZlbC5kZXB0aD0zXSBTZXQgdGhlIGxldmVsIGRlcHRoLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhZGFyLmxldmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtyYWRhci5sZXZlbC50ZXh0LmZvcm1hdD0oeCkgPT4gKHggJSAxID09PSAwID8geCA6IHgudG9GaXhlZCgyKSldIFNldCBmb3JtYXQgZnVuY3Rpb24gZm9yIHRoZSBsZXZlbCB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWRhci5sZXZlbC50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsIHRleHQuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRhci5zaXplLnJhdGlvPTAuODddIFNldCBzaXplIHJhdGlvLlxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5SYWRhckNoYXJ0KVxyXG5cdCAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXMpXHJcblx0ICogQHNlZSBbRGVtbzogcmFkYXIgbGV2ZWxdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckxldmVsKVxyXG5cdCAqIEBzZWUgW0RlbW86IHJhZGFyIHNpemVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhclNpemUpXHJcblx0ICogQHNlZSBbRGVtbzogcmFkYXIgYXhpcyBtdWx0aWxpbmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXNNdWx0aWxpbmUpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgcmFkYXI6IHtcclxuXHQgKiAgICAgIGF4aXM6IHtcclxuXHQgKiAgICAgICAgICBtYXg6IDUwLFxyXG5cdCAqICAgICAgICAgIGxpbmU6IHtcclxuXHQgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgICAgICAgXHR4OiAwLFxyXG5cdCAqICAgICAgICAgICAgICBcdHk6IDBcclxuXHQgKiAgICAgICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgZGlyZWN0aW9uOiB7XHJcblx0ICogICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgbGV2ZWw6IHtcclxuXHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcclxuXHQgKiAgICAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG5cdCAqICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuXHQgKiAgICAgICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBzaXplOiB7XHJcblx0ICogICAgICAgICAgcmF0aW86IDAuN1xyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0cmFkYXJfYXhpc19tYXg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cmFkYXJfYXhpc19saW5lX3Nob3c6IHRydWUsXHJcblx0cmFkYXJfYXhpc190ZXh0X3Nob3c6IHRydWUsXHJcblx0cmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uOiA8e3g/OiBudW1iZXI7IHk/OiBudW1iZXI7fT4ge30sXHJcblx0cmFkYXJfbGV2ZWxfZGVwdGg6IDMsXHJcblx0cmFkYXJfbGV2ZWxfc2hvdzogdHJ1ZSxcclxuXHRyYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdDogKHg6IG51bWJlcikgPT4gKHggJSAxID09PSAwID8geCA6IHgudG9GaXhlZCgyKSksXHJcblx0cmFkYXJfbGV2ZWxfdGV4dF9zaG93OiB0cnVlLFxyXG5cdHJhZGFyX3NpemVfcmF0aW86IDAuODcsXHJcblx0cmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vLyBjb21tb25cclxuaW1wb3J0IGRhdGEgZnJvbSBcIi4vZGF0YS9kYXRhXCI7XHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9jb21tb24vY29sb3JcIjtcclxuaW1wb3J0IGludGVyYWN0aW9uIGZyb20gXCIuL2NvbW1vbi9pbnRlcmFjdGlvblwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2NvbW1vbi9sZWdlbmRcIjtcclxuaW1wb3J0IHRpdGxlIGZyb20gXCIuL2NvbW1vbi90aXRsZVwiO1xyXG5pbXBvcnQgdG9vbHRpcCBmcm9tIFwiLi9jb21tb24vdG9vbHRpcFwiO1xyXG5cclxuLy8gQXhpcyBiYXNlZFxyXG5pbXBvcnQgZGF0YUF4aXMgZnJvbSBcIi4vZGF0YS9heGlzXCI7XHJcbmltcG9ydCBkYXRhU2VsZWN0aW9uIGZyb20gXCIuL2RhdGEvc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBheGlzIGZyb20gXCIuL2F4aXMvYXhpc1wiO1xyXG5pbXBvcnQgZ3JpZCBmcm9tIFwiLi9jb21tb24vZ3JpZFwiO1xyXG5pbXBvcnQgcG9pbnQgZnJvbSBcIi4vY29tbW9uL3BvaW50XCI7XHJcbmltcG9ydCBzdWJjaGFydCBmcm9tIFwiLi9jb21tb24vc3ViY2hhcnRcIjtcclxuaW1wb3J0IHpvb20gZnJvbSBcIi4vY29tbW9uL3pvb21cIjtcclxuXHJcbmltcG9ydCBhcmVhIGZyb20gXCIuL3NoYXBlL2FyZWFcIjtcclxuaW1wb3J0IGJhciBmcm9tIFwiLi9zaGFwZS9iYXJcIjtcclxuaW1wb3J0IGJ1YmJsZSBmcm9tIFwiLi9zaGFwZS9idWJibGVcIjtcclxuaW1wb3J0IGxpbmUgZnJvbSBcIi4vc2hhcGUvbGluZVwiO1xyXG5pbXBvcnQgc3BsaW5lIGZyb20gXCIuL3NoYXBlL3NwbGluZVwiO1xyXG5cclxuLy8gTm9uLUF4aXMgYmFzZWRcclxuaW1wb3J0IGRvbnV0IGZyb20gXCIuL3NoYXBlL2RvbnV0XCI7XHJcbmltcG9ydCBnYXVnZSBmcm9tIFwiLi9zaGFwZS9nYXVnZVwiO1xyXG5pbXBvcnQgcGllIGZyb20gXCIuL3NoYXBlL3BpZVwiO1xyXG5pbXBvcnQgcmFkYXIgZnJvbSBcIi4vc2hhcGUvcmFkYXJcIjtcclxuXHJcbmltcG9ydCB7bWVyZ2VPYmp9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRvIHNldCBvcHRpb25zIG9uIGdlbmVyYXRpbmcgY2hhcnQuXHJcbiAqIC0gSXQncyBpbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cclxuICogQGNsYXNzIE9wdGlvbnNcclxuICogQHNlZSB7QGxpbmsgYmIuZ2VuZXJhdGV9IHRvIHVzZSB0aGVzZSBvcHRpb25zIG9uIGdlbmVyYXRpbmcgdGhlIGNoYXJ0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25zIHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdGNvbnN0IGFyY1NoYXBlQ29uZmlnID0gW2RvbnV0LCBnYXVnZSwgcGllLCByYWRhcl07XHJcblxyXG5cdFx0Y29uc3QgYXhpc0NvbmZpZyA9IFtkYXRhQXhpcywgZGF0YVNlbGVjdGlvbiwgYXhpcywgZ3JpZCwgcG9pbnQsIHN1YmNoYXJ0LCB6b29tXTtcclxuXHRcdGNvbnN0IGF4aXNTaGFwZUNvbmZpZyA9IFthcmVhLCBiYXIsIGJ1YmJsZSwgbGluZSwgc3BsaW5lXTtcclxuXHJcblx0XHRjb25zdCBjb25maWcgPSBbXHJcblx0XHRcdGRhdGEsXHJcblx0XHRcdGNvbG9yLFxyXG5cdFx0XHRpbnRlcmFjdGlvbixcclxuXHRcdFx0bGVnZW5kLFxyXG5cdFx0XHR0aXRsZSxcclxuXHRcdFx0dG9vbHRpcCxcclxuXHRcdFx0Li4uYXJjU2hhcGVDb25maWcsXHJcblx0XHRcdC4uLmF4aXNDb25maWcsXHJcblx0XHRcdC4uLmF4aXNTaGFwZUNvbmZpZ1xyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gbWVyZ2VPYmooe1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU3BlY2lmeSB0aGUgQ1NTIHNlbGVjdG9yIG9yIHRoZSBlbGVtZW50IHdoaWNoIHRoZSBjaGFydCB3aWxsIGJlIHNldCB0by4gRDMgc2VsZWN0aW9uIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIGFsc28uPGJyPlxyXG5cdFx0XHQgKiBJZiBvdGhlciBjaGFydCBpcyBzZXQgYWxyZWFkeSwgaXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBuZXcgb25lIChvbmx5IG9uZSBjaGFydCBjYW4gYmUgc2V0IGluIG9uZSBlbGVtZW50KS5cclxuXHRcdFx0ICogLSAqKk5PVEU6KiogSW4gY2FzZSBvZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3Qgb3Igbm90IHNwZWNpZmllZCwgd2lsbCBhZGQgYSBgPGRpdj5gIGVsZW1lbnQgdG8gdGhlIGJvZHkuXHJcblx0XHRcdCAqIEBuYW1lIGJpbmR0b1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb258b2JqZWN0fSBbYmluZHRvPVwiI2NoYXJ0XCJdIFNwZWNpZnkgdGhlIGVsZW1lbnQgd2hlcmUgY2hhcnQgd2lsbCBiZSBkcmF3bi5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG8uZWxlbWVudD1cIiNjaGFydFwiIFNwZWNpZnkgdGhlIGVsZW1lbnQgd2hlcmUgY2hhcnQgd2lsbCBiZSBkcmF3bi5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtiaW5kdG8uY2xhc3NuYW1lPWJiXSBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIG9mIGJpbmQgZWxlbWVudC48YnI+XHJcblx0XHRcdCAqICAgICAqKk5PVEU6KiogV2hlbiBjbGFzcyBuYW1lIGlzbid0IGBiYmAsIHRoZW4geW91IGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIGRlZmF1bHQgQ1NTIHRvIGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cclxuXHRcdFx0ICogQGRlZmF1bHQgI2NoYXJ0XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIGJpbmR0bzogXCIjbXlDb250YWluZXJcIlxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAvLyBvciBIVE1MRWxlbWVudFxyXG5cdFx0XHQgKiBiaW5kdG86IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlDb250YWluZXJcIilcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogLy8gb3IgRDMgc2VsZWN0aW9uIG9iamVjdFxyXG5cdFx0XHQgKiBiaW5kdG86IGQzLnNlbGVjdChcIiNteUNvbnRhaW5lclwiKVxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAvLyBvciB0byBjaGFuZ2UgZGVmYXVsdCBjbGFzc25hbWVcclxuXHRcdFx0ICogYmluZHRvOiB7XHJcblx0XHRcdCAqICAgIGVsZW1lbnQ6IFwiI2NoYXJ0XCIsXHJcblx0XHRcdCAqICAgIGNsYXNzbmFtZTogXCJiaWxsLWJvYXJkXCIgIC8vIGV4KSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2JpbGwtYm9hcmQnPlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRiaW5kdG86IDxzdHJpbmd8e2VsZW1lbnQ6IHN0cmluZzsgY2xhc3NuYW1lPzogc3RyaW5nfT4gXCIjY2hhcnRcIixcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgY2hhcnQgYmFja2dyb3VuZC5cclxuXHRcdFx0ICogQG5hbWUgYmFja2dyb3VuZFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gYmFja2dyb3VuZCBiYWNrZ3JvdW5kIG9iamVjdFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZC5jbGFzcyBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIGZvciBiYWNrZ3JvdW5kIGVsZW1lbnQuXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZ3JvdW5kLmNvbG9yIFNwZWNpZnkgdGhlIGZpbGwgY29sb3IgZm9yIGJhY2tncm91bmQgZWxlbWVudC48YnI+KipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgaW1nVXJsYCBvcHRpb24gaXMgc2V0LlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZC5pbWdVcmwgU3BlY2lmeSB0aGUgaW1hZ2UgdXJsIHN0cmluZyBmb3IgYmFja2dyb3VuZC5cclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5CYWNrZ3JvdW5kKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBiYWNrZ3JvdW5kOiB7XHJcblx0XHRcdCAqICAgIGNsYXNzOiBcIm15Q2xhc3NcIixcclxuXHRcdFx0ICogICAgY29sb3I6IFwicmVkXCIsXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgIC8vIFNldCBpbWFnZSB1cmwgZm9yIGJhY2tncm91bmQuXHJcblx0XHRcdCAqICAgIC8vIElmIHNwZWNpZmllZCwgJ2NvbG9yJyBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxyXG5cdFx0XHQgKiAgICBpbWdVcmw6IFwiaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2ltZy9sb2dvL2JpbGxib2FyZC5qcy5zdmdcIixcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0YmFja2dyb3VuZDogPHtjbGFzcz86IHN0cmluZzsgY29sb3I/OiBzdHJpbmc7IGltZ1VybD86IHN0cmluZzt9PiB7fSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIGZvciBjaGFydCBlbGVtZW50XHJcblx0XHRcdCAqIC0gKipOT1RFOioqXHJcblx0XHRcdCAqICA+IFdoZW4gaXMgZmFsc2UsIGNoYXJ0IG5vZGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGFmdGVyIHRoZSBheGlzIG5vZGUgaW4gRE9NIHRyZWUgaGllcmFyY2h5LlxyXG5cdFx0XHQgKiAgPiBJcyB0byBtYWtlIGNoYXJ0IGVsZW1lbnQgcG9zaXRpb25lZCBvdmVyIGF4aXMgZWxlbWVudC5cclxuXHRcdFx0ICogQG5hbWUgY2xpcFBhdGhcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5jbGlwUGF0aClcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxyXG5cdFx0XHQgKiBjbGlwUGF0aDogZmFsc2VcclxuXHRcdFx0ICovXHJcblx0XHRcdGNsaXBQYXRoOiB0cnVlLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBzdmcgZWxlbWVudCdzIGNsYXNzIG5hbWVcclxuXHRcdFx0ICogQG5hbWUgc3ZnXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc3ZnXSBzdmcgb2JqZWN0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3ZnLmNsYXNzbmFtZV0gY2xhc3MgbmFtZSBmb3Igc3ZnIGVsZW1lbnRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogc3ZnOiB7XHJcblx0XHRcdCAqICAgY2xhc3NuYW1lOiBcInRlc3RfY2xhc3NcIlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRzdmdfY2xhc3NuYW1lOiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFRoZSBkZXNpcmVkIHNpemUgb2YgdGhlIGNoYXJ0IGVsZW1lbnQuXHJcblx0XHRcdCAqIElmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB3aWR0aCBvZiB0aGUgY2hhcnQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpdCdzIGFwcGVuZGVkIHRvLlxyXG5cdFx0XHQgKiBAbmFtZSBzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc2l6ZV0gc2l6ZSBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplLndpZHRoXSB3aWR0aCBvZiB0aGUgY2hhcnQgZWxlbWVudFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemUuaGVpZ2h0XSBoZWlnaHQgb2YgdGhlIGNoYXJ0IGVsZW1lbnRcclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5DaGFydFNpemUpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHNpemU6IHtcclxuXHRcdFx0ICogICB3aWR0aDogNjQwLFxyXG5cdFx0XHQgKiAgIGhlaWdodDogNDgwXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHNpemVfd2lkdGg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHNpemVfaGVpZ2h0OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFRoZSBwYWRkaW5nIG9mIHRoZSBjaGFydCBlbGVtZW50LlxyXG5cdFx0XHQgKiBAbmFtZSBwYWRkaW5nXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcGFkZGluZ10gcGFkZGluZyBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWRkaW5nLnRvcF0gcGFkZGluZyBvbiB0aGUgdG9wIG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFkZGluZy5yaWdodF0gcGFkZGluZyBvbiB0aGUgcmlnaHQgb2YgY2hhcnRcclxuXHRcdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWRkaW5nLmJvdHRvbV0gcGFkZGluZyBvbiB0aGUgYm90dG9tIG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFkZGluZy5sZWZ0XSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHBhZGRpbmc6IHtcclxuXHRcdFx0ICogICB0b3A6IDIwLFxyXG5cdFx0XHQgKiAgIHJpZ2h0OiAyMCxcclxuXHRcdFx0ICogICBib3R0b206IDIwLFxyXG5cdFx0XHQgKiAgIGxlZnQ6IDIwXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHBhZGRpbmdfbGVmdDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRcdFx0cGFkZGluZ19yaWdodDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRcdFx0cGFkZGluZ190b3A6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfYm90dG9tOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBjaGFydCByZXNpemUgb3B0aW9uc1xyXG5cdFx0XHQgKiBAbmFtZSByZXNpemVcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge29iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtyZXNpemVdIHJlc2l6ZSBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzaXplLmF1dG89dHJ1ZV0gU2V0IGNoYXJ0IHJlc2l6ZSBhdXRvbWF0aWNhbGx5IG9uIHZpZXdwb3J0IGNoYW5nZXMuXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICByZXNpemU6IHtcclxuXHRcdFx0ICogICAgICBhdXRvOiBmYWxzZVxyXG5cdFx0XHQgKiAgfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0cmVzaXplX2F1dG86IHRydWUsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIG1vdXNlL3RvdWNoIGVudGVycyB0aGUgY2hhcnQuXHJcblx0XHRcdCAqIEBuYW1lIG9ub3ZlclxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25vdmVyOiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25vdmVyOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBtb3VzZS90b3VjaCBsZWF2ZXMgdGhlIGNoYXJ0LlxyXG5cdFx0XHQgKiBAbmFtZSBvbm91dFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25vdXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbm91dDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdXNlciByZXNpemVzIHRoZSBzY3JlZW4uXHJcblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlc2l6ZTogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ucmVzaXplOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBzY3JlZW4gcmVzaXplIGZpbmlzaGVkLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlc2l6ZWRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ucmVzaXplZDogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ucmVzaXplZDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWRcclxuXHRcdFx0ICogQG5hbWUgb25iZWZvcmVpbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmJlZm9yZWluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbmJlZm9yZWluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cclxuXHRcdFx0ICogQG5hbWUgb25pbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbmluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBhZnRlciB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWRcclxuXHRcdFx0ICogQG5hbWUgb25hZnRlcmluaXRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9uYWZ0ZXJpbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25hZnRlcmluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhcnQgaXMgcmVuZGVyZWQuIEJhc2ljYWxseSwgdGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpbiBlYWNoIHRpbWUgd2hlbiB0aGUgY2hhcnQgaXMgcmVkcmF3ZWQuXHJcblx0XHRcdCAqIEBuYW1lIG9ucmVuZGVyZWRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ucmVuZGVyZWQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbnJlbmRlcmVkOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cclxuXHRcdFx0ICogLSAqKk5PVEU6KiogSWYgYDAgYG9yIGBudWxsYCBzZXQsIHRyYW5zaXRpb24gd2lsbCBiZSBza2lwcGVkLiBTbywgdGhpcyBtYWtlcyBpbml0aWFsIHJlbmRlcmluZyBmYXN0ZXIgZXNwZWNpYWxseSBpbiBjYXNlIHlvdSBoYXZlIGEgbG90IG9mIGRhdGEuXHJcblx0XHRcdCAqIEBuYW1lIHRyYW5zaXRpb25cclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge29iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IFt0cmFuc2l0aW9uXSB0cmFuc2l0aW9uIG9iamVjdFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb24uZHVyYXRpb249MzUwXSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogdHJhbnNpdGlvbjoge1xyXG5cdFx0XHQgKiAgICBkdXJhdGlvbjogNTAwXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHRyYW5zaXRpb25fZHVyYXRpb246IDM1MCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgc2NhdHRlciBvcHRpb25zXHJcblx0XHRcdCAqIEBuYW1lIHNjYXR0ZXJcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge29iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtzY2F0dGVyXSBzY2F0dGVyIG9iamVjdFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzY2F0dGVyLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIHNjYXR0ZXIgY2hhcnQuXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICBzY2F0dGVyOiB7XHJcblx0XHRcdCAqICAgICAgY29ubmVjdE51bGw6IHRydWUsXHJcblx0XHRcdCAqICAgICAgc3RlcDoge1xyXG5cdFx0XHQgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG5cdFx0XHQgKiAgICAgIH0sXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuXHRcdFx0ICogICAgICBwb2ludDogZmFsc2UsXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuXHRcdFx0ICogICAgICBwb2ludDogW1xyXG5cdFx0XHQgKiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxyXG5cdFx0XHQgKiAgICAgIF0sXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG5cdFx0XHQgKiAgfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0c2NhdHRlcl96ZXJvYmFzZWQ6IGZhbHNlLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBwbHVnaW5zXHJcblx0XHRcdCAqIEBuYW1lIHBsdWdpbnNcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0FycmF5fVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcGx1Z2luczogW1xyXG5cdFx0XHQgKiAgICBuZXcgYmIucGx1Z2luLnN0YW5mb3JkKHsgLi4uIH0pLFxyXG5cdFx0XHQgKiAgICBuZXcgUGx1Z2luQSgpLFxyXG5cdFx0XHQgKiAgICAuLi5cclxuXHRcdFx0ICogXVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0cGx1Z2luczogW10sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogQ29udHJvbCB0aGUgcmVuZGVyIHRpbWluZ1xyXG5cdFx0XHQgKiBAbmFtZSByZW5kZXJcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge29iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtyZW5kZXJdIHJlbmRlciBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmVuZGVyLmxhenk9dHJ1ZV0gTWFrZSB0byBub3QgcmVuZGVyIGF0IGluaXRpYWxpemF0aW9uIChlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBiaW5kIGVsZW1lbnQncyB2aXNpYmlsaXR5IGlzIGhpZGRlbikuXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlbmRlci5vYnNlcnZlPXRydWVdIE9ic2VydmUgYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eShgZGlzcGxheWAgb3IgYHZpc2libGl0eWAgaW5saW5lIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyB2YWx1ZSkgJiByZW5kZXIgd2hlbiBpcyB2aXNpYmxlIGF1dG9tYXRpY2FsbHkgKGZvciBJRXMsIG9ubHkgd29ya3MgSUUxMSspLiBXaGVuIHNldCB0byAqKmZhbHNlKiosIGNhbGwgW2AuZmx1c2goKWBdKC4vQ2hhcnQuaHRtbCNmbHVzaCkgdG8gcmVuZGVyLlxyXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkxhenlSZW5kZXIpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICByZW5kZXI6IHtcclxuXHRcdFx0ICogICAgbGF6eTogdHJ1ZSxcclxuXHRcdFx0ICogICAgb2JzZXJ2ZTogdHJ1ZVxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqXHQvLyA8IS0tIHJlbmRlci5sYXp5IHdpbGwgZGV0ZWN0IHZpc2liaWxpdHkgZGVmaW5lZCAtLT5cclxuXHRcdFx0ICogIC8vIChhKSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2hpZGUnPjwvZGl2PlxyXG5cdFx0XHQgKiAgLy8gKGIpIDxkaXYgaWQ9J2NoYXJ0JyBzdHlsZT0nZGlzcGxheTpub25lJz48L2Rpdj5cclxuXHRcdFx0ICpcclxuXHRcdFx0ICogIC8vIHJlbmRlci5sYXp5IGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIGVsZW1lbnQgaXMgaGlkZGVuXHJcblx0XHRcdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7IC4uLiB9KTtcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogIC8vIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQgYXV0b21hdGljYWxseSB3aGVuIGVsZW1lbnQncyB2aXNpYmlsaXR5IGNoYW5nZXNcclxuXHRcdFx0ICogIC8vIE5vdGU6IHdvcmtzIG9ubHkgZm9yIGlubGluZWQgY3NzIHByb3BlcnR5IG9yIGNsYXNzIGF0dHJpYnV0ZSBjaGFuZ2VzXHJcblx0XHRcdCAqICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJykgIC8vIChhKVxyXG5cdFx0XHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7ICAvLyAoYilcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICpcdC8vIGNoYXJ0IHdvbid0IGJlIHJlbmRlcmVkIGFuZCBub3Qgb2JzZXJ2aW5nIGJpbmQgZWxlbWVudCdzIHZpc2libGl0eSBjaGFuZ2VzXHJcblx0XHRcdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcblx0XHRcdCAqICAgICByZW5kZXI6IHtcclxuXHRcdFx0ICogICAgICAgICAgbGF6eTogdHJ1ZSxcclxuXHRcdFx0ICogICAgICAgICAgb2JzZXJ2ZTogZmFsc2VcclxuXHRcdFx0ICogICAgIH1cclxuXHRcdFx0ICogIH0pO1xyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgLy8gY2FsbCBhdCBhbnkgcG9pbnQgd2hlbiB5b3Ugd2FudCB0byByZW5kZXJcclxuXHRcdFx0ICogIGNoYXJ0LmZsdXNoKCk7XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRyZW5kZXI6IDx7bGF6eT86IGJvb2xlYW47IG9ic2VydmU/OiBib29sZWFuO30+IHt9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNob3cgcmVjdGFuZ2xlcyBpbnNpZGUgdGhlIGNoYXJ0Ljxicj48YnI+XHJcblx0XHRcdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyBheGlzLCBzdGFydCwgZW5kIGFuZCBjbGFzcy5cclxuXHRcdFx0ICogVGhlIGtleXMgc3RhcnQsIGVuZCBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLlxyXG5cdFx0XHQgKiBheGlzIG11c3QgYmUgeCwgeSBvciB5Mi4gc3RhcnQgYW5kIGVuZCBzaG91bGQgYmUgdGhlIHZhbHVlIHdoZXJlIHJlZ2lvbnMgc3RhcnQgYW5kIGVuZC5cclxuXHRcdFx0ICogSWYgbm90IHNwZWNpZmllZCwgdGhlIGVkZ2UgdmFsdWVzIHdpbGwgYmUgdXNlZC5cclxuXHRcdFx0ICogSWYgdGltZXNlcmllcyB4IGF4aXMsIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlciBjYW4gYmUgdXNlZC5cclxuXHRcdFx0ICogSWYgY2xhc3MgaXMgc2V0LCB0aGUgcmVnaW9uIGVsZW1lbnQgd2lsbCBoYXZlIGl0IGFzIGNsYXNzLlxyXG5cdFx0XHQgKiBAbmFtZSByZWdpb25zXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cclxuXHRcdFx0ICogQGRlZmF1bHQgW11cclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHJlZ2lvbnM6IFtcclxuXHRcdFx0ICogICAge1xyXG5cdFx0XHQgKiAgICAgIGF4aXM6IFwieFwiLFxyXG5cdFx0XHQgKiAgICAgIHN0YXJ0OiAxLFxyXG5cdFx0XHQgKiAgICAgIGVuZDogNCxcclxuXHRcdFx0ICogICAgICBjbGFzczogXCJyZWdpb24tMS00XCJcclxuXHRcdFx0ICogICAgfVxyXG5cdFx0XHQgKiAgXVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0cmVnaW9uczogPHtheGlzPzogc3RyaW5nOyBzdGFydD86IG51bWJlcjsgZW5kPzogbnVtYmVyOyBjbGFzcz86IHN0cmluZzt9W10+IFtdXHJcblx0XHR9LCAuLi5jb25maWcpO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7dG9BcnJheX0gZnJvbSBcIi4vdXRpbFwiO1xyXG5pbXBvcnQge0RhdGFSb3d9IGZyb20gXCIuLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0YW50IGZvciBjYWNoZSBrZXlcclxuICogLSBOT1RFOiBQcmVmaXhlZCB3aXRoICckJywgd2lsbCBiZSByZXNldHRlZCB3aGVuIC5sb2FkKCkgaXMgY2FsbGVkXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgS0VZID0ge1xyXG5cdGJ1YmJsZUJhc2VMZW5ndGg6IFwiJGJhc2VMZW5ndGhcIixcclxuXHRjb2xvclBhdHRlcm46IFwiX19jb2xvclBhdHRlcm5fX1wiLFxyXG5cdGRhdGFNaW5NYXg6IFwiJGRhdGFNaW5NYXhcIixcclxuXHRkYXRhVG90YWxTdW06IFwiJGRhdGFUb3RhbFN1bVwiLFxyXG5cdGRhdGFUb3RhbFBlckluZGV4OiBcIiR0b3RhbFBlckluZGV4XCIsXHJcblx0bGVnZW5kSXRlbVRleHRCb3g6IFwibGVnZW5kSXRlbVRleHRCb3hcIixcclxuXHRyYWRhclBvaW50czogXCIkcmFkYXJQb2ludHNcIixcclxuXHR0ZXh0UmVjdDogXCJ0ZXh0UmVjdFwiXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWNoZSB7XHJcblx0cHJpdmF0ZSBjYWNoZSA9IHt9O1xyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgY2FjaGVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IENhY2hlIGtleVxyXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYmUgc3RvcmVkXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0RhdGFUeXBlIFdlYXRoZXIgdGhlIGNhY2hlIGlzIGRhdGEgdHlwZWQgJ3tpZDonZGF0YScsIGlkX29yZzogJ2RhdGEnLCB2YWx1ZXM6IFt7eDowLCBpbmRleDowLC4uLn0sIC4uLl19J1xyXG5cdCAqIEByZXR1cm5zIHsqfSBBZGRlZCBkYXRhIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRhZGQoa2V5OiBzdHJpbmcsIHZhbHVlLCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcclxuXHRcdHRoaXMuY2FjaGVba2V5XSA9IGlzRGF0YVR5cGUgPyB0aGlzLmNsb25lVGFyZ2V0KHZhbHVlKSA6IHZhbHVlO1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBjYWNoZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXkgQ2FjaGUga2V5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZW1vdmUoa2V5OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0dG9BcnJheShrZXkpLmZvckVhY2godiA9PiBkZWxldGUgdGhpcy5jYWNoZVt2XSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgY2FoY2VcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5IENhY2hlIGtleVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEYXRhVHlwZSBXZWF0aGVyIHRoZSBjYWNoZSBpcyBkYXRhIHR5cGVkICd7aWQ6J2RhdGEnLCBpZF9vcmc6ICdkYXRhJywgdmFsdWVzOiBbe3g6MCwgaW5kZXg6MCwuLi59LCAuLi5dfSdcclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldChrZXk6IHN0cmluZywgaXNEYXRhVHlwZSA9IGZhbHNlKTogYW55IHwgbnVsbCB7XHJcblx0XHRpZiAoaXNEYXRhVHlwZSkge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlkOyAoaWQgPSBrZXlbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoaWQgaW4gdGhpcy5jYWNoZSkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRoaXMuY2xvbmVUYXJnZXQodGhpcy5jYWNoZVtpZF0pKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVba2V5XSB8fCBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgY2FjaGVkIGRhdGFcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbCB0cnVlOiByZXNldCBhbGwgZGF0YSwgZmFsc2U6IHJlc2V0IG9ubHkgJyQnIHByZWZpeGVkIGtleSBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZXNldChhbGw/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Zm9yIChjb25zdCB4IGluICQkLmNhY2hlKSB7XHJcblx0XHRcdC8vIHJlc2V0IHRoZSBwcmVmaXhlZCAnJCcga2V5KHdoaWNoIGlzIGludGVybmFsIHVzZSBkYXRhKSBvbmx5LlxyXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XHJcblx0XHRcdFx0JCQuY2FjaGVbeF0gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbG9uZSBkYXRhIHRhcmdldCBvYmplY3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuXHRjbG9uZVRhcmdldCh0YXJnZXQ6IERhdGFSb3cpOiBEYXRhUm93IHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlkOiB0YXJnZXQuaWQsXHJcblx0XHRcdGlkX29yZzogdGFyZ2V0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChkID0+ICh7eDogZC54LCB2YWx1ZTogZC52YWx1ZSwgaWQ6IGQuaWR9KSlcclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcclxuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiLi91dGlsXCI7XHJcblxyXG5jb25zdCB7c2V0VGltZW91dCwgY2xlYXJUaW1lb3V0fSA9IHdpbmRvdztcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSByZXNpemUgcXVldWUgZnVuY3Rpb25cclxuICogQHJldHVybnMge0Z1Y250aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmVzaXplKCkge1xyXG5cdGNvbnN0IGZuOiBhbnlbXSA9IFtdO1xyXG5cdGxldCB0aW1lb3V0O1xyXG5cclxuXHRjb25zdCBjYWxsUmVzaXplRm4gPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIERlbGF5IGFsbCByZXNpemUgZnVuY3Rpb25zIGNhbGwsIHRvIHByZXZlbnQgdW5pbnRlbmRlZCBleGNlc3NpdmUgY2FsbCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0Y2FsbFJlc2l6ZUZuLmNsZWFyKCk7XHJcblxyXG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRmbi5mb3JFYWNoKChmOiBGdW5jdGlvbikgPT4gZigpKTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fTtcclxuXHJcblx0Y2FsbFJlc2l6ZUZuLmNsZWFyID0gKCkgPT4ge1xyXG5cdFx0aWYgKHRpbWVvdXQpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRjYWxsUmVzaXplRm4uYWRkID0gZiA9PiBmbi5wdXNoKGYpO1xyXG5cdGNhbGxSZXNpemVGbi5yZW1vdmUgPSBmID0+IGZuLnNwbGljZShmbi5pbmRleE9mKGYpLCAxKTtcclxuXHJcblx0cmV0dXJuIGNhbGxSZXNpemVGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHRyYW5zaXRpb24gcXVldWUgZnVuY3Rpb25cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlV2FpdCgpIHtcclxuXHRsZXQgdHJhbnNpdGlvbnNUb1dhaXQ6IGFueSA9IFtdO1xyXG5cdGNvbnN0IGYgPSBmdW5jdGlvbih0LCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IHRpbWVyO1xyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gbG9vcCgpIHtcclxuXHRcdFx0bGV0IGRvbmUgPSAwO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHQ7ICh0ID0gdHJhbnNpdGlvbnNUb1dhaXRbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodCA9PT0gdHJ1ZSB8fCAodC5lbXB0eSAmJiB0LmVtcHR5KCkpKSB7XHJcblx0XHRcdFx0XHRkb25lKys7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR0LnRyYW5zaXRpb24oKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRkb25lKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cclxuXHRcdFx0aWYgKGRvbmUgPT09IHRyYW5zaXRpb25zVG9XYWl0Lmxlbmd0aCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGxvb3AsIDUwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxvb3AoKTtcclxuXHR9O1xyXG5cclxuXHRmLmFkZCA9IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlzQXJyYXkodCkgP1xyXG5cdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodCkpIDpcclxuXHRcdFx0dHJhbnNpdGlvbnNUb1dhaXQucHVzaCh0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gZjtcclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHtzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyfSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IHtpc0RlZmluZWQsIGlzTnVtYmVyLCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1JlbmRlcmVySGVscGVyIHtcclxuXHRwcml2YXRlIG93bmVyO1xyXG5cdHByaXZhdGUgY29uZmlnO1xyXG5cdHByaXZhdGUgc2NhbGU7XHJcblxyXG5cdGNvbnN0cnVjdG9yKG93bmVyKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IGQzU2NhbGVMaW5lYXIoKTtcclxuXHRcdGNvbnN0IHtjb25maWcsIHBhcmFtc30gPSBvd25lcjtcclxuXHJcblx0XHR0aGlzLm93bmVyID0gb3duZXI7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuXHJcblx0XHRpZiAoY29uZmlnLm5vVHJhbnNpdGlvbiB8fCAhcGFyYW1zLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKSB7XHJcblx0XHRcdGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IHJhbmdlXHJcblx0XHRjb25maWcucmFuZ2UgPSB0aGlzLnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgYSBjaGFyYWN0ZXIgZGltZW5zaW9uXHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IG5vZGUgPGcgY2xhc3M9dGljaz4gbm9kZVxyXG5cdCAqIEByZXR1cm5zIHt7dzogbnVtYmVyLCBoOiBudW1iZXJ9fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c3RhdGljIGdldFNpemVGb3IxQ2hhcihub2RlPykge1xyXG5cdFx0Ly8gZGVmYXVsdCBzaXplIGZvciBvbmUgY2hhcmFjdGVyXHJcblx0XHRjb25zdCBzaXplID0ge1xyXG5cdFx0XHR3OiA1LjUsXHJcblx0XHRcdGg6IDExLjVcclxuXHRcdH07XHJcblxyXG5cdFx0IW5vZGUuZW1wdHkoKSAmJiBub2RlLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LnRleHQoXCIwXCIpXHJcblx0XHRcdC5jYWxsKGVsID0+IHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWwubm9kZSgpLmdldEJCb3goKTtcclxuXHJcblx0XHRcdFx0XHRpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHNpemUudyA9IHdpZHRoO1xyXG5cdFx0XHRcdFx0XHRzaXplLmggPSBoZWlnaHQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdH0gZmluYWxseSB7XHJcblx0XHRcdFx0XHRlbC50ZXh0KFwiXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5nZXRTaXplRm9yMUNoYXIgPSAoKSA9PiBzaXplO1xyXG5cclxuXHRcdHJldHVybiBzaXplO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgdHJhbnNmb3JtIHNldHRlciBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSB0cmFuc2Zyb20gc2V0dGVyIGZ1bmN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaWNrVHJhbnNmb3JtU2V0dGVyKGlkOiBzdHJpbmcpOiAoc2VsZWN0aW9uOiBkM1NlbGVjdGlvbiwgc2NhbGUpID0+IHZvaWQge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgZm4gPSBpZCA9PT0gXCJ4XCIgP1xyXG5cdFx0XHR2YWx1ZSA9PiBgdHJhbnNsYXRlKCR7dmFsdWUgKyBjb25maWcudGlja09mZnNldH0sMClgIDpcclxuXHRcdFx0dmFsdWUgPT4gYHRyYW5zbGF0ZSgwLCR7dmFsdWV9KWA7XHJcblxyXG5cdFx0cmV0dXJuIChzZWxlY3Rpb24sIHNjYWxlKSA9PiB7XHJcblx0XHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gZm4oTWF0aC5jZWlsKHNjYWxlKGQpKSkpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHNjYWxlRXh0ZW50KGRvbWFpbjogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl0ge1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSBkb21haW5bMF07XHJcblx0XHRjb25zdCBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRyZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tzKHNjYWxlLCBpc1lBeGVzOiBib29sZWFuKTogbnVtYmVyW10ge1xyXG5cdFx0Y29uc3Qge3RpY2tTdGVwU2l6ZX0gPSB0aGlzLm93bmVyLnBhcmFtcztcclxuXHRcdGxldCB0aWNrczogbnVtYmVyW10gPSBbXTtcclxuXHJcblx0XHQvLyBXaGVuICdheGlzW3l8eTJdLnRpY2suc3RlcFNpemUnIG9wdGlvbiBpcyBzZXRcclxuXHRcdGlmIChpc1lBeGVzICYmIHRpY2tTdGVwU2l6ZSkge1xyXG5cdFx0XHRjb25zdCBbc3RhcnQsIGVuZF0gPSBzY2FsZS5kb21haW4oKTtcclxuXHRcdFx0bGV0IGludGVydmFsID0gc3RhcnQ7XHJcblxyXG5cdFx0XHR3aGlsZSAoaW50ZXJ2YWwgPD0gZW5kKSB7XHJcblx0XHRcdFx0dGlja3MucHVzaChpbnRlcnZhbCk7XHJcblx0XHRcdFx0aW50ZXJ2YWwgKz0gdGlja1N0ZXBTaXplO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHNjYWxlLnRpY2tzKSB7XHJcblx0XHRcdHRpY2tzID0gc2NhbGUudGlja3MoXHJcblx0XHRcdFx0Li4uKHRoaXMuY29uZmlnLnRpY2tBcmd1bWVudHMgfHwgW10pXHJcblx0XHRcdCkubWFwKHYgPT4gKFxyXG5cdFx0XHRcdC8vIHJvdW5kIHRoZSB0aWNrIHZhbHVlIGlmIGlzIG51bWJlclxyXG5cdFx0XHRcdChpc1N0cmluZyh2KSAmJiBpc051bWJlcih2KSAmJiAhaXNOYU4odikgJiZcclxuXHRcdFx0XHRcdE1hdGgucm91bmQodiAqIDEwKSAvIDEwXHJcblx0XHRcdFx0KSB8fCB2XHJcblx0XHRcdCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gTWF0aC5jZWlsKGRvbWFpblswXSk7IGkgPCBkb21haW5bMV07IGkrKykge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aWNrcy5sZW5ndGggPiAwICYmIHRpY2tzWzBdID4gMCkge1xyXG5cdFx0XHRcdHRpY2tzLnVuc2hpZnQodGlja3NbMF0gLSAodGlja3NbMV0gLSB0aWNrc1swXSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpY2tzO1xyXG5cdH1cclxuXHJcblx0Y29weVNjYWxlKCkge1xyXG5cdFx0Y29uc3QgbmV3U2NhbGUgPSB0aGlzLnNjYWxlLmNvcHkoKTtcclxuXHJcblx0XHRpZiAoIW5ld1NjYWxlLmRvbWFpbigpLmxlbmd0aCkge1xyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4odGhpcy5zY2FsZS5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld1NjYWxlO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvcm1hdHRlZCh2OiBzdHJpbmcgfCBudW1iZXIgfCBhbnkpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gdG8gcm91bmQgZmxvYXQgbnVtYmVycyBmcm9tICdiaW5hcnkgZmxvYXRpbmcgcG9pbnQnXHJcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxyXG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDkxMDEvbGF5bWFucy1leHBsYW5hdGlvbi1mb3Itd2h5LWphdmFzY3JpcHQtaGFzLXdlaXJkLWZsb2F0aW5nLW1hdGgtaWVlZS03NTQtc3RhbmRcclxuXHRcdGNvbnN0IHZhbHVlID0gL1xcZCtcXC5cXGQrMHs1LH1cXGQkLy50ZXN0KHYpID8gK1N0cmluZyh2KS5yZXBsYWNlKC8wK1xcZCQvLCBcIlwiKSA6IHY7XHJcblx0XHRjb25zdCBmb3JtYXR0ZWQgPSB0aWNrRm9ybWF0ID8gdGlja0Zvcm1hdCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKGZvcm1hdHRlZCkgPyBmb3JtYXR0ZWQgOiBcIlwiO1xyXG5cdH1cclxuXHJcblx0dHJhbnNpdGlvbmlzZShzZWxlY3Rpb24pOiBkM1NlbGVjdGlvbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA/XHJcblx0XHRcdHNlbGVjdGlvbi5pbnRlcnJ1cHQoKSA6IHNlbGVjdGlvbi50cmFuc2l0aW9uKGNvbmZpZy50cmFuc2l0aW9uKTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCIuL0F4aXNSZW5kZXJlckhlbHBlclwiO1xyXG5pbXBvcnQge2lzQXJyYXksIHRvQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlcn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzUmVuZGVyZXIge1xyXG5cdGhlbHBlcjtcclxuXHRjb25maWc7XHJcblx0cGFyYW1zO1xyXG5cdGc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBhcmFtczogYW55ID0ge30pIHtcclxuXHRcdGNvbnN0IGNvbmZpZyA9IHtcclxuXHRcdFx0aW5uZXJUaWNrU2l6ZTogNixcclxuXHRcdFx0b3V0ZXJUaWNrU2l6ZTogcGFyYW1zLm91dGVyVGljayA/IDYgOiAwLFxyXG5cdFx0XHRvcmllbnQ6IFwiYm90dG9tXCIsXHJcblx0XHRcdHJhbmdlOiBbXSxcclxuXHRcdFx0dGlja0FyZ3VtZW50czogbnVsbCxcclxuXHRcdFx0dGlja0NlbnRlcmVkOiBudWxsLFxyXG5cdFx0XHR0aWNrQ3VsbGluZzogdHJ1ZSxcclxuXHRcdFx0dGlja0Zvcm1hdDogbnVsbCxcclxuXHRcdFx0dGlja0xlbmd0aDogOSxcclxuXHRcdFx0dGlja09mZnNldDogMCxcclxuXHRcdFx0dGlja1BhZGRpbmc6IDMsXHJcblx0XHRcdHRpY2tWYWx1ZXM6IG51bGwsXHJcblx0XHRcdHRyYW5zaXRpb246IG51bGwsXHJcblx0XHRcdG5vVHJhbnNpdGlvbjogcGFyYW1zLm5vVHJhbnNpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25maWcudGlja0xlbmd0aCA9IE1hdGgubWF4KGNvbmZpZy5pbm5lclRpY2tTaXplLCAwKSArIGNvbmZpZy50aWNrUGFkZGluZztcclxuXHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdFx0dGhpcy5oZWxwZXIgPSBuZXcgSGVscGVyKHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGF4aXMgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBnIEF4aXMgc2VsZWN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjcmVhdGUoZzogZDNTZWxlY3Rpb24pOiB2b2lkIHtcclxuXHRcdGNvbnN0IGN0eCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBoZWxwZXIsIHBhcmFtc30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NjYWxlfSA9IGhlbHBlcjtcclxuXHRcdGNvbnN0IHtvcmllbnR9ID0gY29uZmlnO1xyXG5cdFx0Y29uc3Qgc3BsaXRUaWNrVGV4dCA9IHRoaXMuc3BsaXRUaWNrVGV4dC5iaW5kKHRoaXMpO1xyXG5cdFx0Y29uc3QgaXNMZWZ0UmlnaHQgPSAvXihsZWZ0fHJpZ2h0KSQvLnRlc3Qob3JpZW50KTtcclxuXHRcdGNvbnN0IGlzVG9wQm90dG9tID0gL14odG9wfGJvdHRvbSkkLy50ZXN0KG9yaWVudCk7XHJcblxyXG5cdFx0Ly8gbGluZS90ZXh0IGVudGVyIGFuZCBwYXRoIHVwZGF0ZVxyXG5cdFx0Y29uc3QgdGlja1RyYW5zZm9ybSA9IGhlbHBlci5nZXRUaWNrVHJhbnNmb3JtU2V0dGVyKGlzVG9wQm90dG9tID8gXCJ4XCIgOiBcInlcIik7XHJcblx0XHRjb25zdCBheGlzUHggPSB0aWNrVHJhbnNmb3JtID09PSBoZWxwZXIuYXhpc1ggPyBcInlcIiA6IFwieFwiO1xyXG5cdFx0Y29uc3Qgc2lnbiA9IC9eKHRvcHxsZWZ0KSQvLnRlc3Qob3JpZW50KSA/IC0xIDogMTtcclxuXHJcblx0XHQvLyB0aWNrIHRleHQgaGVscGVyc1xyXG5cdFx0Y29uc3Qgcm90YXRlID0gcGFyYW1zLnRpY2tUZXh0Um90YXRlO1xyXG5cclxuXHRcdHRoaXMuY29uZmlnLnJhbmdlID0gc2NhbGUucmFuZ2VFeHRlbnQgP1xyXG5cdFx0XHRzY2FsZS5yYW5nZUV4dGVudCgpIDpcclxuXHRcdFx0aGVscGVyLnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHJcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgdGlja0xlbmd0aCwgcmFuZ2V9ID0gY29uZmlnO1xyXG5cclxuXHRcdC8vIC8vIGdldCB0aGUgYXhpcycgdGljayBwb3NpdGlvbiBjb25maWd1cmF0aW9uXHJcblx0XHRjb25zdCBpZCA9IHBhcmFtcy5pZDtcclxuXHRcdGNvbnN0IHRpY2tUZXh0UG9zID0gaWQgJiYgL14oeHx5fHkyKSQvLnRlc3QoaWQpID9cclxuXHRcdFx0cGFyYW1zLmNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3RleHRfcG9zaXRpb25gXSA6IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHQvLyB0aWNrIHZpc2libGl0eVxyXG5cdFx0Y29uc3QgcHJlZml4ID0gaWQgPT09IFwic3ViWFwiID8gYHN1YmNoYXJ0X2F4aXNfeGAgOiBgYXhpc18ke2lkfWA7XHJcblx0XHRjb25zdCBheGlzU2hvdyA9IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV9zaG93YF07XHJcblx0XHRjb25zdCB0aWNrU2hvdyA9IHtcclxuXHRcdFx0dGljazogYXhpc1Nob3cgPyBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fdGlja19zaG93YF0gOiBmYWxzZSxcclxuXHRcdFx0dGV4dDogYXhpc1Nob3cgPyBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fdGlja190ZXh0X3Nob3dgXSA6IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdGxldCAkZztcclxuXHJcblx0XHRnLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGcgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0bGV0IHNjYWxlMCA9IHRoaXMuX19jaGFydF9fIHx8IHNjYWxlO1xyXG5cdFx0XHRsZXQgc2NhbGUxID0gaGVscGVyLmNvcHlTY2FsZSgpO1xyXG5cclxuXHRcdFx0JGcgPSBnO1xyXG5cdFx0XHR0aGlzLl9fY2hhcnRfXyA9IHNjYWxlMTtcclxuXHJcblx0XHRcdGNvbmZpZy50aWNrT2Zmc2V0ID0gcGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdE1hdGguY2VpbCgoc2NhbGUxKDEpIC0gc2NhbGUxKDApKSAvIDIpIDogMDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb24gLSBkYXRhIGpvaW5cclxuXHRcdFx0Y29uc3QgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFswXSk7XHJcblxyXG5cdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0cGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXHJcblx0XHRcdFx0Lm1lcmdlKGhlbHBlci50cmFuc2l0aW9uaXNlKHBhdGgpKVxyXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBvdXRlclRpY2tTaXplZCA9IGNvbmZpZy5vdXRlclRpY2tTaXplICogc2lnbjtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gaXNUb3BCb3R0b20gP1xyXG5cdFx0XHRcdFx0XHRgTSR7cmFuZ2VbMF19LCR7b3V0ZXJUaWNrU2l6ZWR9VjBIJHtyYW5nZVsxXX1WJHtvdXRlclRpY2tTaXplZH1gIDpcclxuXHRcdFx0XHRcdFx0YE0ke291dGVyVGlja1NpemVkfSwke3JhbmdlWzBdfUgwViR7cmFuZ2VbMV19SCR7b3V0ZXJUaWNrU2l6ZWR9YDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmICh0aWNrU2hvdy50aWNrIHx8IHRpY2tTaG93LnRleHQpIHtcclxuXHRcdFx0XHQvLyBjb3VudCBvZiB0aWNrIGRhdGEgaW4gYXJyYXlcclxuXHRcdFx0XHRjb25zdCB0aWNrcyA9IGNvbmZpZy50aWNrVmFsdWVzIHx8IGhlbHBlci5nZW5lcmF0ZVRpY2tzKHNjYWxlMSwgaXNMZWZ0UmlnaHQpO1xyXG5cclxuXHRcdFx0XHQvLyB1cGRhdGUgc2VsZWN0aW9uXHJcblx0XHRcdFx0bGV0IHRpY2s6IGQzU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoXCIudGlja1wiKVxyXG5cdFx0XHRcdFx0LmRhdGEodGlja3MsIHNjYWxlMSk7XHJcblxyXG5cdFx0XHRcdC8vIGVudGVyIHNlbGVjdGlvblxyXG5cdFx0XHRcdGNvbnN0IHRpY2tFbnRlciA9IHRpY2tcclxuXHRcdFx0XHRcdC5lbnRlcigpXHJcblx0XHRcdFx0XHQuaW5zZXJ0KFwiZ1wiLCBcIi5kb21haW5cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHRcdFx0Ly8gTUVNTzogTm8gZXhpdCB0cmFuc2l0aW9uLiBUaGUgcmVhc29uIGlzIHRoaXMgdHJhbnNpdGlvbiBhZmZlY3RzIG1heCB0aWNrIHdpZHRoIGNhbGN1bGF0aW9uIGJlY2F1c2Ugb2xkIHRpY2sgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgdGlja3MuXHJcblx0XHRcdFx0Y29uc3QgdGlja0V4aXQgPSB0aWNrLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdFx0Ly8gZW50ZXIgKyB1cGRhdGUgc2VsZWN0aW9uXHJcblx0XHRcdFx0dGljayA9IHRpY2tFbnRlci5tZXJnZSh0aWNrKTtcclxuXHJcblx0XHRcdFx0dGlja1Nob3cudGljayAmJiB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcclxuXHRcdFx0XHR0aWNrU2hvdy50ZXh0ICYmIHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaXplRm9yMUNoYXIgPSBIZWxwZXIuZ2V0U2l6ZUZvcjFDaGFyKHRpY2spO1xyXG5cdFx0XHRcdGNvbnN0IGNvdW50czogbnVtYmVyW10gPSBbXTtcclxuXHJcblx0XHRcdFx0bGV0IHRzcGFuOiBkM1NlbGVjdGlvbiA9IHRpY2suc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdFx0LnNlbGVjdEFsbChcInRzcGFuXCIpXHJcblx0XHRcdFx0XHQuZGF0YSgoZCwgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc3BsaXQgPSBwYXJhbXMudGlja011bHRpbGluZSA/XHJcblx0XHRcdFx0XHRcdFx0c3BsaXRUaWNrVGV4dChkLCBzY2FsZTEsIHRpY2tzLCBpc0xlZnRSaWdodCwgc2l6ZUZvcjFDaGFyLncpIDogKFxyXG5cdFx0XHRcdFx0XHRcdFx0aXNBcnJheShoZWxwZXIudGV4dEZvcm1hdHRlZChkKSkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWxwZXIudGV4dEZvcm1hdHRlZChkKS5jb25jYXQoKSA6IFtoZWxwZXIudGV4dEZvcm1hdHRlZChkKV1cclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0Y291bnRzW2luZGV4XSA9IHNwbGl0Lmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBzcGxpdC5tYXAoc3BsaXR0ZWQgPT4gKHtpbmRleCwgc3BsaXR0ZWR9KSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dHNwYW4uZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0XHR0c3BhbiA9IHRzcGFuXHJcblx0XHRcdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHRcdFx0LmFwcGVuZChcInRzcGFuXCIpXHJcblx0XHRcdFx0XHQubWVyZ2UodHNwYW4pXHJcblx0XHRcdFx0XHQudGV4dChkID0+IGQuc3BsaXR0ZWQpO1xyXG5cclxuXHRcdFx0XHQvLyBzZXQgPHRzcGFuPidzIHBvc2l0aW9uXHJcblx0XHRcdFx0dHNwYW5cclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBpc1RvcEJvdHRvbSA/IDAgOiB0aWNrTGVuZ3RoICogc2lnbilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IGR4ID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICgvKHRvcHxib3R0b20pLy50ZXN0KG9yaWVudCkgJiYgcm90YXRlKSB7XHJcblx0XHRcdFx0XHRcdFx0ZHggPSA4ICogTWF0aC5zaW4oTWF0aC5QSSAqIChyb3RhdGUgLyAxODApKSAqIChvcmllbnQgPT09IFwidG9wXCIgPyAtMSA6IDEpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZHggKyAodGlja1RleHRQb3MueCB8fCAwKTtcclxuXHRcdFx0XHRcdH0pKCkpXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIChkLCBpKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRlZlZhbHVlID0gXCIuNzFlbVwiO1xyXG5cdFx0XHRcdFx0XHRsZXQgZHk6IG51bWJlciB8IHN0cmluZyA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAob3JpZW50ICE9PSBcInRvcFwiKSB7XHJcblx0XHRcdFx0XHRcdFx0ZHkgPSBzaXplRm9yMUNoYXIuaDtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGR5ID0gaXNMZWZ0UmlnaHQgPyAtKChjb3VudHNbZC5pbmRleF0gLSAxKSAqIChzaXplRm9yMUNoYXIuaCAvIDIpIC0gMykgOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQodGlja1RleHRQb3MueSA9PT0gMCA/IGRlZlZhbHVlIDogMCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXNOdW1iZXIoZHkpICYmIHRpY2tUZXh0UG9zLnkgP1xyXG5cdFx0XHRcdFx0XHRcdGR5ICsgdGlja1RleHRQb3MueSA6IGR5IHx8IGRlZlZhbHVlO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxpbmVVcGRhdGUgPSB0aWNrLnNlbGVjdChcImxpbmVcIik7XHJcblx0XHRcdFx0Y29uc3QgdGV4dFVwZGF0ZSA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcclxuXHJcblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcImxpbmVcIikuYXR0cihgJHtheGlzUHh9MmAsIGlubmVyVGlja1NpemUgKiBzaWduKTtcclxuXHRcdFx0XHR0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKS5hdHRyKGF4aXNQeCwgdGlja0xlbmd0aCAqIHNpZ24pO1xyXG5cclxuXHRcdFx0XHRjdHguc2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSk7XHJcblxyXG5cdFx0XHRcdC8vIEFwcGVuZCA8dGl0bGU+IGZvciB0b29sdGlwIGRpc3BsYXlcclxuXHRcdFx0XHRpZiAocGFyYW1zLnRpY2tUaXRsZSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdGl0bGUgPSB0ZXh0VXBkYXRlLnNlbGVjdChcInRpdGxlXCIpO1xyXG5cclxuXHRcdFx0XHRcdCh0aXRsZS5lbXB0eSgpID8gdGV4dFVwZGF0ZS5hcHBlbmQoXCJ0aXRsZVwiKSA6IHRpdGxlKVxyXG5cdFx0XHRcdFx0XHQudGV4dChpbmRleCA9PiBwYXJhbXMudGlja1RpdGxlW2luZGV4XSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc2NhbGUxLmJhbmR3aWR0aCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHNjYWxlMTtcclxuXHRcdFx0XHRcdGNvbnN0IGR4ID0geC5iYW5kd2lkdGgoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGUwID0gZCA9PiB4KGQpICsgZHg7XHJcblx0XHRcdFx0XHRzY2FsZTEgPSBzY2FsZTA7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZTAuYmFuZHdpZHRoKSB7XHJcblx0XHRcdFx0XHRzY2FsZTAgPSBzY2FsZTE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUcmFuc2Zvcm0odGlja0V4aXQsIHNjYWxlMSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aWNrVHJhbnNmb3JtKHRpY2tFbnRlciwgc2NhbGUwKTtcclxuXHRcdFx0XHR0aWNrVHJhbnNmb3JtKGhlbHBlci50cmFuc2l0aW9uaXNlKHRpY2spLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksIHNjYWxlMSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZyA9ICRnO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgeC95IGNvb3JkaW5hdGVcclxuXHQgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpY2tYWSgpOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBvcyA9IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRwb3MueCA9IGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0XHRcdHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgc2l6ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIGRhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpY2tTaXplKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3Qge3NjYWxlfSA9IHRoaXMuaGVscGVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHJhbmdlfSA9IGNvbmZpZztcclxuXHJcblx0XHRjb25zdCB0aWNrUG9zaXRpb24gPSBzY2FsZShkKSArXHJcblx0XHRcdChjb25maWcudGlja0NlbnRlcmVkID8gMCA6IGNvbmZpZy50aWNrT2Zmc2V0KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgcmFuZ2VbMV0gPyBpbm5lclRpY2tTaXplIDogMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrJ3MgbGluZSAmIHRleHQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gbGluZVVwZGF0ZSBMaW5lIHNlbGVjdGlvblxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSB0ZXh0VXBkYXRlIFRleHQgc2VsZWN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRUaWNrTGluZVRleHRQb3NpdGlvbihsaW5lVXBkYXRlLCB0ZXh0VXBkYXRlKTogdm9pZCB7XHJcblx0XHRjb25zdCB0aWNrUG9zID0gdGhpcy5nZXRUaWNrWFkoKTtcclxuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCBvcmllbnQsIHRpY2tMZW5ndGgsIHRpY2tPZmZzZXR9ID0gdGhpcy5jb25maWc7XHJcblx0XHRjb25zdCByb3RhdGUgPSB0aGlzLnBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcclxuXHJcblx0XHRjb25zdCB0ZXh0QW5jaG9yRm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IFtcInN0YXJ0XCIsIFwiZW5kXCJdO1xyXG5cclxuXHRcdFx0b3JpZW50ID09PSBcInRvcFwiICYmIHZhbHVlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdHJldHVybiAhciA/IFwibWlkZGxlXCIgOiAociA+IDAgPyB2YWx1ZVswXSA6IHZhbHVlWzFdKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCB0ZXh0VHJhbnNmb3JtID0gciA9PiAociA/IGByb3RhdGUoJHtyfSlgIDogbnVsbCk7XHJcblx0XHRjb25zdCB5Rm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCByMiA9IHIgLyAob3JpZW50ID09PSBcImJvdHRvbVwiID8gMTUgOiAyMyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gciA/IDExLjUgLSAyLjUgKiByMiAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzd2l0Y2ggKG9yaWVudCkge1xyXG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB0aWNrUG9zLngpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHRpY2tQb3MueClcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGhpcy5nZXRUaWNrU2l6ZS5iaW5kKHRoaXMpKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQocm90YXRlKSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidG9wXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIC15Rm9yVGV4dChyb3RhdGUpICogMilcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwibGVmdFwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgLWlubmVyVGlja1NpemUpXHJcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHRpY2tQb3MueSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGlja1Bvcy55KTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIC10aWNrTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHRpY2tPZmZzZXQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpbm5lclRpY2tTaXplKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRpY2tMZW5ndGgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgMClcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlLCB0aWNrcywgaXNMZWZ0UmlnaHQsIGNoYXJXaWR0aCkge1xyXG5cdFx0Y29uc3Qge3BhcmFtc30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGlja1RleHQgPSB0aGlzLmhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpO1xyXG5cdFx0Y29uc3Qgc3BsaXR0ZWQgPSBpc1N0cmluZyh0aWNrVGV4dCkgJiYgdGlja1RleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xID9cclxuXHRcdFx0dGlja1RleHQuc3BsaXQoXCJcXG5cIikgOiBbXTtcclxuXHJcblx0XHRpZiAoc3BsaXR0ZWQubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBzcGxpdHRlZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNBcnJheSh0aWNrVGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIHRpY2tUZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrV2lkdGggPSBwYXJhbXMudGlja1dpZHRoO1xyXG5cclxuXHRcdGlmICghdGlja1dpZHRoIHx8IHRpY2tXaWR0aCA8PSAwKSB7XHJcblx0XHRcdHRpY2tXaWR0aCA9IGlzTGVmdFJpZ2h0ID8gOTUgOiAoXHJcblx0XHRcdFx0cGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdFx0KE1hdGguY2VpbChzY2FsZSh0aWNrc1sxXSkgLSBzY2FsZSh0aWNrc1swXSkpIC0gMTIpIDogMTEwXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3BsaXQgZ2l2ZW4gdGV4dCBieSB0aWNrIHdpZHRoIHNpemVcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gc3BsaXQoc3BsaXR0ZWQsIHRleHQpIHtcclxuXHRcdFx0bGV0IHN1YnRleHQ7XHJcblx0XHRcdGxldCBzcGFjZUluZGV4O1xyXG5cdFx0XHRsZXQgdGV4dFdpZHRoO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRleHQuY2hhckF0KGkpID09PSBcIiBcIikge1xyXG5cdFx0XHRcdFx0c3BhY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpO1xyXG5cdFx0XHRcdHRleHRXaWR0aCA9IGNoYXJXaWR0aCAqIHN1YnRleHQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjdXJyZW50IGluZGV4XHJcblx0XHRcdFx0aWYgKHRpY2tXaWR0aCA8IHRleHRXaWR0aCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNwbGl0KFxyXG5cdFx0XHRcdFx0XHRzcGxpdHRlZC5jb25jYXQodGV4dC5zdWJzdHIoMCwgc3BhY2VJbmRleCB8fCBpKSksXHJcblx0XHRcdFx0XHRcdHRleHQuc2xpY2Uoc3BhY2VJbmRleCA/IHNwYWNlSW5kZXggKyAxIDogaSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzcGxpdChzcGxpdHRlZCwgU3RyaW5nKHRpY2tUZXh0KSk7XHJcblx0fVxyXG5cclxuXHRzY2FsZSh4KTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXIuc2NhbGU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5oZWxwZXIuc2NhbGUgPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0b3JpZW50KHgpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNvbmZpZy5vcmllbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb25maWcub3JpZW50ID0geCBpbiB7XHJcblx0XHRcdHRvcDogMSxcclxuXHRcdFx0cmlnaHQ6IDEsXHJcblx0XHRcdGJvdHRvbTogMSxcclxuXHRcdFx0bGVmdDogMVxyXG5cdFx0fSA/IFN0cmluZyh4KSA6IFwiYm90dG9tXCI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrRm9ybWF0KGZvcm1hdCk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0Zvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcudGlja0Zvcm1hdCA9IGZvcm1hdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tDZW50ZXJlZChpc0NlbnRlcmVkOiBib29sZWFuKTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQ2VudGVyZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tDZW50ZXJlZCA9IGlzQ2VudGVyZWQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGljaydzIG9mZnNldCB2YWx1ZS5cclxuXHQgKiBUaGUgdmFsdWUgd2lsbCBiZSBzZXQgZm9yICdjYXRlZ29yeScgYXhpcyB0eXBlLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0aWNrT2Zmc2V0KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcudGlja09mZnNldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIGludGVydmFsIGNvdW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUb3RhbCBkYXRhIHNpemVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqL1xyXG5cdHRpY2tJbnRlcnZhbChzaXplOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGludGVydmFsO1xyXG5cclxuXHRcdGlmICh0aGlzLnBhcmFtcy5pc0NhdGVnb3J5KSB7XHJcblx0XHRcdGludGVydmFsID0gdGhpcy5jb25maWcudGlja09mZnNldCAqIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmcuc2VsZWN0KFwicGF0aC5kb21haW5cIilcclxuXHRcdFx0XHQubm9kZSgpXHJcblx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCkgLSB0aGlzLmNvbmZpZy5vdXRlclRpY2tTaXplICogMjtcclxuXHJcblx0XHRcdGludGVydmFsID0gbGVuZ3RoIC8gKHNpemUgfHwgdGhpcy5nLnNlbGVjdEFsbChcImxpbmVcIikuc2l6ZSgpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW50ZXJ2YWwgPT09IEluZmluaXR5ID8gMCA6IGludGVydmFsO1xyXG5cdH1cclxuXHJcblx0dGlja3MoLi4uYXJncyk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tBcmd1bWVudHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0N1bGxpbmcoY3VsbGluZyk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0N1bGxpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tDdWxsaW5nID0gY3VsbGluZztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tWYWx1ZXMoeCk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKGlzRnVuY3Rpb24oeCkpIHtcclxuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSAoKSA9PiB4KHRoaXMuaGVscGVyLnNjYWxlLmRvbWFpbigpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBjb25maWcudGlja1ZhbHVlcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSB4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0c2V0VHJhbnNpdGlvbih0KTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdHRoaXMuY29uZmlnLnRyYW5zaXRpb24gPSB0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0YXhpc1RvcCBhcyBkM0F4aXNUb3AsXHJcblx0YXhpc0JvdHRvbSBhcyBkM0F4aXNCb3R0b20sXHJcblx0YXhpc0xlZnQgYXMgZDNBeGlzTGVmdCxcclxuXHRheGlzUmlnaHQgYXMgZDNBeGlzUmlnaHRcclxufSBmcm9tIFwiZDMtYXhpc1wiO1xyXG5pbXBvcnQge3NjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJ9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQgQXhpc1JlbmRlcmVyIGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsdWUsIGlzRW1wdHksIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIG1lcmdlT2JqLCBub3RFbXB0eSwgcGFyc2VEYXRlLCBzb3J0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpcyB7XHJcblx0cHVibGljIG93bmVyO1xyXG5cclxuXHRwdWJsaWMgeDtcclxuXHRwdWJsaWMgc3ViWDtcclxuXHRwdWJsaWMgeTtcclxuXHRwdWJsaWMgeTI7XHJcblxyXG5cdHByaXZhdGUgYXhlc0xpc3QgPSB7fTtcclxuXHRwdWJsaWMgdGljayA9IHtcclxuXHRcdHg6IG51bGwsIHk6IG51bGwsIHkyOiBudWxsXHJcblx0fTtcclxuXHRwdWJsaWMgeHMgPSBbXTtcclxuXHRwcml2YXRlIG9yaWVudCA9IHtcclxuXHRcdHg6IFwiYm90dG9tXCIsXHJcblx0XHR5OiBcImxlZnRcIixcclxuXHRcdHkyOiBcInJpZ2h0XCIsXHJcblx0XHRzdWJYOiBcImJvdHRvbVwiXHJcblx0fTtcclxuXHJcblx0Y29uc3RydWN0b3Iob3duZXIpIHtcclxuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcclxuXHRcdHRoaXMuc2V0T3JpZW50KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldEF4aXNDbGFzc05hbWUoaWQpIHtcclxuXHRcdHJldHVybiBgJHtDTEFTUy5heGlzfSAke0NMQVNTW2BheGlzJHtjYXBpdGFsaXplKGlkKX1gXX1gO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpIHtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzQ2F0ZWdvcml6ZWQoKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSB0aGlzLm93bmVyO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuYXhpc194X3R5cGUuaW5kZXhPZihcImNhdGVnb3J5XCIpID49IDAgfHwgc3RhdGUuaGFzUmFkYXI7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNDdXN0b21YKCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzLm93bmVyO1xyXG5cclxuXHRcdHJldHVybiAhdGhpcy5pc1RpbWVTZXJpZXMoKSAmJiAoY29uZmlnLmRhdGFfeCB8fCBub3RFbXB0eShjb25maWcuZGF0YV94cykpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzVGltZVNlcmllcyhpZCA9IFwieFwiKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXMub3duZXI7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZ1tgYXhpc18ke2lkfV90eXBlYF0gPT09IFwidGltZXNlcmllc1wiO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzVGltZVNlcmllc1koKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1RpbWVTZXJpZXMoXCJ5XCIpO1xyXG5cdH1cclxuXHJcblx0aW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW4sIGF4aXN9LCBzdGF0ZToge2NsaXB9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHRhcmdldCA9IFtcInhcIiwgXCJ5XCJdO1xyXG5cclxuXHRcdGNvbmZpZy5heGlzX3kyX3Nob3cgJiYgdGFyZ2V0LnB1c2goXCJ5MlwiKTtcclxuXHJcblx0XHR0YXJnZXQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgY2xhc3NBeGlzID0gdGhpcy5nZXRBeGlzQ2xhc3NOYW1lKHYpO1xyXG5cdFx0XHRjb25zdCBjbGFzc0xhYmVsID0gQ0xBU1NbYGF4aXMke3YudG9VcHBlckNhc2UoKX1MYWJlbGBdO1xyXG5cclxuXHRcdFx0YXhpc1t2XSA9IG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBeGlzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGxldCByZXMgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdGlmICh2ID09PSBcInhcIikge1xyXG5cdFx0XHRcdFx0XHRyZXMgPSBjbGlwLnBhdGhYQXhpcztcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJ5XCIgJiYgY29uZmlnLmF4aXNfeV9pbm5lcikge1xyXG5cdFx0XHRcdFx0XHRyZXMgPSBjbGlwLnBhdGhZQXhpcztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKHYpKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW2BheGlzXyR7dn1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcclxuXHJcblx0XHRcdGF4aXNbdl0uYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMYWJlbClcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBbXCJyb3RhdGUoLTkwKVwiLCBudWxsXVtcclxuXHRcdFx0XHRcdHYgPT09IFwieFwiID8gKyFpc1JvdGF0ZWQgOiAraXNSb3RhdGVkXHJcblx0XHRcdFx0XSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCAoKSA9PiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodikpO1xyXG5cclxuXHRcdFx0dGhpcy5nZW5lcmF0ZUF4ZXModik7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBheGlzIG9yaWVudCBhY2NvcmRpbmcgb3B0aW9uIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRPcmllbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGF4aXNfcm90YXRlZDogaXNSb3RhdGVkLFxyXG5cdFx0XHRheGlzX3lfaW5uZXI6IHlJbm5lcixcclxuXHRcdFx0YXhpc195Ml9pbm5lcjogeTJJbm5lclxyXG5cdFx0fSA9ICQkLmNvbmZpZztcclxuXHJcblx0XHR0aGlzLm9yaWVudCA9IHtcclxuXHRcdFx0eDogaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiLFxyXG5cdFx0XHR5OiBpc1JvdGF0ZWQgPyAoeUlubmVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpIDogKHlJbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKSxcclxuXHRcdFx0eTI6IGlzUm90YXRlZCA/ICh5MklubmVyID8gXCJib3R0b21cIiA6IFwidG9wXCIpIDogKHkySW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIiksXHJcblx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIlxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGF4ZXNcclxuXHQgKiBJdCdzIHVzZWQgd2hlbiBheGlzJyBheGVzIG9wdGlvbiBpcyBzZXRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVBeGVzKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzOiBhbnlbXSA9IFtdO1xyXG5cdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IGQzQXhpcztcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0xlZnQgOiBkM0F4aXNCb3R0b207XHJcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInlcIikge1xyXG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNCb3R0b20gOiBkM0F4aXNMZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc1RvcCA6IGQzQXhpc1JpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzQ29uZmlnLmxlbmd0aCkge1xyXG5cdFx0XHRheGVzQ29uZmlnLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGljayA9IHYudGljayB8fCB7fTtcclxuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlW2lkXS5jb3B5KCk7XHJcblxyXG5cdFx0XHRcdHYuZG9tYWluICYmIHNjYWxlLmRvbWFpbih2LmRvbWFpbik7XHJcblxyXG5cdFx0XHRcdGF4ZXMucHVzaChcclxuXHRcdFx0XHRcdGQzQXhpcyhzY2FsZSlcclxuXHRcdFx0XHRcdFx0LnRpY2tzKHRpY2suY291bnQpXHJcblx0XHRcdFx0XHRcdC50aWNrRm9ybWF0KGlzRnVuY3Rpb24odGljay5mb3JtYXQpID8gdGljay5mb3JtYXQuYmluZCgkJC5hcGkpIDogKCh4OiBhbnkpID0+IHgpKVxyXG5cdFx0XHRcdFx0XHQudGlja1ZhbHVlcyh0aWNrLnZhbHVlcylcclxuXHRcdFx0XHRcdFx0LnRpY2tTaXplT3V0ZXIodGljay5vdXRlciA9PT0gZmFsc2UgPyAwIDogNilcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmF4ZXNMaXN0W2lkXSA9IGF4ZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgYXhlcyBub2Rlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlQXhlcygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHRoaXMuYXhlc0xpc3QpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCBheGVzQ29uZmlnID0gY29uZmlnW2BheGlzXyR7aWR9X2F4ZXNgXTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpO1xyXG5cdFx0XHRjb25zdCByYW5nZSA9IHNjYWxlLnJhbmdlKCk7XHJcblxyXG5cdFx0XHR0aGlzLmF4ZXNMaXN0W2lkXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgYXhpc1JhbmdlID0gdi5zY2FsZSgpLnJhbmdlKCk7XHJcblxyXG5cdFx0XHRcdC8vIGFkanVzdCByYW5nZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvODU5XHJcblx0XHRcdFx0aWYgKCFyYW5nZS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYXhpc1JhbmdlW2ldKSkge1xyXG5cdFx0XHRcdFx0di5zY2FsZSgpLnJhbmdlKHJhbmdlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGAke3RoaXMuZ2V0QXhpc0NsYXNzTmFtZShpZCl9LSR7aSArIDF9YDtcclxuXHRcdFx0XHRsZXQgZyA9IG1haW4uc2VsZWN0KGAuJHtjbGFzc05hbWUucmVwbGFjZSgvXFxzLywgXCIuXCIpfWApO1xyXG5cclxuXHRcdFx0XHRpZiAoZy5lbXB0eSgpKSB7XHJcblx0XHRcdFx0XHRnID0gbWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpXHJcblx0XHRcdFx0XHRcdC5jYWxsKHYpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRheGVzQ29uZmlnW2ldLmRvbWFpbiAmJiBzY2FsZS5kb21haW4oYXhlc0NvbmZpZ1tpXS5kb21haW4pO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMueC5oZWxwZXIudHJhbnNpdGlvbmlzZShnKVxyXG5cdFx0XHRcdFx0XHQuY2FsbCh2LnNjYWxlKHNjYWxlKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKGlkLCBpICsgMSkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IEF4aXMgJiB0aWNrIHZhbHVlc1xyXG5cdCAqIGNhbGxlZCBmcm9tOiB1cGRhdGVTY2FsZXMoKVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRBeGlzKGlkLCAuLi5hcmdzKTogdm9pZCB7XHJcblx0XHRpZiAoaWQgIT09IFwic3ViWFwiKSB7XHJcblx0XHRcdHRoaXMudGlja1tpZF0gPSB0aGlzLmdldFRpY2tWYWx1ZXMoaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHRoaXNbaWRdID0gdGhpcy5nZXRBeGlzKGlkLCAuLi5hcmdzKTtcclxuXHR9XHJcblxyXG5cdC8vIGNhbGxlZCBmcm9tIDogZ2V0TWF4VGlja1dpZHRoKClcclxuXHRnZXRBeGlzKGlkLCBzY2FsZSwgb3V0ZXJUaWNrLCBub1RyYW5zaXRpb24sIG5vVGlja1RleHRSb3RhdGUpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzWCA9IC9eKHh8c3ViWCkkLy50ZXN0KGlkKTtcclxuXHRcdGNvbnN0IHR5cGUgPSBpc1ggPyBcInhcIiA6IGlkO1xyXG5cclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcnkgPSBpc1ggJiYgdGhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBvcmllbnQgPSB0aGlzLm9yaWVudFtpZF07XHJcblx0XHRjb25zdCB0aWNrVGV4dFJvdGF0ZSA9IG5vVGlja1RleHRSb3RhdGUgPyAwIDogJCQuZ2V0QXhpc1RpY2tSb3RhdGUodHlwZSk7XHJcblx0XHRsZXQgdGlja0Zvcm1hdDtcclxuXHJcblx0XHRpZiAoaXNYKSB7XHJcblx0XHRcdHRpY2tGb3JtYXQgPSAkJC5mb3JtYXQueEF4aXNUaWNrO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZm4gPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19mb3JtYXRgXTtcclxuXHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGZuKSkge1xyXG5cdFx0XHRcdHRpY2tGb3JtYXQgPSBmbi5iaW5kKCQkLmFwaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdGlja1ZhbHVlcyA9IHRoaXMudGlja1t0eXBlXTtcclxuXHJcblx0XHRjb25zdCBheGlzUGFyYW1zID0gbWVyZ2VPYmooe1xyXG5cdFx0XHRvdXRlclRpY2ssXHJcblx0XHRcdG5vVHJhbnNpdGlvbixcclxuXHRcdFx0Y29uZmlnLFxyXG5cdFx0XHRpZCxcclxuXHRcdFx0dGlja1RleHRSb3RhdGVcclxuXHRcdH0sIGlzWCAmJiB7XHJcblx0XHRcdGlzQ2F0ZWdvcnksXHJcblx0XHRcdHRpY2tNdWx0aWxpbmU6IGNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUsXHJcblx0XHRcdHRpY2tXaWR0aDogY29uZmlnLmF4aXNfeF90aWNrX3dpZHRoLFxyXG5cdFx0XHR0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcclxuXHRcdFx0b3JnWFNjYWxlOiAkJC5zY2FsZS54XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWlzWCkge1xyXG5cdFx0XHRheGlzUGFyYW1zLnRpY2tTdGVwU2l6ZSA9IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfc3RlcFNpemVgXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBheGlzID0gbmV3IEF4aXNSZW5kZXJlcihheGlzUGFyYW1zKVxyXG5cdFx0XHQuc2NhbGUoKGlzWCAmJiAkJC5zY2FsZS56b29tKSB8fCBzY2FsZSlcclxuXHRcdFx0Lm9yaWVudChvcmllbnQpO1xyXG5cclxuXHRcdGlmIChpc1ggJiYgdGhpcy5pc1RpbWVTZXJpZXMoKSAmJiB0aWNrVmFsdWVzICYmICFpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMubWFwKHYgPT4gZm4odikpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNYICYmIHRoaXMuaXNUaW1lU2VyaWVzWSgpKSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9ibG9iL21hc3Rlci9DSEFOR0VTLm1kI3RpbWUtaW50ZXJ2YWxzLWQzLXRpbWVcclxuXHRcdFx0YXhpcy50aWNrcyhjb25maWcuYXhpc195X3RpY2tfdGltZV92YWx1ZSk7XHJcblx0XHRcdHRpY2tWYWx1ZXMgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRpY2tWYWx1ZXMgJiYgYXhpcy50aWNrVmFsdWVzKHRpY2tWYWx1ZXMpO1xyXG5cclxuXHRcdC8vIFNldCB0aWNrXHJcblx0XHRheGlzLnRpY2tGb3JtYXQoXHJcblx0XHRcdHRpY2tGb3JtYXQgfHwgKFxyXG5cdFx0XHRcdCFpc1ggJiYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgJiYgKHggPT4gYCR7eH0lYCkpXHJcblx0XHRcdClcclxuXHRcdCk7XHJcblxyXG5cdFx0aWYgKGlzQ2F0ZWdvcnkpIHtcclxuXHRcdFx0YXhpcy50aWNrQ2VudGVyZWQoY29uZmlnLmF4aXNfeF90aWNrX2NlbnRlcmVkKTtcclxuXHJcblx0XHRcdGlmIChpc0VtcHR5KGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nKSkge1xyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0aWNrQ291bnQgPSBjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX2NvdW50YF07XHJcblxyXG5cdFx0dGlja0NvdW50ICYmIGF4aXMudGlja3ModGlja0NvdW50KTtcclxuXHJcblx0XHRyZXR1cm4gYXhpcztcclxuXHR9XHJcblxyXG5cdHVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzLCBheGlzPyk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBmaXQgPSBjb25maWcuYXhpc194X3RpY2tfZml0O1xyXG5cdFx0bGV0IGNvdW50ID0gY29uZmlnLmF4aXNfeF90aWNrX2NvdW50O1xyXG5cdFx0bGV0IHZhbHVlcztcclxuXHJcblx0XHRpZiAoZml0IHx8IChjb3VudCAmJiBmaXQpKSB7XHJcblx0XHRcdHZhbHVlcyA9ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpO1xyXG5cclxuXHRcdFx0Ly8gaWYgZ2l2ZW4gY291bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBsZW5ndGgsIHRoZW4gbGltaXQgdGhlIGNvdW50LlxyXG5cdFx0XHRpZiAodGhpcy5pc0NhdGVnb3JpemVkKCkgJiYgY291bnQgPiB2YWx1ZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0Y291bnQgPSB2YWx1ZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcclxuXHRcdFx0XHR2YWx1ZXMsXHJcblx0XHRcdFx0Y291bnQsXHJcblx0XHRcdFx0dGhpcy5pc1RpbWVTZXJpZXMoKVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGlzKSB7XHJcblx0XHRcdGF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLngpIHtcclxuXHRcdFx0dGhpcy54LnRpY2tWYWx1ZXModmFsdWVzKTtcclxuXHRcdFx0dGhpcy5zdWJYICYmIHRoaXMuc3ViWC50aWNrVmFsdWVzKHZhbHVlcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG5cdGdldElkKGlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gdGhpcy5vd25lcjtcclxuXHRcdGxldCBheGlzID0gY29uZmlnLmRhdGFfYXhlc1tpZF07XHJcblxyXG5cdFx0Ly8gd2hlbiBkYXRhLmF4ZXMgb3B0aW9uIGhhcyAneTInLCBidXQgJ2F4aXMueTIuc2hvdz10cnVlJyBpc24ndCBzZXQgd2lsbCByZXR1cm4gJ3knXHJcblx0XHRpZiAoIWF4aXMgfHwgIXNjYWxlW2F4aXNdKSB7XHJcblx0XHRcdGF4aXMgPSBcInlcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXhpcztcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzVGlja0Zvcm1hdCgpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXR9ID0gJCQ7XHJcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gY29uZmlnLmF4aXNfeF90aWNrX2Zvcm1hdDtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9IHRoaXMuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gdGhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRsZXQgY3VyckZvcm1hdDtcclxuXHJcblx0XHRpZiAodGlja0Zvcm1hdCkge1xyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbih0aWNrRm9ybWF0KSkge1xyXG5cdFx0XHRcdGN1cnJGb3JtYXQgPSB0aWNrRm9ybWF0LmJpbmQoJCQuYXBpKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRjdXJyRm9ybWF0ID0gZGF0ZSA9PiAoZGF0ZSA/IGZvcm1hdC5heGlzVGltZSh0aWNrRm9ybWF0KShkYXRlKSA6IFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJyRm9ybWF0ID0gaXNUaW1lU2VyaWVzID8gZm9ybWF0LmRlZmF1bHRBeGlzVGltZSA6IChcclxuXHRcdFx0XHRpc0NhdGVnb3JpemVkID9cclxuXHRcdFx0XHRcdCQkLmNhdGVnb3J5TmFtZSA6IHYgPT4gKHYgPCAwID8gdi50b0ZpeGVkKDApIDogdilcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihjdXJyRm9ybWF0KSA/IHYgPT5cclxuXHRcdFx0Y3VyckZvcm1hdC5hcHBseSgkJCwgaXNDYXRlZ29yaXplZCA/XHJcblx0XHRcdFx0W3YsICQkLmNhdGVnb3J5TmFtZSh2KV0gOiBbdl1cclxuXHRcdFx0KSA6IGN1cnJGb3JtYXQ7XHJcblx0fVxyXG5cclxuXHRnZXRUaWNrVmFsdWVzKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSAkJC5jb25maWdbYGF4aXNfJHtpZH1fdGlja192YWx1ZXNgXTtcclxuXHRcdGNvbnN0IGF4aXMgPSAkJFtgJHtpZH1BeGlzYF07XHJcblxyXG5cdFx0cmV0dXJuIChpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpID8gdGlja1ZhbHVlcy5jYWxsKCQkLmFwaSkgOiB0aWNrVmFsdWVzKSB8fFxyXG5cdFx0XHQoYXhpcyA/IGF4aXMudGlja1ZhbHVlcygpIDogdW5kZWZpbmVkKTtcclxuXHR9XHJcblxyXG5cdGdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQ6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3duZXIuY29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF07XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFRleHQoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcclxuXHJcblx0XHRyZXR1cm4gaXNTdHJpbmcob3B0aW9uKSA/IG9wdGlvbiA6IChcclxuXHRcdFx0b3B0aW9uID8gb3B0aW9uLnRleHQgOiBudWxsXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0c2V0TGFiZWxUZXh0KGlkOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblxyXG5cdFx0aWYgKGlzU3RyaW5nKG9wdGlvbikpIHtcclxuXHRcdFx0Y29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF0gPSB0ZXh0O1xyXG5cdFx0fSBlbHNlIGlmIChvcHRpb24pIHtcclxuXHRcdFx0b3B0aW9uLnRleHQgPSB0ZXh0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxQb3NpdGlvbihpZDogc3RyaW5nLCBkZWZhdWx0UG9zaXRpb24pIHtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IChpc09iamVjdFR5cGUob3B0aW9uKSAmJiBvcHRpb24ucG9zaXRpb24pID9cclxuXHRcdFx0b3B0aW9uLnBvc2l0aW9uIDogZGVmYXVsdFBvc2l0aW9uWyshaXNSb3RhdGVkXTtcclxuXHJcblx0XHRjb25zdCBoYXMgPSB2ID0+ICEhfnBvc2l0aW9uLmluZGV4T2Yodik7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0aXNJbm5lcjogaGFzKFwiaW5uZXJcIiksXHJcblx0XHRcdGlzT3V0ZXI6IGhhcyhcIm91dGVyXCIpLFxyXG5cdFx0XHRpc0xlZnQ6IGhhcyhcImxlZnRcIiksXHJcblx0XHRcdGlzQ2VudGVyOiBoYXMoXCJjZW50ZXJcIiksXHJcblx0XHRcdGlzUmlnaHQ6IGhhcyhcInJpZ2h0XCIpLFxyXG5cdFx0XHRpc1RvcDogaGFzKFwidG9wXCIpLFxyXG5cdFx0XHRpc01pZGRsZTogaGFzKFwibWlkZGxlXCIpLFxyXG5cdFx0XHRpc0JvdHRvbTogaGFzKFwiYm90dG9tXCIpXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Z2V0QXhpc0xhYmVsUG9zaXRpb24oaWQ6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihpZCwgaWQgPT09IFwieFwiID8gW1wiaW5uZXItdG9wXCIsIFwiaW5uZXItcmlnaHRcIl0gOiBbXCJpbm5lci1yaWdodFwiLCBcImlubmVyLXRvcFwiXSk7XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFBvc2l0aW9uQnlJZChpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCk7XHJcblx0fVxyXG5cclxuXHR4Rm9yQXhpc0xhYmVsKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtzdGF0ZToge3dpZHRoLCBoZWlnaHR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKGlkKTtcclxuXHRcdGxldCB4ID0gcG9zaXRpb24uaXNNaWRkbGUgPyAtaGVpZ2h0IC8gMiA6IDA7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCQkLCBpZCAhPT0gXCJ4XCIpKSB7XHJcblx0XHRcdHggPSBwb3NpdGlvbi5pc0xlZnQgPyAwIDogKFxyXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gd2lkdGggLyAyIDogd2lkdGhcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNCb3R0b20pIHtcclxuXHRcdFx0eCA9IC1oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cclxuXHRkeEZvckF4aXNMYWJlbChpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpO1xyXG5cdFx0bGV0IGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGlkICE9PSBcInhcIikpIHtcclxuXHRcdFx0ZHggPSBwb3NpdGlvbi5pc0xlZnQgPyBcIjAuNWVtXCIgOiAoXHJcblx0XHRcdFx0cG9zaXRpb24uaXNSaWdodCA/IFwiLTAuNWVtXCIgOiBcIjBcIlxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc1RvcCkge1xyXG5cdFx0XHRkeCA9IFwiLTAuNWVtXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGR4O1xyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvckF4aXNMYWJlbChpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpO1xyXG5cdFx0bGV0IGFuY2hvciA9IHBvc2l0aW9uLmlzTWlkZGxlID8gXCJtaWRkbGVcIiA6IFwiZW5kXCI7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCQkLCBpZCAhPT0gXCJ4XCIpKSB7XHJcblx0XHRcdGFuY2hvciA9IHBvc2l0aW9uLmlzTGVmdCA/IFwic3RhcnRcIiA6IChcclxuXHRcdFx0XHRwb3NpdGlvbi5pc0NlbnRlciA/IFwibWlkZGxlXCIgOiBcImVuZFwiXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzQm90dG9tKSB7XHJcblx0XHRcdGFuY2hvciA9IFwic3RhcnRcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5jaG9yO1xyXG5cdH1cclxuXHJcblx0ZHlGb3JBeGlzTGFiZWwoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCkuaXNJbm5lcjtcclxuXHRcdGNvbnN0IHRpY2tSb3RhdGUgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19yb3RhdGVgXSA/ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKSA6IDA7XHJcblx0XHRjb25zdCBtYXhUaWNrV2lkdGggPSB0aGlzLmdldE1heFRpY2tXaWR0aChpZCk7XHJcblx0XHRsZXQgZHk7XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIikge1xyXG5cdFx0XHRjb25zdCB4SGVpZ2h0ID0gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0ZHkgPSBpc0lubmVyID8gXCIxLjJlbVwiIDogLTI1IC0gbWF4VGlja1dpZHRoO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzSW5uZXIpIHtcclxuXHRcdFx0XHRkeSA9IFwiLTAuNWVtXCI7XHJcblx0XHRcdH0gZWxzZSBpZiAoeEhlaWdodCkge1xyXG5cdFx0XHRcdGR5ID0geEhlaWdodCAtIDEwO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRpY2tSb3RhdGUpIHtcclxuXHRcdFx0XHRkeSA9IHRpY2tSb3RhdGUgLSAxMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkeSA9IFwiM2VtXCI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGR5ID0ge1xyXG5cdFx0XHRcdHk6IFtcIi0wLjVlbVwiLCAxMCwgXCIzZW1cIiwgXCIxLjJlbVwiLCAxMF0sXHJcblx0XHRcdFx0eTI6IFtcIjEuMmVtXCIsIC0yMCwgXCItMi4yZW1cIiwgXCItMC41ZW1cIiwgMTVdXHJcblx0XHRcdH1baWRdO1xyXG5cclxuXHRcdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRcdGlmIChpc0lubmVyKSB7XHJcblx0XHRcdFx0XHRkeSA9IGR5WzBdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlja1JvdGF0ZSkge1xyXG5cdFx0XHRcdFx0ZHkgPSB0aWNrUm90YXRlICogKGlkID09PSBcInkyXCIgPyAtMSA6IDEpIC0gZHlbMV07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGR5ID0gZHlbMl07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGR5ID0gaXNJbm5lciA/XHJcblx0XHRcdFx0XHRkeVszXSA6IChcclxuXHRcdFx0XHRcdFx0ZHlbNF0gKyAoXHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnW2BheGlzXyR7aWR9X2lubmVyYF0gPyAwIDogKG1heFRpY2tXaWR0aCArIGR5WzRdKVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpICogKGlkID09PSBcInlcIiA/IC0xIDogMSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZHk7XHJcblx0fVxyXG5cclxuXHRnZXRNYXhUaWNrV2lkdGgoaWQ6IHN0cmluZywgd2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fSwgJGVsOiB7c3ZnLCBjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50VGlja01heCA9IGN1cnJlbnQubWF4VGlja1dpZHRoc1tpZF07XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cclxuXHRcdGlmICh3aXRob3V0UmVjb21wdXRlIHx8ICFjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdIHx8ICQkLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRjb25zdCBpc1lBeGlzID0gL155Mj8kLy50ZXN0KGlkKTtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpLmRvbWFpbigkJFtgZ2V0JHtpc1lBeGlzID8gXCJZXCIgOiBcIlhcIn1Eb21haW5gXSh0YXJnZXRzVG9TaG93LCBpZCkpO1xyXG5cdFx0XHRjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcclxuXHJcblx0XHRcdC8vIGRvIG5vdCBjb21wdXRlIGlmIGRvbWFpbiBpcyBzYW1lXHJcblx0XHRcdGlmIChkb21haW5bMF0gPT09IGRvbWFpblsxXSB8fFxyXG5cdFx0XHRcdChpc0FycmF5KGN1cnJlbnRUaWNrTWF4LmRvbWFpbikgJiYgY3VycmVudFRpY2tNYXguZG9tYWluWzBdID09PSBjdXJyZW50VGlja01heC5kb21haW5bMV0pXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN1cnJlbnRUaWNrTWF4LmRvbWFpbiA9IGRvbWFpbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgYXhpcyA9IHRoaXMuZ2V0QXhpcyhpZCwgc2NhbGUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XHJcblx0XHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2NvdW50YF07XHJcblx0XHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja192YWx1ZXNgXTtcclxuXHJcblx0XHRcdC8vIE1ha2UgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHRpY2sgdGV4dCB0byBiZSByZW5kZXJlZFxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy85MjBcclxuXHRcdFx0Ly8gRG8gbm90IGdlbmVyYXRlIGlmICd0aWNrIHZhbHVlcycgb3B0aW9uIGlzIGdpdmVuXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzEyNTFcclxuXHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdGF4aXMudGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRkb21haW4sXHJcblx0XHRcdFx0XHRcdHRpY2tDb3VudCxcclxuXHRcdFx0XHRcdFx0aXNZQXhpcyA/IHRoaXMuaXNUaW1lU2VyaWVzWSgpIDogdGhpcy5pc1RpbWVTZXJpZXMoKVxyXG5cdFx0XHRcdFx0KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCFpc1lBeGlzICYmIHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3csIGF4aXMpO1xyXG5cclxuXHRcdFx0Y29uc3QgZHVtbXkgPSBjaGFydC5hcHBlbmQoXCJzdmdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBcIjBweFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgXCIwcHhcIik7XHJcblxyXG5cdFx0XHRheGlzLmNyZWF0ZShkdW1teSk7XHJcblxyXG5cdFx0XHRkdW1teS5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudFRleHRXaWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XHJcblxyXG5cdFx0XHRcdFx0bWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgY3VycmVudFRleHRXaWR0aCk7XHJcblx0XHRcdFx0XHQvLyBjYWNoZSB0aWNrIHRleHQgd2lkdGggZm9yIGdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93KClcclxuXHRcdFx0XHRcdGlmIChpZCA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0XHRcdFx0Y3VycmVudFRpY2tNYXgudGlja3NbaV0gPSBjdXJyZW50VGV4dFdpZHRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZHVtbXkucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFdpZHRoID4gMCkge1xyXG5cdFx0XHRjdXJyZW50VGlja01heC5zaXplID0gbWF4V2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0fVxyXG5cclxuXHRnZXRYQXhpc1RpY2tUZXh0WTJPdmVyZmxvdyhkZWZhdWx0UGFkZGluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB4QXhpc1RpY2tSb3RhdGUgPSAkJC5nZXRBeGlzVGlja1JvdGF0ZShcInhcIik7XHJcblx0XHRjb25zdCBwb3NpdGl2ZVJvdGF0aW9uID0geEF4aXNUaWNrUm90YXRlID4gMCAmJiB4QXhpc1RpY2tSb3RhdGUgPCA5MDtcclxuXHJcblx0XHRpZiAoKGF4aXMuaXNDYXRlZ29yaXplZCgpIHx8IGF4aXMuaXNUaW1lU2VyaWVzKCkpICYmXHJcblx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19maXQgJiZcclxuXHRcdFx0IWNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nICYmXHJcblx0XHRcdCFjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmXHJcblx0XHRcdHBvc2l0aXZlUm90YXRpb25cclxuXHRcdCkge1xyXG5cdFx0XHRjb25zdCB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgPSBzdGF0ZS5jdXJyZW50LndpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCk7XHJcblx0XHRcdGNvbnN0IG1heE92ZXJmbG93ID0gdGhpcy5nZXRYQXhpc1RpY2tNYXhPdmVyZmxvdyhcclxuXHRcdFx0XHR4QXhpc1RpY2tSb3RhdGUsIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCAtIGRlZmF1bHRQYWRkaW5nXHJcblx0XHRcdCk7XHJcblx0XHRcdGNvbnN0IHhBeGlzVGlja1RleHRZMk92ZXJmbG93ID0gTWF0aC5tYXgoMCwgbWF4T3ZlcmZsb3cpICtcclxuXHRcdFx0XHRkZWZhdWx0UGFkZGluZzsgLy8gZm9yIGRpc3BsYXkgaW5jb25zaXN0ZW5jaWVzIGJldHdlZW4gYnJvd3NlcnNcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLm1pbih4QXhpc1RpY2tUZXh0WTJPdmVyZmxvdywgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0IC8gMik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRnZXRYQXhpc1RpY2tNYXhPdmVyZmxvdyh4QXhpc1RpY2tSb3RhdGUsIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSBheGlzLmlzVGltZVNlcmllcygpO1xyXG5cclxuXHRcdGNvbnN0IHRpY2tUZXh0V2lkdGhzID0gc3RhdGUuY3VycmVudC5tYXhUaWNrV2lkdGhzLngudGlja3M7XHJcblx0XHRjb25zdCB0aWNrQ291bnQgPSB0aWNrVGV4dFdpZHRocy5sZW5ndGg7XHJcblx0XHRjb25zdCB7bGVmdCwgcmlnaHR9ID0gc3RhdGUuYXhpcy54LnBhZGRpbmc7XHJcblx0XHRsZXQgbWF4T3ZlcmZsb3cgPSAwO1xyXG5cclxuXHRcdGNvbnN0IHJlbWFpbmluZyA9IHRpY2tDb3VudCAtIChpc1RpbWVTZXJpZXMgJiYgY29uZmlnLmF4aXNfeF90aWNrX2ZpdCA/IDAuNSA6IDApO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcclxuXHRcdFx0Y29uc3QgdGlja0luZGV4ID0gaSArIDE7XHJcblx0XHRcdGNvbnN0IHJvdGF0ZWRUaWNrVGV4dFdpZHRoID0gTWF0aC5jb3MoTWF0aC5QSSAqIHhBeGlzVGlja1JvdGF0ZSAvIDE4MCkgKiB0aWNrVGV4dFdpZHRoc1tpXTtcclxuXHRcdFx0Y29uc3QgdGlja3NCZWZvcmVUaWNrVGV4dCA9IHRpY2tJbmRleCAtIChpc1RpbWVTZXJpZXMgPyAxIDogMC41KSArIGxlZnQ7XHJcblxyXG5cdFx0XHQvLyBTa2lwIHRpY2tzIGlmIHRoZXJlIGFyZSBubyB0aWNrcyBiZWZvcmUgdGhlbVxyXG5cdFx0XHRpZiAodGlja3NCZWZvcmVUaWNrVGV4dCA8PSAwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHhBeGlzTGVuZ3RoV2l0aG91dFRpY2tUZXh0V2lkdGggPSB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgLSByb3RhdGVkVGlja1RleHRXaWR0aDtcclxuXHRcdFx0Y29uc3QgdGlja0xlbmd0aCA9IHhBeGlzTGVuZ3RoV2l0aG91dFRpY2tUZXh0V2lkdGggLyB0aWNrc0JlZm9yZVRpY2tUZXh0O1xyXG5cdFx0XHRjb25zdCByZW1haW5pbmdUaWNrcyA9IHJlbWFpbmluZyAtIHRpY2tJbmRleDtcclxuXHJcblx0XHRcdGNvbnN0IHBhZGRpbmdSaWdodExlbmd0aCA9IHJpZ2h0ICogdGlja0xlbmd0aDtcclxuXHRcdFx0Y29uc3QgcmVtYWluaW5nVGlja1dpZHRoID0gKHJlbWFpbmluZ1RpY2tzICogdGlja0xlbmd0aCkgKyBwYWRkaW5nUmlnaHRMZW5ndGg7XHJcblx0XHRcdGNvbnN0IG92ZXJmbG93ID0gcm90YXRlZFRpY2tUZXh0V2lkdGggLSAodGlja0xlbmd0aCAvIDIpIC0gcmVtYWluaW5nVGlja1dpZHRoO1xyXG5cclxuXHRcdFx0bWF4T3ZlcmZsb3cgPSBNYXRoLm1heChtYXhPdmVyZmxvdywgb3ZlcmZsb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrT2Zmc2V0ID0gMDtcclxuXHJcblx0XHRpZiAoIWlzVGltZVNlcmllcykge1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9IGQzU2NhbGVMaW5lYXIoKVxyXG5cdFx0XHRcdC5kb21haW4oW1xyXG5cdFx0XHRcdFx0bGVmdCAqIC0xLFxyXG5cdFx0XHRcdFx0JCQuZ2V0WERvbWFpbk1heCgkJC5kYXRhLnRhcmdldHMpICsgMSArIHJpZ2h0XHJcblx0XHRcdFx0XSlcclxuXHRcdFx0XHQucmFuZ2UoWzAsIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCAtIG1heE92ZXJmbG93XSk7XHJcblxyXG5cdFx0XHR0aWNrT2Zmc2V0ID0gKE1hdGguY2VpbCgoc2NhbGUoMSkgLSBzY2FsZSgwKSkgLyAyKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1heE92ZXJmbG93ICsgdGlja09mZnNldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB4IEF4aXMgcGFkZGluZ1xyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgVGljayBjb3VudFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFBhZGRpbmcgb2JqZWN0IHZhbHVlcyB3aXRoICdsZWZ0JyAmICdyaWdodCcga2V5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRYQXhpc1BhZGRpbmcodGlja0NvdW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRsZXQgcGFkZGluZyA9ICQkLmNvbmZpZy5heGlzX3hfcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNFbXB0eShwYWRkaW5nKSkge1xyXG5cdFx0XHRwYWRkaW5nID0ge2xlZnQ6IDAsIHJpZ2h0OiAwfTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcubGVmdCA9IHBhZGRpbmcubGVmdCB8fCAwO1xyXG5cdFx0XHRwYWRkaW5nLnJpZ2h0ID0gcGFkZGluZy5yaWdodCB8fCAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgkJC5heGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGNvbnN0IGZpcnN0WCA9ICskJC5nZXRYRG9tYWluTWluKCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHRcdGNvbnN0IGxhc3RYID0gKyQkLmdldFhEb21haW5NYXgoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3QgdGltZURpZmYgPSBsYXN0WCAtIGZpcnN0WDtcclxuXHJcblx0XHRcdGNvbnN0IHJhbmdlID0gdGltZURpZmYgKyBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xyXG5cdFx0XHRjb25zdCByZWxhdGl2ZVRpY2tXaWR0aCA9ICh0aW1lRGlmZiAvIHRpY2tDb3VudCkgLyByYW5nZTtcclxuXHJcblx0XHRcdGNvbnN0IGxlZnQgPSBwYWRkaW5nLmxlZnQgLyByYW5nZSAvIHJlbGF0aXZlVGlja1dpZHRoIHx8IDA7XHJcblx0XHRcdGNvbnN0IHJpZ2h0ID0gcGFkZGluZy5yaWdodCAvIHJhbmdlIC8gcmVsYXRpdmVUaWNrV2lkdGggfHwgMDtcclxuXHJcblx0XHRcdHBhZGRpbmcgPSB7bGVmdCwgcmlnaHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nO1xyXG5cdH1cclxuXHJcblxyXG5cdHVwZGF0ZUxhYmVscyh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cclxuXHRcdGNvbnN0IGxhYmVscyA9IHtcclxuXHRcdFx0eDogbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfSAuJHtDTEFTUy5heGlzWExhYmVsfWApLFxyXG5cdFx0XHR5OiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1l9IC4ke0NMQVNTLmF4aXNZTGFiZWx9YCksXHJcblx0XHRcdHkyOiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1kyfSAuJHtDTEFTUy5heGlzWTJMYWJlbH1gKVxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhsYWJlbHMpLmZpbHRlcihpZCA9PiAhbGFiZWxzW2lkXS5lbXB0eSgpKVxyXG5cdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBub2RlID0gbGFiZWxzW3ZdO1xyXG5cclxuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gPyBub2RlLnRyYW5zaXRpb24oKSA6IG5vZGUpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgKCkgPT4gdGhpcy54Rm9yQXhpc0xhYmVsKHYpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCAoKSA9PiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHYpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCAoKSA9PiB0aGlzLmR5Rm9yQXhpc0xhYmVsKHYpKVxyXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gdGhpcy5nZXRMYWJlbFRleHQodikpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGdldFBhZGRpbmcocGFkZGluZywga2V5LCBkZWZhdWx0VmFsdWUsIGRvbWFpbkxlbmd0aCkge1xyXG5cdFx0Y29uc3QgcCA9IGlzTnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IHBhZGRpbmdba2V5XTtcclxuXHJcblx0XHRpZiAoIWlzVmFsdWUocCkpIHtcclxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwLCBkb21haW5MZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Y29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcocGl4ZWxzLCBkb21haW5MZW5ndGgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7d2lkdGgsIGhlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBsZW5ndGggPSBjb25maWcuYXhpc19yb3RhdGVkID8gd2lkdGggOiBoZWlnaHQ7XHJcblxyXG5cdFx0cmV0dXJuIGRvbWFpbkxlbmd0aCAqIChwaXhlbHMgLyBsZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUaWNrVmFsdWVzKHZhbHVlcywgdGlja0NvdW50LCBmb3JUaW1lU2VyaWVzKSB7XHJcblx0XHRsZXQgdGlja1ZhbHVlcyA9IHZhbHVlcztcclxuXHJcblx0XHRpZiAodGlja0NvdW50KSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRpY2tzIGFjY29yZGluZyB0byB0aWNrQ291bnRcclxuXHRcdFx0aWYgKHRhcmdldENvdW50ID09PSAxKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID09PSAyKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF0sIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID4gMikge1xyXG5cdFx0XHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSB0aGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgY291bnQgPSB0YXJnZXRDb3VudCAtIDI7XHJcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2YWx1ZXNbMF07XHJcblx0XHRcdFx0Y29uc3QgZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRjb25zdCBpbnRlcnZhbCA9IChlbmQgLSBzdGFydCkgLyAoY291bnQgKyAxKTtcclxuXHRcdFx0XHRsZXQgdGlja1ZhbHVlO1xyXG5cclxuXHRcdFx0XHQvLyByZS1jb25zdHJ1Y3QgdW5pcXVlIHZhbHVlc1xyXG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbc3RhcnRdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZSA9ICtzdGFydCArIGludGVydmFsICogKGkgKyAxKTtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Zm9yVGltZVNlcmllcyA/IG5ldyBEYXRlKHRpY2tWYWx1ZSkgOiAoXHJcblx0XHRcdFx0XHRcdFx0aXNDYXRlZ29yaXplZCA/IE1hdGgucm91bmQodGlja1ZhbHVlKSA6IHRpY2tWYWx1ZVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKGVuZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZvclRpbWVTZXJpZXMpIHtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrVmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgYXhpcyA9ICQkLiRlbC5heGlzO1xyXG5cclxuXHRcdGNvbnN0IFtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1YlhdID0gW1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YlhcIl1cclxuXHRcdFx0Lm1hcCh2ID0+IHtcclxuXHRcdFx0XHRsZXQgYXggPSBheGlzW3ZdO1xyXG5cclxuXHRcdFx0XHRpZiAoYXggJiYgZHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdGF4ID0gYXgudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBheDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1Ylh9O1xyXG5cdH1cclxuXHJcblx0cmVkcmF3KHRyYW5zaXRpb25zLCBpc0hpZGRlbiwgaXNJbml0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gaXNIaWRkZW4gPyBcIjBcIiA6IFwiMVwiO1xyXG5cclxuXHRcdFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJYXCJdLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gdGhpc1tpZF07XHJcblx0XHRcdGNvbnN0ICRheGlzID0gJGVsLmF4aXNbaWRdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMgJiYgJGF4aXMpIHtcclxuXHRcdFx0XHRpZiAoIWlzSW5pdCkge1xyXG5cdFx0XHRcdFx0YXhpcy5jb25maWcud2l0aG91dFRyYW5zaXRpb24gPSAhY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb247XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQkYXhpcy5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XHJcblx0XHRcdFx0YXhpcy5jcmVhdGUodHJhbnNpdGlvbnNbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVBeGVzKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgYXhpc1xyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNUb1Nob3cgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHd0aCBvcHRpb24gb2JqZWN0XHJcblx0ICogQHBhcmFtIHtkMy5UcmFuc2l0aW9ufSB0cmFuc2l0aW9ucyBUcmFuc2l0aW9uIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBmbG93IGZsb3cgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0luaXQgY2FsbGVkIGZyb20gaW5pdGlhbGl6YXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaXNJbml0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzWm9vbSA9ICEhc2NhbGUuem9vbTtcclxuXHRcdGxldCB4RG9tYWluRm9yWm9vbTtcclxuXHJcblx0XHRpZiAoIWhhc1pvb20gJiYgdGhpcy5pc0NhdGVnb3JpemVkKCkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oWzAsICRlbC5heGlzLnguc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNjYWxlLnggJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0IWhhc1pvb20gJiZcclxuXHRcdFx0XHQkJC51cGRhdGVYRG9tYWluKHRhcmdldHNUb1Nob3csIHd0aC5VcGRhdGVYRG9tYWluLCB3dGguVXBkYXRlT3JnWERvbWFpbiwgd3RoLlRyaW1YRG9tYWluKTtcclxuXHJcblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3cpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMueCkge1xyXG5cdFx0XHR0aGlzLngudGlja1ZhbHVlcyhbXSk7XHJcblx0XHRcdHRoaXMuc3ViWCAmJiB0aGlzLnN1YlgudGlja1ZhbHVlcyhbXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy56b29tX3Jlc2NhbGUgJiYgIWZsb3cpIHtcclxuXHRcdFx0eERvbWFpbkZvclpvb20gPSBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdFtcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGNvbnN0IGF4aXNTY2FsZSA9IHNjYWxlW2tleV07XHJcblxyXG5cdFx0XHRpZiAoYXhpc1NjYWxlKSB7XHJcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja192YWx1ZXNgXTtcclxuXHRcdFx0XHRjb25zdCB0aWNrQ291bnQgPSBjb25maWdbYGF4aXNfJHtrZXl9X3RpY2tfY291bnRgXTtcclxuXHJcblx0XHRcdFx0YXhpc1NjYWxlLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIGtleSwgeERvbWFpbkZvclpvb20pKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgYXhpcyA9ICQkLmF4aXNba2V5XTtcclxuXHRcdFx0XHRcdGNvbnN0IGRvbWFpbiA9IGF4aXNTY2FsZS5kb21haW4oKTtcclxuXHJcblx0XHRcdFx0XHRheGlzLnRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbixcclxuXHRcdFx0XHRcdFx0XHRkb21haW4uZXZlcnkodiA9PiB2ID09PSAwKSA/IDEgOiB0aWNrQ291bnQsXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5pc1RpbWVTZXJpZXNZKClcclxuXHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGF4ZXNcclxuXHRcdHRoaXMucmVkcmF3KHRyYW5zaXRpb25zLCAkJC5oYXNBcmNUeXBlKCksIGlzSW5pdCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGF4aXMgbGFiZWxcclxuXHRcdHRoaXMudXBkYXRlTGFiZWxzKHd0aC5UcmFuc2l0aW9uKTtcclxuXHJcblx0XHQvLyBzaG93L2hpZGUgaWYgbWFudWFsIGN1bGxpbmcgbmVlZGVkXHJcblx0XHRpZiAoKHd0aC5VcGRhdGVYRG9tYWluIHx8IHd0aC5VcGRhdGVYQXhpcyB8fCB3dGguWSkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0dGhpcy5zZXRDdWxsaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHN1YiBkb21haW5cclxuXHRcdGlmICh3dGguWSkge1xyXG5cdFx0XHRzY2FsZS5zdWJZICYmIHNjYWxlLnN1YlkuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgXCJ5XCIpKTtcclxuXHRcdFx0c2NhbGUuc3ViWTIgJiYgc2NhbGUuc3ViWTIuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgXCJ5MlwiKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWFudWFsIGN1bGxpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEN1bGxpbmcoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXAsIGN1cnJlbnR9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0W1wic3ViWFwiLCBcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaCh0eXBlID0+IHtcclxuXHRcdFx0Y29uc3QgYXhpcyA9ICRlbC5heGlzW3R5cGVdO1xyXG5cclxuXHRcdFx0Ly8gc3ViY2hhcnQgeCBheGlzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggeCBheGlzIGN1bGxpbmdcclxuXHRcdFx0Y29uc3QgaWQgPSB0eXBlID09PSBcInN1YlhcIiA/IFwieFwiIDogdHlwZTtcclxuXHRcdFx0Y29uc3QgdG9DdWxsID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY3VsbGluZ2BdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMgJiYgdG9DdWxsKSB7XHJcblx0XHRcdFx0Y29uc3QgdGlja1RleHQgPSBheGlzLnNlbGVjdEFsbChcIi50aWNrIHRleHRcIik7XHJcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IHNvcnRWYWx1ZSh0aWNrVGV4dC5kYXRhKCkpO1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tTaXplID0gdGlja1ZhbHVlcy5sZW5ndGg7XHJcblx0XHRcdFx0Y29uc3QgY3VsbGluZ01heCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2N1bGxpbmdfbWF4YF07XHJcblx0XHRcdFx0bGV0IGludGVydmFsRm9yQ3VsbGluZztcclxuXHJcblx0XHRcdFx0aWYgKHRpY2tTaXplKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tTaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKHRpY2tTaXplIC8gaSA8IGN1bGxpbmdNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnRlcnZhbEZvckN1bGxpbmcgPSBpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGlja1RleHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IHRpY2tWYWx1ZXMuaW5kZXhPZihkKSAlIGludGVydmFsRm9yQ3VsbGluZyA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUZXh0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc2V0L3Vuc2V0IHhfYXhpc190aWNrX2NsaXBwYXRoXHJcblx0XHRcdFx0aWYgKHR5cGUgPT09IFwieFwiKSB7XHJcblx0XHRcdFx0XHRjb25zdCBjbGlwUGF0aCA9IGN1cnJlbnQubWF4VGlja1dpZHRocy54LmNsaXBQYXRoID8gY2xpcC5wYXRoWEF4aXNUaWNrVGV4dHMgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRcdCRlbC5zdmcuc2VsZWN0QWxsKGAuJHtDTEFTUy5heGlzWH0gLnRpY2sgdGV4dGApXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0Y3N2UGFyc2UgYXMgZDNDc3ZQYXJzZSxcclxuXHR0c3ZQYXJzZSBhcyBkM1RzdlBhcnNlLFxyXG5cdGNzdlBhcnNlUm93cyBhcyBkM0NzdlBhcnNlUm93cyxcclxuXHR0c3ZQYXJzZVJvd3MgYXMgZDNUc3ZQYXJzZVJvd3MsXHJcbn0gZnJvbSBcImQzLWRzdlwiO1xyXG5pbXBvcnQge2lzVW5kZWZpbmVkLCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1ZhbHVlLCBub3RFbXB0eSwgaXNBcnJheSwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRGF0YSBjb252ZXJ0XHJcbiAqIEBtZW1iZXJvZiBDaGFydEludGVybmFsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGFjY29yZGluZyBpdHMgdHlwZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIGRhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmb3IgdXJsKFhIUikgdHlwZSBsb2FkaW5nXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnREYXRhKGFyZ3MsIGNhbGxiYWNrOiBGdW5jdGlvbik6IG9iamVjdCB7XHJcblx0XHRsZXQgZGF0YTtcclxuXHJcblx0XHRpZiAoYXJncy5iaW5kdG8pIHtcclxuXHRcdFx0ZGF0YSA9IHt9O1xyXG5cclxuXHRcdFx0W1widXJsXCIsIFwibWltZVR5cGVcIiwgXCJoZWFkZXJzXCIsIFwia2V5c1wiLCBcImpzb25cIiwgXCJrZXlzXCIsIFwicm93c1wiLCBcImNvbHVtbnNcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGtleSA9IGBkYXRhXyR7dn1gO1xyXG5cclxuXHRcdFx0XHRcdGlmIChrZXkgaW4gYXJncykge1xyXG5cdFx0XHRcdFx0XHRkYXRhW3ZdID0gYXJnc1trZXldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGF0YSA9IGFyZ3M7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRhdGEudXJsICYmIGNhbGxiYWNrKSB7XHJcblx0XHRcdHRoaXMuY29udmVydFVybFRvRGF0YShkYXRhLnVybCwgZGF0YS5taW1lVHlwZSwgZGF0YS5oZWFkZXJzLCBkYXRhLmtleXMsIGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5qc29uKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRKc29uVG9EYXRhKGRhdGEuanNvbiwgZGF0YS5rZXlzKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5yb3dzKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRSb3dzVG9EYXRhKGRhdGEucm93cyk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Q29sdW1uc1RvRGF0YShkYXRhLmNvbHVtbnMpO1xyXG5cdFx0fSBlbHNlIGlmIChhcmdzLmJpbmR0bykge1xyXG5cdFx0XHR0aHJvdyBFcnJvcihcInVybCBvciBqc29uIG9yIHJvd3Mgb3IgY29sdW1ucyBpcyByZXF1aXJlZC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkoZGF0YSkgJiYgZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IFVSTCBkYXRhXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZW1vdGUgVVJMXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIE1JTUUgdHlwZSBzdHJpbmc6IGpzb24gfCBjc3YgfCB0c3ZcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVycyBIZWFkZXIgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGtleXMgS2V5IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGJhY2sgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRVcmxUb0RhdGEodXJsOiBzdHJpbmcsIG1pbWVUeXBlID0gXCJjc3ZcIiwgaGVhZGVyczogb2JqZWN0LCBrZXlzOiBvYmplY3QsIGRvbmU6IEZ1bmN0aW9uKTogdm9pZCB7XHJcblx0XHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRyZXEub3BlbihcIkdFVFwiLCB1cmwpO1xyXG5cclxuXHRcdGlmIChoZWFkZXJzKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRyZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcblx0XHRcdGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cdFx0XHRcdGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcclxuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcclxuXHJcblx0XHRcdFx0XHRyZXNwb25zZSAmJiBkb25lLmNhbGwodGhpcyxcclxuXHRcdFx0XHRcdFx0dGhpc1tgY29udmVydCR7Y2FwaXRhbGl6ZShtaW1lVHlwZSl9VG9EYXRhYF0oXHJcblx0XHRcdFx0XHRcdFx0bWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSxcclxuXHRcdFx0XHRcdFx0XHRrZXlzXHJcblx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dXJsfTogU29tZXRoaW5nIHdlbnQgd3JvbmcgbG9hZGluZyFgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmVxLnNlbmQoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IENTVi9UU1YgZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZXIgUGFyc2VyIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB4c3YgRGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKi9cclxuXHRjb252ZXJ0Q3N2VHN2VG9EYXRhKHBhcnNlciwgeHN2KSB7XHJcblx0XHRjb25zdCByb3dzID0gcGFyc2VyLnJvd3MoeHN2KTtcclxuXHRcdGxldCBkO1xyXG5cclxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRkID0gW3t9XTtcclxuXHJcblx0XHRcdHJvd3NbMF0uZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0ZFswXVtpZF0gPSBudWxsO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGQgPSBwYXJzZXIucGFyc2UoeHN2KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0Q3N2VG9EYXRhKHhzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzQ3N2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNDc3ZQYXJzZVxyXG5cdFx0fSwgeHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VHN2VG9EYXRhKHRzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzVHN2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNUc3ZQYXJzZVxyXG5cdFx0fSwgdHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0SnNvblRvRGF0YShqc29uLCBrZXlzUGFyYW0pIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IHN0cmluZ1tdW10gPSBbXTtcclxuXHRcdGxldCB0YXJnZXRLZXlzOiBzdHJpbmdbXTtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdGlmIChpc0FycmF5KGpzb24pKSB7XHJcblx0XHRcdGNvbnN0IGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcclxuXHJcblx0XHRcdGlmIChrZXlzLngpIHtcclxuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KTtcclxuXHRcdFx0XHRjb25maWcuZGF0YV94ID0ga2V5cy54O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdSb3dzLnB1c2godGFyZ2V0S2V5cyk7XHJcblxyXG5cdFx0XHRqc29uLmZvckVhY2gobyA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0gdGFyZ2V0S2V5cy5tYXAoa2V5ID0+IHtcclxuXHRcdFx0XHRcdC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgYmVjYXVzZSB1bmRlZmluZWQgZGF0YSB3aWxsIGJlIHJlbW92ZWQgaW4gY29udmVydERhdGFUb1RhcmdldHMoKVxyXG5cdFx0XHRcdFx0bGV0IHYgPSB0aGlzLmZpbmRWYWx1ZUluSnNvbihvLCBrZXkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2KSkge1xyXG5cdFx0XHRcdFx0XHR2ID0gbnVsbDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEobmV3Um93cyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG1wID0ganNvbltrZXldLmNvbmNhdCgpO1xyXG5cclxuXHRcdFx0XHR0bXAudW5zaGlmdChrZXkpO1xyXG5cdFx0XHRcdG5ld1Jvd3MucHVzaCh0bXApO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRDb2x1bW5zVG9EYXRhKG5ld1Jvd3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRWYWx1ZUluSnNvbihvYmplY3QsIHBhdGgpIHtcclxuXHRcdGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gb2JqZWN0W3BhdGhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcWyhcXHcrKVxcXS9nLCBcIi4kMVwiKTsgLy8gY29udmVydCBpbmRleGVzIHRvIHByb3BlcnRpZXMgKHJlcGxhY2UgW10gd2l0aCAuKVxyXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gY29udmVydGVkUGF0aC5yZXBsYWNlKC9eXFwuLywgXCJcIikuc3BsaXQoXCIuXCIpOyAvLyBzdHJpcCBhIGxlYWRpbmcgZG90XHJcblx0XHRsZXQgdGFyZ2V0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHBhdGhBcnJheS5zb21lKGsgPT4gIShcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID9cclxuXHRcdFx0XHR0YXJnZXRba10gOiB1bmRlZmluZWRcclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0Y29udmVydFJvd3NUb0RhdGEocm93cykge1xyXG5cdFx0Y29uc3Qga2V5cyA9IHJvd3NbMF07XHJcblx0XHRjb25zdCBuZXdSb3dzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdHJvd3MuZm9yRWFjaCgocm93LCBpKSA9PiB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IG5ld1JvdyA9IHt9O1xyXG5cclxuXHRcdFx0XHRyb3cuZm9yRWFjaCgodiwgaikgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU291cmNlIGRhdGEgaXMgbWlzc2luZyBhIGNvbXBvbmVudCBhdCAoJHtpfSwgJHtqfSkhYCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bmV3Um93W2tleXNbal1dID0gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBuZXdSb3dzO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRDb2x1bW5zVG9EYXRhKGNvbHVtbnMpIHtcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IGFueVtdID0gW107XHJcblxyXG5cdFx0Y29sdW1ucy5mb3JFYWNoKChjb2wsIGkpID0+IHtcclxuXHRcdFx0Y29uc3Qga2V5ID0gY29sWzBdO1xyXG5cclxuXHRcdFx0Y29sLmZvckVhY2goKHYsIGopID0+IHtcclxuXHRcdFx0XHRpZiAoaiA+IDApIHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZChuZXdSb3dzW2ogLSAxXSkpIHtcclxuXHRcdFx0XHRcdFx0bmV3Um93c1tqIC0gMV0gPSB7fTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRuZXdSb3dzW2ogLSAxXVtrZXldID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XHJcblx0fSxcclxuXHJcblx0Y29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgYXBwZW5kWHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzLCBjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0bGV0IGlzQ2F0ZWdvcml6ZWQgPSBmYWxzZTtcclxuXHRcdGxldCBpc1RpbWVTZXJpZXMgPSBmYWxzZTtcclxuXHRcdGxldCBpc0N1c3RvbVggPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoYXhpcykge1xyXG5cdFx0XHRpc0NhdGVnb3JpemVkID0gYXhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRcdGlzVGltZVNlcmllcyA9IGF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRcdGlzQ3VzdG9tWCA9IGF4aXMuaXNDdXN0b21YKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KTtcclxuXHRcdGNvbnN0IGlkcyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc05vdFgsICQkKSA6IFtdO1xyXG5cdFx0Y29uc3QgeHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNYLCAkJCkgOiBbXTtcclxuXHJcblx0XHRsZXQgeHNEYXRhO1xyXG5cclxuXHRcdC8vIHNhdmUgeCBmb3IgdXBkYXRlIGRhdGEgYnkgbG9hZCB3aGVuIGN1c3RvbSB4IGFuZCBiYi54IEFQSVxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCB4S2V5ID0gdGhpcy5nZXRYS2V5KGlkKTtcclxuXHJcblx0XHRcdGlmIChpc0N1c3RvbVggfHwgaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0Ly8gaWYgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YVxyXG5cdFx0XHRcdGlmICh4cy5pbmRleE9mKHhLZXkpID49IDApIHtcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICgoYXBwZW5kWHMgJiYgJCQuZGF0YS54c1tpZF0pIHx8IFtdKVxyXG5cdFx0XHRcdFx0XHQuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEubWFwKGQgPT4gZFt4S2V5XSlcclxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoaXNWYWx1ZSlcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHJhd1gsIGkpID0+ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSkpXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb25maWcuZGF0YV94KSB7XHJcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhIG9mIG90aGVyIGlkJ3MgeFxyXG5cdFx0XHRcdFx0eHNEYXRhID0gdGhpcy5nZXRPdGhlclRhcmdldFhzKCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChub3RFbXB0eShjb25maWcuZGF0YV94cykpIHtcclxuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGFcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICQkLmdldFhWYWx1ZXNPZlhLZXkoeEtleSwgJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gTUVNTzogaWYgbm8geCBpbmNsdWRlZCwgdXNlIHNhbWUgeCBvZiBjdXJyZW50IHdpbGwgYmUgdXNlZFxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHhzRGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiBpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eHNEYXRhICYmICh0aGlzLmRhdGEueHNbaWRdID0geHNEYXRhKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGNoZWNrIHggaXMgZGVmaW5lZFxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRpZiAoIXRoaXMuZGF0YS54c1tpZF0pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHggaXMgbm90IGRlZmluZWQgZm9yIGlkID0gXCIke2lkfVwiLmApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjb252ZXJ0IHRvIHRhcmdldFxyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IGlkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRjb25zdCBjb252ZXJ0ZWRJZCA9IGNvbmZpZy5kYXRhX2lkQ29udmVydGVyLmJpbmQoJCQuYXBpKShpZCk7XHJcblx0XHRcdGNvbnN0IHhLZXkgPSAkJC5nZXRYS2V5KGlkKTtcclxuXHRcdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzQ3VzdG9tWCAmJiBpc0NhdGVnb3JpemVkO1xyXG5cdFx0XHRjb25zdCBoYXNDYXRlZ29yeSA9IGlzQ2F0ZWdvcnkgJiYgZGF0YS5tYXAodiA9PiB2LngpXHJcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcclxuXHRcdFx0XHRpZF9vcmc6IGlkLFxyXG5cdFx0XHRcdHZhbHVlczogZGF0YS5tYXAoKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xyXG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZFtpZF07XHJcblx0XHRcdFx0XHRsZXQgeDtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgIWlzT2JqZWN0KHZhbHVlKSA/XHJcblx0XHRcdFx0XHRcdCt2YWx1ZSA6IChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHVzZSB4IGFzIGNhdGVnb3JpZXMgaWYgY3VzdG9tIHggYW5kIGNhdGVnb3JpemVkXHJcblx0XHRcdFx0XHRpZiAoKGlzQ2F0ZWdvcnkgfHwgc3RhdGUuaGFzUmFkYXIpICYmIGluZGV4ID09PSAwICYmICFpc1VuZGVmaW5lZChyYXdYKSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIWhhc0NhdGVnb3J5ICYmIGluZGV4ID09PSAwICYmIGkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHJhd1gpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHggPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLnB1c2gocmF3WCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHggPSAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIG1hcmsgYXMgeCA9IHVuZGVmaW5lZCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIGZpbHRlciB0byByZW1vdmUgYWZ0ZXIgbWFwcGVkXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8ICQkLmRhdGEueHNbaWRdLmxlbmd0aCA8PSBpKSB7XHJcblx0XHRcdFx0XHRcdHggPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHt4LCB2YWx1ZSwgaWQ6IGNvbnZlcnRlZElkfTtcclxuXHRcdFx0XHR9KS5maWx0ZXIodiA9PiBpc0RlZmluZWQodi54KSlcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGZpbmlzaCB0YXJnZXRzXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdC8vIHNvcnQgdmFsdWVzIGJ5IGl0cyB4XHJcblx0XHRcdGlmIChjb25maWcuZGF0YV94U29ydCkge1xyXG5cdFx0XHRcdHQudmFsdWVzID0gdC52YWx1ZXMuc29ydCgodjEsIHYyKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4MSA9IHYxLnggfHwgdjEueCA9PT0gMCA/IHYxLnggOiBJbmZpbml0eTtcclxuXHRcdFx0XHRcdGNvbnN0IHgyID0gdjIueCB8fCB2Mi54ID09PSAwID8gdjIueCA6IEluZmluaXR5O1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB4MSAtIHgyO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpbmRleGluZyBlYWNoIHZhbHVlXHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHYsIGkpID0+ICh2LmluZGV4ID0gaSkpO1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBuZWVkcyB0byBiZSBzb3J0ZWQgYmVjYXVzZSBpdHMgaW5kZXggYW5kIHZhbHVlLmluZGV4IGlzIGlkZW50aWNhbFxyXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdLnNvcnQoKHYxLCB2MikgPT4gdjEgLSB2Mik7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjYWNoZSBpbmZvcm1hdGlvbiBhYm91dCB2YWx1ZXNcclxuXHRcdHN0YXRlLmhhc05lZ2F0aXZlVmFsdWUgPSAkJC5oYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xyXG5cdFx0c3RhdGUuaGFzUG9zaXRpdmVWYWx1ZSA9ICQkLmhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gc2V0IHRhcmdldCB0eXBlc1xyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3R5cGUpIHtcclxuXHRcdFx0JCQuc2V0VGFyZ2V0VHlwZSgkJC5tYXBUb0lkcyh0YXJnZXRzKVxyXG5cdFx0XHRcdC5maWx0ZXIoaWQgPT4gIShpZCBpbiBjb25maWcuZGF0YV90eXBlcykpLCBjb25maWcuZGF0YV90eXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWNoZSBhcyBvcmlnaW5hbCBpZCBrZXllZFxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4gJCQuY2FjaGUuYWRkKGQuaWRfb3JnLCBkLCB0cnVlKSk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtcclxuXHRnZXRVbmlxdWUsXHJcblx0aGFzVmFsdWUsXHJcblx0aXNBcnJheSxcclxuXHRpc2Jvb2xlYW4sXHJcblx0aXNEZWZpbmVkLFxyXG5cdGlzRnVuY3Rpb24sXHJcblx0aXNOdW1iZXIsXHJcblx0aXNPYmplY3QsXHJcblx0aXNPYmplY3RUeXBlLFxyXG5cdGlzU3RyaW5nLFxyXG5cdGlzVW5kZWZpbmVkLFxyXG5cdGlzVmFsdWUsXHJcblx0bWVyZ2VBcnJheSxcclxuXHRub3RFbXB0eSxcclxuXHRwYXJzZURhdGUsXHJcblx0c29ydFZhbHVlXHJcbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aXNYKGtleSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeDtcclxuXHRcdGNvbnN0IGV4aXN0VmFsdWUgPSBub3RFbXB0eShjb25maWcuZGF0YV94cykgJiYgaGFzVmFsdWUoY29uZmlnLmRhdGFfeHMsIGtleSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFLZXkgfHwgZXhpc3RWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRpc05vdFgoa2V5KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gIXRoaXMuaXNYKGtleSk7XHJcblx0fSxcclxuXHJcblx0aXNTdGFja05vcm1hbGl6ZWQoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICEhKGNvbmZpZy5kYXRhX3N0YWNrX25vcm1hbGl6ZSAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoKTtcclxuXHR9LFxyXG5cclxuXHRpc0dyb3VwZWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX2dyb3Vwc1xyXG5cdFx0XHQubWFwKHYgPT4gdi5pbmRleE9mKGlkKSA+PSAwKVswXTtcclxuXHR9LFxyXG5cclxuXHRnZXRYS2V5KGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuZGF0YV94ID9cclxuXHRcdFx0Y29uZmlnLmRhdGFfeCA6IChub3RFbXB0eShjb25maWcuZGF0YV94cykgPyBjb25maWcuZGF0YV94c1tpZF0gOiBudWxsKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYVmFsdWVzT2ZYS2V5KGtleSwgdGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzID0gdGFyZ2V0cyAmJiBub3RFbXB0eSh0YXJnZXRzKSA/ICQkLm1hcFRvSWRzKHRhcmdldHMpIDogW107XHJcblx0XHRsZXQgeFZhbHVlcztcclxuXHJcblx0XHRpZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGlmICgkJC5nZXRYS2V5KGlkKSA9PT0ga2V5KSB7XHJcblx0XHRcdFx0eFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4geFZhbHVlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kZXggbnVtYmVyIGJhc2VkIG9uIGdpdmVuIHggQXhpcyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RGF0ZXxudW1iZXJ8c3RyaW5nfSB4IHggQXhpcyB0byBiZSBjb21wYXJlZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGJhc2VkWCB4IEF4aXMgbGlzdCB0byBiZSBiYXNlZCBvblxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kZXhCeVgoeCwgYmFzZWRYOiAoc3RyaW5nfERhdGUpW10pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBiYXNlZFggP1xyXG5cdFx0XHRiYXNlZFguaW5kZXhPZihpc1N0cmluZyh4KSA/IHggOiAreCkgOlxyXG5cdFx0XHQoJCQuZmlsdGVyQnlYKCQkLmRhdGEudGFyZ2V0cywgeClbMF0gfHwge2luZGV4OiBudWxsfSkuaW5kZXg7XHJcblx0fSxcclxuXHJcblx0Z2V0WFZhbHVlKGlkOiBzdHJpbmcsIGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGlkIGluICQkLmRhdGEueHMgJiZcclxuXHRcdFx0JCQuZGF0YS54c1tpZF0gJiZcclxuXHRcdFx0aXNWYWx1ZSgkJC5kYXRhLnhzW2lkXVtpXSkgPyAkJC5kYXRhLnhzW2lkXVtpXSA6IGk7XHJcblx0fSxcclxuXHJcblx0Z2V0T3RoZXJUYXJnZXRYcygpOiBzdHJpbmcgfCBudWxsIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlkc0ZvclggPSBPYmplY3Qua2V5cygkJC5kYXRhLnhzKTtcclxuXHJcblx0XHRyZXR1cm4gaWRzRm9yWC5sZW5ndGggPyAkJC5kYXRhLnhzW2lkc0ZvclhbMF1dIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRPdGhlclRhcmdldFgoaW5kZXg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcclxuXHJcblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGFkZFhzKHhzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNNdWx0aXBsZVgoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcclxuXHRcdFx0IXRoaXMuY29uZmlnLmRhdGFfeFNvcnQgfHxcclxuXHRcdFx0dGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8XHJcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0YWRkTmFtZShkYXRhKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IG5hbWU7XHJcblxyXG5cdFx0aWYgKGRhdGEpIHtcclxuXHRcdFx0bmFtZSA9IGNvbmZpZy5kYXRhX25hbWVzW2RhdGEuaWRdO1xyXG5cdFx0XHRkYXRhLm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogZGF0YS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYWxsIHZhbHVlcyBvbiBnaXZlbiBpbmRleFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyTnVsbCBGaWx0ZXIgbnVsbGlzaCB2YWx1ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXg6IG51bWJlciwgZmlsdGVyTnVsbCA9IGZhbHNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IHZhbHVlID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpXHJcblx0XHRcdC5tYXAodCA9PiAkJC5hZGROYW1lKCQkLmdldFZhbHVlT25JbmRleCh0LnZhbHVlcywgaW5kZXgpKSk7XHJcblxyXG5cdFx0aWYgKGZpbHRlck51bGwpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5maWx0ZXIodiA9PiBpc1ZhbHVlKHYudmFsdWUpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVPbkluZGV4KHZhbHVlcywgaW5kZXg6IG51bWJlcikge1xyXG5cdFx0Y29uc3QgdmFsdWVPbkluZGV4ID0gdmFsdWVzLmZpbHRlcih2ID0+IHYuaW5kZXggPT09IGluZGV4KTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWVPbkluZGV4Lmxlbmd0aCA/IHZhbHVlT25JbmRleFswXSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0WCh0YXJnZXRzLCB4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0di54ID0gJCQuZ2VuZXJhdGVUYXJnZXRYKHhbaV0sIHQuaWQsIGkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmRhdGEueHNbdC5pZF0gPSB4O1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0WHModGFyZ2V0cywgeHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHhzW3QuaWRdICYmICQkLnVwZGF0ZVRhcmdldFgoW3RdLCB4c1t0LmlkXSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQ6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXN9ID0gJCQ7XHJcblx0XHRsZXQgeCA9IGF4aXMgJiYgYXhpcy5pc0NhdGVnb3JpemVkKCkgPyBpbmRleCA6IChyYXdYIHx8IGluZGV4KTtcclxuXHJcblx0XHRpZiAoYXhpcyAmJiBheGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0eCA9IHJhd1ggPyBmbihyYXdYKSA6IGZuKCQkLmdldFhWYWx1ZShpZCwgaW5kZXgpKTtcclxuXHRcdH0gZWxzZSBpZiAoYXhpcyAmJiBheGlzLmlzQ3VzdG9tWCgpICYmICFheGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWHModmFsdWVzKTogdm9pZCB7XHJcblx0XHRpZiAodmFsdWVzLmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLmF4aXMueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQcmV2WChpOiBudW1iZXIpOiBudW1iZXJbXSB8IG51bGwge1xyXG5cdFx0Y29uc3QgeCA9IHRoaXMuYXhpcy54c1tpIC0gMV07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldE5leHRYKGk6IG51bWJlcik6IG51bWJlcltdIHwgbnVsbCB7XHJcblx0XHRjb25zdCB4ID0gdGhpcy5heGlzLnhzW2kgKyAxXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGJhc2UgdmFsdWUgaXNBcmVhUmFuZ2VUeXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZVZhbHVlKGRhdGEpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gJCQuc3RhdGU7XHJcblx0XHRsZXQge3ZhbHVlfSA9IGRhdGE7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSBvZiBhcmVhLXJhbmdlLCBkYXRhIGlzIGdpdmVuIGFzOiBbbG93LCBtaWQsIGhpZ2hdIG9yIHtsb3csIG1pZCwgaGlnaH1cclxuXHRcdC8vIHdpbGwgdGFrZSB0aGUgJ21pZCcgYXMgdGhlIGJhc2UgdmFsdWVcclxuXHRcdGlmICh2YWx1ZSAmJiBoYXNBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5pc0FyZWFSYW5nZVR5cGUoZGF0YSkpIHtcclxuXHRcdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVaVHlwZShkYXRhKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBtaW4vbWF4IHZhbHVlIGZyb20gdGhlIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgZGF0YSB0byBiZSBldmFsdWF0ZWRcclxuXHQgKiBAcmV0dXJucyB7e21pbjoge251bWJlcn0sIG1heDoge251bWJlcn19fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heFZhbHVlKGRhdGEpOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSB7XHJcblx0XHRjb25zdCBnZXRCYXNlVmFsdWUgPSB0aGlzLmdldEJhc2VWYWx1ZS5iaW5kKHRoaXMpO1xyXG5cdFx0bGV0IG1pbjtcclxuXHRcdGxldCBtYXg7XHJcblxyXG5cdFx0KGRhdGEgfHwgdGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxyXG5cdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdi5tYXAoZ2V0QmFzZVZhbHVlKS5maWx0ZXIoaXNOdW1iZXIpO1xyXG5cclxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihpID8gbWluIDogSW5maW5pdHksIC4uLnZhbHVlKTtcclxuXHRcdFx0XHRtYXggPSBNYXRoLm1heChpID8gbWF4IDogLUluZmluaXR5LCAuLi52YWx1ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB7bWluLCBtYXh9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluL21heCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7e21pbjogQXJyYXksIG1heDogQXJyYXl9fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heERhdGEoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5kYXRhTWluTWF4O1xyXG5cdFx0bGV0IG1pbk1heERhdGEgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghbWluTWF4RGF0YSkge1xyXG5cdFx0XHRjb25zdCBkYXRhID0gJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKTtcclxuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4VmFsdWUoZGF0YSk7XHJcblxyXG5cdFx0XHRsZXQgbWluID0gW107XHJcblx0XHRcdGxldCBtYXggPSBbXTtcclxuXHJcblx0XHRcdGRhdGEuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaW5EYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWluKTtcclxuXHRcdFx0XHRjb25zdCBtYXhEYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWF4KTtcclxuXHJcblx0XHRcdFx0aWYgKG1pbkRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtaW4gPSBtaW4uY29uY2F0KG1pbkRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG1heERhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtYXggPSBtYXguY29uY2F0KG1heERhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGNhY2hlZCBkYXRhXHJcblx0XHRcdCQkLmNhY2hlLmFkZChjYWNoZUtleSwgbWluTWF4RGF0YSA9IHttaW4sIG1heH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtaW5NYXhEYXRhO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBzdW0gb2YgZGF0YSBwZXIgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKi9cclxuXHRnZXRUb3RhbFBlckluZGV4KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuZGF0YVRvdGFsUGVySW5kZXg7XHJcblx0XHRsZXQgc3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAhc3VtKSB7XHJcblx0XHRcdHN1bSA9IFtdO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2gocm93ID0+IHtcclxuXHRcdFx0XHRyb3cudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdGlmICghc3VtW2ldKSB7XHJcblx0XHRcdFx0XHRcdHN1bVtpXSA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRvdGFsIGRhdGEgc3VtXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzdWJ0cmFjdEhpZGRlbiBTdWJ0cmFjdCBoaWRkZW4gZGF0YSBmcm9tIHRvdGFsXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvdGFsRGF0YVN1bShzdWJ0cmFjdEhpZGRlbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuZGF0YVRvdGFsU3VtO1xyXG5cdFx0bGV0IHRvdGFsID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIWlzTnVtYmVyKHRvdGFsKSkge1xyXG5cdFx0XHRjb25zdCBzdW0gPSBtZXJnZUFycmF5KCQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYudmFsdWUpXHJcblx0XHRcdFx0LnJlZHVjZSgocCwgYykgPT4gcCArIGMpO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCB0b3RhbCA9IHN1bSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN1YnRyYWN0SGlkZGVuKSB7XHJcblx0XHRcdHRvdGFsIC09ICQkLmdldEhpZGRlblRvdGFsRGF0YVN1bSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b3RhbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdG90YWwgaGlkZGVuIGRhdGEgc3VtXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEhpZGRlblRvdGFsRGF0YVN1bSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHthcGksIHN0YXRlOiB7aGlkZGVuVGFyZ2V0SWRzfX0gPSAkJDtcclxuXHRcdGxldCB0b3RhbCA9IDA7XHJcblxyXG5cdFx0aWYgKGhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0dG90YWwgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpKGhpZGRlblRhcmdldElkcylcclxuXHRcdFx0XHQucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRvdGFsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmaWx0ZXJlZCBkYXRhIGJ5IHZhbHVlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBiZSBmaWx0ZXJlZFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZmlsdGVyZWQgYXJyYXkgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RmlsdGVyZWREYXRhQnlWYWx1ZShkYXRhLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKHQgPT4gdGhpcy5nZXRCYXNlVmFsdWUodCkgPT09IHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgdGhlIGRhdGFcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggZGF0YSBsZW5ndGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldE1heERhdGFDb3VudCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLmxlbmd0aCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heERhdGFDb3VudFRhcmdldCgpIHtcclxuXHRcdGxldCB0YXJnZXQgPSB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKSB8fCBbXTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcCh0ID0+IHQudmFsdWVzKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2LngpO1xyXG5cclxuXHRcdFx0dGFyZ2V0ID0gc29ydFZhbHVlKGdldFVuaXF1ZSh0YXJnZXQpKVxyXG5cdFx0XHRcdC5tYXAoKHgsIGluZGV4KSA9PiAoe3gsIGluZGV4fSkpO1xyXG5cdFx0fSBlbHNlIGlmIChsZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0WzBdLnZhbHVlcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvSWRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0YXJnZXRzLm1hcChkID0+IGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvVGFyZ2V0SWRzKGlkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgPyAoaXNBcnJheShpZHMpID8gaWRzLmNvbmNhdCgpIDogW2lkc10pIDogJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHR9LFxyXG5cclxuXHRoYXNUYXJnZXQodGFyZ2V0cywgaWQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHZhbDsgKHZhbCA9IGlkc1tpXSk7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclRhcmdldHNUb1Nob3codGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAodGFyZ2V0cyB8fCAkJC5kYXRhLnRhcmdldHMpLmZpbHRlcih0ID0+ICQkLmlzVGFyZ2V0VG9TaG93KHQuaWQpKTtcclxuXHR9LFxyXG5cclxuXHRtYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpc30gPSAkJDtcclxuXHRcdGxldCB4czogYW55W10gPSBbXTtcclxuXHJcblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR4cyA9IGdldFVuaXF1ZShcclxuXHRcdFx0XHRtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMubWFwKHYgPT4gK3YueCkpKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0eHMgPSBheGlzICYmIGF4aXMuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUuaGlkZGVuVGFyZ2V0SWRzID0gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuY29uY2F0KHRhcmdldElkcyk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSGlkZGVuVGFyZ2V0SWRzKHRhcmdldElkcyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0YWRkSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCB5cyA9IHt9O1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0Y29uc3QgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpXHJcblx0XHRcdC5tYXAodiA9PiAoaXNTdHJpbmcodikgPyB2IDogK3YpKSA6IG51bGw7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRjb25zdCBkYXRhOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYudmFsdWU7XHJcblxyXG5cdFx0XHRcdGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLnZhbHVlKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBcImhpZ2hcIiBpbiB2YWx1ZSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlWlR5cGUodikpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaChoYXNBeGlzICYmICQkLmdldEJ1YmJsZVpEYXRhKHZhbHVlLCBcInlcIikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YVskJC5nZXRJbmRleEJ5WCh2LngsIHhzKV0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGRhdGEucHVzaCh2YWx1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHlzW3QuaWRdID0gZGF0YTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB5cztcclxuXHR9LFxyXG5cclxuXHRjaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIGNoZWNrZXI6IEZ1bmN0aW9uKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBpZHMgPSBPYmplY3Qua2V5cyh0YXJnZXRzKTtcclxuXHRcdGxldCB2YWx1ZXM7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFsdWVzID0gdGFyZ2V0c1tpZHNbaV1dLnZhbHVlcztcclxuXHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGNoZWNrZXIodmFsdWVzW2pdLnZhbHVlKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGhhc011bHRpVGFyZ2V0cygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPiAxO1xyXG5cdH0sXHJcblxyXG5cdGhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCB2ID0+IHYgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2ID4gMCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrT3JkZXIodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy5kYXRhX29yZGVyO1xyXG5cclxuXHRcdHJldHVybiBpc1N0cmluZyhvcmRlcikgJiYgb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcclxuXHR9LFxyXG5cclxuXHRpc09yZGVyRGVzYygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiZGVzY1wiKTtcclxuXHR9LFxyXG5cclxuXHRpc09yZGVyQXNjKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJhc2NcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCB0YXJnZXRzIGRhdGFcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRzVmFsdWUgVGFyZ2V0IHZhbHVlXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b3JkZXJUYXJnZXRzKHRhcmdldHNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSBbLi4udGFyZ2V0c1ZhbHVlXTtcclxuXHRcdGNvbnN0IG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpO1xyXG5cdFx0Y29uc3Qgb3JkZXJEZXNjID0gJCQuaXNPcmRlckRlc2MoKTtcclxuXHJcblx0XHRpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XHJcblx0XHRcdHRhcmdldHMuc29ydCgodDEsIHQyKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgcmVkdWNlciA9IChwLCBjKSA9PiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XHJcblx0XHRcdFx0Y29uc3QgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xyXG5cdFx0XHRcdGNvbnN0IHQyU3VtID0gdDIudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9yZGVyQXNjID8gdDJTdW0gLSB0MVN1bSA6IHQxU3VtIC0gdDJTdW07XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xyXG5cdFx0XHR0YXJnZXRzLnNvcnQoY29uZmlnLmRhdGFfb3JkZXIuYmluZCgkJC5hcGkpKTtcclxuXHRcdH0gLy8gVE9ETzogYWNjZXB0IG5hbWUgYXJyYXkgZm9yIG9yZGVyXHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0ZmlsdGVyQnlYKHRhcmdldHMsIHgpIHtcclxuXHRcdHJldHVybiBtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKS5maWx0ZXIodiA9PiB2LnggLSB4ID09PSAwKTtcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJSZW1vdmVOdWxsKGRhdGEpIHtcclxuXHRcdHJldHVybiBkYXRhLmZpbHRlcihkID0+IGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJCeVhEb21haW4odGFyZ2V0cywgeERvbWFpbikge1xyXG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKHQgPT4gKHtcclxuXHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdGlkX29yZzogdC5pZF9vcmcsXHJcblx0XHRcdHZhbHVlczogdC52YWx1ZXMuZmlsdGVyKHYgPT4geERvbWFpblswXSA8PSB2LnggJiYgdi54IDw9IHhEb21haW5bMV0pXHJcblx0XHR9KSk7XHJcblx0fSxcclxuXHJcblx0aGFzRGF0YUxhYmVsKCkge1xyXG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9IHRoaXMuY29uZmlnLmRhdGFfbGFiZWxzO1xyXG5cclxuXHRcdHJldHVybiAoaXNib29sZWFuKGRhdGFMYWJlbHMpICYmIGRhdGFMYWJlbHMpIHx8XHJcblx0XHRcdChpc09iamVjdFR5cGUoZGF0YUxhYmVscykgJiYgbm90RW1wdHkoZGF0YUxhYmVscykpO1xyXG5cdH0sXHJcblxyXG5cdGdldERhdGFMYWJlbExlbmd0aChtaW4sIG1heCwga2V5KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsZW5ndGhzID0gWzAsIDBdO1xyXG5cdFx0Y29uc3QgcGFkZGluZ0NvZWYgPSAxLjM7XHJcblxyXG5cdFx0JCQuJGVsLmNoYXJ0LnNlbGVjdChcInN2Z1wiKS5zZWxlY3RBbGwoXCIuZHVtbXlcIilcclxuXHRcdFx0LmRhdGEoW21pbiwgbWF4XSlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LnRleHQoZCA9PiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkoZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRsZW5ndGhzW2ldID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldICogcGFkZGluZ0NvZWY7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRyZXR1cm4gbGVuZ3RocztcclxuXHR9LFxyXG5cclxuXHRpc05vbmVBcmMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyYyhkKSB7XHJcblx0XHRyZXR1cm4gXCJkYXRhXCIgaW4gZCAmJiB0aGlzLmhhc1RhcmdldCh0aGlzLmRhdGEudGFyZ2V0cywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRmaW5kU2FtZVhPZlZhbHVlcyh2YWx1ZXMsIGluZGV4KSB7XHJcblx0XHRjb25zdCB0YXJnZXRYID0gdmFsdWVzW2luZGV4XS54O1xyXG5cdFx0Y29uc3Qgc2FtZXM6IGFueVtdID0gW107XHJcblx0XHRsZXQgaTtcclxuXHJcblx0XHRmb3IgKGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmICh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzYW1lcy5wdXNoKHZhbHVlc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gaW5kZXg7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2FtZXM7XHJcblx0fSxcclxuXHJcblx0ZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4gJCQuZmluZENsb3Nlc3QodGFyZ2V0LnZhbHVlcywgcG9zKSk7IC8vIG1hcCB0byBhcnJheSBvZiBjbG9zZXN0IHBvaW50cyBvZiBlYWNoIHRhcmdldFxyXG5cclxuXHRcdC8vIGRlY2lkZSBjbG9zZXN0IHBvaW50IGFuZCByZXR1cm5cclxuXHRcdHJldHVybiAkJC5maW5kQ2xvc2VzdChjYW5kaWRhdGVzLCBwb3MpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRDbG9zZXN0KHZhbHVlcywgcG9zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGEgPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdiAmJiBpc1ZhbHVlKHYudmFsdWUpKTtcclxuXHRcdGxldCBtaW5EaXN0ID0gY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5O1xyXG5cdFx0bGV0IGNsb3Nlc3Q7XHJcblxyXG5cdFx0Ly8gZmluZCBtb3VzZW92ZXJpbmcgYmFyXHJcblx0XHRkYXRhXHJcblx0XHRcdC5maWx0ZXIodiA9PiAkJC5pc0JhclR5cGUodi5pZCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh2LmlkKX0gLiR7Q0xBU1MuYmFyfS0ke3YuaW5kZXh9YCkubm9kZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWNsb3Nlc3QgJiYgJCQuaXNXaXRoaW5CYXIoc2hhcGUpKSB7XHJcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vIGZpbmQgY2xvc2VzdCBwb2ludCBmcm9tIG5vbi1iYXJcclxuXHRcdGRhdGFcclxuXHRcdFx0LmZpbHRlcih2ID0+ICEkJC5pc0JhclR5cGUodi5pZCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSAkJC5kaXN0KHYsIHBvcyk7XHJcblxyXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdCkge1xyXG5cdFx0XHRcdFx0bWluRGlzdCA9IGQ7XHJcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjbG9zZXN0O1xyXG5cdH0sXHJcblxyXG5cdGRpc3QoZGF0YSwgcG9zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YXhpc19yb3RhdGVkOiBpc1JvdGF0ZWR9LCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhJbmRleCA9IGlzUm90YXRlZCA/IDEgOiAwO1xyXG5cdFx0Y29uc3QgeUluZGV4ID0gaXNSb3RhdGVkID8gMCA6IDE7XHJcblx0XHRjb25zdCB5ID0gJCQuY2lyY2xlWShkYXRhLCBkYXRhLmluZGV4KTtcclxuXHRcdGNvbnN0IHggPSAoc2NhbGUuem9vbSB8fCBzY2FsZS54KShkYXRhLngpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIHBvc1t4SW5kZXhdLCAyKSArIE1hdGgucG93KHkgLSBwb3NbeUluZGV4XSwgMikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgZGF0YSBmb3Igc3RlcCB0eXBlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIE9iamVjdCBkYXRhIHZhbHVlc1xyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBzdGVwVHlwZSA9IGNvbmZpZy5saW5lX3N0ZXBfdHlwZTtcclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSBheGlzID8gYXhpcy5pc0NhdGVnb3JpemVkKCkgOiBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBjb252ZXJ0ZWQgPSBpc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMuY29uY2F0KCkgOiBbdmFsdWVzXTtcclxuXHJcblx0XHRpZiAoIWlzUm90YXRlZCAmJiAhaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluc2VydCAmIGFwcGVuZCBjbG9uaW5nIGZpcnN0L2xhc3QgdmFsdWUgdG8gYmUgZnVsbHkgcmVuZGVyZWQgY292ZXJpbmcgb24gZWFjaCBnYXAgc2lkZXNcclxuXHRcdGNvbnN0IGlkID0gY29udmVydGVkWzBdLmlkO1xyXG5cclxuXHRcdC8vIGluc2VydFxyXG5cdFx0bGV0IHggPSBjb252ZXJ0ZWRbMF0ueCAtIDE7XHJcblx0XHRsZXQgdmFsdWUgPSBjb252ZXJ0ZWRbMF0udmFsdWU7XHJcblxyXG5cdFx0aXNDYXRlZ29yaXplZCAmJiBjb252ZXJ0ZWQudW5zaGlmdCh7eCwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0c3RlcFR5cGUgPT09IFwic3RlcC1hZnRlclwiICYmXHJcblx0XHRcdGNvbnZlcnRlZC51bnNoaWZ0KHt4OiB4IC0gMSwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0Ly8gYXBwZW5kXHJcblx0XHR4ID0gY29udmVydGVkLmxlbmd0aCAtIDE7XHJcblx0XHR2YWx1ZSA9IGNvbnZlcnRlZFt4XS52YWx1ZTtcclxuXHJcblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC5wdXNoKHt4LCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWJlZm9yZVwiICYmXHJcblx0XHRcdGNvbnZlcnRlZC5wdXNoKHt4OiB4ICsgMSwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VmFsdWVzVG9SYW5nZSh2YWx1ZXMpIHtcclxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xyXG5cdFx0Y29uc3QgcmFuZ2VzOiB7eDogc3RyaW5nIHwgbnVtYmVyLCBpZDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyfVtdID0gW107XHJcblxyXG5cdFx0Y29udmVydGVkLmZvckVhY2gocmFuZ2UgPT4ge1xyXG5cdFx0XHRjb25zdCB7eCwgaWR9ID0gcmFuZ2U7XHJcblxyXG5cdFx0XHRyYW5nZXMucHVzaCh7XHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHRpZCxcclxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMF1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyYW5nZXMucHVzaCh7XHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHRpZCxcclxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMl1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZURhdGFBdHRyaWJ1dGVzKG5hbWUsIGF0dHJzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgY3VycmVudCA9IGNvbmZpZ1tgZGF0YV8ke25hbWV9YF07XHJcblxyXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGF0dHJzKSkge1xyXG5cdFx0XHRyZXR1cm4gY3VycmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGN1cnJlbnRbaWRdID0gYXR0cnNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0JCQucmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYVJhbmdlRGF0YShkLCB0eXBlKSB7XHJcblx0XHRjb25zdCB2YWx1ZSA9IGQudmFsdWU7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gW1wiaGlnaFwiLCBcIm1pZFwiLCBcImxvd1wiXS5pbmRleE9mKHR5cGUpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiB2YWx1ZVtpbmRleF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlW3R5cGVdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCByYXRpbyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFJhdGlvIGZvciBnaXZlbiB0eXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSB2YWx1ZSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFzUGVyY2VudCBDb252ZXJ0IHRoZSByZXR1cm4gYXMgcGVyY2VudCBvciBub3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSYXRpbyB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0UmF0aW8odHlwZSwgZCwgYXNQZXJjZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGFwaSA9ICQkLmFwaTtcclxuXHRcdGxldCByYXRpbyA9IDA7XHJcblxyXG5cdFx0aWYgKGQgJiYgYXBpLmRhdGEuc2hvd24oKS5sZW5ndGgpIHtcclxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXHJcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gZC52YWx1ZSAvICQkLmdldFRvdGFsRGF0YVN1bSh0cnVlKTtcclxuXHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcclxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcclxuXHRcdFx0XHRjb25zdCBkYXRhVmFsdWVzID0gYXBpLmRhdGEudmFsdWVzLmJpbmQoYXBpKTtcclxuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKHN0YXRlLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XHJcblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xyXG5cclxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KFN0cmluZyhNYXRoLm1heChkLnZhbHVlLCAwKSkpIC8gc3RhdGUuY3VycmVudC5kYXRhTWF4XHJcblx0XHRcdFx0KSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YUluZGV4QnlYKHRpY2tWYWx1ZXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB0aWNrVmFsdWVNYXAgPSB0aWNrVmFsdWVzLnJlZHVjZSgob3V0LCB0aWNrLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbTnVtYmVyKHRpY2sueCldID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gdGlja1ZhbHVlTWFwW051bWJlcih2YWx1ZS54KV07XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpbmRleCA9IHZhbHVlSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhbHVlLmluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtlbmRhbGx9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGxvYWQocmF3VGFyZ2V0cywgYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHRhcmdldHMgPSByYXdUYXJnZXRzO1xyXG5cclxuXHRcdGlmICh0YXJnZXRzKSB7XHJcblx0XHRcdC8vIGZpbHRlciBsb2FkaW5nIHRhcmdldHMgaWYgbmVlZGVkXHJcblx0XHRcdGlmIChhcmdzLmZpbHRlcikge1xyXG5cdFx0XHRcdHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihhcmdzLmZpbHRlcik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNldCB0eXBlIGlmIGFyZ3MudHlwZXMgfHwgYXJncy50eXBlIHNwZWNpZmllZFxyXG5cdFx0XHRpZiAoYXJncy50eXBlIHx8IGFyZ3MudHlwZXMpIHtcclxuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gKGFyZ3MudHlwZXMgJiYgYXJncy50eXBlc1t0LmlkXSkgfHwgYXJncy50eXBlO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNldFRhcmdldFR5cGUodC5pZCwgdHlwZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVwZGF0ZS9BZGQgZGF0YVxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChkLmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XHJcblx0XHRcdFx0XHRcdGQudmFsdWVzID0gdGFyZ2V0c1tpXS52YWx1ZXM7XHJcblx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBVcGRhdGUgY3VycmVudCBzdGF0ZSBjaGFydCB0eXBlIGFuZCBlbGVtZW50cyBsaXN0IGFmdGVyIHJlZHJhd1xyXG5cdFx0JCQudXBkYXRlVHlwZXNFbGVtZW50cygpO1xyXG5cclxuXHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUuY2FsbCgkJC5hcGkpO1xyXG5cdH0sXHJcblxyXG5cdGxvYWRGcm9tQXJncyhhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBsb2FkIHdoZW4gY2hhcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcclxuXHRcdGlmICghJCQuY29uZmlnKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZXNldCgpO1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBhcmdzLmRhdGEgfHwgJCQuY29udmVydERhdGEoYXJncywgZCA9PiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGQpLCBhcmdzKSk7XHJcblxyXG5cdFx0ZGF0YSAmJiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcclxuXHR9LFxyXG5cclxuXHR1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0bGV0IGRvbmUgPSBjdXN0b21Eb25lQ2I7XHJcblx0XHRsZXQgdGFyZ2V0SWRzID0gcmF3VGFyZ2V0SWRzO1xyXG5cclxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlc2V0KCk7XHJcblxyXG5cdFx0aWYgKCFkb25lKSB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XHJcblx0XHR0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGlkID0+ICQkLmhhc1RhcmdldCgkJC5kYXRhLnRhcmdldHMsIGlkKSk7XHJcblxyXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMgfHwgdGFyZ2V0SWRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRkb25lKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkKSkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpXHJcblx0XHRcdC5jYWxsKGVuZGFsbCwgZG9uZSk7XHJcblxyXG5cdFx0dGFyZ2V0SWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHQvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXHJcblx0XHRcdHN0YXRlLndpdGhvdXRGYWRlSW5baWRdID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvLyBSZW1vdmUgdGFyZ2V0J3MgZWxlbWVudHNcclxuXHRcdFx0aWYgKCRlbC5sZWdlbmQpIHtcclxuXHRcdFx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX0keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gKS5yZW1vdmUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldFxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHQgPT4gdC5pZCAhPT0gaWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGN1cnJlbnQgc3RhdGUgY2hhcnQgdHlwZSBhbmQgZWxlbWVudHMgbGlzdCBhZnRlciByZWRyYXdcclxuXHRcdCQkLnVwZGF0ZVR5cGVzRWxlbWVudHMoKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkcmFnIGFzIGQzRHJhZ30gZnJvbSBcImQzLWRyYWdcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2VtdWxhdGVFdmVudCwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1ZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBIYW5kbGUgZGF0YS5vbm92ZXIvb3V0IGNhbGxiYWNrIG9wdGlvbnNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzT3ZlciBPdmVyIG9yIG5vdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gZCBkYXRhIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0T3Zlck91dChpc092ZXI6IGJvb2xlYW4sIGQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNBcmMgPSBpc09iamVjdChkKTtcclxuXHJcblx0XHQvLyBDYWxsIGV2ZW50IGhhbmRsZXJcclxuXHRcdGlmIChpc0FyYyB8fCBkICE9PSAtMSkge1xyXG5cdFx0XHRsZXQgY2FsbGJhY2sgPSBjb25maWdbaXNPdmVyID8gXCJkYXRhX29ub3ZlclwiIDogXCJkYXRhX29ub3V0XCJdLmJpbmQoJCQuYXBpKTtcclxuXHJcblx0XHRcdGNvbmZpZy5jb2xvcl9vbm92ZXIgJiYgJCQuc2V0T3ZlckNvbG9yKGlzT3ZlciwgZCwgaXNBcmMpO1xyXG5cclxuXHRcdFx0aWYgKGlzQXJjKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soZCwgbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmFyY30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApLm5vZGUoKSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRjb25zdCBjYWxsZWUgPSAkJC5zZXRPdmVyT3V0O1xyXG5cdFx0XHRcdGxldCBsYXN0ID0gY2FsbGVlLmxhc3QgfHwgW107XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YClcclxuXHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRzaGFwZVxyXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0XHRpZiAobGFzdC5sZW5ndGggPT09IDAgfHwgbGFzdC5ldmVyeSh2ID0+IHYgIT09IHRoaXMpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZCwgdGhpcyk7XHJcblx0XHRcdFx0XHRcdFx0bGFzdC5wdXNoKHRoaXMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYgKGxhc3QubGVuZ3RoID4gMCAmJiBzaGFwZS5lbXB0eSgpKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGNvbmZpZy5kYXRhX29ub3V0LmJpbmQoJCQuYXBpKTtcclxuXHJcblx0XHRcdFx0XHRsYXN0LmZvckVhY2godiA9PiBjYWxsYmFjayhkM1NlbGVjdCh2KS5kYXR1bSgpLCB2KSk7XHJcblx0XHRcdFx0XHRsYXN0ID0gW107XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjYWxsZWUubGFzdCA9IGxhc3Q7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGlzT3Zlcikge1xyXG5cdFx0XHRcdFx0Y29uZmlnLnBvaW50X2ZvY3VzX29ubHkgP1xyXG5cdFx0XHRcdFx0XHQkJC5zaG93Q2lyY2xlRm9jdXMoJCQuZ2V0QWxsVmFsdWVzT25JbmRleChkLCB0cnVlKSkgOlxyXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCEkJC5pc011bHRpcGxlWCgpICYmIG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBmb3IgdG91Y2ggZXZlbnRcclxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsbE92ZXJPdXRGb3JUb3VjaChkKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWxsZWUgPSAkJC5jYWxsT3Zlck91dEZvclRvdWNoO1xyXG5cdFx0Y29uc3Qge2xhc3R9ID0gY2FsbGVlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChkKSAmJiBsYXN0ID8gZC5pZCAhPT0gbGFzdC5pZCA6IChkICE9PSBsYXN0KSkge1xyXG5cdFx0XHQobGFzdCB8fCBpc051bWJlcihsYXN0KSkgJiYgJCQuc2V0T3Zlck91dChmYWxzZSwgbGFzdCk7XHJcblx0XHRcdChkIHx8IGlzTnVtYmVyKGQpKSAmJiAkJC5zZXRPdmVyT3V0KHRydWUsIGQpO1xyXG5cclxuXHRcdFx0Y2FsbGVlLmxhc3QgPSBkO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBkcmFnZ2FibGUgc2VsZWN0aW9uIGZ1bmN0aW9uXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUgJiYgJCQuZHJhZyA/XHJcblx0XHRcdGQzRHJhZygpXHJcblx0XHRcdFx0Lm9uKFwiZHJhZ1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdCQkLmRyYWcoZDNNb3VzZSh0aGlzKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdCQkLmRyYWdzdGFydChkM01vdXNlKHRoaXMpKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7ICQkLmRyYWdlbmQoKTsgfSkgOiAoKSA9PiB7fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaCBhIG1vdXNlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXZlbnQgdHlwZVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiBldmVudFJlY3RcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWVcclxuXHQgKi9cclxuXHRkaXNwYXRjaEV2ZW50KHR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlciwgbW91c2UpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcclxuXHRcdGNvbnN0IHNlbGVjdG9yID0gYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLiRlbC5tYWluLnNlbGVjdChzZWxlY3Rvcikubm9kZSgpO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBsZWZ0LCB0b3B9ID0gZXZlbnRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFx0Y29uc3QgeCA9IGxlZnQgKyAobW91c2UgPyBtb3VzZVswXSA6IDApICsgKFxyXG5cdFx0XHRpc011bHRpcGxlWCB8fCAkJC5jb25maWcuYXhpc19yb3RhdGVkID8gMCA6ICh3aWR0aCAvIDIpXHJcblx0XHQpO1xyXG5cdFx0Y29uc3QgeSA9IHRvcCArIChtb3VzZSA/IG1vdXNlWzFdIDogMCk7XHJcblx0XHRjb25zdCBwYXJhbXMgPSB7XHJcblx0XHRcdHNjcmVlblg6IHgsXHJcblx0XHRcdHNjcmVlblk6IHksXHJcblx0XHRcdGNsaWVudFg6IHgsXHJcblx0XHRcdGNsaWVudFk6IHlcclxuXHRcdH07XHJcblxyXG5cdFx0ZW11bGF0ZUV2ZW50Wy9eKG1vdXNlfGNsaWNrKS8udGVzdCh0eXBlKSA/IFwibW91c2VcIiA6IFwidG91Y2hcIl0oZXZlbnRSZWN0LCB0eXBlLCBwYXJhbXMpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2VuZXJhdGVDbGFzcyhwcmVmaXg6IHN0cmluZywgdGFyZ2V0SWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYCAke3ByZWZpeH0gJHtwcmVmaXggKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKX1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzVGV4dChkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0cyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dHMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzU2hhcGUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlLCBkLmluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1NoYXBlcyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGVzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNsYXNzZXMgPSAkJC5jb25maWcubGluZV9jbGFzc2VzIHx8IFtdO1xyXG5cdFx0Y29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdGNvbnN0IGlkOiBzdHJpbmcgPSBkLmlkIHx8IChkLmRhdGEgJiYgZC5kYXRhLmlkKSB8fCBkO1xyXG5cclxuXHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcclxuXHRcdFx0XHRpZHMucHVzaChpZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjbGFzc2VzW2lkcy5pbmRleE9mKGlkKSAlIGNsYXNzZXMubGVuZ3RoXTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Y2xhc3NMaW5lKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmVzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGluZXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2lyY2xlKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5jaXJjbGUsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2lyY2xlcyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQmFyKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5iYXIsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQmFycyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhcnMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJjKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyYywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyY3MoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyY3MsIGQuZGF0YS5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NBcmVhKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmVhLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyZWFzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzUmVnaW9uKGQsIGk6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYCR7dGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnJlZ2lvbiwgaSl9ICR7XCJjbGFzc1wiIGluIGQgPyBkLmNsYXNzIDogXCJcIn1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzRXZlbnQoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5ldmVudFJlY3QsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzVGFyZ2V0KGlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgYWRkaXRpb25hbENsYXNzU3VmZml4ID0gdGhpcy5jb25maWcuZGF0YV9jbGFzc2VzW2lkXTtcclxuXHRcdGxldCBhZGRpdGlvbmFsQ2xhc3MgPSBcIlwiO1xyXG5cclxuXHRcdGlmIChhZGRpdGlvbmFsQ2xhc3NTdWZmaXgpIHtcclxuXHRcdFx0YWRkaXRpb25hbENsYXNzID0gYCAke0NMQVNTLnRhcmdldH0tJHthZGRpdGlvbmFsQ2xhc3NTdWZmaXh9YDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRhcmdldCwgaWQpICsgYWRkaXRpb25hbENsYXNzO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzRm9jdXMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc0ZvY3VzZWQoZCkgKyB0aGlzLmNsYXNzRGVmb2N1c2VkKGQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzRm9jdXNlZChkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgICR7dGhpcy5zdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmZvY3VzZWQgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NEZWZvY3VzZWQoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYCAke3RoaXMuc3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmRlZm9jdXNlZCA6IFwiXCJ9YDtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0VGV4dChkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydFRleHQgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRMaW5lKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydEJhcihkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydEJhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydEFyYyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydEFyYyArIHRoaXMuY2xhc3NUYXJnZXQoZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0UmFkYXIoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRSYWRhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQ/OiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRhcmdldElkIHx8IHRhcmdldElkID09PSAwID9cclxuXHRcdFx0YC0ke3RhcmdldElkfWAucmVwbGFjZSgvW1xccz8hQCMkJV4mKigpXz0rLC48PidcIjo7XFxbXFxdXFwvfH5ge31cXFxcXS9nLCBcIi1cIikgOiBcIlwiO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yVGFyZ2V0KGlkOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBwZnggPSBwcmVmaXggfHwgXCJcIjtcclxuXHRcdGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpO1xyXG5cclxuXHRcdC8vIHNlbGVjdCB0YXJnZXQgJiBjaXJjbGVcclxuXHRcdHJldHVybiBgJHtwZnh9LiR7Q0xBU1MudGFyZ2V0ICsgdGFyZ2V0fSwgJHtwZnh9LiR7Q0xBU1MuY2lyY2xlcyArIHRhcmdldH1gO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yVGFyZ2V0cyhpZHNWYWx1ZSwgcHJlZml4OiBzdHJpbmcpOiBzdHJpbmdbXSB8IG51bGwge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzID0gaWRzVmFsdWUgfHwgW107XHJcblxyXG5cdFx0cmV0dXJuIGlkcy5sZW5ndGggP1xyXG5cdFx0XHRpZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkLCBwcmVmaXgpKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JMZWdlbmQoaWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYC4ke0NMQVNTLmxlZ2VuZEl0ZW0gKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yTGVnZW5kcyhpZHMpOiBzdHJpbmdbXSB8IG51bGwge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgJiYgaWRzLmxlbmd0aCA/XHJcblx0XHRcdGlkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JMZWdlbmQoaWQpKSA6IG51bGw7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ2F0ZWdvcnkgTmFtZVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4IG51bWJlclxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IGNhdGVnb3J5IE5hbWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNhdGVnb3J5TmFtZShpOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3Qge2F4aXNfeF9jYXRlZ29yaWVzOiBjYXRlZ29yaWVzfSA9IHRoaXMuY29uZmlnO1xyXG5cclxuXHRcdHJldHVybiBpIDwgY2F0ZWdvcmllcy5sZW5ndGggPyBjYXRlZ29yaWVzW2ldIDogaTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7c2NhbGVPcmRpbmFsIGFzIGQzU2NhbGVPcmRpbmFsfSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge25vdEVtcHR5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmd9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFNldCBwYXR0ZXJuJ3MgYmFja2dyb3VuZCBjb2xvclxyXG4gKiAoaXQgYWRkcyBhIDxyZWN0PiBlbGVtZW50IHRvIHNpbXVsYXRlIGJnLWNvbG9yKVxyXG4gKiBAcGFyYW0ge1NWR1BhdHRlcm5FbGVtZW50fSBwYXR0ZXJuIFNWRyBwYXR0ZXJuIGVsZW1lbnRcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIENvbG9yIHN0cmluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgdG8gYmUgc2V0XHJcbiAqIEByZXR1cm5zIHt7aWQ6IHN0cmluZywgbm9kZTogU1ZHUGF0dGVybkVsZW1lbnR9fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY29sb3JpemVQYXR0ZXJuID0gKHBhdHRlcm4sIGNvbG9yLCBpZDogc3RyaW5nKSA9PiB7XHJcblx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHBhdHRlcm4uY2xvbmVOb2RlKHRydWUpKTtcclxuXHJcblx0bm9kZVxyXG5cdFx0LmF0dHIoXCJpZFwiLCBpZClcclxuXHRcdC5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpXHJcblx0XHQuYXR0cihcIndpZHRoXCIsIG5vZGUuYXR0cihcIndpZHRoXCIpKVxyXG5cdFx0LmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5hdHRyKFwiaGVpZ2h0XCIpKVxyXG5cdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRpZCxcclxuXHRcdG5vZGU6IG5vZGUubm9kZSgpXHJcblx0fTtcclxufTtcclxuXHJcbi8vIFJlcGxhY2VtZW50IG9mIGQzLnNjaGVtZUNhdGVnb3J5MTAuXHJcbi8vIENvbnRhaW5lZCBkaWZmZXJlbnRseSBkZXBlbmQgb24gZDMgdmVyc2lvbjogdjQoZDMtc2NhbGUpLCB2NShkMy1zY2FsZS1jaHJvbWF0aWMpXHJcbmNvbnN0IHNjaGVtZUNhdGVnb3J5MTAgPSBbXCIjMWY3N2I0XCIsIFwiI2ZmN2YwZVwiLCBcIiMyY2EwMmNcIiwgXCIjZDYyNzI4XCIsIFwiIzk0NjdiZFwiLCBcIiM4YzU2NGJcIiwgXCIjZTM3N2MyXCIsIFwiIzdmN2Y3ZlwiLCBcIiNiY2JkMjJcIiwgXCIjMTdiZWNmXCJdO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBjb2xvciBwYXR0ZXJuIGZyb20gQ1NTIGZpbGVcclxuXHQgKiBDU1Mgc2hvdWxkIGJlIGRlZmluZWQgYXM6IGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiMwMGM3M2M7I2ZhNzE3MTsgLi4uXCIpO1xyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldENvbG9yRnJvbUNzcygpOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5jb2xvclBhdHRlcm47XHJcblx0XHRjb25zdCB7Ym9keX0gPSBkb2N1bWVudDtcclxuXHRcdGxldCBwYXR0ZXJuID0gYm9keVtjYWNoZUtleV07XHJcblxyXG5cdFx0aWYgKCFwYXR0ZXJuKSB7XHJcblx0XHRcdGNvbnN0IGRlbGltaXRlciA9IFwiO1wiO1xyXG5cdFx0XHRjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcblxyXG5cdFx0XHRzcGFuLmNsYXNzTmFtZSA9IENMQVNTLmNvbG9yUGF0dGVybjtcclxuXHRcdFx0c3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XHJcblxyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuYmFja2dyb3VuZEltYWdlO1xyXG5cclxuXHRcdFx0c3Bhbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNwYW4pO1xyXG5cclxuXHRcdFx0aWYgKGNvbnRlbnQuaW5kZXhPZihkZWxpbWl0ZXIpID4gLTEpIHtcclxuXHRcdFx0XHRwYXR0ZXJuID0gY29udGVudFxyXG5cdFx0XHRcdFx0LnJlcGxhY2UoL3VybFteI10qfFtcIicoKV18KFxcc3wlMjApL2csIFwiXCIpXHJcblx0XHRcdFx0XHQuc3BsaXQoZGVsaW1pdGVyKVxyXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IHYudHJpbSgpLnJlcGxhY2UoL1tcXFwiJ1xcc10vZywgXCJcIikpXHJcblx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuXHRcdFx0XHRib2R5W2NhY2hlS2V5XSA9IHBhdHRlcm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGF0dGVybjtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUNvbG9yKCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjb2xvcnMgPSBjb25maWcuZGF0YV9jb2xvcnM7XHJcblx0XHRjb25zdCBjYWxsYmFjayA9IGNvbmZpZy5kYXRhX2NvbG9yO1xyXG5cdFx0Y29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdGxldCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLmNvbG9yX3BhdHRlcm4pID8gY29uZmlnLmNvbG9yX3BhdHRlcm4gOlxyXG5cdFx0XHRkM1NjYWxlT3JkaW5hbCgkJC5nZXRDb2xvckZyb21Dc3MoKSB8fCBzY2hlbWVDYXRlZ29yeTEwKS5yYW5nZSgpO1xyXG5cclxuXHRcdGNvbnN0IG9yaWdpbmFsQ29sb3JQYXR0ZXJuID0gcGF0dGVybjtcclxuXHJcblx0XHRpZiAoaXNGdW5jdGlvbihjb25maWcuY29sb3JfdGlsZXMpKSB7XHJcblx0XHRcdGNvbnN0IHRpbGVzID0gY29uZmlnLmNvbG9yX3RpbGVzLmJpbmQoJCQuYXBpKSgpO1xyXG5cclxuXHRcdFx0Ly8gQWRkIGJhY2tncm91bmQgY29sb3IgdG8gcGF0dGVybnNcclxuXHRcdFx0Y29uc3QgY29sb3JpemVkUGF0dGVybnMgPSBwYXR0ZXJuLm1hcCgocCwgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9IHAucmVwbGFjZSgvWyNcXChcXClcXHMsXS9nLCBcIlwiKTtcclxuXHRcdFx0XHRjb25zdCBpZCA9IGAkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LXBhdHRlcm4tJHtjb2xvcn0tJHtpbmRleH1gO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29sb3JpemVQYXR0ZXJuKHRpbGVzW2luZGV4ICUgdGlsZXMubGVuZ3RoXSwgcCwgaWQpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBhdHRlcm4gPSBjb2xvcml6ZWRQYXR0ZXJucy5tYXAocCA9PiBgdXJsKCMke3AuaWR9KWApO1xyXG5cdFx0XHQkJC5wYXR0ZXJucyA9IGNvbG9yaXplZFBhdHRlcm5zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdGNvbnN0IGlkOiBzdHJpbmcgPSBkLmlkIHx8IChkLmRhdGEgJiYgZC5kYXRhLmlkKSB8fCBkO1xyXG5cdFx0XHRjb25zdCBpc0xpbmUgPSAkJC5pc1R5cGVPZihpZCwgW1wibGluZVwiLCBcInNwbGluZVwiLCBcInN0ZXBcIl0pIHx8ICFjb25maWcuZGF0YV90eXBlc1tpZF07XHJcblx0XHRcdGxldCBjb2xvcjtcclxuXHJcblx0XHRcdC8vIGlmIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkXHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGNvbG9yc1tpZF0pKSB7XHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaWRdLmJpbmQoJCQuYXBpKShkKTtcclxuXHJcblx0XHRcdC8vIGlmIHNwZWNpZmllZCwgY2hvb3NlIHRoYXQgY29sb3JcclxuXHRcdFx0fSBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaWRdO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChpZHMuaW5kZXhPZihpZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvciA9IGlzTGluZSA/IG9yaWdpbmFsQ29sb3JQYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIG9yaWdpbmFsQ29sb3JQYXR0ZXJuLmxlbmd0aF0gOlxyXG5cdFx0XHRcdFx0cGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XHJcblxyXG5cdFx0XHRcdGNvbG9yc1tpZF0gPSBjb2xvcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oY2FsbGJhY2spID9cclxuXHRcdFx0XHRjYWxsYmFjay5iaW5kKCQkLmFwaSkoY29sb3IsIGQpIDogY29sb3I7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlTGV2ZWxDb2xvcigpOiBGdW5jdGlvbiB8IG51bGwge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5jb2xvcl9wYXR0ZXJuO1xyXG5cdFx0Y29uc3QgdGhyZXNob2xkID0gY29uZmlnLmNvbG9yX3RocmVzaG9sZDtcclxuXHRcdGNvbnN0IGFzVmFsdWUgPSB0aHJlc2hvbGQudW5pdCA9PT0gXCJ2YWx1ZVwiO1xyXG5cdFx0Y29uc3QgbWF4ID0gdGhyZXNob2xkLm1heCB8fCAxMDA7XHJcblx0XHRjb25zdCB2YWx1ZXMgPSB0aHJlc2hvbGQudmFsdWVzICYmXHJcblx0XHRcdHRocmVzaG9sZC52YWx1ZXMubGVuZ3RoID8gdGhyZXNob2xkLnZhbHVlcyA6IFtdO1xyXG5cclxuXHRcdHJldHVybiBub3RFbXB0eSh0aHJlc2hvbGQpID8gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0Y29uc3QgdiA9IGFzVmFsdWUgPyB2YWx1ZSA6ICh2YWx1ZSAqIDEwMCAvIG1heCk7XHJcblx0XHRcdGxldCBjb2xvciA9IGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gMV07XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodiA8PSB2YWx1ZXNbaV0pIHtcclxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzW2ldO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY29sb3I7XHJcblx0XHR9IDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIGRhdGEgb3ZlciBjb2xvci5cclxuXHQgKiBXaGVuIGlzIG91dCwgd2lsbCByZXN0YXRlIGluIGl0cyBwcmV2aW91cyBjb2xvciB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPdmVyIHRydWU6IHNldCBvdmVyZWQgY29sb3IsIGZhbHNlOiByZXN0b3JlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldE92ZXJDb2xvcihpc092ZXI6IGJvb2xlYW4sIGQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgb25vdmVyID0gY29uZmlnLmNvbG9yX29ub3ZlcjtcclxuXHRcdGxldCBjb2xvciA9IGlzT3ZlciA/IG9ub3ZlciA6ICQkLmNvbG9yO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb2xvcikpIHtcclxuXHRcdFx0Y29sb3IgPSAoe2lkfSkgPT4gKGlkIGluIG9ub3ZlciA/IG9ub3ZlcltpZF0gOiAkJC5jb2xvcihpZCkpO1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhjb2xvcikpIHtcclxuXHRcdFx0Y29sb3IgPSAoKSA9PiBvbm92ZXI7XHJcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24ob25vdmVyKSkge1xyXG5cdFx0XHRjb2xvciA9IGNvbG9yLmJpbmQoJCQuYXBpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB3aGVuIGlzIEFyYyB0eXBlXHJcblx0XHRpZiAoaXNPYmplY3QoZCkpIHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcihkKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7ZH1gKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQ2hhcnQgdHlwZSBjb25zdGFudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRZUEUgPSB7XHJcblx0QVJFQTogXCJhcmVhXCIsXHJcblx0QVJFQV9MSU5FX1JBTkdFOiBcImFyZWEtbGluZS1yYW5nZVwiLFxyXG5cdEFSRUFfU1BMSU5FOiBcImFyZWEtc3BsaW5lXCIsXHJcblx0QVJFQV9TUExJTkVfUkFOR0U6IFwiYXJlYS1zcGxpbmUtcmFuZ2VcIixcclxuXHRBUkVBX1NURVA6IFwiYXJlYS1zdGVwXCIsXHJcblx0QkFSOiBcImJhclwiLFxyXG5cdEJVQkJMRTogXCJidWJibGVcIixcclxuXHRET05VVDogXCJkb251dFwiLFxyXG5cdEdBVUdFOiBcImdhdWdlXCIsXHJcblx0TElORTogXCJsaW5lXCIsXHJcblx0UElFOiBcInBpZVwiLFxyXG5cdFJBREFSOiBcInJhZGFyXCIsXHJcblx0U0NBVFRFUjogXCJzY2F0dGVyXCIsXHJcblx0U1BMSU5FOiBcInNwbGluZVwiLFxyXG5cdFNURVA6IFwic3RlcFwiXHJcbn07XHJcblxyXG4vKipcclxuICogY2hhcnQgdHlwZXMgYnkgY2F0ZWdvcnlcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBUWVBFX0JZX0NBVEVHT1JZID0ge1xyXG5cdEFyZWE6IFtcclxuXHRcdFRZUEUuQVJFQSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkUsXHJcblx0XHRUWVBFLkFSRUFfU1BMSU5FX1JBTkdFLFxyXG5cdFx0VFlQRS5BUkVBX0xJTkVfUkFOR0UsXHJcblx0XHRUWVBFLkFSRUFfU1RFUFxyXG5cdF0sXHJcblx0QXJlYVJhbmdlOiBbXHJcblx0XHRUWVBFLkFSRUFfU1BMSU5FX1JBTkdFLFxyXG5cdFx0VFlQRS5BUkVBX0xJTkVfUkFOR0VcclxuXHRdLFxyXG5cdEFyYzogW1xyXG5cdFx0VFlQRS5QSUUsXHJcblx0XHRUWVBFLkRPTlVULFxyXG5cdFx0VFlQRS5HQVVHRSxcclxuXHRcdFRZUEUuUkFEQVJcclxuXHRdLFxyXG5cdExpbmU6IFtcclxuXHRcdFRZUEUuTElORSxcclxuXHRcdFRZUEUuU1BMSU5FLFxyXG5cdFx0VFlQRS5BUkVBLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0UsXHJcblx0XHRUWVBFLkFSRUFfTElORV9SQU5HRSxcclxuXHRcdFRZUEUuU1RFUCxcclxuXHRcdFRZUEUuQVJFQV9TVEVQXHJcblx0XSxcclxuXHRTdGVwOiBbXHJcblx0XHRUWVBFLlNURVAsXHJcblx0XHRUWVBFLkFSRUFfU1RFUFxyXG5cdF0sXHJcblx0U3BsaW5lOiBbXHJcblx0XHRUWVBFLlNQTElORSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkUsXHJcblx0XHRUWVBFLkFSRUFfU1BMSU5FX1JBTkdFXHJcblx0XVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7VFlQRSwgVFlQRV9CWV9DQVRFR09SWX0gZnJvbSBcIi4uLy4uL2NvbmZpZy9jb25zdFwiO1xyXG5pbXBvcnQge2JydXNoRW1wdHksIGdldEJydXNoU2VsZWN0aW9uLCBnZXRNaW5NYXgsIGlzRGVmaW5lZCwgbm90RW1wdHksIGlzVmFsdWUsIGlzT2JqZWN0LCBpc051bWJlciwgZGlmZkRvbWFpbiwgcGFyc2VEYXRlLCBzb3J0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZTogXCJtaW5cIiB8IFwibWF4XCIpOiBudW1iZXIgfCBEYXRlIHwgdW5kZWZpbmVkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzLCBjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc01pbiA9IHR5cGUgPT09IFwibWluXCI7XHJcblxyXG5cdFx0Y29uc3QgZGF0YUdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHRcdGNvbnN0IGlkcyA9ICQkLm1hcFRvSWRzKHRhcmdldHMpO1xyXG5cdFx0Y29uc3QgeXMgPSAkJC5nZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cyk7XHJcblxyXG5cdFx0aWYgKGRhdGFHcm91cHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRjb25zdCBoYXNWYWx1ZSA9ICQkW2BoYXMke2lzTWluID8gXCJOZWdhdGl2ZVwiIDogXCJQb3NpdGl2ZVwifVZhbHVlSW5UYXJnZXRzYF0odGFyZ2V0cyk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqID0gMCwgaWRzSW5Hcm91cDsgKGlkc0luR3JvdXAgPSBkYXRhR3JvdXBzW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGJhc2VJZFxyXG5cdFx0XHRcdGlkc0luR3JvdXAgPSBpZHNJbkdyb3VwLmZpbHRlcih2ID0+IGlkcy5pbmRleE9mKHYpID49IDApO1xyXG5cclxuXHRcdFx0XHRpZiAoaWRzSW5Hcm91cC5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgYmFzZUlkID0gaWRzSW5Hcm91cFswXTtcclxuXHRcdFx0XHRjb25zdCBiYXNlQXhpc0lkID0gYXhpcy5nZXRJZChiYXNlSWQpO1xyXG5cclxuXHRcdFx0XHQvLyBJbml0aWFsaXplIGJhc2UgdmFsdWUuIFNldCB0byAwIGlmIG5vdCBtYXRjaCB3aXRoIHRoZSBjb25kaXRpb25cclxuXHRcdFx0XHRpZiAoaGFzVmFsdWUgJiYgeXNbYmFzZUlkXSkge1xyXG5cdFx0XHRcdFx0eXNbYmFzZUlkXSA9IHlzW2Jhc2VJZF0ubWFwKHYgPT4gKFxyXG5cdFx0XHRcdFx0XHQoaXNNaW4gPyB2IDwgMCA6IHYgPiAwKSA/IHYgOiAwXHJcblx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGsgPSAxLCBpZDsgKGlkID0gaWRzSW5Hcm91cFtrXSk7IGsrKykge1xyXG5cdFx0XHRcdFx0aWYgKCF5c1tpZF0pIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYXhpc0lkID0gYXhpcy5nZXRJZChpZCk7XHJcblxyXG5cdFx0XHRcdFx0eXNbaWRdLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgdmFsID0gK3Y7XHJcblx0XHRcdFx0XHRcdGNvbnN0IG1lZXRDb25kaXRpb24gPSBpc01pbiA/IHZhbCA+IDAgOiB2YWwgPCAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGF4aXNJZCA9PT0gYmFzZUF4aXNJZCAmJiAhKGhhc1ZhbHVlICYmIG1lZXRDb25kaXRpb24pKSB7XHJcblx0XHRcdFx0XHRcdFx0eXNbYmFzZUlkXVtpXSArPSB2YWw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRNaW5NYXgodHlwZSwgT2JqZWN0LmtleXMoeXMpLm1hcChrZXkgPT4gZ2V0TWluTWF4KHR5cGUsIHlzW2tleV0pKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0WURvbWFpbk1pbih0YXJnZXRzKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtaW5cIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WURvbWFpbk1heCh0YXJnZXRzKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgaGlkZGVuIHRhcmdldHMgYm91bmQgdG8gdGhlIGdpdmVuIGF4aXMgaWRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgdG8gYmUgY2hlY2tlZFxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aXNIaWRkZW5UYXJnZXRXaXRoWURvbWFpbihpZCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5zdGF0ZS5oaWRkZW5UYXJnZXRJZHNcclxuXHRcdFx0LnNvbWUodiA9PiAkJC5heGlzLmdldElkKHYpID09PSBpZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WURvbWFpbih0YXJnZXRzLCBheGlzSWQ6IHN0cmluZywgeERvbWFpbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBwZnggPSBgYXhpc18ke2F4aXNJZH1gO1xyXG5cclxuXHRcdGlmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpKSB7XHJcblx0XHRcdHJldHVybiBbMCwgMTAwXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YXJnZXRzQnlBeGlzSWQgPSB0YXJnZXRzLmZpbHRlcih0ID0+IGF4aXMuZ2V0SWQodC5pZCkgPT09IGF4aXNJZCk7XHJcblx0XHRjb25zdCB5VGFyZ2V0cyA9IHhEb21haW4gPyAkJC5maWx0ZXJCeVhEb21haW4odGFyZ2V0c0J5QXhpc0lkLCB4RG9tYWluKSA6IHRhcmdldHNCeUF4aXNJZDtcclxuXHJcblx0XHRpZiAoeVRhcmdldHMubGVuZ3RoID09PSAwKSB7IC8vIHVzZSBkb21haW4gb2YgdGhlIG90aGVyIGF4aXMgaWYgdGFyZ2V0IG9mIGF4aXNJZCBpcyBub25lXHJcblx0XHRcdGlmICgkJC5pc0hpZGRlblRhcmdldFdpdGhZRG9tYWluKGF4aXNJZCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gc2NhbGVbYXhpc0lkXS5kb21haW4oKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gYXhpc0lkID09PSBcInkyXCIgP1xyXG5cdFx0XHRcdFx0c2NhbGUueS5kb21haW4oKSA6XHJcblx0XHRcdFx0XHQvLyBXaGVuIGFsbCBkYXRhIGJvdW5kcyB0byB5MiwgeSBBeGlzIGRvbWFpbiBpcyBjYWxsZWQgcHJpb3IgeTIuXHJcblx0XHRcdFx0XHQvLyBTbywgaXQgbmVlZHMgdG8gY2FsbCB0byBnZXQgeTIgZG9tYWluIGhlcmVcclxuXHRcdFx0XHRcdCQkLmdldFlEb21haW4odGFyZ2V0cywgXCJ5MlwiLCB4RG9tYWluKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHlNaW4gPSBjb25maWdbYCR7cGZ4fV9taW5gXTtcclxuXHRcdGNvbnN0IHlNYXggPSBjb25maWdbYCR7cGZ4fV9tYXhgXTtcclxuXHRcdGxldCB5RG9tYWluTWluID0gJCQuZ2V0WURvbWFpbk1pbih5VGFyZ2V0cyk7XHJcblx0XHRsZXQgeURvbWFpbk1heCA9ICQkLmdldFlEb21haW5NYXgoeVRhcmdldHMpO1xyXG5cclxuXHRcdGNvbnN0IGNlbnRlciA9IGNvbmZpZ1tgJHtwZnh9X2NlbnRlcmBdO1xyXG5cdFx0bGV0IGlzWmVyb0Jhc2VkID0gW1RZUEUuQkFSLCBUWVBFLkJVQkJMRSwgVFlQRS5TQ0FUVEVSLCAuLi5UWVBFX0JZX0NBVEVHT1JZLkxpbmVdXHJcblx0XHRcdC5zb21lKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHR5cGUgPSB2LmluZGV4T2YoXCJhcmVhXCIpID4gLTEgPyBcImFyZWFcIiA6IHY7XHJcblxyXG5cdFx0XHRcdHJldHVybiAkJC5oYXNUeXBlKHYsIHlUYXJnZXRzKSAmJiBjb25maWdbYCR7dHlwZX1femVyb2Jhc2VkYF07XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IGlzSW52ZXJ0ZWQgPSBjb25maWdbYCR7cGZ4fV9pbnZlcnRlZGBdO1xyXG5cdFx0Y29uc3Qgc2hvd0hvcml6b250YWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgc2hvd1ZlcnRpY2FsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Ly8gTUVNTzogYXZvaWQgaW52ZXJ0aW5nIGRvbWFpbiB1bmV4cGVjdGVkbHlcclxuXHRcdHlEb21haW5NaW4gPSBpc1ZhbHVlKHlNaW4pID8geU1pbiA6XHJcblx0XHRcdChpc1ZhbHVlKHlNYXgpID8gKHlEb21haW5NaW4gPCB5TWF4ID8geURvbWFpbk1pbiA6IHlNYXggLSAxMCkgOiB5RG9tYWluTWluKTtcclxuXHRcdHlEb21haW5NYXggPSBpc1ZhbHVlKHlNYXgpID8geU1heCA6XHJcblx0XHRcdChpc1ZhbHVlKHlNaW4pID8gKHlNaW4gPCB5RG9tYWluTWF4ID8geURvbWFpbk1heCA6IHlNaW4gKyAxMCkgOiB5RG9tYWluTWF4KTtcclxuXHJcblx0XHRpZiAoaXNOYU4oeURvbWFpbk1pbikpIHsgLy8gc2V0IG1pbmltdW0gdG8gemVybyB3aGVuIG5vdCBudW1iZXJcclxuXHRcdFx0eURvbWFpbk1pbiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTmFOKHlEb21haW5NYXgpKSB7IC8vIHNldCBtYXhpbXVtIHRvIGhhdmUgc2FtZSB2YWx1ZSBhcyB5RG9tYWluTWluXHJcblx0XHRcdHlEb21haW5NYXggPSB5RG9tYWluTWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh5RG9tYWluTWluID09PSB5RG9tYWluTWF4KSB7XHJcblx0XHRcdHlEb21haW5NaW4gPCAwID8geURvbWFpbk1heCA9IDAgOiB5RG9tYWluTWluID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc0FsbFBvc2l0aXZlID0geURvbWFpbk1pbiA+PSAwICYmIHlEb21haW5NYXggPj0gMDtcclxuXHRcdGNvbnN0IGlzQWxsTmVnYXRpdmUgPSB5RG9tYWluTWluIDw9IDAgJiYgeURvbWFpbk1heCA8PSAwO1xyXG5cclxuXHRcdC8vIENhbmNlbCB6ZXJvYmFzZWQgaWYgYXhpc18qX21pbiAvIGF4aXNfKl9tYXggc3BlY2lmaWVkXHJcblx0XHRpZiAoKGlzVmFsdWUoeU1pbikgJiYgaXNBbGxQb3NpdGl2ZSkgfHwgKGlzVmFsdWUoeU1heCkgJiYgaXNBbGxOZWdhdGl2ZSkpIHtcclxuXHRcdFx0aXNaZXJvQmFzZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcclxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xyXG5cdFx0XHRpc0FsbFBvc2l0aXZlICYmICh5RG9tYWluTWluID0gMCk7XHJcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHlEb21haW5NYXggPSAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkb21haW5MZW5ndGggPSBNYXRoLmFicyh5RG9tYWluTWF4IC0geURvbWFpbk1pbik7XHJcblx0XHRjb25zdCBwYWRkaW5nID0ge3RvcDogZG9tYWluTGVuZ3RoICogMC4xLCBib3R0b206IGRvbWFpbkxlbmd0aCAqIDAuMX07XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjZW50ZXIpKSB7XHJcblx0XHRcdGNvbnN0IHlEb21haW5BYnMgPSBNYXRoLm1heChNYXRoLmFicyh5RG9tYWluTWluKSwgTWF0aC5hYnMoeURvbWFpbk1heCkpO1xyXG5cclxuXHRcdFx0eURvbWFpbk1heCA9IGNlbnRlciArIHlEb21haW5BYnM7XHJcblx0XHRcdHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFkZCBwYWRkaW5nIGZvciBkYXRhIGxhYmVsXHJcblx0XHRpZiAoc2hvd0hvcml6b250YWxEYXRhTGFiZWwpIHtcclxuXHRcdFx0Y29uc3QgZGlmZiA9IGRpZmZEb21haW4oc2NhbGUueS5yYW5nZSgpKTtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJ3aWR0aFwiKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2IC8gZGlmZik7XHJcblxyXG5cdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdHBhZGRpbmdbdl0gKz0gZG9tYWluTGVuZ3RoICogKHJhdGlvW2ldIC8gKDEgLSByYXRpb1swXSAtIHJhdGlvWzFdKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChzaG93VmVydGljYWxEYXRhTGFiZWwpIHtcclxuXHRcdFx0Y29uc3QgbGVuZ3RocyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcImhlaWdodFwiKTtcclxuXHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSArPSBheGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKGxlbmd0aHNbaV0sIGRvbWFpbkxlbmd0aCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIHBhZGRpbmcgaXMgc2V0LCB0aGUgZG9tYWluIHdpbGwgYmUgdXBkYXRlZCByZWxhdGl2ZSB0aGUgY3VycmVudCBkb21haW4gdmFsdWVcclxuXHRcdC8vIGV4KSAkJC5oZWlnaHQ9MzAwLCBwYWRkaW5nLnRvcD0xNTAsIGRvbWFpbkxlbmd0aD00ICAtLT4gZG9tYWluPTZcclxuXHRcdGNvbnN0IHAgPSBjb25maWdbYCR7cGZ4fV9wYWRkaW5nYF07XHJcblxyXG5cdFx0aWYgKG5vdEVtcHR5KHApKSB7XHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdHBhZGRpbmdbdl0gPSBheGlzLmdldFBhZGRpbmcocCwgdiwgcGFkZGluZ1t2XSwgZG9tYWluTGVuZ3RoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmFyL0FyZWEgY2hhcnQgc2hvdWxkIGJlIDAtYmFzZWQgaWYgYWxsIHBvc2l0aXZlfG5lZ2F0aXZlXHJcblx0XHRpZiAoaXNaZXJvQmFzZWQpIHtcclxuXHRcdFx0aXNBbGxQb3NpdGl2ZSAmJiAocGFkZGluZy5ib3R0b20gPSB5RG9tYWluTWluKTtcclxuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAocGFkZGluZy50b3AgPSAteURvbWFpbk1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZG9tYWluID0gW3lEb21haW5NaW4gLSBwYWRkaW5nLmJvdHRvbSwgeURvbWFpbk1heCArIHBhZGRpbmcudG9wXTtcclxuXHJcblx0XHRyZXR1cm4gaXNJbnZlcnRlZCA/IGRvbWFpbi5yZXZlcnNlKCkgOiBkb21haW47XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjb25maWdWYWx1ZSA9ICQkLmNvbmZpZ1tgYXhpc194XyR7dHlwZX1gXTtcclxuXHRcdGNvbnN0IGRhdGFWYWx1ZSA9IGdldE1pbk1heCh0eXBlLCB0YXJnZXRzLm1hcCh0ID0+IGdldE1pbk1heCh0eXBlLCB0LnZhbHVlcy5tYXAodiA9PiB2LngpKSkpO1xyXG5cdFx0bGV0IHZhbHVlID0gaXNPYmplY3QoY29uZmlnVmFsdWUpID8gY29uZmlnVmFsdWUudmFsdWUgOiBjb25maWdWYWx1ZTtcclxuXHJcblx0XHR2YWx1ZSA9IGlzRGVmaW5lZCh2YWx1ZSkgJiYgJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSA/IHBhcnNlRGF0ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoY29uZmlnVmFsdWUpICYmIGNvbmZpZ1ZhbHVlLmZpdCAmJiAoXHJcblx0XHRcdCh0eXBlID09PSBcIm1pblwiICYmIHZhbHVlIDwgZGF0YVZhbHVlKSB8fCAodHlwZSA9PT0gXCJtYXhcIiAmJiB2YWx1ZSA+IGRhdGFWYWx1ZSlcclxuXHRcdCkpIHtcclxuXHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IGRhdGFWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluTWluKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtaW5cIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbk1heCh0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWF4XCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5QYWRkaW5nKGRvbWFpbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRpZmYgPSBkb21haW5bMV0gLSBkb21haW5bMF07XHJcblx0XHRjb25zdCB4UGFkZGluZyA9IGNvbmZpZy5heGlzX3hfcGFkZGluZztcclxuXHRcdGxldCBtYXhEYXRhQ291bnQ7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoYXhpcy5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0cGFkZGluZyA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJiYXJcIikpIHtcclxuXHRcdFx0bWF4RGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XHJcblx0XHRcdHBhZGRpbmcgPSBtYXhEYXRhQ291bnQgPiAxID8gKGRpZmYgLyAobWF4RGF0YUNvdW50IC0gMSkpIC8gMiA6IDAuNTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBkaWZmICogMC4wMTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbGVmdCA9IHBhZGRpbmc7XHJcblx0XHRsZXQgcmlnaHQgPSBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc09iamVjdCh4UGFkZGluZykgJiYgbm90RW1wdHkoeFBhZGRpbmcpKSB7XHJcblx0XHRcdGxlZnQgPSBpc1ZhbHVlKHhQYWRkaW5nLmxlZnQpID8geFBhZGRpbmcubGVmdCA6IHBhZGRpbmc7XHJcblx0XHRcdHJpZ2h0ID0gaXNWYWx1ZSh4UGFkZGluZy5yaWdodCkgPyB4UGFkZGluZy5yaWdodCA6IHBhZGRpbmc7XHJcblx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGNvbmZpZy5heGlzX3hfcGFkZGluZykpIHtcclxuXHRcdFx0bGVmdCA9IHhQYWRkaW5nO1xyXG5cdFx0XHRyaWdodCA9IHhQYWRkaW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7bGVmdCwgcmlnaHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW4odGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmF4aXMuaXNDYXRlZ29yaXplZCgpO1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuYXhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHRcdGNvbnN0IHhEb21haW4gPSBbJCQuZ2V0WERvbWFpbk1pbih0YXJnZXRzKSwgJCQuZ2V0WERvbWFpbk1heCh0YXJnZXRzKV07XHJcblx0XHRjb25zdCBwYWRkaW5nID0gJCQuZ2V0WERvbWFpblBhZGRpbmcoeERvbWFpbik7XHJcblx0XHRsZXQgW2ZpcnN0WCwgbGFzdFhdID0geERvbWFpbjtcclxuXHRcdGxldCBtaW46IERhdGUgfCBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IG1heDogRGF0ZSB8IG51bWJlciA9IDA7XHJcblxyXG5cdFx0Ly8gc2hvdyBjZW50ZXIgb2YgeCBkb21haW4gaWYgbWluIGFuZCBtYXggYXJlIHRoZSBzYW1lXHJcblx0XHRpZiAoKGZpcnN0WCAtIGxhc3RYKSA9PT0gMCAmJiAhaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRpZiAoaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0Zmlyc3RYID0gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAqIDAuNSk7XHJcblx0XHRcdFx0bGFzdFggPSBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKiAxLjUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZpcnN0WCA9IGZpcnN0WCA9PT0gMCA/IDEgOiAoZmlyc3RYICogMC41KTtcclxuXHRcdFx0XHRsYXN0WCA9IGxhc3RYID09PSAwID8gLTEgOiAobGFzdFggKiAxLjUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZpcnN0WCB8fCBmaXJzdFggPT09IDApIHtcclxuXHRcdFx0bWluID0gaXNUaW1lU2VyaWVzID8gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAtIHBhZGRpbmcubGVmdCkgOiBmaXJzdFggLSBwYWRkaW5nLmxlZnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhc3RYIHx8IGxhc3RYID09PSAwKSB7XHJcblx0XHRcdG1heCA9IGlzVGltZVNlcmllcyA/IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSArIHBhZGRpbmcucmlnaHQpIDogbGFzdFggKyBwYWRkaW5nLnJpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBbbWluLCBtYXhdO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVhEb21haW4odGFyZ2V0cywgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbSwgZG9tYWluKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmcsIHNjYWxlOiB7eCwgc3ViWH19ID0gJCQ7XHJcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XHJcblxyXG5cdFx0aWYgKHdpdGhVcGRhdGVPcmdYRG9tYWluKSB7XHJcblx0XHRcdHguZG9tYWluKGRvbWFpbiB8fCBzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbih0YXJnZXRzKSkpO1xyXG5cdFx0XHRvcmcueERvbWFpbiA9IHguZG9tYWluKCk7XHJcblxyXG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XHJcblxyXG5cdFx0XHRzdWJYLmRvbWFpbih4LmRvbWFpbigpKTtcclxuXHRcdFx0JCQuYnJ1c2ggJiYgJCQuYnJ1c2guc2NhbGUoc3ViWCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdpdGhVcGRhdGVYRG9tYWluKSB7XHJcblx0XHRcdGNvbnN0IGRvbWFpblZhbHVlID0gZG9tYWluIHx8ICghJCQuYnJ1c2ggfHwgYnJ1c2hFbXB0eSgkJCkpID9cclxuXHRcdFx0XHRvcmcueERvbWFpbiA6IGdldEJydXNoU2VsZWN0aW9uKCQkKS5tYXAoc3ViWC5pbnZlcnQpO1xyXG5cclxuXHRcdFx0eC5kb21haW4oZG9tYWluVmFsdWUpO1xyXG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVHJpbSBkb21haW4gd2hlbiB0b28gYmlnIGJ5IHpvb20gbW91c2Vtb3ZlIGV2ZW50XHJcblx0XHR3aXRoVHJpbSAmJiB4LmRvbWFpbigkJC50cmltWERvbWFpbih4Lm9yZ0RvbWFpbigpKSk7XHJcblxyXG5cdFx0cmV0dXJuIHguZG9tYWluKCk7XHJcblx0fSxcclxuXHJcblx0dHJpbVhEb21haW4oZG9tYWluKSB7XHJcblx0XHRjb25zdCB6b29tRG9tYWluID0gdGhpcy5nZXRab29tRG9tYWluKCk7XHJcblx0XHRjb25zdCBbbWluLCBtYXhdID0gem9vbURvbWFpbjtcclxuXHJcblx0XHRpZiAoZG9tYWluWzBdIDw9IG1pbikge1xyXG5cdFx0XHRkb21haW5bMV0gPSArZG9tYWluWzFdICsgKG1pbiAtIGRvbWFpblswXSk7XHJcblx0XHRcdGRvbWFpblswXSA9IG1pbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4IDw9IGRvbWFpblsxXSkge1xyXG5cdFx0XHRkb21haW5bMF0gPSArZG9tYWluWzBdIC0gKGRvbWFpblsxXSAtIG1heCk7XHJcblx0XHRcdGRvbWFpblsxXSA9IG1heDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZG9tYWluO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1ZhbHVlLCBpc0Z1bmN0aW9uLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge0F4aXNUeXBlfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZm9ybWF0dGVkXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSAkJCBDb250ZXh0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlVmFsdWUgQXhpcyB0eXBlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFZhbHVlIHRvIGJlIGZvcm1hdHRlZFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgc3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Rm9ybWF0KCQkLCB0eXBlVmFsdWU6IEF4aXNUeXBlLCB2OiBudW1iZXIpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0Y29uc3QgdHlwZSA9IGBheGlzXyR7dHlwZVZhbHVlfV90aWNrX2Zvcm1hdGA7XHJcblx0Y29uc3QgZm9ybWF0ID0gY29uZmlnW3R5cGVdID9cclxuXHRcdGNvbmZpZ1t0eXBlXSA6ICQkLmRlZmF1bHRWYWx1ZUZvcm1hdDtcclxuXHJcblx0cmV0dXJuIGZvcm1hdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFlGb3JtYXQoZm9yQXJjOiBib29sZWFuKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHt5Rm9ybWF0LCB5MkZvcm1hdH0gPSAkJDtcclxuXHJcblx0XHRpZiAoZm9yQXJjICYmICEkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcclxuXHRcdFx0eUZvcm1hdCA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcclxuXHRcdFx0eTJGb3JtYXQgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHYsIHJhdGlvLCBpZCkge1xyXG5cdFx0XHRjb25zdCBmb3JtYXQgPSAkJC5heGlzICYmICQkLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgP1xyXG5cdFx0XHRcdHkyRm9ybWF0IDogeUZvcm1hdDtcclxuXHJcblx0XHRcdHJldHVybiBmb3JtYXQuY2FsbCgkJCwgdiwgcmF0aW8pO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHR5Rm9ybWF0KHY6IG51bWJlcik6IG51bWJlciB8IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieVwiLCB2KTtcclxuXHR9LFxyXG5cclxuXHR5MkZvcm1hdCh2OiBudW1iZXIpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGdldEZvcm1hdCh0aGlzLCBcInkyXCIsIHYpO1xyXG5cdH0sXHJcblxyXG5cdGRlZmF1bHRWYWx1ZUZvcm1hdCh2KTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRcdHJldHVybiBpc1ZhbHVlKHYpID8gK3YgOiBcIlwiO1xyXG5cdH0sXHJcblxyXG5cdGRlZmF1bHRBcmNWYWx1ZUZvcm1hdCh2LCByYXRpbyk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gYCR7KHJhdGlvICogMTAwKS50b0ZpeGVkKDEpfSVgO1xyXG5cdH0sXHJcblxyXG5cdGRhdGFMYWJlbEZvcm1hdCh0YXJnZXRJZDogc3RyaW5nKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVscztcclxuXHRcdGNvbnN0IGRlZmF1bHRGb3JtYXQgPSB2ID0+IChpc1ZhbHVlKHYpID8gK3YgOiBcIlwiKTtcclxuXHRcdGxldCBmb3JtYXQgPSBkZWZhdWx0Rm9ybWF0O1xyXG5cclxuXHRcdC8vIGZpbmQgZm9ybWF0IGFjY29yZGluZyB0byBheGlzIGlkXHJcblx0XHRpZiAoaXNGdW5jdGlvbihkYXRhTGFiZWxzLmZvcm1hdCkpIHtcclxuXHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXQ7XHJcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzLmZvcm1hdCkpIHtcclxuXHRcdFx0aWYgKGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSkge1xyXG5cdFx0XHRcdGZvcm1hdCA9IGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0XHRkZWZhdWx0Rm9ybWF0IDogZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvcm1hdCA9ICgpID0+IFwiXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm9ybWF0LmJpbmQoJCQuYXBpKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudCxcclxuXHRuYW1lc3BhY2VzIGFzIGQzTmFtZXNwYWNlc1xyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGlzRGVmaW5lZCwgZ2V0T3B0aW9uLCBpc0VtcHR5LCBpc0Z1bmN0aW9uLCBub3RFbXB0eSwgdHBsUHJvY2Vzc30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgbGVnZW5kLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdExlZ2VuZCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHQkJC5sZWdlbmRJdGVtVGV4dEJveCA9IHt9O1xyXG5cdFx0JCQuc3RhdGUubGVnZW5kSGFzUmVuZGVyZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93KSB7XHJcblx0XHRcdGlmICghY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8pIHtcclxuXHRcdFx0XHQkZWwubGVnZW5kID0gJCQuJGVsLnN2Zy5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYWxsIGhlcmUgdG8gdXBkYXRlIGxlZ2VuZCBib3ggYW5kIHRyYW5zbGF0ZSBmb3IgYWxsXHJcblx0XHRcdC8vIE1FTU86IHRyYW5zbGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYnkgdGhpcywgc28gdHJhbnNmb3JtIG5vdCBuZWVkZWQgaW4gdXBkYXRlTGVnZW5kKClcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdHJhbnNpdGlvbnMgUmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmQodGFyZ2V0SWRzLCBvcHRpb25zLCB0cmFuc2l0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsIHNjYWxlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBvcHRpb256ID0gb3B0aW9ucyB8fCB7XHJcblx0XHRcdHdpdGhUcmFuc2Zvcm06IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRvcHRpb256LndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnosIFwid2l0aFRyYW5zaXRpb25cIiwgdHJ1ZSk7XHJcblx0XHRvcHRpb256LndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnosIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvICYmIGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGUpIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kVGVtcGxhdGUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZEVsZW1lbnQoXHJcblx0XHRcdFx0dGFyZ2V0SWRzIHx8ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksXHJcblx0XHRcdFx0b3B0aW9ueixcclxuXHRcdFx0XHR0cmFuc2l0aW9uc1xyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvZ2dsZSBsZWdlbmQgc3RhdGVcclxuXHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4sIGlkID0+ICEkJC5pc1RhcmdldFRvU2hvdyhpZCkpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBzaXplIGFuZCBzY2FsZVxyXG5cdFx0JCQudXBkYXRlU2NhbGVzKGZhbHNlLCAhc2NhbGUuem9vbSk7XHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXHJcblx0XHQkJC50cmFuc2Zvcm1BbGwob3B0aW9uei53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xyXG5cclxuXHRcdHN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIHVzaW5nIHRlbXBsYXRlIG9wdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kVGVtcGxhdGUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB3cmFwcGVyID0gZDNTZWxlY3QoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8pO1xyXG5cdFx0Y29uc3QgdGVtcGxhdGUgPSBjb25maWcubGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlO1xyXG5cclxuXHRcdGlmICghd3JhcHBlci5lbXB0eSgpKSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldHMgPSAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xyXG5cdFx0XHRjb25zdCBpZHM6IGFueVtdID0gW107XHJcblx0XHRcdGxldCBodG1sID0gXCJcIjtcclxuXHJcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gaXNGdW5jdGlvbih0ZW1wbGF0ZSkgP1xyXG5cdFx0XHRcdFx0dGVtcGxhdGUuYmluZCgkJC5hcGkpKHYsICQkLmNvbG9yKHYpLCAkJC5hcGkuZGF0YSh2KVswXS52YWx1ZXMpIDpcclxuXHRcdFx0XHRcdHRwbFByb2Nlc3ModGVtcGxhdGUsIHtcclxuXHRcdFx0XHRcdFx0Q09MT1I6ICQkLmNvbG9yKHYpLFxyXG5cdFx0XHRcdFx0XHRUSVRMRTogdlxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZW50KSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaCh2KTtcclxuXHRcdFx0XHRcdGh0bWwgKz0gY29udGVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVnZW5kSXRlbSA9IHdyYXBwZXIuaHRtbChodG1sKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXM7IH0pXHJcblx0XHRcdFx0LmRhdGEoaWRzKTtcclxuXHJcblx0XHRcdCQkLnNldExlZ2VuZEl0ZW0obGVnZW5kSXRlbSk7XHJcblxyXG5cdFx0XHQkZWwubGVnZW5kID0gd3JhcHBlcjtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIHNpemUgb2YgdGhlIGxlZ2VuZC5cclxuXHQgKiBAcGFyYW0ge09iZWpjdH0gc2l6ZSBTaXplIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlU2l6ZUZvckxlZ2VuZChzaXplKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge1xyXG5cdFx0XHRpc0xlZ2VuZFRvcCwgaXNMZWdlbmRMZWZ0LCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0LCBjdXJyZW50XHJcblx0XHR9fSA9ICQkO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcclxuXHJcblx0XHRjb25zdCBpbnNldExlZ2VuZFBvc2l0aW9uID0ge1xyXG5cdFx0XHR0b3A6IGlzTGVnZW5kVG9wID9cclxuXHRcdFx0XHQkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpICsgY29uZmlnLmxlZ2VuZF9pbnNldF95ICsgNS41IDpcclxuXHRcdFx0XHRjdXJyZW50LmhlaWdodCAtIGhlaWdodCAtICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkgLSBjb25maWcubGVnZW5kX2luc2V0X3ksXHJcblx0XHRcdGxlZnQ6IGlzTGVnZW5kTGVmdCA/XHJcblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkgKyBjb25maWcubGVnZW5kX2luc2V0X3ggKyAwLjUgOlxyXG5cdFx0XHRcdGN1cnJlbnQud2lkdGggLSB3aWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSAtIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNVxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC5zdGF0ZS5tYXJnaW4zID0ge1xyXG5cdFx0XHR0b3A6IGlzTGVnZW5kUmlnaHQgP1xyXG5cdFx0XHRcdDAgOiBpc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi50b3AgOiBjdXJyZW50LmhlaWdodCAtIGhlaWdodCxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRsZWZ0OiBpc0xlZ2VuZFJpZ2h0ID9cclxuXHRcdFx0XHRjdXJyZW50LndpZHRoIC0gd2lkdGggOiBpc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi5sZWZ0IDogMFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gTGVnZW5kXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB3aXRoVHJhbnNpdGlvbiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dHJhbnNmb3JtTGVnZW5kKHdpdGhUcmFuc2l0aW9uKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bGVnZW5kfSA9ICQkLiRlbDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBsZWdlbmQudHJhbnNpdGlvbigpIDogbGVnZW5kKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgbGVnZW5kIHN0ZXBcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBTdGVwIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRTdGVwKHN0ZXA6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5sZWdlbmRTdGVwID0gc3RlcDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gd2lkdGhcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCh3aWR0aDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZEl0ZW1XaWR0aCA9IHdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSBoZWlnaHRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbUhlaWdodChoZWlnaHQpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUubGVnZW5kSXRlbUhlaWdodCA9IGhlaWdodDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gY29sb3JcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29ycmVzcG9uZGluZyBkYXRhIElEIHZhbHVlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRJdGVtQ29sb3IoaWQ6IHN0cmluZywgY29sb3I6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy4kZWwubGVnZW5kLnNlbGVjdChgLiR7Q0xBU1MubGVnZW5kSXRlbX0tJHtpZH0gbGluZWApXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBjb2xvcik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgbGVnZW5kXHJcblx0ICogQHJldHVybnMge251bWJlcn0gd2lkdGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y3VycmVudDoge3dpZHRofSwgaXNMZWdlbmRSaWdodCwgaXNMZWdlbmRJbnNldCwgbGVnZW5kSXRlbVdpZHRoLCBsZWdlbmRTdGVwfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAoXHJcblx0XHRcdGlzTGVnZW5kUmlnaHQgfHwgaXNMZWdlbmRJbnNldCA/XHJcblx0XHRcdFx0bGVnZW5kSXRlbVdpZHRoICogKGxlZ2VuZFN0ZXAgKyAxKSA6IHdpZHRoXHJcblx0XHQpIDogMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kXHJcblx0ICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRMZWdlbmRIZWlnaHQoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjdXJyZW50LCBpc0xlZ2VuZFJpZ2h0LCBsZWdlbmRJdGVtSGVpZ2h0LCBsZWdlbmRTdGVwfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAoXHJcblx0XHRcdGlzTGVnZW5kUmlnaHQgP1xyXG5cdFx0XHRcdGN1cnJlbnQuaGVpZ2h0IDogTWF0aC5tYXgoMjAsIGxlZ2VuZEl0ZW1IZWlnaHQpICogKGxlZ2VuZFN0ZXAgKyAxKVxyXG5cdFx0KSA6IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gbGVnZW5kSXRlbSBMZWdlbmQgaXRlbSBub2RlXHJcblx0ICogQHJldHVybnMge3N0cmluZ3xudWxsfSBvcGFjaXR5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvcGFjaXR5Rm9yTGVnZW5kKGxlZ2VuZEl0ZW0pOiBzdHJpbmcgfCBudWxsIHtcclxuXHRcdHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIxXCI7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsZWdlbmQgdGhhdCBpcyB1bmZvY3VzZWRcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gbGVnZW5kSXRlbSBMZWdlbmQgaXRlbSBub2RlXHJcblx0ICogQHJldHVybnMge3N0cmluZ3xudWxsfSBvcGFjaXR5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kKGxlZ2VuZEl0ZW0pOiBzdHJpbmcgfCBudWxsIHtcclxuXHRcdHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIwLjNcIjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBmb2N1cyBvZiB0aGUgbGVnZW5kXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBmb2N1cyB3aGV0aGVyIG9yIG5vdCB0byBmb2N1cy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkczogc3RyaW5nW10sIGZvY3VzOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bGVnZW5kfSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IHRhcmdldElkeiA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0bGVnZW5kICYmIGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmZpbHRlcihpZCA9PiB0YXJnZXRJZHouaW5kZXhPZihpZCkgPj0gMClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZvY3VzKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIChmb2N1cyA/ICQkLm9wYWNpdHlGb3JMZWdlbmQgOiAkJC5vcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kKVxyXG5cdFx0XHRcdFx0LmNhbGwoJCQsIGQzU2VsZWN0KHRoaXMpKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV2ZXJ0IHRoZSBsZWdlbmQgdG8gaXRzIGRlZmF1bHQgc3RhdGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJldmVydExlZ2VuZCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cclxuXHRcdGxlZ2VuZCAmJiBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAkJC5vcGFjaXR5Rm9yTGVnZW5kKGQzU2VsZWN0KHRoaXMpKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvd3MgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd0xlZ2VuZCh0YXJnZXRJZHM6IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0Y29uZmlnLmxlZ2VuZF9zaG93ID0gdHJ1ZTtcclxuXHJcblx0XHRcdCRlbC5sZWdlbmQgP1xyXG5cdFx0XHRcdCRlbC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKSA6XHJcblx0XHRcdFx0JCQuaW5pdExlZ2VuZCgpO1xyXG5cclxuXHRcdFx0ISQkLnN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkICYmICQkLnVwZGF0ZUxlZ2VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlbW92ZUhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIHRoZSBsZWdlbmRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhpZGVMZWdlbmQodGFyZ2V0SWRzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bGVnZW5kfX0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93ICYmIGlzRW1wdHkodGFyZ2V0SWRzKSkge1xyXG5cdFx0XHRjb25maWcubGVnZW5kX3Nob3cgPSBmYWxzZTtcclxuXHRcdFx0bGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5hZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcclxuXHRcdGxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGxlZ2VuZCBpdGVtIHRleHRib3ggZGltZW5zaW9uXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIERhdGEgSURcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gdGV4dEVsZW1lbnQgVGV4dCBub2RlIGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBCb3VuZGluZyByZWN0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRMZWdlbmRJdGVtVGV4dEJveChpZD86IHN0cmluZywgdGV4dEVsZW1lbnQ/KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y2FjaGV9ID0gJCQ7XHJcblx0XHRsZXQgZGF0YTtcclxuXHJcblx0XHQvLyBkbyBub3QgcHJlZml4IHcvJyQnLCB0byBub3QgYmUgcmVzZXR0ZWQgY2FjaGUgaW4gLmxvYWQoKSBjYWxsXHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5sZWdlbmRJdGVtVGV4dEJveDtcclxuXHJcblx0XHRpZiAoaWQpIHtcclxuXHRcdFx0ZGF0YSA9IGNhY2hlLmdldChjYWNoZUtleSkgfHwge307XHJcblxyXG5cdFx0XHRpZiAoIWRhdGFbaWRdKSB7XHJcblx0XHRcdFx0ZGF0YVtpZF0gPSAkJC5nZXRUZXh0UmVjdCh0ZXh0RWxlbWVudCwgQ0xBU1MubGVnZW5kSXRlbSk7XHJcblx0XHRcdFx0Y2FjaGUuYWRkKGNhY2hlS2V5LCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGF0YSA9IGRhdGFbaWRdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsZWdlbmQgaXRlbSBzdHlsZSAmIGJpbmQgZXZlbnRzXHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGl0ZW0gSXRlbSBub2RlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRMZWdlbmRJdGVtKGl0ZW0pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHthcGksIGNvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1RvdWNoID0gc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCI7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHJcblx0XHRpdGVtXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRjb25zdCBub2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgaXRlbUNsYXNzID0gKCFub2RlLmVtcHR5KCkgJiYgbm9kZS5hdHRyKFwiY2xhc3NcIikpIHx8IFwiXCI7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpdGVtQ2xhc3MgKyAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLmxlZ2VuZEl0ZW0sIGlkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBpZCA9PiAoJCQuaXNMZWdlbmRUb1Nob3coaWQpID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxyXG5cdFx0XHQub24oXCJjbGlja1wiLCBpZCA9PiB7XHJcblx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29uY2xpY2ssIGFwaSwgaWQpKSB7XHJcblx0XHRcdFx0XHRpZiAoZDNFdmVudC5hbHRLZXkpIHtcclxuXHRcdFx0XHRcdFx0YXBpLmhpZGUoKTtcclxuXHRcdFx0XHRcdFx0YXBpLnNob3coaWQpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0YXBpLnRvZ2dsZShpZCk7XHJcblx0XHRcdFx0XHRcdCFpc1RvdWNoICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSA/IGFwaS5mb2N1cyhpZCkgOiBhcGkucmV2ZXJ0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpc1RvdWNoICYmICQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdGlmICghaXNUb3VjaCkge1xyXG5cdFx0XHRpdGVtXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdGlmICghY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm91dCwgYXBpLCBpZCkpIHtcclxuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQudW5kb01hcmtPdmVybGFwcGVkKCQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0JCQuYXBpLnJldmVydCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGlkKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25vdmVyLCBhcGksIGlkKSkge1xyXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChoYXNHYXVnZSkge1xyXG5cdFx0XHRcdFx0XHRcdCQkLm1hcmtPdmVybGFwcGVkKGlkLCAkJCwgYC4ke0NMQVNTLmdhdWdlVmFsdWV9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICghc3RhdGUudHJhbnNpdGluZyAmJiAkJC5pc1RhcmdldFRvU2hvdyhpZCkpIHtcclxuXHRcdFx0XHRcdFx0XHRhcGkuZm9jdXMoaWQpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBsZWdlbmRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB3aXRoVHJhbnNmb3JtIDogV2hldGhlciB0byB1c2UgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBXaGV0aGVyIHRyYW5zaXRpb24gaXMgdXNlZCB3aGVuIHVzaW5nIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbiA6IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkczogc3RyaW5nW10sIG9wdGlvbnMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgcGFkZGluZ1RvcCA9IDQ7XHJcblx0XHRjb25zdCBwYWRkaW5nUmlnaHQgPSAxMDtcclxuXHRcdGNvbnN0IHBvc01pbiA9IDEwO1xyXG5cdFx0Y29uc3QgdGlsZVdpZHRoID0gY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfd2lkdGggKyA1O1xyXG5cdFx0bGV0IG1heFdpZHRoID0gMDtcclxuXHRcdGxldCBtYXhIZWlnaHQgPSAwO1xyXG5cdFx0bGV0IHhGb3JMZWdlbmQ7XHJcblx0XHRsZXQgeUZvckxlZ2VuZDtcclxuXHRcdGxldCB0b3RhbExlbmd0aCA9IDA7XHJcblx0XHRjb25zdCBvZmZzZXRzID0ge307XHJcblx0XHRjb25zdCB3aWR0aHMgPSB7fTtcclxuXHRcdGNvbnN0IGhlaWdodHMgPSB7fTtcclxuXHRcdGNvbnN0IG1hcmdpbnMgPSBbMF07XHJcblx0XHRjb25zdCBzdGVwcyA9IHt9O1xyXG5cdFx0bGV0IHN0ZXAgPSAwO1xyXG5cdFx0bGV0IGJhY2tncm91bmQ7XHJcblx0XHRjb25zdCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA9IHN0YXRlLmlzTGVnZW5kUmlnaHQgfHwgc3RhdGUuaXNMZWdlbmRJbnNldDtcclxuXHJcblx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxyXG5cdFx0Y29uc3QgdGFyZ2V0SWR6ID0gdGFyZ2V0SWRzXHJcblx0XHRcdC5maWx0ZXIoaWQgPT4gIWlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pIHx8IGNvbmZpZy5kYXRhX25hbWVzW2lkXSAhPT0gbnVsbCk7XHJcblxyXG5cdFx0Y29uc3Qgd2l0aFRyYW5zaXRpb24gPSBvcHRpb25zLndpdGhUcmFuc2l0aW9uO1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHRleHRFbGVtZW50LCBpZCwgaW5kZXgpIHtcclxuXHRcdFx0Y29uc3QgcmVzZXQgPSBpbmRleCA9PT0gMDtcclxuXHRcdFx0Y29uc3QgaXNMYXN0ID0gaW5kZXggPT09IHRhcmdldElkei5sZW5ndGggLSAxO1xyXG5cdFx0XHRjb25zdCBib3ggPSAkJC5nZXRMZWdlbmRJdGVtVGV4dEJveChpZCwgdGV4dEVsZW1lbnQpO1xyXG5cdFx0XHRjb25zdCBpdGVtV2lkdGggPSBib3gud2lkdGggKyB0aWxlV2lkdGggK1xyXG5cdFx0XHRcdChpc0xhc3QgJiYgIWlzTGVnZW5kUmlnaHRPckluc2V0ID8gMCA6IHBhZGRpbmdSaWdodCkgKyBjb25maWcubGVnZW5kX3BhZGRpbmc7XHJcblx0XHRcdGNvbnN0IGl0ZW1IZWlnaHQgPSBib3guaGVpZ2h0ICsgcGFkZGluZ1RvcDtcclxuXHRcdFx0Y29uc3QgaXRlbUxlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gaXRlbUhlaWdodCA6IGl0ZW1XaWR0aDtcclxuXHRcdFx0Y29uc3QgYXJlYUxlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgOiAkJC5nZXRMZWdlbmRXaWR0aCgpO1xyXG5cdFx0XHRsZXQgbWFyZ2luO1xyXG5cclxuXHRcdFx0Ly8gTUVNTzogY2FyZSBhYm91dCBjb25kaWZpb24gb2Ygc3RlcCwgdG90YWxMZW5ndGhcclxuXHRcdFx0Y29uc3QgdXBkYXRlVmFsdWVzID0gZnVuY3Rpb24oaWQyLCB3aXRob3V0U3RlcD86IGJvb2xlYW4pIHtcclxuXHRcdFx0XHRpZiAoIXdpdGhvdXRTdGVwKSB7XHJcblx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIHRvdGFsTGVuZ3RoIC0gaXRlbUxlbmd0aCkgLyAyO1xyXG5cclxuXHRcdFx0XHRcdGlmIChtYXJnaW4gPCBwb3NNaW4pIHtcclxuXHRcdFx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XHJcblx0XHRcdFx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdFx0XHRcdFx0c3RlcCsrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RlcHNbaWQyXSA9IHN0ZXA7XHJcblx0XHRcdFx0bWFyZ2luc1tzdGVwXSA9IHN0YXRlLmlzTGVnZW5kSW5zZXQgPyAxMCA6IG1hcmdpbjtcclxuXHRcdFx0XHRvZmZzZXRzW2lkMl0gPSB0b3RhbExlbmd0aDtcclxuXHRcdFx0XHR0b3RhbExlbmd0aCArPSBpdGVtTGVuZ3RoO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKHJlc2V0KSB7XHJcblx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdHN0ZXAgPSAwO1xyXG5cdFx0XHRcdG1heFdpZHRoID0gMDtcclxuXHRcdFx0XHRtYXhIZWlnaHQgPSAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93ICYmICEkJC5pc0xlZ2VuZFRvU2hvdyhpZCkpIHtcclxuXHRcdFx0XHR3aWR0aHNbaWRdID0gMDtcclxuXHRcdFx0XHRoZWlnaHRzW2lkXSA9IDA7XHJcblx0XHRcdFx0c3RlcHNbaWRdID0gMDtcclxuXHRcdFx0XHRvZmZzZXRzW2lkXSA9IDA7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2lkdGhzW2lkXSA9IGl0ZW1XaWR0aDtcclxuXHRcdFx0aGVpZ2h0c1tpZF0gPSBpdGVtSGVpZ2h0O1xyXG5cclxuXHRcdFx0aWYgKCFtYXhXaWR0aCB8fCBpdGVtV2lkdGggPj0gbWF4V2lkdGgpIHtcclxuXHRcdFx0XHRtYXhXaWR0aCA9IGl0ZW1XaWR0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFtYXhIZWlnaHQgfHwgaXRlbUhlaWdodCA+PSBtYXhIZWlnaHQpIHtcclxuXHRcdFx0XHRtYXhIZWlnaHQgPSBpdGVtSGVpZ2h0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBtYXhMZW5ndGggPSBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IG1heEhlaWdodCA6IG1heFdpZHRoO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRfZXF1YWxseSkge1xyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHdpZHRocykuZm9yRWFjaChpZDIgPT4gKHdpZHRoc1tpZDJdID0gbWF4V2lkdGgpKTtcclxuXHRcdFx0XHRPYmplY3Qua2V5cyhoZWlnaHRzKS5mb3JFYWNoKGlkMiA9PiAoaGVpZ2h0c1tpZDJdID0gbWF4SGVpZ2h0KSk7XHJcblx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSBtYXhMZW5ndGggKiB0YXJnZXRJZHoubGVuZ3RoKSAvIDI7XHJcblxyXG5cdFx0XHRcdGlmIChtYXJnaW4gPCBwb3NNaW4pIHtcclxuXHRcdFx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdFx0XHRcdHN0ZXAgPSAwO1xyXG5cdFx0XHRcdFx0dGFyZ2V0SWR6LmZvckVhY2goaWQyID0+IHVwZGF0ZVZhbHVlcyhpZDIpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dXBkYXRlVmFsdWVzKGlkLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dXBkYXRlVmFsdWVzKGlkKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCkge1xyXG5cdFx0XHRzdGVwID0gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwID8gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwIDogdGFyZ2V0SWR6Lmxlbmd0aDtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kU3RlcChzdGVwKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRSaWdodCkge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWF4V2lkdGggKiBzdGVwc1tpZF07XHJcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXJnaW5zW3N0ZXBzW2lkXV0gKyBvZmZzZXRzW2lkXTtcclxuXHRcdH0gZWxzZSBpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCkge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWF4V2lkdGggKiBzdGVwc1tpZF0gKyAxMDtcclxuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eEZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWF4SGVpZ2h0ICogc3RlcHNbaWRdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHhGb3JMZWdlbmRUZXh0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSArIDQgKyBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aDtcclxuXHRcdGNvbnN0IHhGb3JMZWdlbmRSZWN0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKTtcclxuXHRcdGNvbnN0IHgxRm9yTGVnZW5kVGlsZSA9IChpZCwgaT86IG51bWJlcikgPT4geEZvckxlZ2VuZChpZCwgaSkgLSAyO1xyXG5cdFx0Y29uc3QgeDJGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDIgKyBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aDtcclxuXHJcblx0XHRjb25zdCB5Rm9yTGVnZW5kVGV4dCA9IChpZCwgaT86IG51bWJlcikgPT4geUZvckxlZ2VuZChpZCwgaSkgKyA5O1xyXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFJlY3QgPSAoaWQsIGk/OiBudW1iZXIpID0+IHlGb3JMZWdlbmQoaWQsIGkpIC0gNTtcclxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDQ7XHJcblxyXG5cdFx0Y29uc3QgcG9zID0gLTIwMDtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgbGVnZW5kIGFyZWFcclxuXHRcdGNvbnN0IGwgPSBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5kYXRhKHRhcmdldElkeilcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImdcIik7XHJcblxyXG5cdFx0JCQuc2V0TGVnZW5kSXRlbShsKTtcclxuXHJcblx0XHRsLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LnRleHQoaWQgPT4gKGlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pID8gY29uZmlnLmRhdGFfbmFtZXNbaWRdIDogaWQpKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihpZCwgaSkge1xyXG5cdFx0XHRcdHVwZGF0ZVBvc2l0aW9ucyh0aGlzLCBpZCwgaSk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4Rm9yTGVnZW5kVGV4dCA6IHBvcylcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8gcG9zIDogeUZvckxlZ2VuZFRleHQpO1xyXG5cclxuXHRcdGwuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEl0ZW1FdmVudClcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4Rm9yTGVnZW5kUmVjdCA6IHBvcylcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8gcG9zIDogeUZvckxlZ2VuZFJlY3QpO1xyXG5cclxuXHRcdGNvbnN0IHVzZVBvaW50ID0gY29uZmlnLmxlZ2VuZF91c2VQb2ludDtcclxuXHJcblx0XHRpZiAodXNlUG9pbnQpIHtcclxuXHRcdFx0Y29uc3QgaWRzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0bC5hcHBlbmQoZCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/XHJcblx0XHRcdFx0XHRjb25maWcucG9pbnRfcGF0dGVybiA6IFtjb25maWcucG9pbnRfdHlwZV07XHJcblxyXG5cdFx0XHRcdGlkcy5pbmRleE9mKGQpID09PSAtMSAmJiBpZHMucHVzaChkKTtcclxuXHJcblx0XHRcdFx0bGV0IHBvaW50ID0gcGF0dGVybltpZHMuaW5kZXhPZihkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0aWYgKHBvaW50ID09PSBcInJlY3RhbmdsZVwiKSB7XHJcblx0XHRcdFx0XHRwb2ludCA9IFwicmVjdFwiO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhkM05hbWVzcGFjZXMuc3ZnLCAkJC5oYXNWYWxpZFBvaW50VHlwZShwb2ludCkgPyBwb2ludCA6IFwidXNlXCIpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVBvaW50KVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZCA9PiAkJC5jb2xvcihkKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcclxuXHRcdFx0XHQuYXR0cihcImhyZWZcIiwgKGRhdGEsIGlkeCwgc2VsZWN0aW9uKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlID0gc2VsZWN0aW9uW2lkeF07XHJcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUgPT09IFwidXNlXCIgPyBgIyR7c3RhdGUuZGF0ZXRpbWVJZH0tcG9pbnQtJHtkYXRhfWAgOiB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsLmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEl0ZW1UaWxlKVxyXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcclxuXHRcdFx0XHQuYXR0cihcIngxXCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geDFGb3JMZWdlbmRUaWxlIDogcG9zKVxyXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geDJGb3JMZWdlbmRUaWxlIDogcG9zKVxyXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcInN0cm9rZS13aWR0aFwiLCBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCBiYWNrZ3JvdW5kIGZvciBpbnNldCBsZWdlbmRcclxuXHRcdGJhY2tncm91bmQgPSBsZWdlbmQuc2VsZWN0KGAuJHtDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kfSByZWN0YCk7XHJcblxyXG5cdFx0aWYgKHN0YXRlLmlzTGVnZW5kSW5zZXQgJiYgbWF4V2lkdGggPiAwICYmIGJhY2tncm91bmQuc2l6ZSgpID09PSAwKSB7XHJcblx0XHRcdGJhY2tncm91bmQgPSBsZWdlbmQuaW5zZXJ0KFwiZ1wiLCBgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kQmFja2dyb3VuZClcclxuXHRcdFx0XHQuYXBwZW5kKFwicmVjdFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0ZXh0cyA9IGxlZ2VuZC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdC5kYXRhKHRhcmdldElkeilcclxuXHRcdFx0LnRleHQoaWQgPT4gKGlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pID8gY29uZmlnLmRhdGFfbmFtZXNbaWRdIDogaWQpKSAvLyBNRU1POiBuZWVkZWQgZm9yIHVwZGF0ZVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihpZCwgaSkge1xyXG5cdFx0XHRcdHVwZGF0ZVBvc2l0aW9ucyh0aGlzLCBpZCwgaSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgeEZvckxlZ2VuZFRleHQpXHJcblx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yTGVnZW5kVGV4dCk7XHJcblxyXG5cdFx0Y29uc3QgcmVjdHMgPSBsZWdlbmQuc2VsZWN0QWxsKGByZWN0LiR7Q0xBU1MubGVnZW5kSXRlbUV2ZW50fWApXHJcblx0XHRcdC5kYXRhKHRhcmdldElkeik7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVjdHMudHJhbnNpdGlvbigpIDogcmVjdHMpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgaWQgPT4gd2lkdGhzW2lkXSlcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaWQgPT4gaGVpZ2h0c1tpZF0pXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kUmVjdClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRSZWN0KTtcclxuXHJcblxyXG5cdFx0aWYgKHVzZVBvaW50KSB7XHJcblx0XHRcdGNvbnN0IHRpbGVzID0gbGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbVBvaW50fWApXHJcblx0XHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcclxuXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRpbGVzLnRyYW5zaXRpb24oKSA6IHRpbGVzKVxyXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Y29uc3Qgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdFx0XHRjb25zdCBwb2ludFIgPSBjb25maWcucG9pbnRfcjtcclxuXHRcdFx0XHRcdGxldCB4ID0gXCJ4XCI7XHJcblx0XHRcdFx0XHRsZXQgeSA9IFwieVwiO1xyXG5cdFx0XHRcdFx0bGV0IHhPZmZzZXQgPSAyO1xyXG5cdFx0XHRcdFx0bGV0IHlPZmZzZXQgPSAyLjU7XHJcblx0XHRcdFx0XHRsZXQgcmFkaXVzO1xyXG5cdFx0XHRcdFx0bGV0IHdpZHRoO1xyXG5cdFx0XHRcdFx0bGV0IGhlaWdodDtcclxuXHJcblx0XHRcdFx0XHRpZiAobm9kZU5hbWUgPT09IFwiY2lyY2xlXCIpIHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IHBvaW50UiAqIDAuMjtcclxuXHJcblx0XHRcdFx0XHRcdHggPSBcImN4XCI7XHJcblx0XHRcdFx0XHRcdHkgPSBcImN5XCI7XHJcblx0XHRcdFx0XHRcdHJhZGl1cyA9IHBvaW50UiArIHNpemU7XHJcblx0XHRcdFx0XHRcdHhPZmZzZXQgPSBwb2ludFIgKiAyO1xyXG5cdFx0XHRcdFx0XHR5T2Zmc2V0ID0gLXNpemU7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcInJlY3RcIikge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMi41O1xyXG5cclxuXHRcdFx0XHRcdFx0d2lkdGggPSBzaXplO1xyXG5cdFx0XHRcdFx0XHRoZWlnaHQgPSBzaXplO1xyXG5cdFx0XHRcdFx0XHR5T2Zmc2V0ID0gMztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKVxyXG5cdFx0XHRcdFx0XHQuYXR0cih4LCBkID0+IHgxRm9yTGVnZW5kVGlsZShkKSArIHhPZmZzZXQpXHJcblx0XHRcdFx0XHRcdC5hdHRyKHksIGQgPT4geUZvckxlZ2VuZFRpbGUoZCkgLSB5T2Zmc2V0KVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInJcIiwgcmFkaXVzKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBsZWdlbmQuc2VsZWN0QWxsKGBsaW5lLiR7Q0xBU1MubGVnZW5kSXRlbVRpbGV9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xyXG5cclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmxldmVsQ29sb3IgPyBpZCA9PiAkJC5sZXZlbENvbG9yKCQkLmNhY2hlLmdldChpZCkudmFsdWVzWzBdLnZhbHVlKSA6ICQkLmNvbG9yKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgeDFGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgeUZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4MkZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5Rm9yTGVnZW5kVGlsZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJhY2tncm91bmQpIHtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gYmFja2dyb3VuZC50cmFuc2l0aW9uKCkgOiBiYWNrZ3JvdW5kKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldExlZ2VuZEhlaWdodCgpIC0gMTIpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBtYXhXaWR0aCAqIChzdGVwICsgMSkgKyAxMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGFsbCB0byByZWZsZWN0IGNoYW5nZSBvZiBsZWdlbmRcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aChtYXhXaWR0aCk7XHJcblx0XHQkJC51cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KG1heEhlaWdodCk7XHJcblx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2VuZXJhdGVXYWl0fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2dlbmVyYXRvclwiO1xyXG5pbXBvcnQge2NhbGxGbiwgZ2V0T3B0aW9uLCBpc1RhYlZpc2libGUsIG5vdEVtcHR5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRyZWRyYXcob3B0aW9uczogYW55ID0ge30sIHRyYW5zaXRpb25zVmFsdWU/KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJGVsO1xyXG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRjb25zdCBpbml0aWFsaXppbmcgPSBvcHRpb25zLmluaXRpYWxpemluZztcclxuXHRcdGNvbnN0IGZsb3cgPSBvcHRpb25zLmZsb3c7XHJcblx0XHRjb25zdCB3dGggPSAkJC5nZXRXaXRoT3B0aW9uKG9wdGlvbnMpO1xyXG5cdFx0Y29uc3QgZHVyYXRpb24gPSB3dGguVHJhbnNpdGlvbiA/IGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uIDogMDtcclxuXHRcdGNvbnN0IGR1cmF0aW9uRm9yRXhpdCA9IHd0aC5UcmFuc2l0aW9uRm9yRXhpdCA/IGR1cmF0aW9uIDogMDtcclxuXHRcdGNvbnN0IGR1cmF0aW9uRm9yQXhpcyA9IHd0aC5UcmFuc2l0aW9uRm9yQXhpcyA/IGR1cmF0aW9uIDogMDtcclxuXHRcdGNvbnN0IHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnNWYWx1ZSB8fCAoJCQuYXhpcyAmJiAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb25Gb3JBeGlzKSk7XHJcblxyXG5cdFx0JCQudXBkYXRlU2l6ZXMoaW5pdGlhbGl6aW5nKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgbGVnZW5kIGFuZCB0cmFuc2Zvcm0gZWFjaCBnXHJcblxyXG5cdFx0aWYgKHd0aC5MZWdlbmQgJiYgY29uZmlnLmxlZ2VuZF9zaG93KSB7XHJcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZCgkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLCBvcHRpb25zLCB0cmFuc2l0aW9ucyk7XHJcblx0XHR9IGVsc2UgaWYgKHd0aC5EaW1lbnNpb24pIHtcclxuXHRcdFx0Ly8gbmVlZCB0byB1cGRhdGUgZGltZW5zaW9uIChlLmcuIGF4aXMueS50aWNrLnZhbHVlcykgYmVjYXVzZSB5IHRpY2sgdmFsdWVzIHNob3VsZCBjaGFuZ2VcclxuXHRcdFx0Ly8gbm8gbmVlZCB0byB1cGRhdGUgYXhpcyBpbiBpdCBiZWNhdXNlIHRoZXkgd2lsbCBiZSB1cGRhdGVkIGluIHJlZHJhdygpXHJcblx0XHRcdCQkLnVwZGF0ZURpbWVuc2lvbih0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0ZXh0XHJcblx0XHQkJC5oYXNEYXRhTGFiZWwoKSAmJiAkJC51cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNpcmNsZVkgYmFzZWQgb24gdXBkYXRlZCBwYXJhbWV0ZXJzXHJcblx0XHRpZiAoISQkLmhhc0FyY1R5cGUoKSB8fCBzdGF0ZS5oYXNSYWRhcikge1xyXG5cdFx0XHQkJC51cGRhdGVDaXJjbGVZKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQFRPRE86IEF4aXMgJiBSYWRhciB0eXBlXHJcblx0XHRpZiAoJCQuaGFzUG9pbnRUeXBlKCkgfHwgc3RhdGUuaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQudXBkYXRlQ2lyY2xlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGF4aXNcclxuXHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdC8vIEBUT0RPOiBNYWtlICdpbml0JyBzdGF0ZSB0byBiZSBhY2Nlc3NpYmxlIGV2ZXJ5d2hlcmUgbm90IHBhc3NpbmcgYXMgYXJndW1lbnQuXHJcblx0XHRcdCQkLmF4aXMucmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpbml0aWFsaXppbmcpO1xyXG5cclxuXHRcdFx0Ly8gRGF0YSBlbXB0eSBsYWJlbCBwb3NpdGlvbmluZyBhbmQgdGV4dC5cclxuXHRcdFx0Y29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCAmJiBtYWluLnNlbGVjdChgdGV4dC4ke0NMQVNTLnRleHR9LiR7Q0xBU1MuZW1wdHl9YClcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgc3RhdGUud2lkdGggLyAyKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCBzdGF0ZS5oZWlnaHQgLyAyKVxyXG5cdFx0XHRcdC50ZXh0KGNvbmZpZy5kYXRhX2VtcHR5X2xhYmVsX3RleHQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCB0YXJnZXRzVG9TaG93Lmxlbmd0aCA/IFwibm9uZVwiIDogbnVsbCk7XHJcblxyXG5cdFx0XHQvLyBncmlkXHJcblx0XHRcdCQkLmhhc0dyaWQoKSAmJiAkJC51cGRhdGVHcmlkKGR1cmF0aW9uKTtcclxuXHJcblx0XHRcdC8vIHJlY3QgZm9yIHJlZ2lvbnNcclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMubGVuZ3RoICYmICQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XHJcblxyXG5cdFx0XHQvLyBiYXJzXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgJCQudXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCk7XHJcblxyXG5cdFx0XHQvLyBsaW5lcywgYXJlYXMgYW5kIGNpcmNsZXNcclxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkxpbmVcIikpIHtcclxuXHRcdFx0XHQkJC51cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJBcmVhXCIpKSB7XHJcblx0XHRcdFx0JCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjaXJjbGVzIGZvciBzZWxlY3RcclxuXHRcdFx0JGVsLnRleHQgJiYgbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc31gKVxyXG5cdFx0XHRcdC5maWx0ZXIoJCQuaXNCYXJUeXBlLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHQvLyBldmVudCByZWN0cyB3aWxsIHJlZHJhd24gd2hlbiBmbG93IGNhbGxlZFxyXG5cdFx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgIWZsb3cgJiYgd3RoLkV2ZW50UmVjdCkge1xyXG5cdFx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gYXJjXHJcblx0XHRcdCRlbC5hcmNzICYmICQkLnJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3dGguVHJhbnNmb3JtKTtcclxuXHJcblx0XHRcdC8vIHJhZGFyXHJcblx0XHRcdCRlbC5yYWRhcnMgJiYgJCQucmVkcmF3UmFkYXIoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0aXRsZVxyXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcclxuXHJcblx0XHRpbml0aWFsaXppbmcgJiYgJCQudXBkYXRlVHlwZXNFbGVtZW50cygpO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzVG9TaG93LCBmbG93LCBkdXJhdGlvbiwgd3RoLlN1YmNoYXJ0KTtcclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJHJlZHJhd1wiLCBvcHRpb25zLCBkdXJhdGlvbik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgcmVkcmF3IGxpc3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyB0YXJnZXRzIGRhdGEgdG8gYmUgc2hvd25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZmxvdyBmbG93IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBkdXJhdGlvbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFN1YmNoYXJ0IHdoZXRoZXIgb3Igbm90IHRvIHNob3cgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzLCBmbG93OiBhbnksIGR1cmF0aW9uOiBudW1iZXIsIHdpdGhTdWJjaGFydDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBzaGFwZSA9ICQkLmdldERyYXdTaGFwZSgpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdC8vIHN1YmNoYXJ0XHJcblx0XHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICQkLnJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydCwgZHVyYXRpb24sIHNoYXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZW5lcmF0ZSBmbG93XHJcblx0XHRjb25zdCBmbG93Rm4gPSBmbG93ICYmICQkLmdlbmVyYXRlRmxvdyh7XHJcblx0XHRcdHRhcmdldHMsXHJcblx0XHRcdGZsb3csXHJcblx0XHRcdGR1cmF0aW9uOiBmbG93LmR1cmF0aW9uLFxyXG5cdFx0XHRzaGFwZSxcclxuXHRcdFx0eHY6ICQkLnh2LmJpbmQoJCQpXHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGlzVHJhbnNpdGlvbiA9IChkdXJhdGlvbiB8fCBmbG93Rm4pICYmIGlzVGFiVmlzaWJsZSgpO1xyXG5cclxuXHRcdC8vIHJlZHJhdyBsaXN0XHJcblx0XHRjb25zdCByZWRyYXdMaXN0ID0gJCQuZ2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIGFmdGVyIHJlZHJhdyBlbmRzXHJcblx0XHRjb25zdCBhZnRlclJlZHJhdyA9IGZsb3cgfHwgY29uZmlnLm9ucmVuZGVyZWQgPyAoKSA9PiB7XHJcblx0XHRcdGZsb3dGbiAmJiBmbG93Rm4oKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5vbnJlbmRlcmVkLCAkJC5hcGkpO1xyXG5cdFx0fSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKGFmdGVyUmVkcmF3KSB7XHJcblx0XHRcdC8vIE9ubHkgdXNlIHRyYW5zaXRpb24gd2hlbiBjdXJyZW50IHRhYiBpcyB2aXNpYmxlLlxyXG5cdFx0XHRpZiAoaXNUcmFuc2l0aW9uICYmIHJlZHJhd0xpc3QubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gV2FpdCBmb3IgZW5kIG9mIHRyYW5zaXRpb25zIGZvciBjYWxsYmFja1xyXG5cdFx0XHRcdGNvbnN0IHdhaXRGb3JEcmF3ID0gZ2VuZXJhdGVXYWl0KCk7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zaXRpb24gc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSBvbmUgdHJhbnNpdGlvblxyXG5cdFx0XHRcdGQzVHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRyZWRyYXdMaXN0XHJcblx0XHRcdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCB0MSkgPT4gYWNjLmNvbmNhdCh0MSksIFtdKVxyXG5cdFx0XHRcdFx0XHRcdC5mb3JFYWNoKHQgPT4gd2FpdEZvckRyYXcuYWRkKHQpKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQuY2FsbCh3YWl0Rm9yRHJhdywgYWZ0ZXJSZWRyYXcpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFzdGF0ZS50cmFuc2l0aW5nKSB7XHJcblx0XHRcdFx0YWZ0ZXJSZWRyYXcoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBmYWRlaW4gY29uZGl0aW9uXHJcblx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRzdGF0ZS53aXRob3V0RmFkZUluW2lkXSA9IHRydWU7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbjogYm9vbGVhbik6IEZ1bmN0aW9uW10ge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtoYXNBeGlzLCBoYXNSYWRhcn19ID0gJCQ7XHJcblx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gc2hhcGUucG9zO1xyXG5cdFx0Y29uc3QgbGlzdDogRnVuY3Rpb25bXSA9IFtdO1xyXG5cclxuXHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdGNvbnN0IHthcmVhLCBiYXIsIGxpbmV9ID0gc2hhcGUudHlwZTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuZ3JpZF94X2xpbmVzLmxlbmd0aCB8fCBjb25maWcuZ3JpZF95X2xpbmVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdHcmlkKGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLnJlZ2lvbnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd1JlZ2lvbihpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JCQuaGFzVHlwZU9mKFwiTGluZVwiKSAmJiBsaXN0LnB1c2goJCQucmVkcmF3TGluZShsaW5lLCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0JCQuaGFzVHlwZU9mKFwiQXJlYVwiKSAmJiBsaXN0LnB1c2goJCQucmVkcmF3QXJlYShhcmVhLCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiBsaXN0LnB1c2goJCQucmVkcmF3QmFyKGJhciwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdCFmbG93ICYmIGxpc3QucHVzaCgkJC51cGRhdGVHcmlkRm9jdXMoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCEkJC5oYXNBcmNUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0bm90RW1wdHkoY29uZmlnLmRhdGFfbGFiZWxzKSAmJlxyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdUZXh0KHhGb3JUZXh0LCB5Rm9yVGV4dCwgZmxvdywgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCgkJC5oYXNQb2ludFR5cGUoKSB8fCBoYXNSYWRhcikgJiYgIWNvbmZpZy5wb2ludF9mb2N1c19vbmx5KSB7XHJcblx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdDaXJjbGUoY3gsIGN5LCBpc1RyYW5zaXRpb24sIGZsb3dGbikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaXN0O1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFuZFJlZHJhdyhvcHRpb25zOiBhbnkgPSB7fSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRsZXQgdHJhbnNpdGlvbnM7XHJcblxyXG5cdFx0Ly8gc2FtZSB3aXRoIHJlZHJhd1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zZm9ybVwiLCBmYWxzZSk7XHJcblx0XHRvcHRpb25zLndpdGhMZWdlbmQgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoTGVnZW5kXCIsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBOT1Qgc2FtZSB3aXRoIHJlZHJhd1xyXG5cdFx0b3B0aW9ucy53aXRoVXBkYXRlWERvbWFpbiA9IHRydWU7XHJcblx0XHRvcHRpb25zLndpdGhVcGRhdGVPcmdYRG9tYWluID0gdHJ1ZTtcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JFeGl0ID0gZmFsc2U7XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgb3B0aW9ucy53aXRoVHJhbnNpdGlvbik7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FsbGVkIGluIHVwZGF0ZUxlZ2VuZCBpbiByZWRyYXcgaWYgd2l0aExlZ2VuZFxyXG5cdFx0aWYgKCEob3B0aW9ucy53aXRoTGVnZW5kICYmIGNvbmZpZy5sZWdlbmRfc2hvdykpIHtcclxuXHRcdFx0aWYgKHN0YXRlLmhhc0F4aXMpIHtcclxuXHRcdFx0XHR0cmFuc2l0aW9ucyA9ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhcclxuXHRcdFx0XHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JBeGlzID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHNjYWxlc1xyXG5cdFx0XHQkJC51cGRhdGVTY2FsZXMoKTtcclxuXHRcdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXHJcblx0XHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIG5ldyBzaXplcyAmIHNjYWxlc1xyXG5cdFx0JCQucmVkcmF3KG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdXaXRob3V0UmVzY2FsZSgpIHtcclxuXHRcdHRoaXMucmVkcmF3KHtcclxuXHRcdFx0d2l0aFk6IGZhbHNlLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRXZlbnRSZWN0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2NhbGVUaW1lIGFzIGQzU2NhbGVUaW1lLFxyXG5cdHNjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJcclxufSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IHtpc1N0cmluZywgaXNWYWx1ZSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRTY2FsZShtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIGZvclRpbWVzZXJpZXM/OiBib29sZWFuKSB7XHJcblx0XHRyZXR1cm4gKGZvclRpbWVzZXJpZXMgP1xyXG5cdFx0XHRkM1NjYWxlVGltZSgpIDogZDNTY2FsZUxpbmVhcigpXHJcblx0XHQpLnJhbmdlKFttaW4sIG1heF0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB4IEF4aXMgc2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIE1pbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHZhbHVlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZG9tYWluIERvbWFpbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldCBUaGUgb2Zmc2V0IGdldHRlciB0byBiZSBzdW1cclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRYU2NhbGUobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBkb21haW46IG51bWJlcltdLCBvZmZzZXQ6IEZ1bmN0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlLnpvb20gfHwgJCQuZ2V0U2NhbGUobWluLCBtYXgsICQkLmF4aXMuaXNUaW1lU2VyaWVzKCkpO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRDdXN0b21pemVkU2NhbGUoXHJcblx0XHRcdGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsXHJcblx0XHRcdG9mZnNldFxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeSBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW4gdmFsdWVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpbiBEb21haW4gdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRZU2NhbGUobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBkb21haW46IG51bWJlcltdKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSAkJC5nZXRTY2FsZShtaW4sIG1heCwgJCQuYXhpcy5pc1RpbWVTZXJpZXNZKCkpO1xyXG5cclxuXHRcdGRvbWFpbiAmJiBzY2FsZS5kb21haW4oZG9tYWluKTtcclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHkgQXhpcyBzY2FsZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc1N1YiBXZWF0aGVyIGlzIHN1YiBBeGlzXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBTY2FsZSBmdW5jdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WVNjYWxlQnlJZChpZDogc3RyaW5nLCBpc1N1YiA9IGZhbHNlKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgaXNZMiA9IHRoaXMuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIjtcclxuXHRcdGNvbnN0IGtleSA9IGlzU3ViID8gKGlzWTIgPyBcInN1YlkyXCIgOiBcInN1YllcIikgOiAoaXNZMiA/IFwieTJcIiA6IFwieVwiKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zY2FsZVtrZXldO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBjdXN0b21pemVkIHNjYWxlXHJcblx0ICogQHBhcmFtIHtkMy5zY2FsZUxpbmVhcnxkMy5zY2FsZVRpbWV9IHNjYWxlVmFsdWUgU2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvZmZzZXRWYWx1ZSBPZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxyXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gU2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEN1c3RvbWl6ZWRTY2FsZShzY2FsZVZhbHVlOiBGdW5jdGlvbiB8IGFueSwgb2Zmc2V0VmFsdWUpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSB8fCAoKCkgPT4gJCQuYXhpcy54LnRpY2tPZmZzZXQoKSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IGZ1bmN0aW9uKGQsIHJhdykge1xyXG5cdFx0XHRjb25zdCB2ID0gc2NhbGVWYWx1ZShkKSArIG9mZnNldCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xyXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc2NhbGVWYWx1ZSkge1xyXG5cdFx0XHRzY2FsZVtrZXldID0gc2NhbGVWYWx1ZVtrZXldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlLm9yZ0RvbWFpbiA9ICgpID0+IHNjYWxlVmFsdWUuZG9tYWluKCk7XHJcblx0XHRzY2FsZS5vcmdTY2FsZSA9ICgpID0+IHNjYWxlVmFsdWU7XHJcblxyXG5cdFx0Ly8gZGVmaW5lIGN1c3RvbSBkb21haW4oKSBmb3IgY2F0ZWdvcml6ZWQgYXhpc1xyXG5cdFx0aWYgKCQkLmF4aXMuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGRvbWFpblZhbHVlKSB7XHJcblx0XHRcdFx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGRvbWFpbiA9IHRoaXMub3JnRG9tYWluKCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIFtkb21haW5bMF0sIGRvbWFpblsxXSArIDFdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2NhbGVWYWx1ZS5kb21haW4oZG9tYWluKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNjYWxlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzY2FsZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgc2NhbGVcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5pdCBQYXJhbSBpcyBnaXZlbiBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVhEb21haW4gSWYgdXBkYXRlIHggZG9tYWluXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTY2FsZXMoaXNJbml0OiBib29sZWFuLCB1cGRhdGVYRG9tYWluID0gdHJ1ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgZm9ybWF0LCBvcmcsIHNjYWxlLFxyXG5cdFx0XHRzdGF0ZToge3dpZHRoLCBoZWlnaHQsIHdpZHRoMiwgaGVpZ2h0MiwgaGFzQXhpc31cclxuXHRcdH0gPSAkJDtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGVkZ2VzXHJcblx0XHRcdGNvbnN0IG1pbiA9IHtcclxuXHRcdFx0XHR4OiBpc1JvdGF0ZWQgPyAxIDogMCxcclxuXHRcdFx0XHR5OiBpc1JvdGF0ZWQgPyAwIDogaGVpZ2h0LFxyXG5cdFx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IDEgOiAwLFxyXG5cdFx0XHRcdHN1Ylk6IGlzUm90YXRlZCA/IDAgOiBoZWlnaHQyXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCBtYXggPSB7XHJcblx0XHRcdFx0eDogaXNSb3RhdGVkID8gaGVpZ2h0IDogd2lkdGgsXHJcblx0XHRcdFx0eTogaXNSb3RhdGVkID8gd2lkdGggOiAxLFxyXG5cdFx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoLFxyXG5cdFx0XHRcdHN1Ylk6IGlzUm90YXRlZCA/IHdpZHRoMiA6IDFcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzY2FsZXNcclxuXHRcdFx0Ly8geCBBeGlzXHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSB1cGRhdGVYRG9tYWluICYmIHNjYWxlLnggJiYgc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdFx0Y29uc3QgeFN1YkRvbWFpbiA9IHVwZGF0ZVhEb21haW4gJiYgb3JnLnhEb21haW47XHJcblxyXG5cdFx0XHRzY2FsZS54ID0gJCQuZ2V0WFNjYWxlKG1pbi54LCBtYXgueCwgeERvbWFpbiwgKCkgPT4gYXhpcy54LnRpY2tPZmZzZXQoKSk7XHJcblx0XHRcdHNjYWxlLnN1YlggPSAkJC5nZXRYU2NhbGUobWluLngsIG1heC54LCB4U3ViRG9tYWluLCBkID0+IChkICUgMSA/IDAgOiBheGlzLnN1YlgudGlja09mZnNldCgpKSk7XHJcblxyXG5cdFx0XHRmb3JtYXQueEF4aXNUaWNrID0gYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKTtcclxuXHJcblx0XHRcdGF4aXMuc2V0QXhpcyhcInhcIiwgc2NhbGUueCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdFx0YXhpcy5zZXRBeGlzKFwic3ViWFwiLCBzY2FsZS5zdWJYLCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHkgQXhpc1xyXG5cdFx0XHRzY2FsZS55ID0gJCQuZ2V0WVNjYWxlKG1pbi55LCBtYXgueSwgc2NhbGUueSA/IHNjYWxlLnkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xyXG5cdFx0XHRzY2FsZS5zdWJZID0gJCQuZ2V0WVNjYWxlKFxyXG5cdFx0XHRcdG1pbi5zdWJZLCBtYXguc3ViWSwgc2NhbGUuc3ViWSA/IHNjYWxlLnN1YlkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xyXG5cclxuXHRcdFx0YXhpcy5zZXRBeGlzKFwieVwiLCBzY2FsZS55LCBjb25maWcuYXhpc195X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblxyXG5cdFx0XHQvLyB5MiBBeGlzXHJcblx0XHRcdGlmIChjb25maWcuYXhpc195Ml9zaG93KSB7XHJcblx0XHRcdFx0c2NhbGUueTIgPSAkJC5nZXRZU2NhbGUobWluLnksIG1heC55LCBzY2FsZS55MiA/IHNjYWxlLnkyLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeTJfZGVmYXVsdCk7XHJcblx0XHRcdFx0c2NhbGUuc3ViWTIgPSAkJC5nZXRZU2NhbGUobWluLnN1YlksIG1heC5zdWJZLFxyXG5cdFx0XHRcdFx0c2NhbGUuc3ViWTIgPyBzY2FsZS5zdWJZMi5kb21haW4oKSA6IGNvbmZpZy5heGlzX3kyX2RlZmF1bHQpO1xyXG5cclxuXHRcdFx0XHRheGlzLnNldEF4aXMoXCJ5MlwiLCBzY2FsZS55MiwgY29uZmlnLmF4aXNfeTJfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdXBkYXRlIGZvciBhcmNcclxuXHRcdFx0JCQudXBkYXRlQXJjICYmICQkLnVwZGF0ZUFyYygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgem9vbSBvciB1bnpvb21lZCBzY2FsZWQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge0RhdGV8bnVtYmVyfG9iamVjdH0gZCBEYXRhIHZhbHVlXHJcblx0ICogQHJldHVybnMge251bWJlcnxudWxsfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0eHgoZCk6IG51bWJlciB8IG51bGwge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGU6IHt4LCB6b29tfX0gPSAkJDtcclxuXHRcdGNvbnN0IGZuID0gY29uZmlnLnpvb21fZW5hYmxlZCAmJiB6b29tID9cclxuXHRcdFx0em9vbSA6IHg7XHJcblxyXG5cdFx0cmV0dXJuIGQgPyBmbihpc1ZhbHVlKGQueCkgPyBkLnggOiBkKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0eHYoZCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBzY2FsZToge3h9fSA9ICQkO1xyXG5cdFx0bGV0IHZhbHVlID0gJCQuZ2V0QmFzZVZhbHVlKGQpO1xyXG5cclxuXHRcdGlmIChheGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdHZhbHVlID0gcGFyc2VEYXRlLmNhbGwoJCQsIHZhbHVlKTtcclxuXHRcdH0gZWxzZSBpZiAoYXhpcy5pc0NhdGVnb3JpemVkKCkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodmFsdWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeCh2YWx1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdHl2KGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NjYWxlOiB7eSwgeTJ9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gZC5heGlzICYmIGQuYXhpcyA9PT0gXCJ5MlwiID8geTIgOiB5O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeVNjYWxlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH0sXHJcblxyXG5cdHN1Ynh4KGQpOiBudW1iZXIgfCBudWxsIHtcclxuXHRcdHJldHVybiBkID8gdGhpcy5zY2FsZS5zdWJYKGQueCkgOiBudWxsO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzVmFsdWUsIGNlaWwxMCwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7QXhpc1R5cGV9IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjb250YWluZXIgc2l6ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0Q29udGFpbmVyU2l6ZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRzdGF0ZS5jdXJyZW50LndpZHRoID0gJCQuZ2V0Q3VycmVudFdpZHRoKCk7XHJcblx0XHRzdGF0ZS5jdXJyZW50LmhlaWdodCA9ICQkLmdldEN1cnJlbnRIZWlnaHQoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50V2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLnNpemVfd2lkdGggfHwgJCQuZ2V0UGFyZW50V2lkdGgoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50SGVpZ2h0KCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaCA9IGNvbmZpZy5zaXplX2hlaWdodCB8fCAkJC5nZXRQYXJlbnRIZWlnaHQoKTtcclxuXHJcblx0XHRyZXR1cm4gaCA+IDAgPyBoIDogMzIwIC8gKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IEF4aXMgc2l6ZSBhY2NvcmRpbmcgaXRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIEF4aXMgaWQgdmFsdWUgLSB4LCB5IG9yIHkyXHJcblx0ICogQHJldHVybnMge251bWJlcn0gc2l6ZSBBeGlzIHNpemUgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEF4aXNTaXplKGlkOiBBeGlzVHlwZSk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdHJldHVybiAoaXNSb3RhdGVkICYmIGlkID09PSBcInhcIikgfHwgKCFpc1JvdGF0ZWQgJiYgL3kyPy8udGVzdChpZCkpID9cclxuXHRcdFx0JCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoaWQsIHRydWUpIDpcclxuXHRcdFx0JCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nVG9wKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnLmF4aXNfeTJfYXhlcy5sZW5ndGg7XHJcblxyXG5cdFx0bGV0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3RvcCkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ190b3AgOiAwO1xyXG5cclxuXHRcdGlmICgkZWwudGl0bGUgJiYgJGVsLnRpdGxlLm5vZGUoKSkge1xyXG5cdFx0XHRwYWRkaW5nICs9ICQkLmdldFRpdGxlUGFkZGluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzTGVuICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICogYXhlc0xlbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZztcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInlcIiA6IFwieFwiO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2JvdHRvbSkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKFxyXG5cdFx0XHRheGVzTGVuID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoYXhpc0lkKSAqIGF4ZXNMZW4gOiAwXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2hhc0F4aXN9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGlzUm90YXRlZCA/IFwieFwiIDogXCJ5XCI7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9heGVzYF0ubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYXhpc1dpZHRoID0gaGFzQXhpcyA/ICQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKGF4aXNJZCwgd2l0aG91dFJlY29tcHV0ZSkgOiAwO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfbGVmdCkpIHtcclxuXHRcdFx0cGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nX2xlZnQ7XHJcblx0XHR9IGVsc2UgaWYgKGhhc0F4aXMgJiYgaXNSb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAhY29uZmlnLmF4aXNfeF9zaG93ID9cclxuXHRcdFx0XHQxIDogTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCksIDQwKTtcclxuXHRcdH0gZWxzZSBpZiAoaGFzQXhpcyAmJiAoIWNvbmZpZy5heGlzX3lfc2hvdyB8fCBjb25maWcuYXhpc195X2lubmVyKSkgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxyXG5cdFx0XHRwYWRkaW5nID0gJCQuYXhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihcInlcIikuaXNPdXRlciA/IDMwIDogMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjZWlsMTAoYXhpc1dpZHRoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChheGlzV2lkdGggKiBheGVzTGVuKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1JpZ2h0KHdpdGhvdXRUaWNrVGV4dE92ZXJmbG93ID0gZmFsc2UpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRlZmF1bHRQYWRkaW5nID0gMTA7XHJcblx0XHRjb25zdCBsZWdlbmRXaWR0aE9uUmlnaHQgPSAkJC5zdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSArIDIwIDogMDtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGF4aXNXaWR0aCA9ICQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKFwieTJcIik7XHJcblx0XHRjb25zdCB4QXhpc1RpY2tUZXh0T3ZlcmZsb3cgPSB3aXRob3V0VGlja1RleHRPdmVyZmxvdyA/XHJcblx0XHRcdDAgOiAkJC5heGlzLmdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93KGRlZmF1bHRQYWRkaW5nKTtcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3JpZ2h0KSkge1xyXG5cdFx0XHRwYWRkaW5nID0gY29uZmlnLnBhZGRpbmdfcmlnaHQgKyAxOyAvLyAxIGlzIG5lZWRlZCBub3QgdG8gaGlkZSB0aWNrIGxpbmVcclxuXHRcdH0gZWxzZSBpZiAoJCQuYXhpcyAmJiBjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgPSBkZWZhdWx0UGFkZGluZyArIGxlZ2VuZFdpZHRoT25SaWdodDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuYXhpcyAmJiAoIWNvbmZpZy5heGlzX3kyX3Nob3cgfHwgY29uZmlnLmF4aXNfeTJfaW5uZXIpKSB7IC8vICYmICFjb25maWcuYXhpc19yb3RhdGVkXHJcblx0XHRcdHBhZGRpbmcgPSBNYXRoLm1heChcclxuXHRcdFx0XHQyICsgbGVnZW5kV2lkdGhPblJpZ2h0ICsgKCQkLmF4aXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oXCJ5MlwiKS5pc091dGVyID8gMjAgOiAwKSxcclxuXHRcdFx0XHR4QXhpc1RpY2tUZXh0T3ZlcmZsb3dcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBNYXRoLm1heChjZWlsMTAoYXhpc1dpZHRoKSArIGxlZ2VuZFdpZHRoT25SaWdodCwgeEF4aXNUaWNrVGV4dE92ZXJmbG93KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChheGlzV2lkdGggKiBheGVzTGVuKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHBhcmVudCByZWN0IGVsZW1lbnQncyBzaXplXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBwcm9wZXJ0eS9hdHRyaWJ1dGUgbmFtZVxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRQYXJlbnRSZWN0VmFsdWUoa2V5KTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IG9mZnNldE5hbWUgPSBgb2Zmc2V0JHtjYXBpdGFsaXplKGtleSl9YDtcclxuXHRcdGxldCBwYXJlbnQgPSB0aGlzLiRlbC5jaGFydC5ub2RlKCk7XHJcblx0XHRsZXQgdjtcclxuXHJcblx0XHR3aGlsZSAoIXYgJiYgcGFyZW50ICYmIHBhcmVudC50YWdOYW1lICE9PSBcIkJPRFlcIikge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHYgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClba2V5XTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdGlmIChvZmZzZXROYW1lIGluIHBhcmVudCkge1xyXG5cdFx0XHRcdFx0Ly8gSW4gSUUgaW4gY2VydGFpbiBjYXNlcyBnZXRCb3VuZGluZ0NsaWVudFJlY3RcclxuXHRcdFx0XHRcdC8vIHdpbGwgY2F1c2UgYW4gXCJ1bnNwZWNpZmllZCBlcnJvclwiXHJcblx0XHRcdFx0XHR2ID0gcGFyZW50W29mZnNldE5hbWVdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGtleSA9PT0gXCJ3aWR0aFwiKSB7XHJcblx0XHRcdC8vIFNvbWV0aW1lcyBlbGVtZW50J3Mgd2lkdGggdmFsdWUgaXMgaW5jb3JyZWN0KGV4LiBmbGV4IGNvbnRhaW5lcilcclxuXHRcdFx0Ly8gSW4gdGhpcyBjYXNlLCB1c2UgYm9keSdzIG9mZnNldFdpZHRoIGluc3RlYWQuXHJcblx0XHRcdGNvbnN0IGJvZHlXaWR0aCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XHJcblxyXG5cdFx0XHR2ID4gYm9keVdpZHRoICYmICh2ID0gYm9keVdpZHRoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdjtcclxuXHR9LFxyXG5cclxuXHRnZXRQYXJlbnRXaWR0aCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGFyZW50UmVjdFZhbHVlKFwid2lkdGhcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyZW50SGVpZ2h0KCk6IG51bWJlciB7XHJcblx0XHRjb25zdCBoID0gdGhpcy4kZWwuY2hhcnQuc3R5bGUoXCJoZWlnaHRcIik7XHJcblxyXG5cdFx0cmV0dXJuIGguaW5kZXhPZihcInB4XCIpID4gMCA/IHBhcnNlSW50KGgsIDEwKSA6IDA7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ZnTGVmdCh3aXRob3V0UmVjb21wdXRlPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNMZWZ0QXhpc1JlY3QgPSBjb25maWcuYXhpc19yb3RhdGVkIHx8ICghY29uZmlnLmF4aXNfcm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeV9pbm5lcik7XHJcblx0XHRjb25zdCBsZWZ0QXhpc0NsYXNzID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IENMQVNTLmF4aXNYIDogQ0xBU1MuYXhpc1k7XHJcblx0XHRjb25zdCBsZWZ0QXhpcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7bGVmdEF4aXNDbGFzc31gKS5ub2RlKCk7XHJcblx0XHRjb25zdCBzdmdSZWN0ID0gbGVmdEF4aXMgJiYgaGFzTGVmdEF4aXNSZWN0ID8gbGVmdEF4aXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7cmlnaHQ6IDB9O1xyXG5cdFx0Y29uc3QgY2hhcnRSZWN0ID0gJGVsLmNoYXJ0Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdGNvbnN0IHN2Z0xlZnQgPSBzdmdSZWN0LnJpZ2h0IC0gY2hhcnRSZWN0LmxlZnQgLVxyXG5cdFx0XHQoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSk7XHJcblxyXG5cdFx0cmV0dXJuIHN2Z0xlZnQgPiAwID8gc3ZnTGVmdCA6IDA7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc1dpZHRoQnlBeGlzSWQoaWQ6IEF4aXNUeXBlLCB3aXRob3V0UmVjb21wdXRlPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCQkLmF4aXMpIHtcclxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSAkJC5heGlzICYmICQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpO1xyXG5cclxuXHRcdFx0cmV0dXJuICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSArXHJcblx0XHRcdFx0KHBvc2l0aW9uLmlzSW5uZXIgPyAyMCA6IDQwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiA0MDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRIb3Jpem9udGFsQXhpc0hlaWdodChpZDogQXhpc1R5cGUpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHtjdXJyZW50LCByb3RhdGVkUGFkZGluZywgaXNMZWdlbmRSaWdodCwgaXNMZWdlbmRJbnNldH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgaCA9IDMwO1xyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgIWNvbmZpZy5heGlzX3hfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gODtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiICYmIGNvbmZpZy5heGlzX3hfaGVpZ2h0KSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2hlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieVwiICYmICFjb25maWcuYXhpc195X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5sZWdlbmRfc2hvdyAmJlxyXG5cdFx0XHRcdCFpc0xlZ2VuZFJpZ2h0ICYmXHJcblx0XHRcdFx0IWlzTGVnZW5kSW5zZXQgPyAxMCA6IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInkyXCIgJiYgIWNvbmZpZy5heGlzX3kyX3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIHJvdGF0ZWRQYWRkaW5nLnRvcDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByb3RhdGUgPSAkJC5nZXRBeGlzVGlja1JvdGF0ZShpZCk7XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHgveSBheGlzIGhlaWdodCB3aGVuIHRpY2sgcm90YXRlZFxyXG5cdFx0aWYgKFxyXG5cdFx0XHQoKGlkID09PSBcInhcIiAmJiAhaXNSb3RhdGVkKSB8fCAoL3kyPy8udGVzdChpZCkgJiYgaXNSb3RhdGVkKSkgJiYgcm90YXRlXHJcblx0XHQpIHtcclxuXHRcdFx0aCA9IDMwICtcclxuXHRcdFx0XHQkJC5heGlzLmdldE1heFRpY2tXaWR0aChpZCkgKlxyXG5cdFx0XHRcdE1hdGguY29zKE1hdGguUEkgKiAoOTAgLSByb3RhdGUpIC8gMTgwKTtcclxuXHJcblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSAmJiBjdXJyZW50LmhlaWdodCkge1xyXG5cdFx0XHRcdGlmIChoID4gY3VycmVudC5oZWlnaHQgLyAyKSB7XHJcblx0XHRcdFx0XHRoID0gY3VycmVudC5oZWlnaHQgLyAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoICtcclxuXHRcdFx0KCQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpLmlzSW5uZXIgPyAwIDogMTApICtcclxuXHRcdFx0KGlkID09PSBcInkyXCIgJiYgIWlzUm90YXRlZCA/IC0xMCA6IDApO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50UmVjdFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5heGlzLngudGlja0ludGVydmFsKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBheGlzIHRpY2sgdGVzdCByb3RhdGUgdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHJvdGF0ZSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QXhpc1RpY2tSb3RhdGUoaWQ6IEF4aXNUeXBlKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzLCBjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRsZXQgcm90YXRlID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfcm90YXRlYF07XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIikge1xyXG5cdFx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gYXhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRcdGNvbnN0IGlzVGltZVNlcmllcyA9IGF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRcdGNvbnN0IGFsbG93ZWRYQXhpc1R5cGVzID0gaXNDYXRlZ29yaXplZCB8fCBpc1RpbWVTZXJpZXM7XHJcblx0XHRcdGxldCB0aWNrQ291bnQgPSAwO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3hfdGlja19maXQgJiYgYWxsb3dlZFhBeGlzVHlwZXMpIHtcclxuXHRcdFx0XHR0aWNrQ291bnQgPSBzdGF0ZS5jdXJyZW50Lm1heFRpY2tXaWR0aHMueC50aWNrcy5sZW5ndGggKyAoaXNUaW1lU2VyaWVzID8gLTEgOiAxKTtcclxuXHJcblx0XHRcdFx0aWYgKHRpY2tDb3VudCAhPT0gc3RhdGUuYXhpcy54LnRpY2tDb3VudCkge1xyXG5cdFx0XHRcdFx0c3RhdGUuYXhpcy54LnBhZGRpbmcgPSAkJC5heGlzLmdldFhBeGlzUGFkZGluZyh0aWNrQ291bnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUuYXhpcy54LnRpY2tDb3VudCA9IHRpY2tDb3VudDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCRlbC5zdmcgJiZcclxuXHRcdFx0XHRjb25maWcuYXhpc194X3RpY2tfZml0ICYmXHJcblx0XHRcdFx0IWNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiZcclxuXHRcdFx0XHQhY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgJiZcclxuXHRcdFx0XHRjb25maWcuYXhpc194X3RpY2tfYXV0b3JvdGF0ZSAmJlxyXG5cdFx0XHRcdGFsbG93ZWRYQXhpc1R5cGVzXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJvdGF0ZSA9ICQkLm5lZWRUb1JvdGF0ZVhBeGlzVGlja1RleHRzKCkgP1xyXG5cdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX3JvdGF0ZSA6IDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcm90YXRlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIHdlYXRoZXIgYXhpcyB0aWNrIHRleHQgbmVlZHMgdG8gYmUgcm90YXRlZFxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0bmVlZFRvUm90YXRlWEF4aXNUaWNrVGV4dHMoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHtheGlzLCBjdXJyZW50fX0gPSAkJDtcclxuXHRcdGNvbnN0IHhBeGlzTGVuZ3RoID0gY3VycmVudC53aWR0aCAtXHJcblx0XHRcdCQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdChmYWxzZSkgLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KHRydWUpO1xyXG5cdFx0Y29uc3QgdGlja0NvdW50V2l0aFBhZGRpbmcgPSBheGlzLngudGlja0NvdW50ICtcclxuXHRcdFx0YXhpcy54LnBhZGRpbmcubGVmdCArIGF4aXMueC5wYWRkaW5nLnJpZ2h0O1xyXG5cclxuXHRcdGNvbnN0IG1heFRpY2tXaWR0aCA9ICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKFwieFwiKTtcclxuXHRcdGNvbnN0IHRpY2tMZW5ndGggPSAoeEF4aXNMZW5ndGggLyB0aWNrQ291bnRXaXRoUGFkZGluZykgfHwgMDtcclxuXHJcblx0XHRyZXR1cm4gbWF4VGlja1dpZHRoID4gdGlja0xlbmd0aDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVEaW1lbnNpb24od2l0aG91dEF4aXM/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2hhc0F4aXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMgJiYgIXdpdGhvdXRBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5heGlzLnggJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5jcmVhdGUoJGVsLmF4aXMueCk7XHJcblx0XHRcdFx0JCQuYXhpcy5zdWJYICYmICQkLmF4aXMuc3ViWC5jcmVhdGUoJGVsLmF4aXMuc3ViWCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQuYXhpcy55ICYmICQkLmF4aXMueS5jcmVhdGUoJGVsLmF4aXMueSk7XHJcblx0XHRcdFx0JCQuYXhpcy55MiAmJiAkJC5heGlzLnkyLmNyZWF0ZSgkZWwuYXhpcy55Mik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBwYXNzICd3aXRob3V0QXhpcycgcGFyYW0gdG8gbm90IGFuaW1hdGUgYXQgdGhlIGluaXQgcmVuZGVyaW5nXHJcblx0XHQkJC51cGRhdGVTY2FsZXMod2l0aG91dEF4aXMpO1xyXG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cdFx0JCQudHJhbnNmb3JtQWxsKGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVTdmdTaXplKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdHN2Z1xyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLmN1cnJlbnQud2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmN1cnJlbnQuaGVpZ2h0KTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCBicnVzaCA9IHN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN2Zy5zZWxlY3RBbGwoW2AjJHtzdGF0ZS5jbGlwLmlkfWAsIGAjJHtzdGF0ZS5jbGlwLmlkR3JpZH1gXSlcclxuXHRcdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuaGVpZ2h0KTtcclxuXHJcblx0XHRcdHN2Zy5zZWxlY3QoYCMke3N0YXRlLmNsaXAuaWRYQXhpc31gKVxyXG5cdFx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFhBeGlzQ2xpcFguYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsICQkLmdldFhBeGlzQ2xpcFkuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRYQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFlBeGlzfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WUF4aXNDbGlwWC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WUF4aXNDbGlwWS5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFlBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHRzdGF0ZS5jbGlwLmlkU3ViY2hhcnQgJiYgc3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFN1YmNoYXJ0fWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGJydXNoU2l6ZS5oZWlnaHQpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1Muem9vbVJlY3R9YClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmhlaWdodCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNpemUgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0luaXQgSWYgaXMgY2FsbGVkIGF0IGluaXRpYWxpemF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplcyhpc0luaXQ/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bGVnZW5kfX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XHJcblxyXG5cdFx0IWlzSW5pdCAmJiAkJC5zZXRDb250YWluZXJTaXplKCk7XHJcblxyXG5cdFx0Y29uc3QgY3VyckxlZ2VuZCA9IHtcclxuXHRcdFx0d2lkdGg6IGxlZ2VuZCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IGxlZ2VuZCA/ICQkLmdldExlZ2VuZEhlaWdodCgpIDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBsZWdlbmRIZWlnaHRGb3JCb3R0b20gPSBzdGF0ZS5pc0xlZ2VuZFJpZ2h0IHx8IHN0YXRlLmlzTGVnZW5kSW5zZXQgPyAwIDogY3VyckxlZ2VuZC5oZWlnaHQ7XHJcblx0XHRjb25zdCB4QXhpc0hlaWdodCA9IGlzUm90YXRlZCB8fCBoYXNBcmMgPyAwIDogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ4XCIpO1xyXG5cclxuXHRcdGNvbnN0IHN1YmNoYXJ0WEF4aXNIZWlnaHQgPSBjb25maWcuc3ViY2hhcnRfYXhpc194X3Nob3cgJiYgY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdyA/XHJcblx0XHRcdHhBeGlzSGVpZ2h0IDogMzA7XHJcblx0XHRjb25zdCBzdWJjaGFydEhlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICFoYXNBcmMgP1xyXG5cdFx0XHQoY29uZmlnLnN1YmNoYXJ0X3NpemVfaGVpZ2h0ICsgc3ViY2hhcnRYQXhpc0hlaWdodCkgOiAwO1xyXG5cclxuXHRcdC8vIGZvciBtYWluXHJcblx0XHRzdGF0ZS5tYXJnaW4gPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdHRvcDogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ5MlwiKSArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksXHJcblx0XHRcdHJpZ2h0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpLFxyXG5cdFx0XHRib3R0b206ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieVwiKSArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXHJcblx0XHRcdGxlZnQ6IHN1YmNoYXJ0SGVpZ2h0ICsgKGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKSlcclxuXHRcdH0gOiB7XHJcblx0XHRcdHRvcDogNCArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksIC8vIGZvciB0b3AgdGljayB0ZXh0XHJcblx0XHRcdHJpZ2h0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpLFxyXG5cdFx0XHRib3R0b206IHhBeGlzSGVpZ2h0ICsgc3ViY2hhcnRIZWlnaHQgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxyXG5cdFx0XHRsZWZ0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KClcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZm9yIHN1YmNoYXJ0XHJcblx0XHRzdGF0ZS5tYXJnaW4yID0gaXNSb3RhdGVkID8ge1xyXG5cdFx0XHR0b3A6IHN0YXRlLm1hcmdpbi50b3AsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMjAgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXHJcblx0XHRcdGxlZnQ6ICQkLnN0YXRlLnJvdGF0ZWRQYWRkaW5nLmxlZnRcclxuXHRcdH0gOiB7XHJcblx0XHRcdHRvcDogc3RhdGUuY3VycmVudC5oZWlnaHQgLSBzdWJjaGFydEhlaWdodCAtIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiBzdWJjaGFydFhBeGlzSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxyXG5cdFx0XHRsZWZ0OiBzdGF0ZS5tYXJnaW4ubGVmdFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmb3IgbGVnZW5kXHJcblx0XHRzdGF0ZS5tYXJnaW4zID0ge1xyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0bGVmdDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC51cGRhdGVTaXplRm9yTGVnZW5kICYmICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQoY3VyckxlZ2VuZCk7XHJcblxyXG5cdFx0c3RhdGUud2lkdGggPSBzdGF0ZS5jdXJyZW50LndpZHRoIC0gc3RhdGUubWFyZ2luLmxlZnQgLSBzdGF0ZS5tYXJnaW4ucmlnaHQ7XHJcblx0XHRzdGF0ZS5oZWlnaHQgPSBzdGF0ZS5jdXJyZW50LmhlaWdodCAtIHN0YXRlLm1hcmdpbi50b3AgLSBzdGF0ZS5tYXJnaW4uYm90dG9tO1xyXG5cclxuXHRcdGlmIChzdGF0ZS53aWR0aCA8IDApIHtcclxuXHRcdFx0c3RhdGUud2lkdGggPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5oZWlnaHQgPCAwKSB7XHJcblx0XHRcdHN0YXRlLmhlaWdodCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUud2lkdGgyID0gaXNSb3RhdGVkID9cclxuXHRcdFx0c3RhdGUubWFyZ2luLmxlZnQgLSBzdGF0ZS5yb3RhdGVkUGFkZGluZy5sZWZ0IC0gc3RhdGUucm90YXRlZFBhZGRpbmcucmlnaHQgOiBzdGF0ZS53aWR0aDtcclxuXHJcblx0XHRzdGF0ZS5oZWlnaHQyID0gaXNSb3RhdGVkID9cclxuXHRcdFx0c3RhdGUuaGVpZ2h0IDogc3RhdGUuY3VycmVudC5oZWlnaHQgLSBzdGF0ZS5tYXJnaW4yLnRvcCAtIHN0YXRlLm1hcmdpbjIuYm90dG9tO1xyXG5cclxuXHRcdGlmIChzdGF0ZS53aWR0aDIgPCAwKSB7XHJcblx0XHRcdHN0YXRlLndpZHRoMiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmhlaWdodDIgPCAwKSB7XHJcblx0XHRcdHN0YXRlLmhlaWdodDIgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBhcmNcclxuXHRcdHN0YXRlLmFyY1dpZHRoID0gc3RhdGUud2lkdGggLSAoc3RhdGUuaXNMZWdlbmRSaWdodCA/IGN1cnJMZWdlbmQud2lkdGggKyAxMCA6IDApO1xyXG5cdFx0c3RhdGUuYXJjSGVpZ2h0ID0gc3RhdGUuaGVpZ2h0IC0gKHN0YXRlLmlzTGVnZW5kUmlnaHQgPyAwIDogMTApO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlKSB7XHJcblx0XHRcdHN0YXRlLmFyY0hlaWdodCArPSBzdGF0ZS5oZWlnaHQgLSAkJC5nZXRHYXVnZUxhYmVsSGVpZ2h0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlUmFkaXVzICYmICQkLnVwZGF0ZVJhZGl1cygpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0ICYmIGhhc0FyYykge1xyXG5cdFx0XHRzdGF0ZS5tYXJnaW4zLmxlZnQgPSBzdGF0ZS5hcmNXaWR0aCAvIDIgKyBzdGF0ZS5yYWRpdXNFeHBhbmRlZCAqIDEuMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWhhc0FyYyAmJiBjb25maWcuYXhpc194X3Nob3cgJiYgY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcpIHtcclxuXHRcdFx0JCQudXBkYXRlWEF4aXNUaWNrQ2xpcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGxcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7S0VZfSBmcm9tIFwiLi4vLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYXBpdGFsaXplLCBnZXRCb3VuZGluZ1JlY3QsIGdldFJhbmRvbSwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1N0cmluZywgZ2V0VHJhbnNsYXRpb259IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge0F4aXNUeXBlfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0b3BhY2l0eUZvclRleHQoKTogXCIxXCIgfCBcIjBcIiB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNEYXRhTGFiZWwoKSA/IFwiMVwiIDogXCIwXCI7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUZXh0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyRlbH0gPSB0aGlzO1xyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0VGV4dHMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjaGFydFRleHRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyAkJC5kYXRhLnRhcmdldHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRhcmdldHNGb3JUZXh0KHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRUZXh0ID0gJCQuY2xhc3NDaGFydFRleHQuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc1RleHRzID0gJCQuY2xhc3NUZXh0cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgbWFpblRleHRVcGRhdGUgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydFRleHR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRUZXh0KGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpblRleHRFbnRlciA9IG1haW5UZXh0VXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRUZXh0KVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0bWFpblRleHRFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0cyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRleHRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25Gb3JFeGl0IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhRm4gPSAkJC5sYWJlbGlzaERhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc1RleHQgPSAkJC5jbGFzc1RleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0JGVsLnRleHQgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dH1gKVxyXG5cdFx0XHQuZGF0YShkID0+ICh0aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBkYXRhRm4oZCkpKTtcclxuXHJcblx0XHQkZWwudGV4dC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwudGV4dCA9ICRlbC50ZXh0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0Lm1lcmdlKCQkLiRlbC50ZXh0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBkID0+IChjb25maWcuYXhpc19yb3RhdGVkID8gKGQudmFsdWUgPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIikgOiBcIm1pZGRsZVwiKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnRleHQoKGQsIGksIGopID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9ICQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInpcIikgOiBkLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKHZhbHVlLCBkLmlkLCBpLCBqKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGV4dENvbG9yKGQpOiBvYmplY3QgfCBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgbGFiZWxDb2xvcnMgPSAkJC5jb25maWcuZGF0YV9sYWJlbHNfY29sb3JzO1xyXG5cdFx0bGV0IGNvbG9yO1xyXG5cclxuXHRcdGlmIChpc1N0cmluZyhsYWJlbENvbG9ycykpIHtcclxuXHRcdFx0Y29sb3IgPSBsYWJlbENvbG9ycztcclxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QobGFiZWxDb2xvcnMpKSB7XHJcblx0XHRcdGNvbG9yID0gbGFiZWxDb2xvcnNbZC5pZF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbG9yIHx8ICQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyBjaGFydFRleHRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB4IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB4XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0geSBQb3NpdGlvbmluZyBmdW5jdGlvbiBmb3IgeVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yRmxvdyBXZWF0aGVyIGlzIGZsb3dcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd1RleHQoeCwgeSwgZm9yRmxvdz86IGJvb2xlYW4sIHdpdGhUcmFuc2l0aW9uPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdDogYW55ID0gZ2V0UmFuZG9tKCk7XHJcblx0XHRjb25zdCBvcGFjaXR5Rm9yVGV4dCA9IGZvckZsb3cgPyAwIDogJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0JCQuJGVsLnRleHQuZWFjaChmdW5jdGlvbihkLCBpOiBudW1iZXIpIHtcclxuXHRcdFx0Y29uc3QgdGV4dCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0Ly8gZG8gbm90IGFwcGx5IHRyYW5zaXRpb24gZm9yIG5ld2x5IGFkZGVkIHRleHQgZWxlbWVudHNcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uICYmIHRleHQuYXR0cihcInhcIikgPyB0ZXh0LnRyYW5zaXRpb24odCkgOiB0ZXh0KVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCB4LmJpbmQodGhpcykoZCwgaSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIGQgPT4geS5iaW5kKHRoaXMpKGQsIGkpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBvcGFjaXR5Rm9yVGV4dCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBuZWVkIHRvIHJldHVybiAndHJ1ZScgYXMgb2YgYmVpbmcgcHVzaGVkIHRvIHRoZSByZWRyYXcgbGlzdFxyXG5cdFx0Ly8gcmVmOiBnZXRSZWRyYXdMaXN0KClcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB2YWx1ZSBvZiB0aGUgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBlbGVtZW50IFRhcmdldCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyBuYW1lXHJcblx0ICogQHJldHVybnMge29iamVjdH0gdmFsdWUgb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGV4dFJlY3QoZWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcpOiBvYmplY3Qge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IGJhc2UgPSAoZWxlbWVudC5ub2RlID8gZWxlbWVudC5ub2RlKCkgOiBlbGVtZW50KTtcclxuXHJcblx0XHRpZiAoIS90ZXh0L2kudGVzdChiYXNlLnRhZ05hbWUpKSB7XHJcblx0XHRcdGJhc2UgPSBiYXNlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHQgPSBiYXNlLnRleHRDb250ZW50O1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBgJHtLRVkudGV4dFJlY3R9LSR7dGV4dC5yZXBsYWNlKC9cXFcvZywgXCJfXCIpfWA7XHJcblx0XHRsZXQgcmVjdCA9ICQkLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0aWYgKCFyZWN0KSB7XHJcblx0XHRcdCQkLiRlbC5zdmcuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250XCIsIGQzU2VsZWN0KGJhc2UpLnN0eWxlKFwiZm9udFwiKSlcclxuXHRcdFx0XHQuY2xhc3NlZChjbGFzc05hbWUsIHRydWUpXHJcblx0XHRcdFx0LnRleHQodGV4dClcclxuXHRcdFx0XHQuY2FsbCh2ID0+IHtcclxuXHRcdFx0XHRcdHJlY3QgPSBnZXRCb3VuZGluZ1JlY3Qodi5ub2RlKCkpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCByZWN0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB4IG9yIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbmRpY2VzIEluZGljZXMgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBmb3JYIHdoZXRoZXIgb3Igbm90IHRvIHhcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBjb29yZGluYXRlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVYWUZvclRleHQoaW5kaWNlcywgZm9yWD86IGJvb2xlYW4pOiAoZCwgaSkgPT4gbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHR5cGVzID0gT2JqZWN0LmtleXMoaW5kaWNlcyk7XHJcblx0XHRjb25zdCBwb2ludHMgPSB7fTtcclxuXHRcdGNvbnN0IGdldHRlciA9IGZvclggPyAkJC5nZXRYRm9yVGV4dCA6ICQkLmdldFlGb3JUZXh0O1xyXG5cclxuXHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiB0eXBlcy5wdXNoKFwicmFkYXJcIik7XHJcblxyXG5cdFx0dHlwZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0cG9pbnRzW3ZdID0gJCRbYGdlbmVyYXRlR2V0JHtjYXBpdGFsaXplKHYpfVBvaW50c2BdKGluZGljZXNbdl0sIGZhbHNlKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdGNvbnN0IHR5cGUgPSAoJCQuaXNBcmVhVHlwZShkKSAmJiBcImFyZWFcIikgfHxcclxuXHRcdFx0XHQoJCQuaXNCYXJUeXBlKGQpICYmIFwiYmFyXCIpIHx8XHJcblx0XHRcdFx0KCQkLmlzUmFkYXJUeXBlKGQpICYmIFwicmFkYXJcIikgfHwgXCJsaW5lXCI7XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2V0dGVyLmNhbGwoJCQsIHBvaW50c1t0eXBlXShkLCBpKSwgZCwgdGhpcyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBjZW50ZXJpemVkIHRleHQgcG9zaXRpb24gZm9yIGJhciB0eXBlIGRhdGEubGFiZWwudGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGV4dEVsZW1lbnQgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2xhYmVscy5jZW50ZXJlZCAmJiAkJC5pc0JhclR5cGUoZCkpIHtcclxuXHRcdFx0Y29uc3QgcmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGlzUG9zaXRpdmUgPSBkLnZhbHVlID49IDA7XHJcblxyXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgdyA9IChcclxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV0gOlxyXG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV1cclxuXHRcdFx0XHQpIC8gMiArIChyZWN0LndpZHRoIC8gMik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gLXcgLSAzIDogdyArIDI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgaCA9IChcclxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV0gOlxyXG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV1cclxuXHRcdFx0XHQpIC8gMiArIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaXNQb3NpdGl2ZSA/IGggOiAtaCAtIDI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YS5sYWJlbHMucG9zaXRpb24gdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgRGF0YSBpZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHggfCB5XHJcblx0ICogQHJldHVybnMge251bWJlcn0gUG9zaXRpb24gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRleHRQb3MoaWQsIHR5cGUpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgcG9zID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHNfcG9zaXRpb247XHJcblxyXG5cdFx0cmV0dXJuIChpZCBpbiBwb3MgPyBwb3NbaWRdIDogcG9zKVt0eXBlXSB8fCAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludHMgRGF0YSBwb2ludHMgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRleHRFbGVtZW50IERhdGEgbGFiZWwgdGV4dCBlbGVtZW50XHJcblx0ICogQHJldHVybnMge251bWJlcn0geCBjb29yZGluYXRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRYRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCB4UG9zO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nID0gJCQuaXNCYXJUeXBlKGQpID8gNCA6IDY7XHJcblx0XHRcdHhQb3MgPSBwb2ludHNbMl1bMV0gKyBwYWRkaW5nICogKGQudmFsdWUgPCAwID8gLTEgOiAxKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHhQb3MgPSAkJC5oYXNUeXBlKFwiYmFyXCIpID8gKHBvaW50c1syXVswXSArIHBvaW50c1swXVswXSkgLyAyIDogcG9pbnRzWzBdWzBdO1xyXG5cdFx0fVxyXG5cdFx0Ly8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcclxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsKSB7XHJcblx0XHRcdGlmICh4UG9zID4gc3RhdGUud2lkdGgpIHtcclxuXHRcdFx0XHRjb25zdCB7d2lkdGh9ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHJcblx0XHRcdFx0eFBvcyA9IHN0YXRlLndpZHRoIC0gd2lkdGg7XHJcblx0XHRcdH0gZWxzZSBpZiAoeFBvcyA8IDApIHtcclxuXHRcdFx0XHR4UG9zID0gNDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0eFBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHhQb3MgKyAkJC5nZXRUZXh0UG9zKGQuaWQsIFwieFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZXh0RWxlbWVudCBEYXRhIGxhYmVsIHRleHQgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHkgY29vcmRpbmF0ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WUZvclRleHQocG9pbnRzLCBkLCB0ZXh0RWxlbWVudCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCByID0gY29uZmlnLnBvaW50X3I7XHJcblx0XHRjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHRcdGxldCBiYXNlWSA9IDM7XHJcblx0XHRsZXQgeVBvcztcclxuXHJcblx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHlQb3MgPSAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzJdWzBdICsgcmVjdC5oZWlnaHQgKiAwLjYpIC8gMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlQb3MgPSBwb2ludHNbMl1bMV07XHJcblxyXG5cdFx0XHRpZiAoaXNOdW1iZXIocikgJiYgciA+IDUgJiYgKCQkLmlzTGluZVR5cGUoZCkgfHwgJCQuaXNTY2F0dGVyVHlwZShkKSkpIHtcclxuXHRcdFx0XHRiYXNlWSArPSBjb25maWcucG9pbnRfciAvIDIuMztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGQudmFsdWUgPCAwIHx8IChkLnZhbHVlID09PSAwICYmICFzdGF0ZS5oYXNQb3NpdGl2ZVZhbHVlICYmIHN0YXRlLmhhc05lZ2F0aXZlVmFsdWUpKSB7XHJcblx0XHRcdFx0eVBvcyArPSByZWN0LmhlaWdodCArICgkJC5pc0JhclR5cGUoZCkgPyAtYmFzZVkgOiBiYXNlWSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGRpZmYgPSAtYmFzZVkgKiAyO1xyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNCYXJUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRkaWZmID0gLWJhc2VZO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRkaWZmID0gYmFzZVk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR5UG9zICs9IGRpZmY7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxyXG5cdFx0aWYgKGQudmFsdWUgPT09IG51bGwgJiYgIWlzUm90YXRlZCkge1xyXG5cdFx0XHRjb25zdCBib3hIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuXHJcblx0XHRcdGlmICh5UG9zIDwgYm94SGVpZ2h0KSB7XHJcblx0XHRcdFx0eVBvcyA9IGJveEhlaWdodDtcclxuXHRcdFx0fSBlbHNlIGlmICh5UG9zID4gc3RhdGUuaGVpZ2h0KSB7XHJcblx0XHRcdFx0eVBvcyA9IHN0YXRlLmhlaWdodCAtIDQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWlzUm90YXRlZCkge1xyXG5cdFx0XHR5UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geVBvcyArICQkLmdldFRleHRQb3MoZC5pZCwgXCJ5XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBpZiB0d28gb3IgbW9yZSB0ZXh0IG5vZGVzIGFyZSBvdmVybGFwcGluZ1xyXG5cdCAqIE1hcmsgb3ZlcmxhcHBpbmcgdGV4dCBub2RlcyB3aXRoIFwidGV4dC1vdmVybGFwcGluZ1wiIGNsYXNzXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIEF4aXMgaWRcclxuXHQgKiBAcGFyYW0ge0NoYXJ0SW50ZXJuYWx9ICQkIENoYXJ0SW50ZXJuYWwgY29udGV4dFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciBzdHJpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG1hcmtPdmVybGFwcGVkKGlkOiBBeGlzVHlwZSwgJCQsIHNlbGVjdG9yOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHRleHROb2RlcyA9ICQkLiRlbC5hcmNzLnNlbGVjdEFsbChzZWxlY3Rvcik7XHJcblx0XHRjb25zdCBmaWx0ZXJlZFRleHROb2RlcyA9IHRleHROb2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmRhdGEuaWQgIT09IGlkKTtcclxuXHRcdGNvbnN0IHRleHROb2RlID0gdGV4dE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUuZGF0YS5pZCA9PT0gaWQpO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gZ2V0VHJhbnNsYXRpb24odGV4dE5vZGUubm9kZSgpKTtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhlIGh5cG90ZW51c2VcclxuXHRcdGNvbnN0IGNhbGNIeXBvID0gKHgsIHkpID0+IE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcclxuXHJcblx0XHR0ZXh0Tm9kZS5ub2RlKCkgJiYgZmlsdGVyZWRUZXh0Tm9kZXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZSA9IGdldFRyYW5zbGF0aW9uKHRoaXMpO1xyXG5cdFx0XHRjb25zdCBmaWx0ZXJlZFRleHROb2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdGNvbnN0IG5vZGVGb3JXaWR0aCA9IGNhbGNIeXBvKHRyYW5zbGF0ZS5lLCB0cmFuc2xhdGUuZikgPiBjYWxjSHlwbyhjb29yZGluYXRlLmUsIGNvb3JkaW5hdGUuZikgP1xyXG5cdFx0XHRcdHRleHROb2RlIDogZmlsdGVyZWRUZXh0Tm9kZTtcclxuXHJcblx0XHRcdGNvbnN0IG92ZXJsYXBzWCA9IE1hdGguY2VpbChNYXRoLmFicyh0cmFuc2xhdGUuZSAtIGNvb3JkaW5hdGUuZSkpIDxcclxuXHRcdFx0XHRNYXRoLmNlaWwobm9kZUZvcldpZHRoLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSk7XHJcblx0XHRcdGNvbnN0IG92ZXJsYXBzWSA9IE1hdGguY2VpbChNYXRoLmFicyh0cmFuc2xhdGUuZiAtIGNvb3JkaW5hdGUuZikpIDxcclxuXHRcdFx0XHRwYXJzZUludCh0ZXh0Tm9kZS5zdHlsZShcImZvbnQtc2l6ZVwiKSwgMCk7XHJcblxyXG5cdFx0XHRmaWx0ZXJlZFRleHROb2RlLmNsYXNzZWQoQ0xBU1MuVGV4dE92ZXJsYXBwaW5nLCBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBpZiB0d28gb3IgbW9yZSB0ZXh0IG5vZGVzIGFyZSBvdmVybGFwcGluZ1xyXG5cdCAqIFJlbW92ZSBcInRleHQtb3ZlcmxhcHBpbmdcIiBjbGFzcyBvbiBzZWxlY3RlZCB0ZXh0IG5vZGVzXHJcblx0ICogQHBhcmFtIHtDaGFydEludGVybmFsfSAkJCBDaGFydEludGVybmFsIGNvbnRleHRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3Igc3RyaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1bmRvTWFya092ZXJsYXBwZWQoJCQsIHNlbGVjdG9yKTogdm9pZCB7XHJcblx0XHQkJC4kZWwuYXJjcy5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGQzU2VsZWN0QWxsKFt0aGlzLCB0aGlzLnByZXZpb3VzU2libGluZ10pXHJcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5UZXh0T3ZlcmxhcHBpbmcsIGZhbHNlKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNOdW1iZXIsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHRleHQgcG9zaXRpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHBvcyByaWdodCwgbGVmdCBvciBjZW50ZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIGNoYXJ0IHdpZHRoXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB0ZXh0LWFuY2hvciB2YWx1ZSBvciBwb3NpdGlvbiBpbiBwaXhlbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGV4dFBvcyhwb3MgPSBcImxlZnRcIiwgd2lkdGg/OiBudW1iZXIgfCBhbnkpOiBudW1iZXIgfCBcInN0YXJ0XCIgfCBcIm1pZGRsZVwiIHwgXCJlbmRcIiB7XHJcblx0Y29uc3QgaXNOdW0gPSBpc051bWJlcih3aWR0aCk7XHJcblx0bGV0IHBvc2l0aW9uO1xyXG5cclxuXHRpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikgPiAtMSkge1xyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IHdpZHRoIC8gMiA6IFwibWlkZGxlXCI7XHJcblx0fSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpID4gLTEpIHtcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyB3aWR0aCA6IFwiZW5kXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyAwIDogXCJzdGFydFwiO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvc2l0aW9uO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VGl0bGUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy50aXRsZV90ZXh0KSB7XHJcblx0XHRcdCRlbC50aXRsZSA9ICRlbC5zdmcuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHRcdGNvbnN0IHRleHQgPSAkZWwudGl0bGVcclxuXHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIGdldFRleHRQb3MoY29uZmlnLnRpdGxlX3Bvc2l0aW9uKSlcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRpdGxlKTtcclxuXHJcblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCBjb25maWcudGl0bGVfdGV4dCwgWzAuMywgMS41XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdUaXRsZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y3VycmVudH0sICRlbDoge3RpdGxlfX0gPSAkJDtcclxuXHJcblx0XHRpZiAodGl0bGUpIHtcclxuXHRcdFx0Y29uc3QgeSA9ICQkLnlGb3JUaXRsZS5jYWxsKCQkKTtcclxuXHJcblx0XHRcdGlmICgvZy9pLnRlc3QodGl0bGUubm9kZSgpLnRhZ05hbWUpKSB7XHJcblx0XHRcdFx0dGl0bGUuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7Z2V0VGV4dFBvcyhjb25maWcudGl0bGVfcG9zaXRpb24sIGN1cnJlbnQud2lkdGgpfSwgJHt5fSlgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aXRsZS5hdHRyKFwieFwiLCAkJC54Rm9yVGl0bGUuY2FsbCgkJCkpLmF0dHIoXCJ5XCIsIHkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgeCBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIHRpdGxlXHJcblx0ICogQHJldHVybnMge251bWJlcn0geCBhdHRyaWJ1dGUgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHhGb3JUaXRsZSgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fX0gPSAkJDtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gY29uZmlnLnRpdGxlX3Bvc2l0aW9uIHx8IFwibGVmdFwiO1xyXG5cdFx0Y29uc3QgdGV4dFJlY3RXaWR0aCA9ICQkLmdldFRleHRSZWN0KCQkLiRlbC50aXRsZSwgQ0xBU1MudGl0bGUpLndpZHRoO1xyXG5cdFx0bGV0IHg7XHJcblxyXG5cdFx0aWYgKC8ocmlnaHR8Y2VudGVyKS8udGVzdChwb3NpdGlvbikpIHtcclxuXHRcdFx0eCA9IGN1cnJlbnQud2lkdGggLSB0ZXh0UmVjdFdpZHRoO1xyXG5cclxuXHRcdFx0aWYgKHBvc2l0aW9uLmluZGV4T2YoXCJyaWdodFwiKSA+PSAwKSB7XHJcblx0XHRcdFx0eCA9IGN1cnJlbnQud2lkdGggLSB0ZXh0UmVjdFdpZHRoIC0gY29uZmlnLnRpdGxlX3BhZGRpbmcucmlnaHQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaW5kZXhPZihcImNlbnRlclwiKSA+PSAwKSB7XHJcblx0XHRcdFx0eCA9IChjdXJyZW50LndpZHRoIC0gdGV4dFJlY3RXaWR0aCkgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgeyAvLyBsZWZ0XHJcblx0XHRcdHggPSAoY29uZmlnLnRpdGxlX3BhZGRpbmcubGVmdCB8fCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB5IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB5IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0eUZvclRpdGxlKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICgkJC5jb25maWcudGl0bGVfcGFkZGluZy50b3AgfHwgMCkgK1xyXG5cdFx0XHQkJC5nZXRUZXh0UmVjdCgkJC4kZWwudGl0bGUsIENMQVNTLnRpdGxlKS5oZWlnaHQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpdGxlIHBhZGRpbmdcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBwYWRkaW5nIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaXRsZVBhZGRpbmcoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQueUZvclRpdGxlKCkgKyAoJCQuY29uZmlnLnRpdGxlX3BhZGRpbmcuYm90dG9tIHx8IDApO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0bW91c2UgYXMgZDNNb3VzZVxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVmFsdWUsIGNhbGxGbiwgc2FuaXRpc2UsIHRwbFByb2Nlc3MsIGlzVW5kZWZpbmVkLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VG9vbHRpcCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHtiaW5kdG99ID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblxyXG5cdFx0JGVsLnRvb2x0aXAgPSBkM1NlbGVjdChiaW5kdG8pO1xyXG5cclxuXHRcdGlmICgkZWwudG9vbHRpcC5lbXB0eSgpKSB7XHJcblx0XHRcdCRlbC50b29sdGlwID0gJGVsLmNoYXJ0XHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJkaXZcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRvb2x0aXBDb250YWluZXIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNob3cgdG9vbHRpcCBpZiBuZWVkZWRcclxuXHRcdGlmIChjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcclxuXHRcdFx0aWYgKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgJiYgaXNTdHJpbmcoY29uZmlnLnRvb2x0aXBfaW5pdF94KSkge1xyXG5cdFx0XHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHNbMF07XHJcblx0XHRcdFx0bGV0IGk7XHJcblx0XHRcdFx0bGV0IHZhbDtcclxuXHJcblx0XHRcdFx0Y29uZmlnLnRvb2x0aXBfaW5pdF94ID0gcGFyc2VEYXRlLmNhbGwoJCQsIGNvbmZpZy50b29sdGlwX2luaXRfeCk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSA9IDA7ICh2YWwgPSB0YXJnZXRzLnZhbHVlc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKCh2YWwueCAtIGNvbmZpZy50b29sdGlwX2luaXRfeCkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSBpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkZWwudG9vbHRpcC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxyXG5cdFx0XHRcdCQkLmRhdGEudGFyZ2V0cy5tYXAoZCA9PiAkJC5hZGROYW1lKGQudmFsdWVzW2NvbmZpZy50b29sdGlwX2luaXRfeF0pKSxcclxuXHRcdFx0XHQkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLFxyXG5cdFx0XHRcdCQkLmdldFlGb3JtYXQoJCQuaGFzQXJjVHlwZShudWxsLCBbXCJyYWRhclwiXSkpLFxyXG5cdFx0XHRcdCQkLmNvbG9yXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdFx0aWYgKCFiaW5kdG8pIHtcclxuXHRcdFx0XHQkZWwudG9vbHRpcC5zdHlsZShcInRvcFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLnRvcClcclxuXHRcdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi5sZWZ0KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuYmluZFRvb2x0aXBSZXNpemVQb3MoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHRvb2x0aXAgSFRNTCBzdHJpbmdcclxuXHQgKiBAcGFyYW0gIHtBcnJheX0gYXJncyBBcmd1bWVudHNcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgSFRNTCBzdHJpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvb2x0aXBIVE1MKC4uLmFyZ3MpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKSA/XHJcblx0XHRcdGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmQoYXBpKSguLi5hcmdzKSA6ICQkLmdldFRvb2x0aXBDb250ZW50KC4uLmFyZ3MpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRvb2x0aXAgY29udGVudChIVE1MIHN0cmluZylcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBkYXRhXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFZhbHVlRm9ybWF0IERlZmF1bHQgZm9ybWF0IGZvciBlYWNoIGRhdGEgdmFsdWUgaW4gdGhlIHRvb2x0aXAuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3IgQ29sb3IgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGxldCBbdGl0bGVGb3JtYXQsIG5hbWVGb3JtYXQsIHZhbHVlRm9ybWF0XSA9IFtcInRpdGxlXCIsIFwibmFtZVwiLCBcInZhbHVlXCJdLm1hcCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgZm4gPSBjb25maWdbYHRvb2x0aXBfZm9ybWF0XyR7dn1gXTtcclxuXHJcblx0XHRcdHJldHVybiBpc0Z1bmN0aW9uKGZuKSA/IGZuLmJpbmQoYXBpKSA6IGZuO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGl0bGVGb3JtYXQgPSB0aXRsZUZvcm1hdCB8fCBkZWZhdWx0VGl0bGVGb3JtYXQ7XHJcblx0XHRuYW1lRm9ybWF0ID0gbmFtZUZvcm1hdCB8fCAobmFtZSA9PiBuYW1lKTtcclxuXHRcdHZhbHVlRm9ybWF0ID0gdmFsdWVGb3JtYXQgfHwgKFxyXG5cdFx0XHQkJC5pc1N0YWNrTm9ybWFsaXplZCgpID8gKHYsIHJhdGlvKSA9PiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JWAgOiBkZWZhdWx0VmFsdWVGb3JtYXRcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3Qgb3JkZXIgPSBjb25maWcudG9vbHRpcF9vcmRlcjtcclxuXHRcdGNvbnN0IGdldFJvd1ZhbHVlID0gcm93ID0+ICgkJC5heGlzICYmICQkLmlzQnViYmxlWlR5cGUocm93KSA/ICQkLmdldEJ1YmJsZVpEYXRhKHJvdy52YWx1ZSwgXCJ6XCIpIDogJCQuZ2V0QmFzZVZhbHVlKHJvdykpO1xyXG5cdFx0Y29uc3QgZ2V0QmdDb2xvciA9ICQkLmxldmVsQ29sb3IgPyByb3cgPT4gJCQubGV2ZWxDb2xvcihyb3cudmFsdWUpIDogcm93ID0+IGNvbG9yKHJvdyk7XHJcblx0XHRjb25zdCBjb250ZW50cyA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzO1xyXG5cdFx0Y29uc3QgdHBsU3RyID0gY29udGVudHMudGVtcGxhdGU7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcygpO1xyXG5cclxuXHRcdGlmIChvcmRlciA9PT0gbnVsbCAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoKSB7XHJcblx0XHRcdC8vIGZvciBzdGFja2VkIGRhdGEsIG9yZGVyIHNob3VsZCBhbGlnbmVkIHdpdGggdGhlIHZpc3VhbGx5IGRpc3BsYXllZCBkYXRhXHJcblx0XHRcdGNvbnN0IGlkcyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpXHJcblx0XHRcdFx0Lm1hcChpMiA9PiBpMi5pZClcclxuXHRcdFx0XHQucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0ZC5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0bGV0IHYxID0gYSA/IGEudmFsdWUgOiBudWxsO1xyXG5cdFx0XHRcdGxldCB2MiA9IGIgPyBiLnZhbHVlIDogbnVsbDtcclxuXHJcblx0XHRcdFx0aWYgKHYxID4gMCAmJiB2MiA+IDApIHtcclxuXHRcdFx0XHRcdHYxID0gYS5pZCA/IGlkcy5pbmRleE9mKGEuaWQpIDogbnVsbDtcclxuXHRcdFx0XHRcdHYyID0gYi5pZCA/IGlkcy5pbmRleE9mKGIuaWQpIDogbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB2MSAtIHYyO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoL14oYXNjfGRlc2MpJC8udGVzdChvcmRlcikpIHtcclxuXHRcdFx0Y29uc3QgaXNBc2NlbmRpbmcgPSBvcmRlciA9PT0gXCJhc2NcIjtcclxuXHJcblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHYxID0gYSA/IGdldFJvd1ZhbHVlKGEpIDogbnVsbDtcclxuXHRcdFx0XHRjb25zdCB2MiA9IGIgPyBnZXRSb3dWYWx1ZShiKSA6IG51bGw7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc0FzY2VuZGluZyA/IHYxIC0gdjIgOiB2MiAtIHYxO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvcmRlcikpIHtcclxuXHRcdFx0ZC5zb3J0KG9yZGVyLmJpbmQoYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdHBsID0gJCQuZ2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpO1xyXG5cdFx0Y29uc3QgbGVuID0gZC5sZW5ndGg7XHJcblx0XHRsZXQgdGV4dDtcclxuXHRcdGxldCByb3c7XHJcblx0XHRsZXQgcGFyYW07XHJcblx0XHRsZXQgdmFsdWU7XHJcblx0XHRsZXQgaTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cm93ID0gZFtpXTtcclxuXHJcblx0XHRcdGlmICghcm93IHx8ICEoZ2V0Um93VmFsdWUocm93KSB8fCBnZXRSb3dWYWx1ZShyb3cpID09PSAwKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQodGV4dCkpIHtcclxuXHRcdFx0XHRjb25zdCB0aXRsZSA9IHNhbml0aXNlKHRpdGxlRm9ybWF0ID8gdGl0bGVGb3JtYXQocm93LngpIDogcm93LngpO1xyXG5cclxuXHRcdFx0XHR0ZXh0ID0gdHBsUHJvY2Vzcyh0cGxbMF0sIHtcclxuXHRcdFx0XHRcdENMQVNTX1RPT0xUSVA6IENMQVNTLnRvb2x0aXAsXHJcblx0XHRcdFx0XHRUSVRMRTogaXNWYWx1ZSh0aXRsZSkgPyAoXHJcblx0XHRcdFx0XHRcdHRwbFN0ciA/IHRpdGxlIDogYDx0cj48dGggY29sc3Bhbj1cIjJcIj4ke3RpdGxlfTwvdGg+PC90cj5gXHJcblx0XHRcdFx0XHQpIDogXCJcIlxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJhbSA9IFtyb3cucmF0aW8sIHJvdy5pZCwgcm93LmluZGV4LCBkXTtcclxuXHRcdFx0dmFsdWUgPSBzYW5pdGlzZSh2YWx1ZUZvcm1hdChnZXRSb3dWYWx1ZShyb3cpLCAuLi5wYXJhbSkpO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVJhbmdlVHlwZShyb3cpKSB7XHJcblx0XHRcdFx0Y29uc3QgW2hpZ2gsIGxvd10gPSBbXCJoaWdoXCIsIFwibG93XCJdLm1hcCh2ID0+IHNhbml0aXNlKFxyXG5cdFx0XHRcdFx0dmFsdWVGb3JtYXQoJCQuZ2V0QXJlYVJhbmdlRGF0YShyb3csIHYpLCAuLi5wYXJhbSlcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBgPGI+TWlkOjwvYj4gJHt2YWx1ZX0gPGI+SGlnaDo8L2I+ICR7aGlnaH0gPGI+TG93OjwvYj4gJHtsb3d9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxyXG5cdFx0XHRcdGlmIChyb3cubmFtZSA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBuYW1lID0gc2FuaXRpc2UobmFtZUZvcm1hdChyb3cubmFtZSwgLi4ucGFyYW0pKTtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9IGdldEJnQ29sb3Iocm93KTtcclxuXHRcdFx0XHRjb25zdCBjb250ZW50VmFsdWUgPSB7XHJcblx0XHRcdFx0XHRDTEFTU19UT09MVElQX05BTUU6IENMQVNTLnRvb2x0aXBOYW1lICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgocm93LmlkKSxcclxuXHRcdFx0XHRcdENPTE9SOiAodHBsU3RyIHx8ICEkJC5wYXR0ZXJucykgPyBjb2xvciA6IGA8c3ZnPjxyZWN0IHN0eWxlPVwiZmlsbDoke2NvbG9yfVwiIHdpZHRoPVwiMTBcIiBoZWlnaHQ9XCIxMFwiPjwvcmVjdD48L3N2Zz5gLFxyXG5cdFx0XHRcdFx0TkFNRTogbmFtZSxcclxuXHRcdFx0XHRcdFZBTFVFOiB2YWx1ZVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGlmICh0cGxTdHIgJiYgaXNPYmplY3QoY29udGVudHMudGV4dCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdGFyZ2V0SWRzLmluZGV4T2Yocm93LmlkKTtcclxuXHJcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhjb250ZW50cy50ZXh0KS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRWYWx1ZVtrZXldID0gY29udGVudHMudGV4dFtrZXldW2luZGV4XTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dCArPSB0cGxQcm9jZXNzKHRwbFsxXSwgY29udGVudFZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgJHt0ZXh0fTwvdGFibGU+YDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGNvbnRlbnQgdGVtcGxhdGUgc3RyaW5nXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRwbFN0ciBUZW1wYWx0ZSBzdHJpbmdcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRlbXBsYXRlIHN0cmluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gKHRwbFN0ciB8fCBgPHRhYmxlIGNsYXNzPVwiez1DTEFTU19UT09MVElQfVwiPjx0Ym9keT5cclxuXHRcdFx0XHR7PVRJVExFfVxyXG5cdFx0XHRcdHt7PHRyIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+XHJcblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJuYW1lXCI+JHt0aGlzLnBhdHRlcm5zID8gYHs9Q09MT1J9YCA6IGA8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ez1DT0xPUn1cIj48L3NwYW4+YH17PU5BTUV9PC90ZD5cclxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cInZhbHVlXCI+ez1WQUxVRX08L3RkPlxyXG5cdFx0XHRcdDwvdHI+fX1cclxuXHRcdFx0PC90Ym9keT48L3RhYmxlPmApXHJcblx0XHRcdC5yZXBsYWNlKC8oXFxyP1xcbnxcXHQpL2csIFwiXCIpXHJcblx0XHRcdC5zcGxpdCgve3soLiopfX0vKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVG9TaG93IGRhdGFcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdFdpZHRoIFdpZHRoIHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0SGVpZ2h0IEhlaWdodCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvcCwgbGVmdCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9vbHRpcFBvc2l0aW9uKGRhdGFUb1Nob3csIHRXaWR0aDogbnVtYmVyLCB0SGVpZ2h0OiBudW1iZXIsIGVsZW1lbnQpOlxyXG5cdFx0e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHQsIGN1cnJlbnQsIGlzTGVnZW5kUmlnaHQsIGlucHV0VHlwZX0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcclxuXHRcdGNvbnN0IHN2Z0xlZnQgPSAkJC5nZXRTdmdMZWZ0KHRydWUpO1xyXG5cdFx0bGV0IFtsZWZ0LCB0b3BdID0gZDNNb3VzZShlbGVtZW50KTtcclxuXHRcdGxldCBjaGFydFJpZ2h0ID0gc3ZnTGVmdCArIGN1cnJlbnQud2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KHRydWUpO1xyXG5cdFx0Y29uc3QgY2hhcnRMZWZ0ID0gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHRydWUpO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IDIwO1xyXG5cclxuXHRcdHRvcCArPSBzaXplO1xyXG5cclxuXHRcdC8vIERldGVybWluZSB0b29sdGlwIHBvc2l0aW9uXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdGNvbnN0IHJhdyA9IGlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcclxuXHJcblx0XHRcdGlmICghcmF3KSB7XHJcblx0XHRcdFx0dG9wICs9IGhhc0dhdWdlID8gaGVpZ2h0IDogaGVpZ2h0IC8gMjtcclxuXHRcdFx0XHRsZWZ0ICs9ICh3aWR0aCAtIChpc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDApKSAvIDI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRhdGFTY2FsZSA9IHNjYWxlLngoZGF0YVRvU2hvd1swXS54KTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdFx0dG9wID0gZGF0YVNjYWxlICsgc2l6ZTtcclxuXHRcdFx0XHRsZWZ0ICs9IHN2Z0xlZnQgKyAxMDA7XHJcblx0XHRcdFx0Y2hhcnRSaWdodCAtPSBzdmdMZWZ0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRvcCAtPSA1O1xyXG5cdFx0XHRcdGxlZnQgPSBzdmdMZWZ0ICsgY2hhcnRMZWZ0ICsgc2l6ZSArICgkJC56b29tU2NhbGUgPyBsZWZ0IDogZGF0YVNjYWxlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdoZW4gdG9vbHRpcCBsZWZ0ICsgdFdpZHRoID4gY2hhcnQncyB3aWR0aFxyXG5cdFx0aWYgKChsZWZ0ICsgdFdpZHRoICsgMTUpID4gY2hhcnRSaWdodCkge1xyXG5cdFx0XHRsZWZ0IC09IHRXaWR0aCArIGNoYXJ0TGVmdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodG9wICsgdEhlaWdodCA+IGN1cnJlbnQuaGVpZ2h0KSB7XHJcblx0XHRcdHRvcCAtPSBoYXNHYXVnZSA/IHRIZWlnaHQgKiAzIDogdEhlaWdodCArIDMwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0b3AgPCAwKSB7XHJcblx0XHRcdHRvcCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt0b3AsIGxlZnR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgdGhlIHRvb2x0aXBcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VsZWN0ZWREYXRhIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUb29sdGlwIGVsZW1lbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgZWxlbWVudCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3Rvb2x0aXB9fSA9ICQkO1xyXG5cdFx0Y29uc3Qge2JpbmR0b30gPSBjb25maWcudG9vbHRpcF9jb250ZW50cztcclxuXHRcdGNvbnN0IGZvckFyYyA9ICQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pO1xyXG5cdFx0Y29uc3QgZGF0YVRvU2hvdyA9IHNlbGVjdGVkRGF0YS5maWx0ZXIoZCA9PiBkICYmIGlzVmFsdWUoJCQuZ2V0QmFzZVZhbHVlKGQpKSk7XHJcblxyXG5cdFx0aWYgKGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICFjb25maWcudG9vbHRpcF9zaG93KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZGF0dW0gPSB0b29sdGlwLmRhdHVtKCk7XHJcblx0XHRsZXQge3dpZHRoID0gMCwgaGVpZ2h0ID0gMH0gPSBkYXR1bSB8fCB7fTtcclxuXHRcdGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdGlmICghZGF0dW0gfHwgZGF0dW0uY3VycmVudCAhPT0gZGF0YVN0cikge1xyXG5cdFx0XHRjb25zdCBpbmRleCA9IHNlbGVjdGVkRGF0YS5jb25jYXQoKS5zb3J0KClbMF0uaW5kZXg7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25zaG93LCAkJC5hcGksIHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBjb250ZW50XHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcclxuXHRcdFx0XHRcdHNlbGVjdGVkRGF0YSwgLy8gZGF0YVxyXG5cdFx0XHRcdFx0JCQuYXhpcyA/ICQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCkgOiAkJC5jYXRlZ29yeU5hbWUuYmluZCgkJCksIC8vIGRlZmF1bHRUaXRsZUZvcm1hdFxyXG5cdFx0XHRcdFx0JCQuZ2V0WUZvcm1hdChmb3JBcmMpLCAvLyBkZWZhdWx0VmFsdWVGb3JtYXRcclxuXHRcdFx0XHRcdCQkLmNvbG9yIC8vIGNvbG9yXHJcblx0XHRcdFx0KSlcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBudWxsKSAvLyBmb3IgSUU5XHJcblx0XHRcdFx0LmRhdHVtKGRhdHVtID0ge1xyXG5cdFx0XHRcdFx0aW5kZXgsXHJcblx0XHRcdFx0XHRjdXJyZW50OiBkYXRhU3RyLFxyXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoID0gdG9vbHRpcC5wcm9wZXJ0eShcIm9mZnNldFdpZHRoXCIpLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQgPSB0b29sdGlwLnByb3BlcnR5KFwib2Zmc2V0SGVpZ2h0XCIpXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25zaG93biwgJCQuYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKHRydWUsIGluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWJpbmR0bykge1xyXG5cdFx0XHRjb25zdCBmblBvcyA9IGNvbmZpZy50b29sdGlwX3Bvc2l0aW9uIHx8ICQkLnRvb2x0aXBQb3NpdGlvbjtcclxuXHJcblx0XHRcdC8vIEdldCB0b29sdGlwIGRpbWVuc2lvbnNcclxuXHRcdFx0Y29uc3QgcG9zID0gZm5Qb3MuY2FsbCh0aGlzLCBkYXRhVG9TaG93LCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KTtcclxuXHJcblx0XHRcdFtcInRvcFwiLCBcImxlZnRcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHBvc1t2XTtcclxuXHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZSh2LCBgJHt2YWx1ZX1weGApO1xyXG5cclxuXHRcdFx0XHQvLyBSZW1lbWJlciBsZWZ0IHBvcyBpbiBwZXJjZW50YWdlIHRvIGJlIHVzZWQgb24gcmVzaXplIGNhbGxcclxuXHRcdFx0XHRpZiAodiA9PT0gXCJsZWZ0XCIgJiYgIWRhdHVtLnhQb3NJblBlcmNlbnQpIHtcclxuXHRcdFx0XHRcdGRhdHVtLnhQb3NJblBlcmNlbnQgPSB2YWx1ZSAvIHN0YXRlLmN1cnJlbnQud2lkdGggKiAxMDA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBZGp1c3QgdG9vbHRpcCBwb3NpdGlvbiBvbiByZXNpemUgZXZlbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRUb29sdGlwUmVzaXplUG9zKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3Jlc2l6ZUZ1bmN0aW9uLCBzdGF0ZSwgJGVsOiB7dG9vbHRpcH19ID0gJCQ7XHJcblxyXG5cdFx0cmVzaXplRnVuY3Rpb24uYWRkKCgpID0+IHtcclxuXHRcdFx0aWYgKHRvb2x0aXAuc3R5bGUoXCJkaXNwbGF5XCIpID09PSBcImJsb2NrXCIpIHtcclxuXHRcdFx0XHRjb25zdCB7Y3VycmVudH0gPSBzdGF0ZTtcclxuXHRcdFx0XHRjb25zdCB7d2lkdGgsIHhQb3NJblBlcmNlbnR9ID0gdG9vbHRpcC5kYXR1bSgpO1xyXG5cdFx0XHRcdGxldCB2YWx1ZSA9IGN1cnJlbnQud2lkdGggLyAxMDAgKiB4UG9zSW5QZXJjZW50O1xyXG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJyZW50LndpZHRoIC0gKHZhbHVlICsgd2lkdGgpO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0b29sdGlwIHNpemUgb3ZlcnMgY3VycmVudCB2aWV3cG9ydCBzaXplXHJcblx0XHRcdFx0aWYgKGRpZmYgPCAwKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSArPSBkaWZmO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZShcImxlZnRcIiwgYCR7dmFsdWV9cHhgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgRm9yY2UgdG8gaGlkZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGlkZVRvb2x0aXAoZm9yY2U/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXBpLCBjb25maWcsICRlbDoge3Rvb2x0aXB9fSA9ICQkO1xyXG5cclxuXHRcdGlmICh0b29sdGlwLnN0eWxlKFwiZGlzcGxheVwiKSAhPT0gXCJub25lXCIgJiYgKCFjb25maWcudG9vbHRpcF9kb05vdEhpZGUgfHwgZm9yY2UpKSB7XHJcblx0XHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IEpTT04ucGFyc2UodG9vbHRpcC5kYXR1bSgpLmN1cnJlbnQpO1xyXG5cclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZSwgYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdFx0Ly8gaGlkZSB0b29sdGlwXHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikgLy8gZm9yIElFOVxyXG5cdFx0XHRcdC5kYXR1bShudWxsKTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbmhpZGRlbiwgYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZSBkaXNwbGF5IGZvciBsaW5rZWQgY2hhcnQgaW5zdGFuY2VzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzaG93IHRydWU6IHNob3csIGZhbHNlOiBoaWRlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHggQXhpcyBpbmRleFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2hhbmRsZUxpbmtlZENoYXJ0cyhzaG93OiBib29sZWFuLCBpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y2hhcnRzLCBjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy50b29sdGlwX2xpbmtlZCAmJiBjaGFydHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRjb25zdCBsaW5rZWROYW1lID0gY29uZmlnLnRvb2x0aXBfbGlua2VkX25hbWU7XHJcblxyXG5cdFx0XHRjaGFydHMuZm9yRWFjaChjID0+IHtcclxuXHRcdFx0XHRpZiAoYyAhPT0gJCQuYXBpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gYy5pbnRlcm5hbDtcclxuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNJbkRvbSA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMoJGVsLmNoYXJ0Lm5vZGUoKSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGlzTGlua2VkICYmIGxpbmtlZE5hbWUgPT09IG5hbWUgJiYgaXNJbkRvbSkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gYy5pbnRlcm5hbC4kZWwudG9vbHRpcC5kYXRhKClbMF07XHJcblx0XHRcdFx0XHRcdGNvbnN0IGlzTm90U2FtZUluZGV4ID0gaW5kZXggIT09IChkYXRhICYmIGRhdGEuaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCB0aHJvd2luZyBlcnJvciBmb3Igbm9uLXBhaXJlZCBsaW5rZWQgaW5kZXhlc1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzaG93ICYmIGlzTm90U2FtZUluZGV4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjLnRvb2x0aXAuc2hvdyh7aW5kZXh9KTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFzaG93KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjLnRvb2x0aXAuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7YXNIYWxmUGl4ZWx9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSBUcmFuc2xhdGVQYXJhbSA9IFwibWFpblwiIHwgXCJjb250ZXh0XCIgfCBcImxlZ2VuZFwiIHwgXCJ4XCIgfCBcInlcIiB8IFwieTJcIiB8IFwic3ViWFwiIHwgXCJhcmNcIiB8IFwicmFkYXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRUcmFuc2xhdGUodGFyZ2V0OiBUcmFuc2xhdGVQYXJhbSwgaW5kZXggPSAwKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0bGV0IHBhZGRpbmcgPSAwO1xyXG5cdFx0bGV0IHg7XHJcblx0XHRsZXQgeTtcclxuXHJcblx0XHRpZiAoaW5kZXggJiYgL14oeHx5Mj8pJC8udGVzdCh0YXJnZXQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAkJC5nZXRBeGlzU2l6ZSh0YXJnZXQpICogaW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRhcmdldCA9PT0gXCJtYWluXCIpIHtcclxuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi5sZWZ0KTtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi50b3ApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiY29udGV4dFwiKSB7XHJcblx0XHRcdHggPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4yLmxlZnQpO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luMi50b3ApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwibGVnZW5kXCIpIHtcclxuXHRcdFx0eCA9IHN0YXRlLm1hcmdpbjMubGVmdDtcclxuXHRcdFx0eSA9IHN0YXRlLm1hcmdpbjMudG9wICsgKGhhc0dhdWdlID8gMTAgOiAwKTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInhcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gLXBhZGRpbmcgOiAwO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCArIHBhZGRpbmc7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ5XCIpIHtcclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiAtcGFkZGluZztcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCArIHBhZGRpbmcgOiAwO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieTJcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLndpZHRoICsgcGFkZGluZztcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDEgLSBwYWRkaW5nIDogMDtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInN1YlhcIikge1xyXG5cdFx0XHR4ID0gMDtcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiBzdGF0ZS5oZWlnaHQyO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiYXJjXCIpIHtcclxuXHRcdFx0eCA9IHN0YXRlLmFyY1dpZHRoIC8gMjtcclxuXHRcdFx0eSA9IHN0YXRlLmFyY0hlaWdodCAvIDI7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdGNvbnN0IFt3aWR0aF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHJcblx0XHRcdHggPSBzdGF0ZS53aWR0aCAvIDIgLSB3aWR0aDtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi50b3ApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYDtcclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uOiBib29sZWFuLCB0cmFuc2l0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0bGV0IHhBeGlzO1xyXG5cdFx0bGV0IHlBeGlzO1xyXG5cdFx0bGV0IHkyQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1gpIHtcclxuXHRcdFx0eEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHhBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eEF4aXMgPSB4QXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kpIHtcclxuXHRcdFx0eUF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eUF4aXMgPSB5QXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kyKSB7XHJcblx0XHRcdHkyQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHkyQXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHR5MkF4aXMgPSB5MkF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gbWFpbi50cmFuc2l0aW9uKCkgOiBtYWluKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHR4QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInhcIikpO1xyXG5cdFx0eUF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5XCIpKTtcclxuXHRcdHkyQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInkyXCIpKTtcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XHJcblx0fSxcclxuXHJcblx0dHJhbnNmb3JtQWxsKHdpdGhUcmFuc2l0aW9uOiBib29sZWFuLCB0cmFuc2l0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtoYXNBeGlzfSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLnRyYW5zZm9ybU1haW4od2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHRoYXNBeGlzICYmIGNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdCQkLnRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHQkZWwubGVnZW5kICYmICQkLnRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbik7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge1RZUEUsIFRZUEVfQllfQ0FURUdPUll9IGZyb20gXCIuLi8uLi9jb25maWcvY29uc3RcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRzZXRUYXJnZXRUeXBlKHRhcmdldElkczogc3RyaW5nW10sIHR5cGU6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aXRob3V0RmFkZUlufX0gPSAkJDtcclxuXHJcblx0XHQkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHR3aXRob3V0RmFkZUluW2lkXSA9ICh0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0pO1xyXG5cdFx0XHRjb25maWcuZGF0YV90eXBlc1tpZF0gPSB0eXBlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZSA9IHR5cGU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkdGUgY3VycmVudCB1c2VkIGNoYXJ0IHR5cGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVUeXBlc0VsZW1lbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7Y3VycmVudH19ID0gJCQ7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoVFlQRSkuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgdCA9IFRZUEVbdl07XHJcblx0XHRcdGNvbnN0IGhhcyA9ICQkLmhhc1R5cGUodCwgbnVsbCwgdHJ1ZSk7XHJcblx0XHRcdGNvbnN0IGlkeCA9IGN1cnJlbnQudHlwZXMuaW5kZXhPZih0KTtcclxuXHJcblx0XHRcdGlmIChpZHggPT09IC0xICYmIGhhcykge1xyXG5cdFx0XHRcdGN1cnJlbnQudHlwZXMucHVzaCh0KTtcclxuXHRcdFx0fSBlbHNlIGlmIChpZHggPiAtMSAmJiAhaGFzKSB7XHJcblx0XHRcdFx0Y3VycmVudC50eXBlcy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGN1cnJlbnQgY2hhcnQgZWxlbWVudHMgcmVmZXJlbmNlXHJcblx0XHQkJC5zZXRDaGFydEVsZW1lbnRzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgZ2l2ZW4gY2hhcnQgdHlwZXMgZXhpc3RzXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQ2hhcnQgdHlwZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNWYWx1ZSBEYXRhIGFycmF5XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBjaGVja0Zyb21EYXRhIEZvcmNlIHRvIGNoZWNrIHR5cGUgY290YWlucyBmcm9tIGRhdGEgdGFyZ2V0c1xyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGFzVHlwZSh0eXBlOiBzdHJpbmcsIHRhcmdldHNWYWx1ZT8sIGNoZWNrRnJvbURhdGEgPSBmYWxzZSk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fX0gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGVzID0gY29uZmlnLmRhdGFfdHlwZXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gdGFyZ2V0c1ZhbHVlIHx8ICQkLmRhdGEudGFyZ2V0cztcclxuXHRcdGxldCBoYXMgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIWNoZWNrRnJvbURhdGEgJiYgY3VycmVudC50eXBlcy5sZW5ndGggJiYgY3VycmVudC50eXBlcy5pbmRleE9mKHR5cGUpID4gLTEpIHtcclxuXHRcdFx0aGFzID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godGFyZ2V0ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0ID0gdHlwZXNbdGFyZ2V0LmlkXTtcclxuXHJcblx0XHRcdFx0aWYgKHQgPT09IHR5cGUgfHwgKCF0ICYmIHR5cGUgPT09IFwibGluZVwiKSkge1xyXG5cdFx0XHRcdFx0aGFzID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChPYmplY3Qua2V5cyh0eXBlcykubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0XHRpZiAodHlwZXNbaWRdID09PSB0eXBlKSB7XHJcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoYXMgPSBjb25maWcuZGF0YV90eXBlID09PSB0eXBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoYXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgZ2l2ZW4gY2hhcnQgdHlwZXNcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIGtleVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRzIFRhcmdldCBkYXRhXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGFzVHlwZU9mKHR5cGUsIHRhcmdldHMsIGV4Y2x1ZGUgPSBbXSk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8g7Iuk7KCcIOuFuOuTnCDsobTsnqwg7Jes67aA64+EIO2ZleyduO2VhOyalFxyXG5cdFx0cmV0dXJuICFUWVBFX0JZX0NBVEVHT1JZW3R5cGVdXHJcblx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0LmZpbHRlcih2ID0+IGV4Y2x1ZGUuaW5kZXhPZih2KSA9PT0gLTEpXHJcblx0XHRcdC5ldmVyeSh2ID0+ICF0aGlzLmhhc1R5cGUodiwgdGFyZ2V0cykpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGdpdmVuIGRhdGEgaXMgY2VydGFpbiBjaGFydCB0eXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdHlwZSBjaGFydCB0eXBlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc1R5cGVPZihkLCB0eXBlKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XHJcblx0XHRjb25zdCBkYXRhVHlwZSA9IHRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdO1xyXG5cclxuXHRcdHJldHVybiBpc0FycmF5KHR5cGUpID9cclxuXHRcdFx0dHlwZS5pbmRleE9mKGRhdGFUeXBlKSA+PSAwIDogZGF0YVR5cGUgPT09IHR5cGU7XHJcblx0fSxcclxuXHJcblx0aGFzUG9pbnRUeXBlKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5oYXNUeXBlT2YoXCJMaW5lXCIpIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgYXJjIHR5cGVzIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgVGFyZ2V0IGRhdGFcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlIEV4Y2x1ZGVkIHR5cGVzXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNBcmNUeXBlKHRhcmdldHMsIGV4Y2x1ZGUpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc1R5cGVPZihcIkFyY1wiLCB0YXJnZXRzLCBleGNsdWRlKTtcclxuXHR9LFxyXG5cclxuXHRoYXNNdWx0aUFyY0dhdWdlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVHlwZShcImdhdWdlXCIpICYmIHRoaXMuY29uZmlnLmdhdWdlX3R5cGUgPT09IFwibXVsdGlcIjtcclxuXHR9LFxyXG5cclxuXHRpc0xpbmVUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcclxuXHJcblx0XHRyZXR1cm4gIXRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdIHx8XHJcblx0XHRcdHRoaXMuaXNUeXBlT2YoaWQsIFRZUEVfQllfQ0FURUdPUlkuTGluZSk7XHJcblx0fSxcclxuXHJcblx0aXNTdGVwVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLlN0ZXApO1xyXG5cdH0sXHJcblxyXG5cdGlzU3BsaW5lVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLlNwbGluZSk7XHJcblx0fSxcclxuXHJcblx0aXNBcmVhVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLkFyZWEpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJlYVJhbmdlVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLkFyZWFSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0aXNCYXJUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYmFyXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzQnViYmxlVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJ1YmJsZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1NjYXR0ZXJUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1BpZVR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJwaWVcIik7XHJcblx0fSxcclxuXHJcblx0aXNHYXVnZVR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJnYXVnZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0RvbnV0VHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImRvbnV0XCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmFkYXJUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicmFkYXJcIik7XHJcblx0fSxcclxuXHJcblx0aXNBcmNUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzUGllVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzRG9udXRUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNHYXVnZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXRlcm1pbmUgaWYgaXMgJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGlzQ2lyY2xlUG9pbnQobm9kZT8pOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBhdHRlcm4gPSBjb25maWcucG9pbnRfcGF0dGVybjtcclxuXHRcdGxldCBpc0NpcmNsZSA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChub2RlICYmIG5vZGUudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRpc0NpcmNsZSA9IHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpc0NpcmNsZSA9IGNvbmZpZy5wb2ludF90eXBlID09PSBcImNpcmNsZVwiICYmXHJcblx0XHRcdFx0KCFwYXR0ZXJuIHx8IChcclxuXHRcdFx0XHRcdGlzQXJyYXkocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDBcclxuXHRcdFx0XHQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNDaXJjbGU7XHJcblx0fSxcclxuXHJcblx0bGluZURhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lVHlwZShkKSA/IFtkXSA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGFyY0RhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyBbZF0gOiBbXTtcclxuXHR9LFxyXG5cclxuXHRiYXJEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgYWRhcHQgZm9yIGRhdGEgbGFiZWwgc2hvd2luZ1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0bGFiZWxpc2hEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzTGluZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1NjYXR0ZXJUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGJhckxpbmVCdWJibGVEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fCB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc0J1YmJsZVR5cGUoZCkgP1xyXG5cdFx0XHRkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZSNjdXJ2ZXNcclxuXHRpc0ludGVycG9sYXRpb25UeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0XCJiYXNpc1wiLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiLFxyXG5cdFx0XHRcImJhc2lzLW9wZW5cIixcclxuXHRcdFx0XCJidW5kbGVcIixcclxuXHRcdFx0XCJjYXJkaW5hbFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIixcclxuXHRcdFx0XCJsaW5lYXJcIixcclxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCIsXHJcblx0XHRcdFwibW9ub3RvbmUteFwiLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIixcclxuXHRcdFx0XCJuYXR1cmFsXCJcclxuXHRcdF0uaW5kZXhPZih0eXBlKSA+PSAwO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3RUeXBlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtDaGFydH0gJCQgQ2hhcnQgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2V0IHR5cGUgJ21pbicgb3IgJ21heCdcclxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIFZhbHVlIHRvIGJlIHNldFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIiwgdmFsdWUpOiB2b2lkIHtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdGNvbnN0IGF4aXNYID0gYGF4aXNfeF8ke3R5cGV9YDtcclxuXHRjb25zdCBheGlzWSA9IGBheGlzX3lfJHt0eXBlfWA7XHJcblx0Y29uc3QgYXhpc1kyID0gYGF4aXNfeTJfJHt0eXBlfWA7XHJcblxyXG5cdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcblx0XHRpZiAoaXNPYmplY3RUeXBlKHZhbHVlKSkge1xyXG5cdFx0XHRpc1ZhbHVlKHZhbHVlLngpICYmIChjb25maWdbYXhpc1hdID0gdmFsdWUueCk7XHJcblx0XHRcdGlzVmFsdWUodmFsdWUueSkgJiYgKGNvbmZpZ1theGlzWV0gPSB2YWx1ZS55KTtcclxuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55MikgJiYgKGNvbmZpZ1theGlzWTJdID0gdmFsdWUueTIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uZmlnW2F4aXNZXSA9IHZhbHVlO1xyXG5cdFx0XHRjb25maWdbYXhpc1kyXSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtaW4vbWF4IHZhbHVlXHJcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkIENoYXJ0IGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFNldCB0eXBlICdtaW4nIG9yICdtYXgnXHJcbiAqIEByZXR1cm5zIHt7eCwgeSwgeTJ9fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIik6IHt4OiBudW1iZXIsIHk6IG51bWJlciwgeTI6IG51bWJlcn0ge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiBjb25maWdbYGF4aXNfeF8ke3R5cGV9YF0sXHJcblx0XHR5OiBjb25maWdbYGF4aXNfeV8ke3R5cGV9YF0sXHJcblx0XHR5MjogY29uZmlnW2BheGlzX3kyXyR7dHlwZX1gXVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYXhpc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCBheGlzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxyXG5cdCAqIEBmdW5jdGlvbiBheGlz4oCkbGFiZWxzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGxhYmVscyBzcGVjaWZpZWQgYXhpcycgbGFiZWwgdG8gYmUgdXBkYXRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMubGFiZWxzKHtcclxuXHQgKiAgIHg6IFwiTmV3IFggQXhpcyBMYWJlbFwiLFxyXG5cdCAqICAgeTogXCJOZXcgWSBBeGlzIExhYmVsXCJcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRsYWJlbHM6IGZ1bmN0aW9uKGxhYmVsczoge3g/OiBzdHJpbmcsIHk/OiBzdHJpbmcsIHkyPzogc3RyaW5nfSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGxhYmVscykuZm9yRWFjaChheGlzSWQgPT4ge1xyXG5cdFx0XHRcdCQkLmF4aXMuc2V0TGFiZWxUZXh0KGF4aXNJZCwgbGFiZWxzW2F4aXNJZF0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmF4aXMudXBkYXRlTGFiZWxzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBtaW4gdmFsdWUuXHJcblx0ICogQGZ1bmN0aW9uIGF4aXPigKRtaW5cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbWluIElmIG1pbiBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1pbiB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxyXG5cdCAqICAgICBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG1pbiB2YWx1ZXMgc2V0IG9uIGdlbmVyYXRpbmcgb3B0aW9uIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWluIHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fHVuZGVmaW5lZH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBtaW5cclxuXHQgKiBjaGFydC5heGlzLm1pbih7XHJcblx0ICogICB4OiAtMTAsXHJcblx0ICogICB5OiAxMDAwLFxyXG5cdCAqICAgeTI6IDEwMFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24obWluPzogbnVtYmVyKTogb2JqZWN0fHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdHJldHVybiBpc1ZhbHVlKG1pbikgP1xyXG5cdFx0XHRzZXRNaW5NYXgoJCQsIFwibWluXCIsIG1pbikgOlxyXG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWluXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWF4IHZhbHVlLlxyXG5cdCAqIEBmdW5jdGlvbiBheGlz4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG1heCBJZiBtYXggaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cclxuXHQgKiAgICAgSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBtYXggdmFsdWVzIHNldCBvbiBnZW5lcmF0aW5nIG9wdGlvbiBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogICAgIElmIG5vdCBzZXQgYW55IG1heCB2YWx1ZXMgb24gZ2VuZXJhdGlvbiwgaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXHJcblx0ICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcclxuXHQgKiBjaGFydC5heGlzLm1heCh7XHJcblx0ICogICAgeDogMTAwLFxyXG5cdCAqICAgIHk6IDEwMDAsXHJcblx0ICogICAgeTI6IDEwMDAwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbihtYXg/OiBudW1iZXIpOiBvYmplY3R8dm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xyXG5cdFx0XHRzZXRNaW5NYXgoJCQsIFwibWF4XCIsIG1heCkgOlxyXG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWF4XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIGFuZCBtYXggdmFsdWUuXHJcblx0ICogQGZ1bmN0aW9uIGF4aXPigKRyYW5nZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSByYW5nZSBJZiByYW5nZSBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1pbiBhbmQgbWF4IHZhbHVlIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcclxuXHQgKiBjaGFydC5heGlzLnJhbmdlKHtcclxuXHQgKiAgIG1pbjoge1xyXG5cdCAqICAgICB4OiAtMTAsXHJcblx0ICogICAgIHk6IC0xMDAwLFxyXG5cdCAqICAgICB5MjogLTEwMDAwXHJcblx0ICogICB9LFxyXG5cdCAqICAgbWF4OiB7XHJcblx0ICogICAgIHg6IDEwMCxcclxuXHQgKiAgICAgeTogMTAwMCxcclxuXHQgKiAgICAgeTI6IDEwMDAwXHJcblx0ICogICB9LFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdHJhbmdlOiBmdW5jdGlvbihyYW5nZSk6IG9iamVjdHx2b2lkIHtcclxuXHRcdGNvbnN0IHtheGlzfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1heCkgJiYgYXhpcy5tYXgocmFuZ2UubWF4KTtcclxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1pbikgJiYgYXhpcy5taW4ocmFuZ2UubWluKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0bWF4OiBheGlzLm1heCgpLFxyXG5cdFx0XHRcdG1pbjogYXhpcy5taW4oKVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2F4aXN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgc3BlY2lmaWVkIGNhdGVnb3J5IG5hbWUgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAZnVuY3Rpb24gY2F0ZWdvcnlcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBpbmRleCBvZiBjYXRlZ29yeSB0byBiZSBjaGFuZ2VkXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5IHZhbHVlIHRvIGJlIGNoYW5nZWRcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcnkoMiwgXCJDYXRlZ29yeSAzXCIpO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3J5KGk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV0gPSBjYXRlZ29yeTtcclxuXHRcdFx0JCQucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAZnVuY3Rpb24gY2F0ZWdvcmllc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNhdGVnb3JpZXMgVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcmllcyhbXHJcblx0ICogICAgICBcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLlxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3JpZXMoY2F0ZWdvcmllczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XHJcblx0XHQkJC5yZWRyYXcoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNUYWJWaXNpYmxlLCBpc1ZhbHVlLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEZsb3cgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBhcHBlbmQgbmV3IGRhdGEgcG9pbnRzIHRvIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24gZmxvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwganNvbiB8IE9iamVjdCB8IERhdGEgYXMgSlNPTiBmb3JtYXQgKEBzZWUgW2RhdGHigKRqc29uXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxyXG5cdCAqICAgIHwgcm93cyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyByb3cgZm9ybWF0IChAc2VlIFtkYXRh4oCkcm93c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0anNvbikpIHxcclxuXHQgKiAgICB8IGNvbHVtbnMgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgY29sdW1uIGZvcm1hdCAoQHNlZSBbZGF0YeKApGNvbHVtbnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbHVtbnMpKSB8XHJcblx0ICogICAgfCB0byB8IFN0cmluZyB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIHRvIHRoYXQgcG9pbnQuIElmIG5vdCBnaXZlbiwgdGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiBnaXZlbiBkYXRhIHBvaW50cyB8XHJcblx0ICogICAgfCBsZW5ndGggfCBOdW1iZXIgfCBUaGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSBieSB0aGUgbnVtYmVyIG9mIHRoaXMgYXJndW1lbnQgfFxyXG5cdCAqICAgIHwgZHVyYXRpb24gfCBOdW1iZXIgfCBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBzcGVjaWZpZWQgdmFsdWUuIElmIG5vdCBnaXZlbiwgdHJhbnNpdGlvbi5kdXJhdGlvbiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB8XHJcblx0ICogICAgfCBkb25lIHwgRnVuY3Rpb24gfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gZmxvdyBlbmRzIHxcclxuXHQgKlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElmIGpzb24sIHJvd3MgYW5kIGNvbHVtbnMgZ2l2ZW4sIHRoZSBkYXRhIHdpbGwgYmUgbG9hZGVkLlxyXG5cdCAqICAgLSBJZiBkYXRhIHRoYXQgaGFzIHRoZSBzYW1lIHRhcmdldCBpZCBpcyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgYmUgYXBwZW5kZWQuXHJcblx0ICogICAtIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkLiBPbmUgb2YgdGhlc2UgaXMgcmVxdWlyZWQgd2hlbiBjYWxsaW5nLlxyXG5cdCAqICAgLSBJZiBqc29uIHNwZWNpZmllZCwga2V5cyBpcyByZXF1aXJlZCBhcyB3ZWxsIGFzIGRhdGEuanNvbi5cclxuXHQgKiBcdCAtIElmIHRhYiBpc24ndCB2aXNpYmxlKGJ5IGV2YWx1YXRpbmcgYGRvY3VtZW50LmhpZGRlbmApLCB3aWxsIG5vdCBiZSBleGVjdXRlZCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHdvcmsuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyAyIGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwcmVuZGVkIHRvIHRoZSB0YWlsIGFuZCBwb3BwZWQgZnJvbSB0aGUgaGVhZC5cclxuXHQgKiAvLyBBZnRlciB0aGF0LCA0IGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwZW5kZWQgYW5kIG5vIGRhdGEgcG9pbnRzIHdpbGwgYmUgcG9wcG9lZC5cclxuXHQgKiBjaGFydC5mbG93KHtcclxuXHQgKiAgY29sdW1uczogW1xyXG5cdCAqICAgIFtcInhcIiwgXCIyMDE4LTAxLTExXCIsIFwiMjAxOC0wMS0yMVwiXSxcclxuXHQgKiAgICBbXCJkYXRhMVwiLCA1MDAsIDIwMF0sXHJcblx0ICogICAgW1wiZGF0YTJcIiwgMTAwLCAzMDBdLFxyXG5cdCAqICAgIFtcImRhdGEzXCIsIDIwMCwgMTIwXVxyXG5cdCAqICBdLFxyXG5cdCAqICB0bzogXCIyMDEzLTAxLTExXCIsXHJcblx0ICogIGRvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHQgKiAgICBjaGFydC5mbG93KHtcclxuXHQgKiAgICAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgICAgW1wieFwiLCBcIjIwMTgtMDItMTFcIiwgXCIyMDE4LTAyLTEyXCIsIFwiMjAxOC0wMi0xM1wiLCBcIjIwMTgtMDItMTRcIl0sXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDIwMCwgMzAwLCAxMDAsIDI1MF0sXHJcblx0ICogICAgICAgIFtcImRhdGEyXCIsIDEwMCwgOTAsIDQwLCAxMjBdLFxyXG5cdCAqICAgICAgICBbXCJkYXRhM1wiLCAxMDAsIDEwMCwgMzAwLCA1MDBdXHJcblx0ICogICAgICBdLFxyXG5cdCAqICAgICAgbGVuZ3RoOiAyLFxyXG5cdCAqICAgICAgZHVyYXRpb246IDE1MDBcclxuXHQgKiAgICB9KTtcclxuXHQgKiAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGZsb3coYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0bGV0IGRhdGE7XHJcblx0XHRsZXQgZG9tYWluO1xyXG5cdFx0bGV0IGxlbmd0aDogbnVtYmVyID0gMDtcclxuXHRcdGxldCB0YWlsID0gMDtcclxuXHRcdGxldCBkaWZmO1xyXG5cdFx0bGV0IHRvO1xyXG5cclxuXHRcdGlmIChhcmdzLmpzb24gfHwgYXJncy5yb3dzIHx8IGFyZ3MuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gJCQuY29udmVydERhdGEoYXJncyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFkYXRhIHx8ICFpc1RhYlZpc2libGUoKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgbm90Zm91bmRJZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBvcmdEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCB0cnVlKTtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlL0FkZCBkYXRhXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXSkge1xyXG5cdFx0XHRcdFx0XHR0YWlsID0gdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0uaW5kZXggKyAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxlbmd0aCA9IHRhcmdldHNbaV0udmFsdWVzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLmluZGV4ID0gdGFpbCArIGo7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIWlzVGltZVNlcmllcykge1xyXG5cdFx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLnggPSB0YWlsICsgajtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHQudmFsdWVzID0gdC52YWx1ZXMuY29uY2F0KHRhcmdldHNbaV0udmFsdWVzKTtcclxuXHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQhZm91bmQgJiYgbm90Zm91bmRJZHMucHVzaCh0LmlkKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEFwcGVuZCBudWxsIGZvciBub3QgZm91bmQgdGFyZ2V0c1xyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm90Zm91bmRJZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodC5pZCA9PT0gbm90Zm91bmRJZHNbaV0pIHtcclxuXHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHR0LnZhbHVlcy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0XHRpZDogdC5pZCxcclxuXHRcdFx0XHRcdFx0XHRpbmRleDogdGFpbCArIGosXHJcblx0XHRcdFx0XHRcdFx0eDogaXNUaW1lU2VyaWVzID8gJCQuZ2V0T3RoZXJUYXJnZXRYKHRhaWwgKyBqKSA6IHRhaWwgKyBqLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgbnVsbCB2YWx1ZXMgZm9yIG5ldyB0YXJnZXRcclxuXHRcdGlmICgkJC5kYXRhLnRhcmdldHMubGVuZ3RoKSB7XHJcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaXNzaW5nOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlc1swXS5pbmRleDsgaSA8IHRhaWw7IGkrKykge1xyXG5cdFx0XHRcdFx0bWlzc2luZy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdFx0XHRcdGluZGV4OiBpLFxyXG5cdFx0XHRcdFx0XHR4OiBpc1RpbWVTZXJpZXMgPyAkJC5nZXRPdGhlclRhcmdldFgoaSkgOiBpLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0di5pbmRleCArPSB0YWlsO1xyXG5cclxuXHRcdFx0XHRcdGlmICghaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0XHRcdHYueCArPSB0YWlsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0LnZhbHVlcyA9IG1pc3NpbmcuY29uY2F0KHQudmFsdWVzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXHJcblxyXG5cdFx0Ly8gY2hlY2sgZGF0YSBjb3VudCBiZWNhdXNlIGJlaGF2aW9yIG5lZWRzIHRvIGNoYW5nZSB3aGVuIGl0XCJzIG9ubHkgb25lXHJcblx0XHQvLyBjb25zdCBkYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IGJhc2VUYXJnZXQgPSAkJC5kYXRhLnRhcmdldHNbMF07XHJcblx0XHRjb25zdCBiYXNlVmFsdWUgPSBiYXNlVGFyZ2V0LnZhbHVlc1swXTtcclxuXHJcblx0XHQvLyBVcGRhdGUgbGVuZ3RoIHRvIGZsb3cgaWYgbmVlZGVkXHJcblx0XHRpZiAoaXNEZWZpbmVkKGFyZ3MudG8pKSB7XHJcblx0XHRcdGxlbmd0aCA9IDA7XHJcblx0XHRcdHRvID0gaXNUaW1lU2VyaWVzID8gcGFyc2VEYXRlLmNhbGwoJCQsIGFyZ3MudG8pIDogYXJncy50bztcclxuXHJcblx0XHRcdGJhc2VUYXJnZXQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0di54IDwgdG8gJiYgbGVuZ3RoKys7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5sZW5ndGgpKSB7XHJcblx0XHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIG9ubHkgb25lIGRhdGEsIHVwZGF0ZSB0aGUgZG9tYWluIHRvIGZsb3cgZnJvbSBsZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0XHJcblx0XHRpZiAoIW9yZ0RhdGFDb3VudCkge1xyXG5cdFx0XHRpZiAoaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0ZGlmZiA9IGJhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCA+IDEgP1xyXG5cdFx0XHRcdFx0YmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54IDpcclxuXHRcdFx0XHRcdGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRpZmYgPSAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XHJcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSAmJiBpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0ZGlmZiA9IChiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLngpIC8gMjtcclxuXHRcdFx0ZG9tYWluID0gW25ldyBEYXRlKCtiYXNlVmFsdWUueCAtIGRpZmYpLCBuZXcgRGF0ZSgrYmFzZVZhbHVlLnggKyBkaWZmKV07XHJcblx0XHR9XHJcblxyXG5cdFx0ZG9tYWluICYmICQkLnVwZGF0ZVhEb21haW4obnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGRvbWFpbik7XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0Zmxvdzoge1xyXG5cdFx0XHRcdGluZGV4OiBiYXNlVmFsdWUuaW5kZXgsXHJcblx0XHRcdFx0bGVuZ3RoOiBsZW5ndGgsXHJcblx0XHRcdFx0ZHVyYXRpb246IGlzVmFsdWUoYXJncy5kdXJhdGlvbikgPyBhcmdzLmR1cmF0aW9uIDogJCQuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24sXHJcblx0XHRcdFx0ZG9uZTogYXJncy5kb25lLFxyXG5cdFx0XHRcdG9yZ0RhdGFDb3VudDogb3JnRGF0YUNvdW50LFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogb3JnRGF0YUNvdW50ID4gMSxcclxuXHRcdFx0d2l0aFRyaW1YRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhBeGlzOiB0cnVlXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSBncmlkc1BhcmFtID0ge3ZhbHVlPzogbnVtYmVyLCBjbGFzcz86IHN0cmluZywgdGV4dD86IHN0cmluZ31bXTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgeCBncmlkIGxpbmVzLlxyXG4gKiBAZnVuY3Rpb24geGdyaWRzXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWCBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzLlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gU2hvdyAyIHggZ3JpZCBsaW5lc1xyXG4gKiBjaGFydC54Z3JpZHMoW1xyXG4gKiAgICB7dmFsdWU6IDEsIHRleHQ6IFwiTGFiZWwgMVwifSxcclxuICogICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuICogXSk7XHJcbiAqIC8vIC0tPiBSZXR1cm5zOiBbe3ZhbHVlOiAxLCB0ZXh0OiBcIkxhYmVsIDFcIn0sIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XVxyXG4gKi9cclxuZnVuY3Rpb24geGdyaWRzKGdyaWRzOiBncmlkc1BhcmFtKTogZ3JpZHNQYXJhbSB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdGlmICghZ3JpZHMpIHtcclxuXHRcdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xyXG5cdH1cclxuXHJcblx0Y29uZmlnLmdyaWRfeF9saW5lcyA9IGdyaWRzO1xyXG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xyXG59XHJcblxyXG5leHRlbmQoeGdyaWRzLCB7XHJcblx0LyoqXHJcblx0ICogQWRkIHggZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeCBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeGdyaWRzLlxyXG5cdCAqIEBmdW5jdGlvbiB4Z3JpZHPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gZ3JpZHMgTmV3IHggZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEFkZCBhIG5ldyB4IGdyaWQgbGluZVxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoXHJcblx0ICogICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xyXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoW1xyXG5cdCAqICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXHJcblx0ICogICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGFkZDogZnVuY3Rpb24oZ3JpZHM6IGdyaWRzUGFyYW0pOiBncmlkc1BhcmFtIHtcclxuXHRcdHJldHVybiB0aGlzLnhncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF94X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHggZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQGZ1bmN0aW9uIHhncmlkc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB4IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHggZ3JpZCBsaW5lIG9uIHggPSAyIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe3ZhbHVlOiAyfSk7XHJcblx0ICpcclxuXHQgKiAvLyB4IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe1xyXG5cdCAqICAgY2xhc3M6IFwiZ3JpZC1BXCJcclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiB4IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ocGFyYW1zPzogZ3JpZHNQYXJhbSk6IHZvaWQgeyAvLyBUT0RPOiBtdWx0aXBsZVxyXG5cdFx0dGhpcy5pbnRlcm5hbC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCB0cnVlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3hncmlkc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB5IGdyaWQgbGluZXMuXHJcbiAqIEBmdW5jdGlvbiB5Z3JpZHNcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBncmlkcyBZIGdyaWQgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMuXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAqIEBleGFtcGxlXHJcbiAqICAvLyBTaG93IDIgeSBncmlkIGxpbmVzXHJcbiAqIGNoYXJ0LnlncmlkcyhbXHJcbiAqICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXHJcbiAqICAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuICogXSk7XHJcbiAqIC8vIC0tPiBSZXR1cm5zOiBbe3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSwge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifV1cclxuICovXHJcbmZ1bmN0aW9uIHlncmlkcyhncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKToge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0aWYgKCFncmlkcykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcblx0fVxyXG5cclxuXHRjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7XHJcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcbn1cclxuXHJcbmV4dGVuZCh5Z3JpZHMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgeSBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyB5IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB5Z3JpZHMuXHJcblx0ICogQGZ1bmN0aW9uIHlncmlkc+KApGFkZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSBncmlkcyBOZXcgeSBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXHJcblx0ICogY2hhcnQueWdyaWRzLmFkZChcclxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcclxuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFtcclxuXHQgKiAgIHt2YWx1ZTogMjAwLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXHJcblx0ICogICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogXSk7XHJcblx0ICovXHJcblx0YWRkOiBmdW5jdGlvbihncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKToge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdIHtcclxuXHRcdHJldHVybiB0aGlzLnlncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF95X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQGZ1bmN0aW9uIHlncmlkc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB5IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHkgZ3JpZCBsaW5lIG9uIHkgPSAyMDAgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7dmFsdWU6IDIwMH0pO1xyXG5cdCAqXHJcblx0ICogLy8geSBncmlkIGxpbmVzIHRoYXQgaGF2ZSAnZ3JpZC1BJyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzOiBcImdyaWQtQVwiXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKHBhcmFtcz86IHt2YWx1ZT86IG51bWJlciwgY2xhc3M/OiBzdHJpbmd9KTogdm9pZCB7IC8vIFRPRE86IG11bHRpcGxlXHJcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZhbHNlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3lncmlkc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1VuZGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGdyb3VwcyBmb3IgdGhlIHRhcmdldHMuXHJcblx0ICogQGZ1bmN0aW9uIGdyb3Vwc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwcyBUaGlzIGFyZ3VtZW50IG5lZWRzIHRvIGJlIGFuIEFycmF5IHRoYXQgaW5jbHVkZXMgb25lIG9yIG1vcmUgQXJyYXkgdGhhdCBpbmNsdWRlcyB0YXJnZXQgaWRzIHRvIGJlIGdyb3VwZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBHcm91cGVkIGRhdGEgbmFtZXMgYXJyYXlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBhIG5ldyBncm91cC5cclxuXHQgKiAgY2hhcnQuZ3JvdXBzKFtcclxuXHQgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxyXG5cdCAqICBdKTtcclxuXHQgKi9cclxuXHRncm91cHMoZ3JvdXBzOiBzdHJpbmdbXVtdKTogc3RyaW5nW11bXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChpc1VuZGVmaW5lZChncm91cHMpKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xyXG5cdFx0JCQucmVkcmF3KCk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldE9wdGlvbiwgZXh0ZW5kfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbnR5cGUgcmVnaW9uc1BhcmFtID0ge2F4aXM/OiBzdHJpbmcsIGNsYXNzPzogc3RyaW5nLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyfVtdO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSByZWdpb25zLlxyXG4gKiBAZnVuY3Rpb24gcmVnaW9uc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJlZ2lvbnMgUmVnaW9ucyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIHJlZ2lvbnMuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gcmVnaW9uc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBTaG93IDIgcmVnaW9uc1xyXG4gKiBjaGFydC5yZWdpb25zKFtcclxuICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcclxuICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcbiAqIF0pO1xyXG4gKi9cclxuZnVuY3Rpb24gcmVnaW9ucyhyZWdpb25zOiByZWdpb25zUGFyYW0pOiByZWdpb25zUGFyYW0ge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRpZiAoIXJlZ2lvbnMpIHtcclxuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gcmVnaW9ucztcclxufVxyXG5cclxuZXh0ZW5kKHJlZ2lvbnMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHJlZ2lvbiBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHJlZ2lvbnMuXHJcblx0ICogQGZ1bmN0aW9uIHJlZ2lvbnPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gcmVnaW9ucyBOZXcgcmVnaW9uIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIHJlZ2lvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gQWRkIGEgbmV3IHJlZ2lvblxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyByZWdpb25zXHJcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoW1xyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXHJcblx0ICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcblx0ICpdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKHJlZ2lvbnM6IHJlZ2lvbnNQYXJhbSk6IHJlZ2lvbnNQYXJhbSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICghcmVnaW9ucykge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnJlZ2lvbnMgPSBjb25maWcucmVnaW9ucy5jb25jYXQocmVnaW9ucyk7XHJcblx0XHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgcmVnaW9ucy48YnI+PGJyPlxyXG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgcmVnaW9ucy5cclxuXHQgKiBAZnVuY3Rpb24gcmVnaW9uc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zVmFsdWUgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSByZWdpb25zIFJlbW92ZWQgcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gcmVnaW9ucyB0aGF0IGhhdmUgJ3JlZ2lvbi1BJyBvciAncmVnaW9uLUInIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSh7XHJcblx0ICogICBjbGFzc2VzOiBbXHJcblx0ICogICAgIFwicmVnaW9uLUFcIiwgXCJyZWdpb24tQlwiXHJcblx0ICogICBdXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogY2hhcnQucmVnaW9ucy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKG9wdGlvbnNWYWx1ZTogcmVnaW9uc1BhcmFtKTogcmVnaW9uc1BhcmFtIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNWYWx1ZSB8fCB7fTtcclxuXHRcdGNvbnN0IGR1cmF0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9IGdldE9wdGlvbihvcHRpb25zLCBcImNsYXNzZXNcIiwgW0NMQVNTLnJlZ2lvbl0pO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChjbGFzc2VzLm1hcChjID0+IGAuJHtjfWApKTtcclxuXHJcblx0XHQoZHVyYXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikgOiByZWdpb25zKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0cmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zO1xyXG5cclxuXHRcdGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcclxuXHRcdFx0cmVnaW9ucyA9IHJlZ2lvbnMuZmlsdGVyKHJlZ2lvbiA9PiB7XHJcblx0XHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmICghcmVnaW9uLmNsYXNzKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJlZ2lvbi5jbGFzcy5zcGxpdChcIiBcIikuZm9yRWFjaChjID0+IHtcclxuXHRcdFx0XHRcdGlmIChjbGFzc2VzLmluZGV4T2YoYykgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiAhZm91bmQ7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVnaW9ucztcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3JlZ2lvbnN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0RhdGFJdGVtfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMuPGJyPjxicj5cclxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBnZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMgaW5mb3JtYXRpb24uIFRvIHVzZSB0aGlzIEFQSSwgZGF0YS5zZWxlY3Rpb24uZW5hYmxlZCBuZWVkcyB0byBiZSBzZXQgdHJ1ZS5cclxuXHQgKiBAZnVuY3Rpb24gc2VsZWN0ZWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldElkXSBZb3UgY2FuIGZpbHRlciB0aGUgcmVzdWx0IGJ5IGdpdmluZyB0YXJnZXQgaWQgdGhhdCB5b3Ugd2FudCB0byBnZXQuIElmIG5vdCBnaXZlbiwgYWxsIG9mIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBkYXRhUG9pbnQgQXJyYXkgb2YgdGhlIGRhdGEgcG9pbnRzLjxicj5leC4pIGBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi5dYFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICBjaGFydC5zZWxlY3RlZCgpO1xyXG5cdCAqICAvLyAtLT4gZXguKSBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi4gXVxyXG5cdCAqXHJcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyBvZiBkYXRhMSB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICBjaGFydC5zZWxlY3RlZChcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdHNlbGVjdGVkKHRhcmdldElkPzogc3RyaW5nKTogRGF0YUl0ZW1bXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCBkYXRhUG9pbnQ6IERhdGFJdGVtW10gPSBbXTtcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlcyArICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKX1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmVhY2goZCA9PiBkYXRhUG9pbnQucHVzaChkKSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFQb2ludDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgc2VsZWN0ZWQuIChgW2RhdGEuc2VsZWN0aW9uLmVuYWJsZWRdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHNlbGVjdGlvbiUyNUUyJTI1ODAlMjVBNGVuYWJsZWQpIG9wdGlvbiBzaG91bGQgYmUgc2V0IHRydWUgdG8gdXNlIHRoaXMgbWV0aG9kKWBcclxuXHQgKiBAZnVuY3Rpb24gc2VsZWN0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IFtpZHNdIGlkIHZhbHVlIHRvIGdldCBzZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0T3RoZXJdIFVuc2VsZWN0IGFscmVhZHkgc2VsZWN0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC5zZWxlY3QoKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGEyJ1xyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMlwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGExJyBhbmQgJ2RhdGEyJ1xyXG5cdCAqICBjaGFydC5zZWxlY3QoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyIGFuZCB1bnNlbGVjdCBvdGhlcnMgc2VsZWN0ZWRcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTFcIiwgWzJdLCB0cnVlKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDAsIDMgYW5kIDVcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTFcIiwgWzAsIDMsIDVdKTtcclxuXHQgKi9cclxuXHRzZWxlY3QoaWRzPzogc3RyaW5nW10gfCBzdHJpbmcsIGluZGljZXM/OiBudW1iZXJbXSwgcmVzZXRPdGhlcj86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XHJcblx0XHRcdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoaXMsIGQpLmJpbmQoJCQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAhaWRzIHx8IGlkcy5pbmRleE9mKGlkKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcclxuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblxyXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKENMQVNTLmFyZWEpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4KSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgJiYgIWlzU2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRcdFx0dG9nZ2xlKHRydWUsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIHRydWUpLCBkLCBpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChyZXNldE90aGVyKSAmJiByZXNldE90aGVyICYmIGlzU2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSB1bi1zZWxlY3RlZC5cclxuXHQgKiBAZnVuY3Rpb24gdW5zZWxlY3RcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gYmUgdW5zZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC51bnNlbGVjdCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBmcm9tICdkYXRhMSdcclxuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyB1bnNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMlxyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIsIFsyXSk7XHJcblx0ICovXHJcblx0dW5zZWxlY3QoaWRzPzogc3RyaW5nIHwgc3RyaW5nW10sIGluZGljZXM/OiBudW1iZXJbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcclxuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHJcblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmXHJcblx0XHRcdFx0XHRpc1RhcmdldEluZGV4ICYmXHJcblx0XHRcdFx0XHRjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSAmJlxyXG5cdFx0XHRcdFx0aXNTZWxlY3RlZFxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIHhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB4IElmIHggaXMgZ2l2ZW4sIHggdmFsdWVzIG9mIGV2ZXJ5IHRhcmdldCB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHhzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcclxuXHQgKiAgY2hhcnQueCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcclxuXHQgKiAgY2hhcnQueChbMTAwLCAyMDAsIDMwMCwgNDAwLCAuLi5dKTtcclxuXHQgKi9cclxuXHR4KHg/OiBudW1iZXJbXSk6IHsgW2tleTogc3RyaW5nXSA6IG51bWJlcltdIH0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGRhdGF9ID0gJCQ7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gYXhpcy5pc0N1c3RvbVgoKSAmJiBheGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0XHRpZiAoaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRcdHRoaXMuY2F0ZWdvcmllcyh4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRYKGRhdGEudGFyZ2V0cywgeCk7XHJcblxyXG5cdFx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNDYXRlZ29yaXplZCA/IHRoaXMuY2F0ZWdvcmllcygpIDogZGF0YS54cztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCB4IHZhbHVlcyBmb3IgdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiB4c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHhzIElmIHhzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgeCB2YWx1ZXMgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB4c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXHJcblx0ICogIGNoYXJ0LnhzKCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54cyh7XHJcblx0ICogICAgZGF0YTE6IFsxMCwgMjAsIDMwLCA0MCwgLi4uXSxcclxuXHQgKiAgICBkYXRhMjogWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXVxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHR4cyh4cz86IHsgW2tleTogc3RyaW5nXSA6IG51bWJlcltdIH0pOiB7IFtrZXk6IHN0cmluZ10gOiBudW1iZXJbXSB9IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoeHMpKSB7XHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldFhzKCQkLmRhdGEudGFyZ2V0cywgeHMpO1xyXG5cclxuXHRcdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJCQuZGF0YS54cztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt6b29tSWRlbnRpdHkgYXMgZDNab29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gYXMgZDNab29tVHJhbnNmb3JtfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBleHRlbmQsIGdldE1pbk1heCwgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNTdHJpbmcsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRvbWFpbiBpcyB3aXRoaW4gem9vbSByYW5nZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW4gZG9tYWluIHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlIHpvb20gcmFuZ2UgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoaW5SYW5nZShkb21haW46IG51bWJlcltdLCByYW5nZTogbnVtYmVyW10pOiBib29sZWFuIHtcclxuXHRjb25zdCBbbWluLCBtYXhdID0gcmFuZ2U7XHJcblxyXG5cdHJldHVybiBkb21haW4uZXZlcnkoKHYsIGkpID0+IChcclxuXHRcdGkgPT09IDAgPyAodiA+PSBtaW4pIDogKHYgPD0gbWF4KVxyXG5cdCkpO1xyXG59XHJcblxyXG4vKipcclxuICogWm9vbSBieSBnaXZpbmcgeCBkb21haW4uXHJcbiAqIC0gKipOT1RFOioqXHJcbiAqICAtIEZvciBgd2hlZWxgIHR5cGUgem9vbSwgdGhlIG1pbmltdW0gem9vbSByYW5nZSB3aWxsIGJlIHNldCBhcyB0aGUgZ2l2ZW4gZG9tYWluLiBUbyBnZXQgdGhlIGluaXRpYWwgc3RhdGUsIFsudW56b29tKCldKCN1bnpvb20pIHNob3VsZCBiZSBjYWxsZWQuXHJcbiAqICAtIFRvIGJlIHVzZWQgW3pvb20uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy56b29tKSBvcHRpb24gc2hvdWxkIGJlIHNldCBhcyBgdHJ1dGh5YC5cclxuICogQGZ1bmN0aW9uIHpvb21cclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5WYWx1ZSBJZiBkb21haW4gaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHpvb21lZCB0byB0aGUgZ2l2ZW4gZG9tYWluLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgem9vbWVkIGRvbWFpbiB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRvbWFpbiB2YWx1ZSBpbiBhcnJheVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKFsxMCwgMjBdKTtcclxuICpcclxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKCk7XHJcbiAqL1xyXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWU/OiBudW1iZXJbXSk6IG51bWJlcltdIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xyXG5cdGxldCByZXN1bHREb21haW47XHJcblxyXG5cdGlmIChjb25maWcuem9vbV9lbmFibGVkICYmIGRvbWFpbiAmJiB3aXRoaW5SYW5nZShkb21haW4sICQkLmdldFpvb21Eb21haW4oKSkpIHtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRjb25zdCBmbiA9IHBhcnNlRGF0ZS5iaW5kKCQkKTtcclxuXHJcblx0XHRcdGRvbWFpbiA9IGRvbWFpbi5tYXAoeCA9PiBmbih4KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHJcblx0XHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgW3hTY2FsZShkb21haW5bMF0pLCB4U2NhbGUoZG9tYWluWzFdKV0pO1xyXG5cdFx0XHRyZXN1bHREb21haW4gPSBkb21haW47XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihkb21haW4pO1xyXG5cdFx0XHRzY2FsZS56b29tID0gc2NhbGUueDtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbS5vcmdEb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5zZXRab29tUmVzZXRCdXR0b24oKTtcclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb20sICQkLmFwaSwgcmVzdWx0RG9tYWluKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbSA/XHJcblx0XHRcdHNjYWxlLnpvb20uZG9tYWluKCkgOiBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdERvbWFpbjtcclxufTtcclxuXHJcbmV4dGVuZCh6b29tLCB7XHJcblx0LyoqXHJcblx0ICogRW5hYmxlIGFuZCBkaXNhYmxlIHpvb21pbmcuXHJcblx0ICogQGZ1bmN0aW9uIHpvb23igKRlbmFibGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBlbmFibGVkIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXMgYXJlIFwid2hlZWxcIiBvciBcImRyYWdcIi4gSWYgZW5hYmxlZCBpcyB0cnVlLCBcIndoZWVsXCIgd2lsbCBiZSB1c2VkLiBJZiBmYWxzZSBpcyBnaXZlbiwgem9vbWluZyB3aWxsIGJlIGRpc2FibGVkLjxicj5XaGVuIHNldCB0byBmYWxzZSwgdGhlIGN1cnJlbnQgem9vbWluZyBzdGF0dXMgd2lsbCBiZSByZXNldC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBFbmFibGUgem9vbWluZyB1c2luZyB0aGUgbW91c2Ugd2hlZWxcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUodHJ1ZSk7XHJcblx0ICogIC8vIE9yXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKFwid2hlZWxcIik7XHJcblx0ICpcclxuXHQgKiAgLy8gRW5hYmxlIHpvb21pbmcgYnkgZHJhZ2dpbmdcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJkcmFnXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIERpc2FibGUgem9vbWluZ1xyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShmYWxzZSk7XHJcblx0ICovXHJcblx0ZW5hYmxlOiBmdW5jdGlvbihlbmFibGVkOiBib29sZWFuIHwgXCJ3aGVlbFwiIHwgXCJkcmFnXCIgfCBhbnkpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgZW5hYmxlVHlwZTogYW55ID0gZW5hYmxlZDtcclxuXHJcblx0XHRpZiAoZW5hYmxlZCkge1xyXG5cdFx0XHRlbmFibGVUeXBlID0gaXNTdHJpbmcoZW5hYmxlZCkgJiYgL14oZHJhZ3x3aGVlbCkkLy50ZXN0KGVuYWJsZWQpID9cclxuXHRcdFx0XHR7dHlwZTogZW5hYmxlZH0gOiBlbmFibGVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgPSBlbmFibGVUeXBlO1xyXG5cclxuXHRcdGlmICghJCQuem9vbSkge1xyXG5cdFx0XHQkJC5pbml0Wm9vbSgpO1xyXG5cdFx0XHQkJC5iaW5kWm9vbUV2ZW50KCk7XHJcblx0XHR9IGVsc2UgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XHJcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIEBmdW5jdGlvbiB6b29t4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYXhdIG1heGltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXHJcblx0ICogQHJldHVybnMge251bWJlcn0gem9vbSBtYXggdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTZXQgbWF4aW11bSByYW5nZSB2YWx1ZVxyXG5cdCAqICBjaGFydC56b29tLm1heCgyMCk7XHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbihtYXg/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnOiB7eERvbWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG1heCA9PT0gMCB8fCBtYXgpIHtcclxuXHRcdFx0Y29uZmlnLnpvb21feF9tYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgW3hEb21haW5bMV0sIG1heF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21heDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgb3IgZ2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiBAZnVuY3Rpb24gem9vbeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbWluIHZhbHVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gU2V0IG1pbmltdW0gcmFuZ2UgdmFsdWVcclxuXHQgKiAgY2hhcnQuem9vbS5taW4oLTEpO1xyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24obWluPzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZzoge3hEb21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmIChtaW4gPT09IDAgfHwgbWluKSB7XHJcblx0XHRcdGNvbmZpZy56b29tX3hfbWluID0gZ2V0TWluTWF4KFwibWluXCIsIFt4RG9tYWluWzBdLCBtaW5dKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnpvb21feF9taW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHpvb20gcmFuZ2VcclxuXHQgKiBAZnVuY3Rpb24gem9vbeKApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtyYW5nZV0gem9vbSByYW5nZVxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiB7XHJcblx0ICogICBtaW46IDAsXHJcblx0ICogICBtYXg6IDEwMFxyXG5cdCAqIH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC56b29tLnJhbmdlKHtcclxuXHQgKiAgICAgIG1pbjogMTAsXHJcblx0ICogICAgICBtYXg6IDEwMFxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpOiB7bWluOiAobnVtYmVyfHVuZGVmaW5lZClbXSwgbWF4OiAobnVtYmVyfHVuZGVmaW5lZClbXX0ge1xyXG5cdFx0Y29uc3Qgem9vbSA9IHRoaXMuem9vbTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QocmFuZ2UpKSB7XHJcblx0XHRcdGNvbnN0IHttaW4sIG1heH0gPSByYW5nZTtcclxuXHJcblx0XHRcdGlzRGVmaW5lZChtaW4pICYmIHpvb20ubWluKG1pbik7XHJcblx0XHRcdGlzRGVmaW5lZChtYXgpICYmIHpvb20ubWF4KG1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0bWluOiB6b29tLm1pbigpLFxyXG5cdFx0XHRtYXg6IHpvb20ubWF4KClcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHR6b29tLFxyXG5cclxuXHQvKipcclxuXHQgKiBVbnpvb20gem9vbWVkIGFyZWFcclxuXHQgKiBAZnVuY3Rpb24gdW56b29tXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgY2hhcnQudW56b29tKCk7XHJcblx0ICovXHJcblx0dW56b29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuc2NhbGUuem9vbSkge1xyXG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyA/XHJcblx0XHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBudWxsKSA6XHJcblx0XHRcdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZShkM1pvb21JZGVudGl0eSk7XHJcblxyXG5cdFx0XHQkJC51cGRhdGVab29tKHRydWUpO1xyXG5cdFx0XHQkJC56b29tLnJlc2V0QnRuICYmICQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHRcdC8vIHJlc2V0IHRyYW5zZm9ybVxyXG5cdFx0XHRjb25zdCBldmVudFJlY3RzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApO1xyXG5cclxuXHRcdFx0aWYgKGQzWm9vbVRyYW5zZm9ybShldmVudFJlY3RzLm5vZGUoKSkgIT09IGQzWm9vbUlkZW50aXR5KSB7XHJcblx0XHRcdFx0JCQuem9vbS50cmFuc2Zvcm0oZXZlbnRSZWN0cywgZDNab29tSWRlbnRpdHkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFBhdGhCb3h9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIGRyYWdnaW5nLlxyXG5cdCAqIERhdGEgcG9pbnRzIGNhbiBiZSBzZWxlY3RlZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtb3VzZSBPYmplY3RcclxuXHQgKi9cclxuXHRkcmFnKG1vdXNlKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fFxyXG5cdFx0XHQhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgfHwgLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxyXG5cdFx0XHQoY29uZmlnLnpvb21fZW5hYmxlZCAmJiAhJCQuem9vbS5hbHREb21haW4pIHx8IC8vIHNraXAgaWYgem9vbWFibGUgYmVjYXVzZSBvZiBjb25mbGljdCBkcmFnIGJlaGF2aW9yXHJcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUgLy8gc2tpcCB3aGVuIHNpbmdsZSBzZWxlY3Rpb24gYmVjYXVzZSBkcmFnIGlzIHVzZWQgZm9yIG11bHRpcGxlIHNlbGVjdGlvblxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBbc3gsIHN5XSA9IHN0YXRlLmRyYWdTdGFydDtcclxuXHRcdGNvbnN0IFtteCwgbXldID0gbW91c2U7XHJcblxyXG5cdFx0Y29uc3QgbWluWCA9IE1hdGgubWluKHN4LCBteCk7XHJcblx0XHRjb25zdCBtYXhYID0gTWF0aC5tYXgoc3gsIG14KTtcclxuXHRcdGNvbnN0IG1pblkgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IHN0YXRlLm1hcmdpbi50b3AgOiBNYXRoLm1pbihzeSwgbXkpO1xyXG5cdFx0Y29uc3QgbWF4WSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gc3RhdGUuaGVpZ2h0IDogTWF0aC5tYXgoc3ksIG15KTtcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuZHJhZ2FyZWF9YClcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIG1pblgpXHJcblx0XHRcdC5hdHRyKFwieVwiLCBtaW5ZKVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFggLSBtaW5YKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBtYXhZIC0gbWluWSk7XHJcblxyXG5cdFx0Ly8gVE9ETzogYmluYXJ5IHNlYXJjaCB3aGVuIG11bHRpcGxlIHhzXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5maWx0ZXIoZCA9PiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGNvbnN0IHNoYXBlOiBkM1NlbGVjdGlvbiA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdFx0XHRjb25zdCBpc0luY2x1ZGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCk7XHJcblx0XHRcdFx0bGV0IGlzV2l0aGluOiBhbnkgPSBmYWxzZTtcclxuXHRcdFx0XHRsZXQgdG9nZ2xlO1xyXG5cclxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5jaXJjbGUpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB4OiBudW1iZXIgPSArc2hhcGUuYXR0cihcImN4XCIpICogMTtcclxuXHRcdFx0XHRcdGNvbnN0IHk6IG51bWJlciA9ICtzaGFwZS5hdHRyKFwiY3lcIikgKiAxO1xyXG5cclxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBvaW50O1xyXG5cdFx0XHRcdFx0aXNXaXRoaW4gPSBtaW5YIDwgeCAmJiB4IDwgbWF4WCAmJiBtaW5ZIDwgeSAmJiB5IDwgbWF4WTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuYmFyKSkge1xyXG5cdFx0XHRcdFx0Y29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gZ2V0UGF0aEJveCh0aGlzKTtcclxuXHJcblx0XHRcdFx0XHR0b2dnbGUgPSAkJC50b2dnbGVQYXRoO1xyXG5cdFx0XHRcdFx0aXNXaXRoaW4gPSAhKG1heFggPCB4IHx8IHggKyB3aWR0aCA8IG1pblgpICYmICEobWF4WSA8IHkgfHwgeSArIGhlaWdodCA8IG1pblkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBsaW5lL2FyZWEgc2VsZWN0aW9uIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0aWYgKGlzV2l0aGluIF4gaXNJbmNsdWRlZCkge1xyXG5cdFx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgIWlzSW5jbHVkZWQpO1xyXG5cdFx0XHRcdFx0Ly8gVE9ETzogaW5jbHVkZWQvdW5pbmNsdWRlZCBjYWxsYmFjayBoZXJlXHJcblx0XHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCAhaXNTZWxlY3RlZCk7XHJcblx0XHRcdFx0XHR0b2dnbGUuY2FsbCgkJCwgIWlzU2VsZWN0ZWQsIHNoYXBlLCBkLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBkcmFnIHN0YXJ0cy5cclxuXHQgKiBBZGRzIGFuZCBTaG93cyB0aGUgZHJhZyBhcmVhLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG1vdXNlIE9iamVjdFxyXG5cdCAqL1xyXG5cdGRyYWdzdGFydChtb3VzZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5kcmFnU3RhcnQgPSBtb3VzZTtcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5kcmFnYXJlYSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjAuMVwiKTtcclxuXHJcblx0XHQkJC5zZXREcmFnU3RhdHVzKHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBkcmFnIGZpbmlzaGVzLlxyXG5cdCAqIFJlbW92ZXMgdGhlIGRyYWcgYXJlYS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGRyYWdlbmQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkgeyAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuZHJhZ2FyZWF9YClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLklOQ0xVREVELCBmYWxzZSk7XHJcblxyXG5cdFx0JCQuc2V0RHJhZ1N0YXR1cyhmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0c2V0RHJhZ1N0YXR1cyhpc0RyYWdnaW5nOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmRyYWdnaW5nID0gaXNEcmFnZ2luZztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtlYXNlTGluZWFyIGFzIGQzRWFzZUxpbmVhcn0gZnJvbSBcImQzLWVhc2VcIjtcclxuaW1wb3J0IHt0cmFuc2l0aW9uIGFzIGQzVHJhbnNpdGlvbn0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHtnZW5lcmF0ZVdhaXR9IGZyb20gXCIuLi8uLi9tb2R1bGUvZ2VuZXJhdG9yXCI7XHJcbmltcG9ydCB7ZGlmZkRvbWFpbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBmbG93XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3Mgb3B0aW9uIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRmxvdyhhcmdzKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2RhdGEsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBmbG93TGVuZ3RoID0gYXJncy5mbG93Lmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIHNldCBmbGFnXHJcblx0XHRcdHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIGhlYWQgZGF0YSBhZnRlciByZW5kZXJlZFxyXG5cdFx0XHRkYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRkLnZhbHVlcy5zcGxpY2UoMCwgZmxvd0xlbmd0aCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxyXG5cdFx0XHRpZiAoJCQudXBkYXRlWEdyaWQpIHtcclxuXHRcdFx0XHQkJC51cGRhdGVYR3JpZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdGFyZ2V0IGVsZW1lbnRzXHJcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0ge307XHJcblxyXG5cdFx0XHRbXCJheGlzLnhcIiwgXCJncmlkLnhcIiwgXCJncmlkTGluZXMueFwiLCBcInJlZ2lvbi5saXN0XCIsIFwidGV4dFwiLCBcImJhclwiLCBcImxpbmVcIiwgXCJhcmVhXCIsIFwiY2lyY2xlXCJdXHJcblx0XHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdi5zcGxpdChcIi5cIik7XHJcblx0XHRcdFx0XHRsZXQgbm9kZSA9ICRlbFtuYW1lWzBdXTtcclxuXHJcblx0XHRcdFx0XHRpZiAobm9kZSAmJiBuYW1lLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVbbmFtZVsxXV07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG5vZGUgJiYgbm9kZS5zaXplKCkpIHtcclxuXHRcdFx0XHRcdFx0ZWxlbWVudHNbdl0gPSBub2RlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0XHQkJC5zZXRGbG93TGlzdChlbGVtZW50cywgYXJncyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBmbG93IGxpc3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudHMgVGFyZ2V0IGVsZW1lbnRzXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3Mgb3B0aW9uIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0Rmxvd0xpc3QoZWxlbWVudHMsIGFyZ3MpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtmbG93LCB0YXJnZXRzfSA9IGFyZ3M7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGR1cmF0aW9uID0gYXJncy5kdXJhdGlvbixcclxuXHRcdFx0aW5kZXg6IGZsb3dJbmRleCxcclxuXHRcdFx0bGVuZ3RoOiBmbG93TGVuZ3RoLFxyXG5cdFx0XHRvcmdEYXRhQ291bnQsXHJcblx0XHR9ID0gZmxvdztcclxuXHJcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSAkJC5nZXRGbG93VHJhbnNmb3JtKHRhcmdldHMsIG9yZ0RhdGFDb3VudCwgZmxvd0luZGV4LCBmbG93TGVuZ3RoKTtcclxuXHRcdGNvbnN0IHdhaXQgPSBnZW5lcmF0ZVdhaXQoKTtcclxuXHRcdGNvbnN0IGd0ID0gZDNUcmFuc2l0aW9uKCkuZWFzZShkM0Vhc2VMaW5lYXIpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbik7XHJcblxyXG5cdFx0d2FpdC5hZGQoT2JqZWN0LmtleXMoZWxlbWVudHMpLm1hcCh2ID0+IHtcclxuXHRcdFx0bGV0IG4gPSBlbGVtZW50c1t2XTtcclxuXHJcblx0XHRcdGlmICh2ID09PSBcImF4aXMueFwiKSB7XHJcblx0XHRcdFx0biA9IG4udHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5jYWxsKGcgPT4gJCQuYXhpcy54LnNldFRyYW5zaXRpb24oZ3QpLmNyZWF0ZShnKSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJyZWdpb24ubGlzdFwiKSB7XHJcblx0XHRcdFx0biA9IG4uZmlsdGVyKCQkLmlzUmVnaW9uT25YKVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG4gPSBuLnRyYW5zaXRpb24oZ3QpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG47XHJcblx0XHR9KSk7XHJcblxyXG5cdFx0Z3QuY2FsbCh3YWl0LCAoKSA9PiB7XHJcblx0XHRcdCQkLmNsZWFuVXBGbG93KGVsZW1lbnRzLCBhcmdzKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFuIHVwIGZsb3dcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudHMgVGFyZ2V0IGVsZW1lbnRzXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3Mgb3B0aW9uIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2xlYW5VcEZsb3coZWxlbWVudHMsIGFyZ3MpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25zdCB7Zmxvdywgc2hhcGUsIHh2fSA9IGFyZ3M7XHJcblx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gc2hhcGUucG9zO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRkb25lID0gKCkgPT4ge30sXHJcblx0XHRcdGxlbmd0aDogZmxvd0xlbmd0aFxyXG5cdFx0fSA9IGZsb3c7XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIGZsb3dlZCBlbGVtZW50c1xyXG5cdFx0aWYgKGZsb3dMZW5ndGgpIHtcclxuXHRcdFx0W1wiY2lyY2xlXCIsIFwidGV4dFwiLCBcInNoYXBlXCIsIFwiZXZlbnRSZWN0XCJdLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGFyZ2V0OiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZsb3dMZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dGFyZ2V0LnB1c2goYC4ke0NMQVNTW3ZdfS0ke2l9YCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdmcuc2VsZWN0QWxsKGAuJHtDTEFTU1tgJHt2fXNgXX1gKSAvLyBjaXJjbGVzLCBzaGFwZXMsIHRleHRzLCBldmVudFJlY3RzXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKHRhcmdldClcclxuXHRcdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRzdmcuc2VsZWN0KGAuJHtDTEFTUy54Z3JpZH1gKVxyXG5cdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkcmF3IGFnYWluIGZvciByZW1vdmluZyBmbG93ZWQgZWxlbWVudHMgYW5kIHJldmVydGluZyBhdHRyXHJcblx0XHRPYmplY3Qua2V5cyhlbGVtZW50cykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgbiA9IGVsZW1lbnRzW3ZdO1xyXG5cclxuXHRcdFx0aWYgKHYgIT09IFwiYXhpcy54XCIpIHtcclxuXHRcdFx0XHRuLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh2ID09PSBcImdyaWQueFwiKSB7XHJcblx0XHRcdFx0bi5hdHRyKHN0YXRlLnhncmlkQXR0cik7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJncmlkTGluZXMueFwiKSB7XHJcblx0XHRcdFx0bi5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IHh2KTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcImdyaWRMaW5lcy54XCIpIHtcclxuXHRcdFx0XHRuLnNlbGVjdChcImxpbmVcIikuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiB4dik7XHJcblxyXG5cdFx0XHRcdG4uc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogMClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB4dik7XHJcblx0XHRcdH0gZWxzZSBpZiAoL14oYXJlYXxiYXJ8bGluZSkkLy50ZXN0KHYpKSB7XHJcblx0XHRcdFx0bi5hdHRyKFwiZFwiLCBzaGFwZS50eXBlW3ZdKTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcInRleHRcIikge1xyXG5cdFx0XHRcdG4uYXR0cihcInhcIiwgeEZvclRleHQpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwiY2lyY2xlXCIpIHtcclxuXHRcdFx0XHRpZiAoJCQuaXNDaXJjbGVQb2ludCgpKSB7XHJcblx0XHRcdFx0XHRuLmF0dHIoXCJjeFwiLCBjeCkuYXR0cihcImN5XCIsIGN5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc3QgeEZ1bmMgPSBkID0+IGN4KGQpIC0gY29uZmlnLnBvaW50X3I7XHJcblx0XHRcdFx0XHRjb25zdCB5RnVuYyA9IGQgPT4gY3koZCkgLSBjb25maWcucG9pbnRfcjtcclxuXHJcblx0XHRcdFx0XHRuLmF0dHIoXCJ4XCIsIHhGdW5jKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZ1bmMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpIC8vIHdoZW4gcGF0dGVybiBpcyB1c2VkLCBpdCBwb3NzaWJseSBjb250YWluICdjaXJjbGUnIGFsc28uXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcInJlZ2lvbi5saXN0XCIpIHtcclxuXHRcdFx0XHRuLnNlbGVjdChcInJlY3RcIikuZmlsdGVyKCQkLmlzUmVnaW9uT25YKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsICQkLnJlZ2lvblguYmluZCgkJCkpXHJcblx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLnJlZ2lvbldpZHRoLmJpbmQoJCQpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgJCQucmVkcmF3RXZlbnRSZWN0KCk7XHJcblxyXG5cdFx0Ly8gY2FsbGJhY2sgZm9yIGVuZCBvZiBmbG93XHJcblx0XHRkb25lLmNhbGwoJCQuYXBpKTtcclxuXHJcblx0XHRzdGF0ZS5mbG93aW5nID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGZsb3cgdHJhbnNmb3JtIHZhbHVlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9yZ0RhdGFDb3VudCBvcmlnaW5hbCBkYXRhIGNvdW50XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZsb3dJbmRleCBmbG93IGluZGV4XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZsb3dMZW5ndGggZmxvdyBsZW5ndGhcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Rmxvd1RyYW5zZm9ybSh0YXJnZXRzLCBvcmdEYXRhQ291bnQsIGZsb3dJbmRleCwgZmxvd0xlbmd0aCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7ZGF0YSwgc2NhbGU6IHt4fX0gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFWYWx1ZXMgPSBkYXRhLnRhcmdldHNbMF0udmFsdWVzO1xyXG5cclxuXHRcdGxldCBmbG93U3RhcnQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoZGF0YVZhbHVlcywgZmxvd0luZGV4KTtcclxuXHRcdGxldCBmbG93RW5kID0gJCQuZ2V0VmFsdWVPbkluZGV4KGRhdGFWYWx1ZXMsIGZsb3dJbmRleCArIGZsb3dMZW5ndGgpO1xyXG5cdFx0bGV0IHRyYW5zbGF0ZVg7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHggZG9tYWluIHRvIGdlbmVyYXRlIGF4aXMgZWxlbWVudHMgZm9yIGZsb3dcclxuXHRcdGNvbnN0IG9yZ0RvbWFpbiA9IHguZG9tYWluKCk7XHJcblx0XHRjb25zdCBkb21haW4gPSAkJC51cGRhdGVYRG9tYWluKHRhcmdldHMsIHRydWUsIHRydWUpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHRyYW5zZm9ybSB0byBmbG93XHJcblx0XHRpZiAoIW9yZ0RhdGFDb3VudCkgeyAvLyBpZiBlbXB0eVxyXG5cdFx0XHRpZiAoZGF0YVZhbHVlcy5sZW5ndGggIT09IDEpIHtcclxuXHRcdFx0XHR0cmFuc2xhdGVYID0geChvcmdEb21haW5bMF0pIC0geChkb21haW5bMF0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICgkJC5heGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0XHRmbG93U3RhcnQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoZGF0YVZhbHVlcywgMCk7XHJcblx0XHRcdFx0XHRmbG93RW5kID0gJCQuZ2V0VmFsdWVPbkluZGV4KGRhdGFWYWx1ZXMsIGRhdGFWYWx1ZXMubGVuZ3RoIC0gMSk7XHJcblx0XHRcdFx0XHR0cmFuc2xhdGVYID0geChmbG93U3RhcnQueCkgLSB4KGZsb3dFbmQueCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSBkaWZmRG9tYWluKGRvbWFpbikgLyAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChvcmdEYXRhQ291bnQgPT09IDEgfHwgKGZsb3dTdGFydCAmJiBmbG93U3RhcnQueCkgPT09IChmbG93RW5kICYmIGZsb3dFbmQueCkpIHtcclxuXHRcdFx0dHJhbnNsYXRlWCA9IHgob3JnRG9tYWluWzBdKSAtIHgoZG9tYWluWzBdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRyYW5zbGF0ZVggPSAkJC5heGlzLmlzVGltZVNlcmllcygpID9cclxuXHRcdFx0XHR4KG9yZ0RvbWFpblswXSkgLSB4KGRvbWFpblswXSkgOlxyXG5cdFx0XHRcdHgoZmxvd1N0YXJ0LngpIC0geChmbG93RW5kLngpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNjYWxlWCA9IChkaWZmRG9tYWluKG9yZ0RvbWFpbikgLyBkaWZmRG9tYWluKGRvbWFpbikpO1xyXG5cclxuXHRcdHJldHVybiBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH0sMCkgc2NhbGUoJHtzY2FsZVh9LDEpYDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzYm9vbGVhbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEFkZCBhIGNvbnRhaW5lciBmb3IgdGhlIHpvbmUgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRFdmVudFJlY3QoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdHMpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3cyB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3RXZlbnRSZWN0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0bGV0IGV2ZW50UmVjdFVwZGF0ZTtcclxuXHJcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XHJcblx0XHRjb25zdCBldmVudFJlY3RzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCB6b29tRW5hYmxlZCAmJiB6b29tRW5hYmxlZC50eXBlICE9PSBcImRyYWdcIiA/IChcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJucy1yZXNpemVcIiA6IFwiZXctcmVzaXplXCJcclxuXHRcdFx0KSA6IG51bGwpXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNNdWx0aXBsZSwgaXNNdWx0aXBsZVgpXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNTaW5nbGUsICFpc011bHRpcGxlWCk7XHJcblxyXG5cdFx0Ly8gY2xlYXIgb2xkIHJlY3RzXHJcblx0XHRldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIG9wZW4gYXMgcHVibGljIGNvbnN0aWFibGVcclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cclxuXHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoWzBdKTtcclxuXHRcdFx0Ly8gdXBkYXRlXHJcblx0XHRcdC8vIGVudGVyOiBvbmx5IG9uZSByZWN0IHdpbGwgYmUgYWRkZWRcclxuXHRcdFx0Ly8gZXhpdDogbm90IG5lZWRlZCBiZWNhdXNlIGFsd2F5cyBvbmx5IG9uZSByZWN0IGV4aXN0c1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gU2V0IGRhdGEgYW5kIHVwZGF0ZSAkZWwuZXZlbnRSZWN0XHJcblx0XHRcdGNvbnN0IHhBeGlzVGlja1ZhbHVlcyA9ICQkLmdldE1heERhdGFDb3VudFRhcmdldCgpO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGRhdGEncyBpbmRleCB2YWx1ZSB0byBiZSBhbGluZ2VkIHdpdGggdGhlIHggQXhpc1xyXG5cdFx0XHQkJC51cGRhdGVEYXRhSW5kZXhCeVgoeEF4aXNUaWNrVmFsdWVzKTtcclxuXHRcdFx0JCQudXBkYXRlWHMoeEF4aXNUaWNrVmFsdWVzKTtcclxuXHRcdFx0JCQudXBkYXRlUG9pbnRDbGFzcyh0cnVlKTtcclxuXHJcblx0XHRcdGV2ZW50UmVjdHMuZGF0dW0oeEF4aXNUaWNrVmFsdWVzKTtcclxuXHJcblx0XHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoZCA9PiBkKTtcclxuXHJcblx0XHRcdC8vIGV4aXRcclxuXHRcdFx0ZXZlbnRSZWN0VXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZVxyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RVcGRhdGU7XHJcblx0XHQkJC51cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKTtcclxuXHJcblx0XHRpZiAoJCQuc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgISRlbC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLmJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRiaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0RXZlbnRSZWN0ID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGQzRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblxyXG5cdFx0XHRyZXR1cm4gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGdldEluZGV4ID0gZXZlbnRSZWN0ID0+IHtcclxuXHRcdFx0bGV0IGluZGV4ID0gZXZlbnRSZWN0ICYmIGV2ZW50UmVjdC5hdHRyKFwiY2xhc3NcIikgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKVxyXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xyXG5cclxuXHRcdFx0aWYgKGlzTmFOKGluZGV4KSB8fCBpbmRleCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdGluZGV4ID0gLTE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbmRleDtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xyXG5cdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KGV2ZW50UmVjdCk7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOlxyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcclxuXHRcdC8vIGFjY29yZGluZyAnaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0JyBvcHRpb25cclxuXHRcdGNvbnN0IHByZXZlbnREZWZhdWx0ID0gY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaC5wcmV2ZW50RGVmYXVsdDtcclxuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzYm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xyXG5cdFx0Y29uc3QgcHJldmVudFRocmVzaG9sZCA9ICghaXNOYU4ocHJldmVudERlZmF1bHQpICYmIHByZXZlbnREZWZhdWx0KSB8fCBudWxsO1xyXG5cdFx0bGV0IHN0YXJ0UHg7XHJcblxyXG5cdFx0Y29uc3QgcHJldmVudEV2ZW50ID0gZXZlbnQgPT4ge1xyXG5cdFx0XHRjb25zdCBldmVudFR5cGUgPSBldmVudC50eXBlO1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRjb25zdCBjdXJyZW50WFkgPSB0b3VjaFtgY2xpZW50JHtjb25maWcuYXhpc19yb3RhdGVkID8gXCJZXCIgOiBcIlhcIn1gXTtcclxuXHJcblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXHJcblx0XHRcdGlmIChldmVudFR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0c3RhcnRQeCA9IGN1cnJlbnRYWTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInRvdWNobW92ZVwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkIHx8IHN0YXJ0UHggPT09IHRydWUgfHwgKFxyXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXHJcblx0XHRcdFx0KSkge1xyXG5cdFx0XHRcdFx0Ly8gb25jZSBwcmV2ZW50ZWQsIGtlZXAgcHJldmVudGVkIGR1cmluZyB3aG9sZSAndG91Y2htb3ZlJyBjb250ZXh0XHJcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXHJcblx0XHRzdmdcclxuXHRcdFx0Lm9uKFwidG91Y2hzdGFydC5ldmVudFJlY3QgdG91Y2htb3ZlLmV2ZW50UmVjdFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHRcdFx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XHJcblxyXG5cdFx0XHRcdGlmICghZXZlbnRSZWN0LmVtcHR5KCkgJiYgZXZlbnRSZWN0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0KSkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgdG91Y2ggcG9pbnRzIGFyZSA+IDEsIG1lYW5zIGRvaW5nIHpvb21pbmcgaW50ZXJhY3Rpb24uIEluIHRoaXMgY2FzZSBkbyBub3QgZXhlY3V0ZSB0b29sdGlwIGNvZGVzLlxyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLmRyYWdnaW5nIHx8IHN0YXRlLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpIHx8IGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cHJldmVudEV2ZW50KGV2ZW50KTtcclxuXHRcdFx0XHRcdHNlbGVjdFJlY3QodGhpcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xyXG5cdFx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdHJ1ZSlcclxuXHRcdFx0Lm9uKFwidG91Y2hlbmQuZXZlbnRSZWN0XCIsICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHJcblx0XHRcdFx0aWYgKCFldmVudFJlY3QuZW1wdHkoKSAmJiBldmVudFJlY3QuY2xhc3NlZChDTEFTUy5ldmVudFJlY3QpKSB7XHJcblx0XHRcdFx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCBzdGF0ZS5jYW5jZWxDbGljaykge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5jYW5jZWxDbGljayAmJiAoc3RhdGUuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBsb2NhdGlvbiBhbmQgc2l6ZSBvZiB0aGUgZXZlbnRSZWN0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFJlY3RVcGRhdGUgZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdERhdGEgPSBldmVudFJlY3RVcGRhdGUgfHwgJCQuJGVsLmV2ZW50UmVjdC5kYXRhKCk7IC8vIHNldCB1cGRhdGUgc2VsZWN0aW9uIGlmIG51bGxcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgeDtcclxuXHRcdGxldCB5O1xyXG5cdFx0bGV0IHc7XHJcblx0XHRsZXQgaDtcclxuXHJcblx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHQvLyBUT0RPOiByb3RhdGVkIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdHggPSAwO1xyXG5cdFx0XHR5ID0gMDtcclxuXHRcdFx0dyA9IHN0YXRlLndpZHRoO1xyXG5cdFx0XHRoID0gc3RhdGUuaGVpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IHJlY3RXO1xyXG5cdFx0XHRsZXQgcmVjdFg7XHJcblxyXG5cdFx0XHRpZiAoJCQuYXhpcy5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0XHRyZWN0VyA9ICQkLmdldEV2ZW50UmVjdFdpZHRoKCk7XHJcblx0XHRcdFx0cmVjdFggPSBkID0+IHhTY2FsZShkLngpIC0gKHJlY3RXIC8gMik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgZ2V0UHJldk5leHRYID0gZCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGQuaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0cHJldjogJCQuZ2V0UHJldlgoaW5kZXgpLFxyXG5cdFx0XHRcdFx0XHRuZXh0OiAkJC5nZXROZXh0WChpbmRleClcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmVjdFcgPSBkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IG1ha2UgdGhlIGV2ZW50UmVjdCBmdWxsIHdpZHRoIChvciBoZWlnaHQpXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsICYmIHgubmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogc3RhdGUud2lkdGg7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHgubmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR4Lm5leHQgPSB4U2NhbGUuZG9tYWluKClbMV07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsICh4U2NhbGUoeC5uZXh0KSAtIHhTY2FsZSh4LnByZXYpKSAvIDIpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJlY3RYID0gZCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgdGhpc1ggPSBkLng7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IHBvc2l0aW9uIHRoZSBldmVudFJlY3QgYXQgMFxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuICh4U2NhbGUodGhpc1gpICsgeFNjYWxlKHgucHJldikpIC8gMjtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IHJlY3RYO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gcmVjdFggOiAwO1xyXG5cdFx0XHR3ID0gaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiByZWN0VztcclxuXHRcdFx0aCA9IGlzUm90YXRlZCA/IHJlY3RXIDogc3RhdGUuaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGV2ZW50UmVjdERhdGEuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeSlcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3KVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBoKTtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1NlbGVjdGlvbkVuYWJsZWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDtcclxuXHRcdGNvbnN0IGlzU2VsZWN0aW9uR3JvdXBlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkO1xyXG5cdFx0Y29uc3QgaXNUb29sdGlwR3JvdXBlZCA9IGNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XHJcblx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSAkJC5nZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KTtcclxuXHJcblx0XHRpZiAoaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xyXG5cdFx0XHQkJC5zaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHRpZiAoIWlzU2VsZWN0aW9uRW5hYmxlZCB8fCBpc1NlbGVjdGlvbkdyb3VwZWQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7aW5kZXh9YClcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQpIHtcclxuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBpc1NlbGVjdGlvbkdyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdFx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHRcdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xyXG5cclxuXHRcdFx0XHRcdCFpc1NlbGVjdGlvbkdyb3VwZWQgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKHNlbGVjdGVkID0+IHtcclxuXHRcdFx0XHRjb25zdCBkID0gc2VsZWN0ZWQuZGF0YSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNTZWxlY3Rpb25FbmFibGVkICYmXHJcblx0XHRcdFx0XHQoaXNTZWxlY3Rpb25Hcm91cGVkIHx8IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpKVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICghaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0JCQuc2hvd1Rvb2x0aXAoZCwgY29udGV4dCk7XHJcblx0XHRcdFx0XHQkJC5zaG93R3JpZEZvY3VzKGQpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWQuZWFjaChkID0+ICQkLmV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBkLmlkKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRDaXJjbGVzQmFycyhpbmRleDogbnVtYmVyLCBpZDogc3RyaW5nLCByZXNldDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7YmFyLCBjaXJjbGV9fSA9ICQkO1xyXG5cclxuXHRcdGNpcmNsZSAmJiBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgJiZcclxuXHRcdFx0JCQuZXhwYW5kQ2lyY2xlcyhpbmRleCwgaWQsIHJlc2V0KTtcclxuXHJcblx0XHRiYXIgJiYgJCQuZXhwYW5kQmFycyhpbmRleCwgaWQsIHJlc2V0KTtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gZG8gbm90aGluZyB3aGVuIGRyYWdnaW5nXHJcblx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKGNvbnRleHQpO1xyXG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5tb3VzZW92ZXIgJiYgKCFjbG9zZXN0IHx8IGNsb3Nlc3QuaWQgIT09IHN0YXRlLm1vdXNlb3Zlci5pZCkpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfb25vdXQuY2FsbCgkJC5hcGksIHN0YXRlLm1vdXNlb3Zlcik7XHJcblx0XHRcdHN0YXRlLm1vdXNlb3ZlciA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNsb3Nlc3QpIHtcclxuXHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzYW1lWERhdGEgPSAoXHJcblx0XHRcdCQkLmlzQnViYmxlVHlwZShjbG9zZXN0KSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGNsb3Nlc3QpIHx8ICFjb25maWcudG9vbHRpcF9ncm91cGVkXHJcblx0XHQpID8gW2Nsb3Nlc3RdIDogJCQuZmlsdGVyQnlYKHRhcmdldHNUb1Nob3csIGNsb3Nlc3QueCk7XHJcblxyXG5cdFx0Ly8gc2hvdyB0b29sdGlwIHdoZW4gY3Vyc29yIGlzIGNsb3NlIHRvIHNvbWUgcG9pbnRcclxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IHNhbWVYRGF0YS5tYXAoZCA9PiAkJC5hZGROYW1lKGQpKTtcclxuXHJcblx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xyXG5cclxuXHRcdC8vIGV4cGFuZCBwb2ludHNcclxuXHRcdCQkLmV4cGFuZENpcmNsZXNCYXJzKGNsb3Nlc3QuaW5kZXgsIGNsb3Nlc3QuaWQsIHRydWUpO1xyXG5cclxuXHRcdC8vIFNob3cgeGdyaWQgZm9jdXMgbGluZVxyXG5cdFx0JCQuc2hvd0dyaWRGb2N1cyhzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdC8vIFNob3cgY3Vyc29yIGFzIHBvaW50ZXIgaWYgcG9pbnQgaXMgY2xvc2UgdG8gbW91c2UgcG9zaXRpb25cclxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0JCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XHJcblxyXG5cdFx0XHRpZiAoIXN0YXRlLm1vdXNlb3Zlcikge1xyXG5cdFx0XHRcdGNvbmZpZy5kYXRhX29ub3Zlci5jYWxsKCQkLmFwaSwgY2xvc2VzdCk7XHJcblx0XHRcdFx0c3RhdGUubW91c2VvdmVyID0gY2xvc2VzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuc2VsZWN0IEV2ZW50UmVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UmVjdCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtiYXIsIGNpcmNsZSwgdG9vbHRpcH19ID0gJCQ7XHJcblxyXG5cdFx0JCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBudWxsKTtcclxuXHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHJcblx0XHRpZiAodG9vbHRpcCkge1xyXG5cdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRjaXJjbGUgJiYgJCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHRiYXIgJiYgJCQudW5leHBhbmRCYXJzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGV2ZW50UmVjdCBmb3IgZWFjaCBkYXRhIG9uIHRoZSB4LWF4aXMuXHJcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFJlY3RFbnRlciBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdEVudGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXIuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbClcclxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0aGlzKShkLCAkJCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0cmVjdFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcclxuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmcgd2hpbGUgZHJhZ2dpbmcvZmxvd2luZ1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLmRyYWdnaW5nIHx8IHN0YXRlLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25maWcudG9vbHRpcF9ncm91cGVkICYmICQkLnNldE92ZXJPdXQodHJ1ZSwgZC5pbmRleCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBpbmRleCA9IGQuaW5kZXg7XHJcblx0XHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSAkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWApO1xyXG5cclxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpICYmXHJcblx0XHRcdFx0XHRcdGNvbmZpZy5saW5lX3N0ZXBfdHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcclxuXHRcdFx0XHRcdFx0ZDNNb3VzZSh0aGlzKVswXSA8ICQkLnNjYWxlLngoJCQuZ2V0WFZhbHVlKGQuaWQsIGluZGV4KSlcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRpbmRleCAtPSAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGluZGV4ID09PSAtMSA/XHJcblx0XHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpIDogJCQuc2VsZWN0UmVjdEZvclNpbmdsZSh0aGlzLCBldmVudFJlY3QsIGluZGV4KTtcclxuXHJcblx0XHRcdFx0XHQvLyBBcyBvZiBpbmRpdmlkdWFsIGRhdGEgcG9pbnQob3IgPHBhdGg+KSBlbGVtZW50IGNhbid0IGJpbmQgbW91c2VvdmVyL291dCBldmVudFxyXG5cdFx0XHRcdFx0Ly8gdG8gZGV0ZXJtaW5lIGN1cnJlbnQgaW50ZXJhY3RpbmcgZWxlbWVudCwgc28gdXNlICdtb3VzZW1vdmUnIGV2ZW50IGluc3RlYWQuXHJcblx0XHRcdFx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdFx0JCQuc2V0T3Zlck91dChpbmRleCAhPT0gLTEsIGQuaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XHJcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcclxuXHRcdFx0XHRcdGlmICghY29uZmlnIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBkLmluZGV4KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHRjbGlja0hhbmRsZXJGb3JTaW5nbGVYKGQsIGN0eCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSBjdHg7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhJCQudG9nZ2xlU2hhcGUgfHwgc3RhdGUuY2FuY2VsQ2xpY2spIHtcclxuXHRcdFx0c3RhdGUuY2FuY2VsQ2xpY2sgJiYgKHN0YXRlLmNhbmNlbENsaWNrID0gZmFsc2UpO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHtpbmRleH0gPSBkO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtpbmRleH1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkMikge1xyXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQyKSkge1xyXG5cdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUodGhpcywgZDIsIGluZGV4KTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suYmluZCgkJC5hcGkpKGQyLCB0aGlzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhbiBldmVudFJlY3QsXHJcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFJlY3RFbnRlciBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdEVudGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodCwgaW5wdXRUeXBlfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIDApXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ldmVudFJlY3QpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcclxuXHJcblx0XHRpZiAoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0cmVjdFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlciBtb3VzZW1vdmVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyh0aGlzKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxyXG5cdFx0XHRcdFx0aWYgKCEkJC5jb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHRjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTKGN0eCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSBjdHg7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoaXMpO1xyXG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xyXG5cclxuXHRcdGlmICghY2xvc2VzdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VsZWN0IGlmIHNlbGVjdGlvbiBlbmFibGVkXHJcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XHJcblx0XHRcdCQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoY2xvc2VzdC5pZCl9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtjbG9zZXN0LmluZGV4fWApXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBjbG9zZXN0KSkge1xyXG5cdFx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBjbG9zZXN0LCBjbG9zZXN0LmluZGV4KTtcclxuXHRcdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5iaW5kKCQkLmFwaSkoY2xvc2VzdCwgdGhpcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7XHJcblx0YnJ1c2hYIGFzIGQzQnJ1c2hYLFxyXG5cdGJydXNoWSBhcyBkM0JydXNoWSxcclxuXHRicnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9uXHJcbn0gZnJvbSBcImQzLWJydXNoXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHticnVzaEVtcHR5LCBjYXBpdGFsaXplLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBnZXRSYW5kb20sIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgYnJ1c2guXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0QnJ1c2goKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgJGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGJydXNoXHJcblx0XHQkJC5icnVzaCA9IGlzUm90YXRlZCA/IGQzQnJ1c2hZKCkgOiBkM0JydXNoWCgpO1xyXG5cclxuXHRcdC8vIHNldCBcImJydXNoXCIgZXZlbnRcclxuXHRcdGNvbnN0IGJydXNoSGFuZGxlciA9ICgpID0+IHtcclxuXHRcdFx0JCQucmVkcmF3Rm9yQnJ1c2goKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCBnZXRCcnVzaFNpemUgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGJydXNoID0gJCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBicnVzaFNpemVbaXNSb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XHJcblx0XHR9O1xyXG5cclxuXHRcdGxldCBsYXN0RG9tYWluO1xyXG5cdFx0bGV0IHRpbWVvdXQ7XHJcblxyXG5cdFx0JCQuYnJ1c2hcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdCQkLnN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHRcdFx0YnJ1c2hIYW5kbGVyKCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImJydXNoXCIsIGJydXNoSGFuZGxlcilcclxuXHRcdFx0Lm9uKFwiZW5kXCIsICgpID0+IHtcclxuXHRcdFx0XHRsYXN0RG9tYWluID0gc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0JCQuYnJ1c2gudXBkYXRlUmVzaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRcdFx0bGFzdERvbWFpbiAmJiBkM0JydXNoU2VsZWN0aW9uKHNlbGVjdGlvbi5ub2RlKCkpICYmXHJcblx0XHRcdFx0XHR0aGlzLm1vdmUoc2VsZWN0aW9uLCBsYXN0RG9tYWluLm1hcChzY2FsZS5zdWJYLm9yZ1NjYWxlKCkpKTtcclxuXHRcdFx0fSwgMCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLmJydXNoLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLmV4dGVudCgpKCk7XHJcblxyXG5cdFx0XHRpZiAoZXh0ZW50WzFdLmZpbHRlcih2ID0+IGlzTmFOKHYpKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRzdWJjaGFydC5tYWluICYmIHN1YmNoYXJ0Lm1haW4uc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc2V0IHRoZSBicnVzaCBleHRlbnRcclxuXHRcdCQkLmJydXNoLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuXHRcdFx0Y29uc3QgaCA9IGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCB8fCBnZXRCcnVzaFNpemUoKTtcclxuXHRcdFx0bGV0IGV4dGVudCA9ICQkLmdldEV4dGVudCgpO1xyXG5cclxuXHRcdFx0aWYgKCFleHRlbnQgJiYgc2NhbGUucmFuZ2UpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBbWzAsIDBdLCBbc2NhbGUucmFuZ2UoKVsxXSwgaF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZXh0ZW50KSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IGV4dGVudC5tYXAoKHYsIGkpID0+IFt2LCBpID4gMCA/IGggOiBpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFtbeDAsIHkwXSwgW3gxLCB5MV1dLCB3aGVyZSBbeDAsIHkwXSBpcyB0aGUgdG9wLWxlZnQgY29ybmVyIGFuZCBbeDEsIHkxXSBpcyB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lclxyXG5cdFx0XHRpc1JvdGF0ZWQgJiYgZXh0ZW50WzFdLnJldmVyc2UoKTtcclxuXHRcdFx0dGhpcy5leHRlbnQoZXh0ZW50KTtcclxuXHJcblx0XHRcdC8vIHdoZW4gZXh0ZW50IHVwZGF0ZXMsIGJydXNoIHNlbGVjdGlvbiBhbHNvIGJlIHJlLWFwcGxpZWRcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8yOTE4XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbiA9ICgpID0+IChcclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRzdWJjaGFydC5tYWluID8gc3ViY2hhcnQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApIDogZDNTZWxlY3QoW10pXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIHN1YmNoYXJ0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFN1YmNoYXJ0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjbGlwLCBoYXNBeGlzfSwgJGVsOiB7ZGVmcywgc3ZnLCBzdWJjaGFydCwgYXhpc319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFoYXNBeGlzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB2aXNpYmlsaXR5ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XHJcblx0XHRjb25zdCBjbGlwSWQgPSBgJHtjbGlwLmlkfS1zdWJjaGFydGA7XHJcblx0XHRjb25zdCBjbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKGNsaXBJZCk7XHJcblxyXG5cdFx0Y2xpcC5pZFN1YmNoYXJ0ID0gY2xpcElkO1xyXG5cdFx0JCQuYXBwZW5kQ2xpcChkZWZzLCBjbGlwSWQpO1xyXG5cdFx0JCQuaW5pdEJydXNoKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQubWFpbiA9IHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblxyXG5cdFx0Y29uc3Qge21haW59ID0gc3ViY2hhcnQ7XHJcblxyXG5cdFx0bWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgdmlzaWJpbGl0eSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcclxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwUGF0aClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGJhciBjaGFydCBhcmVhXHJcblx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGxpbmUgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRMaW5lcyk7XHJcblxyXG5cdFx0Ly8gQWRkIGV4dGVudCByZWN0IGZvciBCcnVzaFxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmJydXNoKVxyXG5cdFx0XHQuY2FsbCgkJC5icnVzaCk7XHJcblxyXG5cdFx0Ly8gQVRURU5USU9OOiBUaGlzIG11c3QgYmUgY2FsbGVkIEFGVEVSIGNoYXJ0IGFkZGVkXHJcblx0XHQvLyBBZGQgQXhpc1xyXG5cdFx0YXhpcy5zdWJYID0gbWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpc1gpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YlhcIikpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIlwiIDogY2xpcC5wYXRoWEF4aXMpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ID8gdmlzaWJpbGl0eSA6IFwiaGlkZGVuXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyAkJC5kYXRhLnRhcmdldHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7c3ViY2hhcnQ6IHttYWlufX19ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xyXG5cdFx0XHQvLyAtLSBCYXIgLS0vL1xyXG5cdFx0XHRjb25zdCBiYXJVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcik7XHJcblx0XHRcdGNvbnN0IGJhckVudGVyID0gYmFyVXBkYXRlLmVudGVyKClcclxuXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxyXG5cdFx0XHRcdC5tZXJnZShiYXJVcGRhdGUpO1xyXG5cclxuXHRcdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXHJcblx0XHRcdGJhckVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycyk7XHJcblxyXG5cdFx0XHQvLyAtLSBMaW5lIC0tLy9cclxuXHRcdFx0Y29uc3QgbGluZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRMaW5lfWApXHJcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKTtcclxuXHRcdFx0Y29uc3QgbGluZUVudGVyID0gbGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdFx0Lm1lcmdlKGxpbmVVcGRhdGUpO1xyXG5cclxuXHRcdFx0Ly8gTGluZXMgZm9yIGVhY2ggZGF0YVxyXG5cdFx0XHRsaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XHJcblxyXG5cdFx0XHQvLyBBcmVhXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJhcmVhXCIpICYmIGxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcclxuXHJcblx0XHRcdC8vIC0tIEJydXNoIC0tLy9cclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJydXNofSByZWN0YClcclxuXHRcdFx0XHQuYXR0cihjb25maWcuYXhpc19yb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IHN0YXRlLndpZHRoMiA6IHN0YXRlLmhlaWdodDIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZHVyYXRpb25Gb3JFeGl0IFRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUJhckZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge3N1YmNoYXJ0fX0gPSAkJDtcclxuXHJcblx0XHRzdWJjaGFydC5iYXIgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxyXG5cdFx0XHQuZGF0YSgkJC5iYXJEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5iYXJcclxuXHRcdFx0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRzdWJjaGFydC5iYXIgPSBzdWJjaGFydC5iYXJcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0Jhci5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIFwibm9uZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2Uoc3ViY2hhcnQuYmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGJhciBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZHJhd0Jhck9uU3ViIHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdCYXJGb3JTdWJjaGFydChkcmF3QmFyT25TdWI6IHN0cmluZywgd2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHtiYXJ9ID0gdGhpcy4kZWwuc3ViY2hhcnQ7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gYmFyLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGJhcilcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXJPblN1YilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBsaW5lIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25Gb3JFeGl0IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxpbmVGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZSA9IHN1YmNoYXJ0Lm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5saW5lXHJcblx0XHRcdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZSA9IHN1YmNoYXJ0LmxpbmVcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0xpbmUuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgbGluZSBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkcmF3TGluZU9uU3ViIHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3TGluZUZvclN1YmNoYXJ0KGRyYXdMaW5lT25TdWI6IHN0cmluZywgd2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHtsaW5lfSA9IHRoaXMuJGVsLnN1YmNoYXJ0O1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogbGluZSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lT25TdWIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYXJlYSBvZiB0aGUgc3ViIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uRm9yRXhpdCBGYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVBcmVhRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmFyZWEgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYVxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmFyZWEgPSBzdWJjaGFydC5hcmVhXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnN0YXRlLm9yZ0FyZWFPcGFjaXR5ID0gZDNTZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpO1xyXG5cdFx0XHRcdHJldHVybiBcIjBcIjtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmFyZWEpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYXJlYSBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkcmF3QXJlYU9uU3ViIHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3QXJlYUZvclN1YmNoYXJ0KGRyYXdBcmVhT25TdWI6IHN0cmluZywgd2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHthcmVhfSA9IHRoaXMuJGVsLnN1YmNoYXJ0O1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogYXJlYSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdBcmVhT25TdWIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCB0aGlzLnN0YXRlLm9yZ0FyZWFPcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgc3ViY2hhcnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIGR1cmF0aW9uXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHNoYXBlIFNoYXBlJ3MgaW5mb1xyXG5cdCAqL1xyXG5cdHJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydDogYm9vbGVhbiwgZHVyYXRpb246IG51bWJlciwgc2hhcGUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3N1YmNoYXJ0OiB7bWFpbn19fSA9ICQkO1xyXG5cclxuXHRcdG1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcclxuXHJcblx0XHQvLyBzdWJjaGFydFxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdC8vIHJlZmxlY3QgbWFpbiBjaGFydCB0byBleHRlbnQgb24gc3ViY2hhcnQgaWYgem9vbWVkXHJcblx0XHRcdGlmIChkM0V2ZW50ICYmIGQzRXZlbnQudHlwZSA9PT0gXCJ6b29tXCIpIHtcclxuXHRcdFx0XHQkJC5icnVzaC51cGRhdGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHN1YmNoYXJ0IGVsZW1lbnRzIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAod2l0aFN1YmNoYXJ0KSB7XHJcblx0XHRcdFx0Ly8gZXh0ZW50IHJlY3RcclxuXHRcdFx0XHQhYnJ1c2hFbXB0eSgkJCkgJiYgJCQuYnJ1c2gudXBkYXRlKCk7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHNoYXBlLnR5cGUpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gY2FwaXRhbGl6ZSh2KTtcclxuXHRcdFx0XHRcdGNvbnN0IGRyYXcgPSAkJFtgZ2VuZXJhdGVEcmF3JHtuYW1lfWBdKHNoYXBlLmluZGljZXNbdl0sIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdCQkW2B1cGRhdGUke25hbWV9Rm9yU3ViY2hhcnRgXShkdXJhdGlvbik7XHJcblx0XHRcdFx0XHQkJFtgcmVkcmF3JHtuYW1lfUZvclN1YmNoYXJ0YF0oZHJhdywgZHVyYXRpb24sIGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYnJ1c2guXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdGb3JCcnVzaCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWc6IHtzdWJjaGFydF9vbmJydXNoOiBvbkJydXNoLCB6b29tX3Jlc2NhbGU6IHdpdGhZfSwgc2NhbGV9ID0gJCQ7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoWSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHRvbkJydXNoLmJpbmQoJCQuYXBpKShzY2FsZS54Lm9yZ0RvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gY29udGV4dFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gaW5kaWNhdGVzIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2l0aW9ucyBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zIG1ldGhvZCBvZiBBeGlzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbC5zdWJjaGFydDtcclxuXHRcdGxldCBzdWJYQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1N1YlgpIHtcclxuXHRcdFx0c3ViWEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzU3ViWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1YlhBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0c3ViWEF4aXMgPSBzdWJYQXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtYWluLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblx0XHRzdWJYQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YlhcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBleHRlbnQgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IGRlZmF1bHQgZXh0ZW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRFeHRlbnQoKTogbnVtYmVyW10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRsZXQgZXh0ZW50ID0gY29uZmlnLmF4aXNfeF9leHRlbnQ7XHJcblxyXG5cdFx0aWYgKGV4dGVudCkge1xyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihleHRlbnQpKSB7XHJcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50LmJpbmQoJCQuYXBpKSgkJC5nZXRYRG9tYWluKCQkLmRhdGEudGFyZ2V0cyksIHNjYWxlLnN1YlgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgJiYgZXh0ZW50LmV2ZXJ5KGlzTmFOKSkge1xyXG5cdFx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKHYgPT4gc2NhbGUuc3ViWChmbih2KSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4dGVudDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdGV2ZW50IGFzIGQzRXZlbnQsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xyXG5pbXBvcnQge3pvb20gYXMgZDNab29tfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgZGlmZkRvbWFpbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzRnVuY3Rpb259IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgem9vbS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRab29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlWm9vbSgpO1xyXG5cdFx0JCQuaW5pdFpvb21CZWhhdmlvdXIoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBCaW5kIHpvb20gZXZlbnRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRab29tRXZlbnQoYmluZCA9IHRydWUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xyXG5cclxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcclxuXHJcblx0XHRpZiAoem9vbUVuYWJsZWQgJiYgYmluZCkge1xyXG5cdFx0XHQvLyBEbyBub3QgYmluZCB6b29tIGV2ZW50IHdoZW4gc3ViY2hhcnQgaXMgc2hvd25cclxuXHRcdFx0IWNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdFx0JCQuYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB6b29tRW5hYmxlZC50eXBlKTtcclxuXHRcdH0gZWxzZSBpZiAoYmluZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYXBpLnVuem9vbSgpO1xyXG5cclxuXHRcdFx0ZXZlbnRSZWN0c1xyXG5cdFx0XHRcdC5vbihcIi56b29tXCIsIG51bGwpXHJcblx0XHRcdFx0Lm9uKFwiLmRyYWdcIiwgbnVsbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVab29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnLCBzY2FsZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB6b29tID0gZDNab29tKCkuZHVyYXRpb24oMClcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgJCQub25ab29tU3RhcnQuYmluZCgkJCkpXHJcblx0XHRcdC5vbihcInpvb21cIiwgJCQub25ab29tLmJpbmQoJCQpKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgJCQub25ab29tRW5kLmJpbmQoJCQpKTtcclxuXHJcblx0XHQvLyBnZXQgem9vbSBleHRlbnRcclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20ub3JnU2NhbGVFeHRlbnQgPSAoKTogW251bWJlciwgbnVtYmVyXSA9PiB7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IGNvbmZpZy56b29tX2V4dGVudCB8fCBbMSwgMTBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtleHRlbnRbMF0sIE1hdGgubWF4KCQkLmdldE1heERhdGFDb3VudCgpIC8gZXh0ZW50WzFdLCBleHRlbnRbMV0pXTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS51cGRhdGVTY2FsZUV4dGVudCA9IGZ1bmN0aW9uKCk6IHpvb20ge1xyXG5cdFx0XHRjb25zdCByYXRpbyA9IGRpZmZEb21haW4oJCQuc2NhbGUueC5vcmdEb21haW4oKSkgLyBkaWZmRG9tYWluKCQkLmdldFpvb21Eb21haW4oKSk7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHRyYW5zZm9ybSB0cmFuc2Zvcm0gb2JqZWN0XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHR6b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlID0gKHRyYW5zZm9ybTogb2JqZWN0KTogdm9pZCA9PiB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgcmVzaXplLCB1cGRhdGUgcmFuZ2Ugb2Ygb3JnWFNjYWxlXHJcblx0XHRcdG9yZy54U2NhbGUgJiYgb3JnLnhTY2FsZS5yYW5nZShzY2FsZS54LnJhbmdlKCkpO1xyXG5cclxuXHRcdFx0Ly8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxyXG5cdFx0XHRjb25zdCBuZXdTY2FsZSA9IHRyYW5zZm9ybVtcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJyZXNjYWxlWVwiIDogXCJyZXNjYWxlWFwiXHJcblx0XHRcdF0ob3JnLnhTY2FsZSB8fCBzY2FsZS54KTtcclxuXHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9ICQkLnRyaW1YRG9tYWluKG5ld1NjYWxlLmRvbWFpbigpKTtcclxuXHRcdFx0Y29uc3QgcmVzY2FsZSA9IGNvbmZpZy56b29tX3Jlc2NhbGU7XHJcblxyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4oZG9tYWluLCBvcmcueERvbWFpbik7XHJcblxyXG5cdFx0XHRzY2FsZS56b29tID0gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKG5ld1NjYWxlKTtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0aWYgKHJlc2NhbGUpIHtcclxuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgaW5pdGlhbCB4IHNjYWxlIGluIGNhc2Ugb2YgcmVzY2FsZSBvcHRpb24gaXMgdXNlZFxyXG5cdFx0XHRcdCFvcmcueFNjYWxlICYmIChvcmcueFNjYWxlID0gc2NhbGUueC5jb3B5KCkpO1xyXG5cdFx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbSA9IHpvb207XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ3N0YXJ0JyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tU3RhcnQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFldmVudCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuem9vbS5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tc3RhcnQsICQkLmFwaSwgZXZlbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICd6b29tJyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIG9yZ30gPSAkJDtcclxuXHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHRcdGNvbnN0IHtzb3VyY2VFdmVudH0gPSBldmVudDtcclxuXHJcblx0XHRpZiAoXHJcblx0XHRcdCFjb25maWcuem9vbV9lbmFibGVkIHx8XHJcblx0XHRcdCFldmVudC5zb3VyY2VFdmVudCB8fFxyXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoID09PSAwIHx8XHJcblx0XHRcdCghc2NhbGUuem9vbSAmJiBzb3VyY2VFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xICYmIHNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc01vdXNlbW92ZSA9IHNvdXJjZUV2ZW50LnR5cGUgPT09IFwibW91c2Vtb3ZlXCI7XHJcblx0XHRjb25zdCBpc1pvb21PdXQgPSBzb3VyY2VFdmVudC53aGVlbERlbHRhIDwgMDtcclxuXHRcdGNvbnN0IHt0cmFuc2Zvcm19ID0gZXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFpc01vdXNlbW92ZSAmJiBpc1pvb21PdXQgJiYgc2NhbGUueC5kb21haW4oKS5ldmVyeSgodiwgaSkgPT4gdiAhPT0gb3JnLnhEb21haW5baV0pKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKG9yZy54RG9tYWluKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKHRyYW5zZm9ybSk7XHJcblxyXG5cdFx0aWYgKCQkLmF4aXMuaXNDYXRlZ29yaXplZCgpICYmIHNjYWxlLngub3JnRG9tYWluKClbMF0gPT09IG9yZy54RG9tYWluWzBdKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKFtvcmcueERvbWFpblswXSAtIDFlLTEwLCBzY2FsZS54Lm9yZ0RvbWFpbigpWzFdXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoWTogY29uZmlnLnpvb21fcmVzY2FsZSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5zdGF0ZS5jYW5jZWxDbGljayA9IGlzTW91c2Vtb3ZlO1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgJCQuYXBpLCBzY2FsZS56b29tLmRvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiAnZW5kJyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tRW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRsZXQge3N0YXJ0RXZlbnR9ID0gJCQuem9vbTtcclxuXHRcdGxldCBldmVudCA9IGQzRXZlbnQgJiYgZDNFdmVudC5zb3VyY2VFdmVudDtcclxuXHJcblx0XHRpZiAoKHN0YXJ0RXZlbnQgJiYgc3RhcnRFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xKSkge1xyXG5cdFx0XHRzdGFydEV2ZW50ID0gc3RhcnRFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHRcdFx0ZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBjbGljaywgZG8gbm90aGluZy4gb3RoZXJ3aXNlLCBjbGljayBpbnRlcmFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxyXG5cdFx0aWYgKCFzdGFydEV2ZW50IHx8XHJcblx0XHRcdChldmVudCAmJiBzdGFydEV2ZW50LmNsaWVudFggPT09IGV2ZW50LmNsaWVudFggJiYgc3RhcnRFdmVudC5jbGllbnRZID09PSBldmVudC5jbGllbnRZKVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXdFdmVudFJlY3QoKTtcclxuXHRcdCQkLnVwZGF0ZVpvb20oKTtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLnpvb21fb256b29tZW5kLCAkJC5hcGksIHNjYWxlW3NjYWxlLnpvb20gPyBcInpvb21cIiA6IFwic3ViWFwiXS5kb21haW4oKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHpvb20gZG9tYWluXHJcblx0ICogQHJldHVybnMge0FycmF5fSB6b29tIGRvbWFpblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Wm9vbURvbWFpbigpOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZ30gPSAkJDtcclxuXHRcdGxldCBbbWluLCBtYXhdID0gb3JnLnhEb21haW47XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21pbikpIHtcclxuXHRcdFx0bWluID0gZ2V0TWluTWF4KFwibWluXCIsIFttaW4sIGNvbmZpZy56b29tX3hfbWluXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21heCkpIHtcclxuXHRcdFx0bWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFttYXgsIGNvbmZpZy56b29tX3hfbWF4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHpvb21cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIEZvcmNlIHVuem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWm9vbShmb3JjZTogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N1YlgsIHgsIHpvb219ID0gJCQuc2NhbGU7XHJcblxyXG5cdFx0aWYgKHpvb20pIHtcclxuXHRcdFx0Y29uc3Qgem9vbURvbWFpbiA9IHpvb20uZG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSBzdWJYLmRvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBkZWx0YSA9IDAuMDE1OyAvLyBhcmJpdHJhcnkgdmFsdWVcclxuXHJcblx0XHRcdGNvbnN0IGlzZnVsbHlTaG93biA9ICh6b29tRG9tYWluWzBdIDw9IHhEb21haW5bMF0gfHwgKHpvb21Eb21haW5bMF0gLSBkZWx0YSkgPD0geERvbWFpblswXSkgJiZcclxuXHRcdFx0XHQoeERvbWFpblsxXSA8PSB6b29tRG9tYWluWzFdIHx8IHhEb21haW5bMV0gPD0gKHpvb21Eb21haW5bMV0gLSBkZWx0YSkpO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHpvb21lZCBjaGFydCBpcyBmdWxseSBzaG93biwgdGhlbiByZXNldCBzY2FsZSB3aGVuIHpvb20gaXMgb3V0IGFzIGluaXRpYWxcclxuXHRcdFx0aWYgKGZvcmNlIHx8IGlzZnVsbHlTaG93bikge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5zY2FsZShzdWJYKTtcclxuXHRcdFx0XHR4LmRvbWFpbihzdWJYLm9yZ0RvbWFpbigpKTtcclxuXHRcdFx0XHQkJC5zY2FsZS56b29tID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEF0dGFjaCB6b29tIGV2ZW50IG9uIDxyZWN0PlxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBldmVudFJlY3RzIGV2ZW10IDxyZWN0PiBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgem9vbSB0eXBlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRiaW5kWm9vbU9uRXZlbnRSZWN0KGV2ZW50UmVjdHMsIHR5cGU6IFwiZHJhZ1wiIHwgXCJ3aGVlbFwiKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBiZWhhdmlvdXIgPSB0eXBlID09PSBcImRyYWdcIiA/ICQkLnpvb21CZWhhdmlvdXIgOiAkJC56b29tO1xyXG5cclxuXHRcdGV2ZW50UmVjdHNcclxuXHRcdFx0LmNhbGwoYmVoYXZpb3VyKVxyXG5cdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIGRyYWcgYmVoYXZpb3VyIHVzZWQgZm9yIHpvb21pbmcuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0Wm9vbUJlaGF2aW91cigpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gMDtcclxuXHRcdGxldCB6b29tUmVjdDtcclxuXHJcblx0XHRjb25zdCBwcm9wID0ge1xyXG5cdFx0XHRheGlzOiBpc1JvdGF0ZWQgPyBcInlcIiA6IFwieFwiLFxyXG5cdFx0XHRhdHRyOiBpc1JvdGF0ZWQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxyXG5cdFx0XHRpbmRleDogaXNSb3RhdGVkID8gMSA6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbUJlaGF2aW91ciA9IGQzRHJhZygpXHJcblx0XHRcdC5jbGlja0Rpc3RhbmNlKDQpXHJcblx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmICghem9vbVJlY3QpIHtcclxuXHRcdFx0XHRcdHpvb21SZWN0ID0gJCQuJGVsLm1haW4uYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBzdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbUJydXNoKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogMClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0c3RhcnQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xyXG5cdFx0XHRcdGVuZCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBzdGFydClcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XHJcblxyXG5cdFx0XHRcdCQkLm9uWm9vbVN0YXJ0KCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGVuZCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIE1hdGgubWluKHN0YXJ0LCBlbmQpKVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCBNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZS56b29tIHx8ICQkLnNjYWxlLng7XHJcblxyXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCAwKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXJ0ID4gZW5kKSB7XHJcblx0XHRcdFx0XHRbc3RhcnQsIGVuZF0gPSBbZW5kLCBzdGFydF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc3RhcnQgPCAwKSB7XHJcblx0XHRcdFx0XHRlbmQgKz0gTWF0aC5hYnMoc3RhcnQpO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0YXJ0ICE9PSBlbmQpIHtcclxuXHRcdFx0XHRcdCQkLmFwaS56b29tKFtzdGFydCwgZW5kXS5tYXAodiA9PiBzY2FsZS5pbnZlcnQodikpKTtcclxuXHRcdFx0XHRcdCQkLm9uWm9vbUVuZCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50IHx8IGQzRXZlbnQ7XHJcblx0XHRcdFx0XHRcdGNvbnN0IFt4LCB5XSA9IFwiY2xpZW50WFwiIGluIGV2ZW50ID8gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldIDogW2V2ZW50LngsIGV2ZW50LnldO1xyXG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xyXG5cclxuXHRcdFx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yU2luZ2xlWC5iaW5kKHRhcmdldCkoZDNTZWxlY3QodGFyZ2V0KS5kYXR1bSgpLCAkJCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRzZXRab29tUmVzZXRCdXR0b24oKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgcmVzZXRCdXR0b24gPSBjb25maWcuem9vbV9yZXNldEJ1dHRvbjtcclxuXHJcblx0XHRpZiAocmVzZXRCdXR0b24gJiYgY29uZmlnLnpvb21fZW5hYmxlZC50eXBlID09PSBcImRyYWdcIikge1xyXG5cdFx0XHRpZiAoISQkLnpvb20ucmVzZXRCdG4pIHtcclxuXHRcdFx0XHQkJC56b29tLnJlc2V0QnRuID0gJCQuJGVsLmNoYXJ0LmFwcGVuZChcImRpdlwiKVxyXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uLCB0cnVlKVxyXG5cdFx0XHRcdFx0LmFwcGVuZChcInNwYW5cIilcclxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKHJlc2V0QnV0dG9uLm9uY2xpY2spICYmIHJlc2V0QnV0dG9uLm9uY2xpY2suYmluZCgkJC5hcGkpKHRoaXMpO1xyXG5cdFx0XHRcdFx0XHQkJC5hcGkudW56b29tKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uWm9vbVJlc2V0LCB0cnVlKVxyXG5cdFx0XHRcdFx0LnRleHQocmVzZXRCdXR0b24udGV4dCB8fCBcIlJlc2V0IFpvb21cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0Q2xpcCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjbGlwfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdC8vIE1FTU86IGNsaXBJZCBuZWVkcyB0byBiZSB1bmlxdWUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgZXhpc3RcclxuXHRcdGNsaXAuaWQgPSBgJHskJC5zdGF0ZS5kYXRldGltZUlkfS1jbGlwYDtcclxuXHRcdGNsaXAuaWRYQXhpcyA9IGAke2NsaXAuaWR9LXhheGlzYDtcclxuXHRcdGNsaXAuaWRZQXhpcyA9IGAke2NsaXAuaWR9LXlheGlzYDtcclxuXHRcdGNsaXAuaWRHcmlkID0gYCR7Y2xpcC5pZH0tZ3JpZGA7XHJcblxyXG5cdFx0Ly8gRGVmaW5lICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSB2YWx1ZXNcclxuXHRcdGNsaXAucGF0aCA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWQpO1xyXG5cdFx0Y2xpcC5wYXRoWEF4aXMgPSAkJC5nZXRDbGlwUGF0aChjbGlwLmlkWEF4aXMpO1xyXG5cdFx0Y2xpcC5wYXRoWUF4aXMgPSAkJC5nZXRDbGlwUGF0aChjbGlwLmlkWUF4aXMpO1xyXG5cdFx0Y2xpcC5wYXRoR3JpZCA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRHcmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDbGlwUGF0aChpZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcclxuXHRcdFx0KCFjb25maWcuYXhpc194X2NsaXBQYXRoICYmIC8tY2xpcC14YXhpcyQvLnRlc3QoaWQpKSB8fFxyXG5cdFx0XHQoIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XHJcblx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvblxyXG5cdFx0XHRcdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llIDkuXCIpID49IDAgOiBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gYHVybCgkeyhpc0lFOSA/IFwiXCIgOiBkb2N1bWVudC5VUkwuc3BsaXQoXCIjXCIpWzBdKX0jJHtpZH0pYDtcclxuXHR9LFxyXG5cclxuXHRhcHBlbmRDbGlwKHBhcmVudCwgaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0aWQgJiYgcGFyZW50LmFwcGVuZChcImNsaXBQYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiaWRcIiwgaWQpXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldEF4aXNDbGlwWChmb3JIb3Jpem9udGFsPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCB7bWFyZ2lufSA9IHRoaXMuc3RhdGU7XHJcblx0XHQvLyBheGlzIGxpbmUgd2lkdGggKyBwYWRkaW5nIGZvciBsZWZ0XHJcblx0XHRjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMzAsIG1hcmdpbi5sZWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0oMSArIGxlZnQpIDogLShsZWZ0IC0gMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBZKGZvckhvcml6b250YWw/OiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IHttYXJnaW59ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0yMCA6IC1tYXJnaW4udG9wO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcFgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYQXhpc0NsaXBZKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwWSghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwWCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXhpc195X2lubmVyID9cclxuXHRcdFx0LTEgOiAkJC5nZXRBeGlzQ2xpcFgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwWSgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBXaWR0aChmb3JIb3Jpem9udGFsPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFyZ2luLCB3aWR0aH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cdFx0Y29uc3QgcmlnaHQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLnJpZ2h0KTtcclxuXHJcblx0XHQvLyB3aWR0aCArIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnQvcmlnaHRcclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID9cclxuXHRcdFx0d2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogbWFyZ2luLmxlZnQgKyAyMDtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3Qge21hcmdpbiwgaGVpZ2h0fSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0Ly8gbGVzcyB0aGFuIDIwIGlzIG5vdCBlbm91Z2ggdG8gc2hvdyB0aGUgYXhpcyBsYWJlbCAnb3V0ZXInIHdpdGhvdXQgbGVnZW5kXHJcblx0XHRyZXR1cm4gKGZvckhvcml6b250YWwgPyBtYXJnaW4uYm90dG9tIDogKG1hcmdpbi50b3AgKyBoZWlnaHQpKSArIDIwO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwV2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBXaWR0aCgkJC5jb25maWcuYXhpc19yb3RhdGVkKSArICgkJC5jb25maWcuYXhpc195X2lubmVyID8gMjAgOiAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBIZWlnaHQoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWEF4aXNUaWNrQ2xpcCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjbGlwfSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgbmV3WEF4aXNIZWlnaHQgPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XHJcblxyXG5cdFx0Y2xpcC5pZFhBeGlzVGlja1RleHRzID0gYCR7JCQuY2xpcElkfS14YXhpc3RpY2t0ZXh0c2A7XHJcblx0XHRjbGlwLnBhdGhYQXhpc1RpY2tUZXh0cyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRYQXhpc1RpY2tUZXh0cyk7XHJcblxyXG5cdFx0aWYgKCEkJC5jb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmXHJcblx0XHRcdCQkLmdldEF4aXNUaWNrUm90YXRlKFwieFwiKSAmJlxyXG5cdFx0XHRuZXdYQXhpc0hlaWdodCAhPT0gJCQueEF4aXNIZWlnaHRcclxuXHRcdCkge1xyXG5cdFx0XHQkJC5zZXRYQXhpc1RpY2tDbGlwV2lkdGgoKTtcclxuXHRcdFx0JCQuc2V0WEF4aXNUaWNrVGV4dENsaXBQYXRoV2lkdGgoKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC54QXhpc0hlaWdodCA9IG5ld1hBeGlzSGVpZ2h0O1xyXG5cdH0sXHJcblxyXG5cdHNldFhBeGlzVGlja0NsaXBXaWR0aCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y3VycmVudDoge21heFRpY2tXaWR0aHN9fX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB4QXhpc1RpY2tSb3RhdGUgPSAkJC5nZXRBeGlzVGlja1JvdGF0ZShcInhcIik7XHJcblxyXG5cdFx0aWYgKCFjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmIHhBeGlzVGlja1JvdGF0ZSkge1xyXG5cdFx0XHRjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKE1hdGguUEkgLyAxODAgKiBNYXRoLmFicyh4QXhpc1RpY2tSb3RhdGUpKTtcclxuXHJcblx0XHRcdG1heFRpY2tXaWR0aHMueC5jbGlwUGF0aCA9ICgkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIikgLSAyMCkgLyBzaW5Sb3RhdGlvbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1heFRpY2tXaWR0aHMueC5jbGlwUGF0aCA9IG51bGw7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0WEF4aXNUaWNrVGV4dENsaXBQYXRoV2lkdGgoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHtjbGlwLCBjdXJyZW50fSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdHN2Zy5zZWxlY3QoYCMke2NsaXAuaWRYQXhpc1RpY2tUZXh0c30gcmVjdGApXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBjdXJyZW50Lm1heFRpY2tXaWR0aHMueC5jbGlwUGF0aClcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCAzMCk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzQXJyYXksIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gR3JpZCBwb3NpdGlvbiBhbmQgdGV4dCBhbmNob3IgaGVscGVyc1xyXG5jb25zdCBnZXRHcmlkVGV4dEFuY2hvciA9IGQgPT4gaXNWYWx1ZShkLnBvc2l0aW9uKSB8fCBcImVuZFwiO1xyXG5jb25zdCBnZXRHcmlkVGV4dER4ID0gZCA9PiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiID8gNCA6IChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiID8gMCA6IC00KSk7XHJcblxyXG4vKipcclxuICogR2V0IGdyaWQgdGV4dCB4IHZhbHVlIGdldHRlciBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzWCBJcyB4IEF4aXNcclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIHZhbHVlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEdyaWRUZXh0WChpc1gsIHdpZHRoLCBoZWlnaHQpOiBGdW5jdGlvbiB7XHJcblx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0bGV0IHggPSBpc1ggPyAwIDogd2lkdGg7XHJcblxyXG5cdFx0aWYgKGQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xyXG5cdFx0XHR4ID0gaXNYID8gLWhlaWdodCA6IDA7XHJcblx0XHR9IGVsc2UgaWYgKGQucG9zaXRpb24gPT09IFwibWlkZGxlXCIpIHtcclxuXHRcdFx0eCA9IChpc1ggPyAtaGVpZ2h0IDogd2lkdGgpIC8gMjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGNvb3JkaW5hdGUgYXR0cmlidXRlcyB2YWx1ZVxyXG4gKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gZWwgVGFyZ2V0IG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc21vb3RoTGluZXMoZWwsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xyXG5cdGlmICh0eXBlID09PSBcImdyaWRcIikge1xyXG5cdFx0ZWwuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZyA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0W1wieDFcIiwgXCJ4MlwiLCBcInkxXCIsIFwieTJcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IGcuYXR0cih2LCBNYXRoLmNlaWwoK2cuYXR0cih2KSkpKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGhhc0dyaWQoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIFtcInhcIiwgXCJ5XCJdXHJcblx0XHRcdC5zb21lKHYgPT4gY29uZmlnW2BncmlkXyR7dn1fc2hvd2BdIHx8IGNvbmZpZ1tgZ3JpZF8ke3Z9X2xpbmVzYF0ubGVuZ3RoKTtcclxuXHR9LFxyXG5cclxuXHRpbml0R3JpZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5oYXNHcmlkKCkgJiYgJCQuaW5pdEdyaWRMaW5lcygpO1xyXG5cdFx0JCQuaW5pdEZvY3VzR3JpZCgpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRHcmlkTGluZXMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXB9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5ncmlkX3hfbGluZXMubGVuZ3RoIHx8IGNvbmZpZy5ncmlkX3lfbGluZXMubGVuZ3RoKSB7XHJcblx0XHRcdCRlbC5ncmlkTGluZXMubWFpbiA9ICRlbC5tYWluLmluc2VydChcImdcIiwgYC4ke0NMQVNTLmNoYXJ0fSR7Y29uZmlnLmdyaWRfbGluZXNfZnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YClcclxuXHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwLnBhdGhHcmlkKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYCR7Q0xBU1MuZ3JpZH0gJHtDTEFTUy5ncmlkTGluZXN9YCk7XHJcblxyXG5cdFx0XHQkZWwuZ3JpZExpbmVzLm1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRMaW5lcyk7XHJcblx0XHRcdCRlbC5ncmlkTGluZXMubWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZExpbmVzKTtcclxuXHJcblx0XHRcdCRlbC5ncmlkTGluZXMueCA9IGQzU2VsZWN0QWxsKFtdKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVYR3JpZCh3aXRob3V0VXBkYXRlKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGUsICRlbDoge21haW4sIGdyaWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHhncmlkRGF0YSA9ICQkLmdlbmVyYXRlR3JpZERhdGEoY29uZmlnLmdyaWRfeF90eXBlLCBzY2FsZS54KTtcclxuXHRcdGNvbnN0IHRpY2tPZmZzZXQgPSAkJC5heGlzLmlzQ2F0ZWdvcml6ZWQoKSA/ICQkLmF4aXMueC50aWNrT2Zmc2V0KCkgOiAwO1xyXG5cdFx0Y29uc3QgcG9zID0gZCA9PiAoKHNjYWxlLnpvb20gfHwgc2NhbGUueCkoZCkgKyB0aWNrT2Zmc2V0KSAqIChpc1JvdGF0ZWQgPyAtMSA6IDEpO1xyXG5cclxuXHRcdHN0YXRlLnhncmlkQXR0ciA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0XCJ4MVwiOiAwLFxyXG5cdFx0XHRcIngyXCI6IHN0YXRlLndpZHRoLFxyXG5cdFx0XHRcInkxXCI6IHBvcyxcclxuXHRcdFx0XCJ5MlwiOiBwb3MsXHJcblx0XHR9IDoge1xyXG5cdFx0XHRcIngxXCI6IHBvcyxcclxuXHRcdFx0XCJ4MlwiOiBwb3MsXHJcblx0XHRcdFwieTFcIjogMCxcclxuXHRcdFx0XCJ5MlwiOiBzdGF0ZS5oZWlnaHQsXHJcblx0XHR9O1xyXG5cclxuXHRcdGdyaWQueCA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZHN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWR9YClcclxuXHRcdFx0LmRhdGEoeGdyaWREYXRhKTtcclxuXHJcblx0XHRncmlkLnguZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGdyaWQueCA9IGdyaWQueC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWQpXHJcblx0XHRcdC5tZXJnZShncmlkLngpO1xyXG5cclxuXHRcdGlmICghd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRncmlkLnguZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBncmlkID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHN0YXRlLnhncmlkQXR0cikuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0XHRncmlkLmF0dHIoaWQsIHN0YXRlLnhncmlkQXR0cltpZF0pXHJcblx0XHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgKCkgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdGdyaWQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIpID09PSAoaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogMCkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XCIwXCIgOiBcIjFcIlxyXG5cdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWUdyaWQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7Z3JpZCwgbWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgZ3JpZFZhbHVlcyA9ICQkLmF4aXMueS50aWNrVmFsdWVzKCkgfHwgJCQuc2NhbGUueS50aWNrcyhjb25maWcuZ3JpZF95X3RpY2tzKTtcclxuXHRcdGNvbnN0IHBvcyA9IGQgPT4gTWF0aC5jZWlsKCQkLnNjYWxlLnkoZCkpO1xyXG5cclxuXHRcdGdyaWQueSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy55Z3JpZHN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWR9YClcclxuXHRcdFx0LmRhdGEoZ3JpZFZhbHVlcyk7XHJcblxyXG5cdFx0Z3JpZC55LmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRncmlkLnkgPSBncmlkLnlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZClcclxuXHRcdFx0Lm1lcmdlKGdyaWQueSk7XHJcblxyXG5cdFx0Z3JpZC55LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyBwb3MgOiAwKVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHBvcyA6IHN0YXRlLndpZHRoKVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IDAgOiBwb3MpXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogcG9zKTtcclxuXHJcblx0XHRzbW9vdGhMaW5lcyhncmlkLnksIFwiZ3JpZFwiKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVHcmlkKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7Z3JpZCwgZ3JpZExpbmVzfX0gPSAkJDtcclxuXHJcblx0XHQhZ3JpZExpbmVzLm1haW4gJiYgJCQuaW5pdEdyaWRMaW5lcygpO1xyXG5cclxuXHRcdC8vIGhpZGUgaWYgYXJjIHR5cGVcclxuXHRcdGdyaWQubWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcclxuXHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHQkJC51cGRhdGVYR3JpZExpbmVzKGR1cmF0aW9uKTtcclxuXHRcdCQkLnVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBYIEdyaWQgbGluZXNcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHJhdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtncmlkTGluZXMsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25maWcuZ3JpZF94X3Nob3cgJiYgJCQudXBkYXRlWEdyaWQoKTtcclxuXHJcblx0XHRsZXQgeExpbmVzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLnhncmlkTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWRMaW5lfWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3hfbGluZXMpO1xyXG5cclxuXHRcdC8vIGV4aXRcclxuXHRcdHhMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB4Z3JpZExpbmUgPSB4TGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhMaW5lcyA9IHhncmlkTGluZS5tZXJnZSh4TGluZXMpO1xyXG5cclxuXHRcdHhMaW5lc1xyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueGdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcclxuXHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcclxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0Z3JpZExpbmVzLnggPSB4TGluZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIFkgR3JpZCBsaW5lc1xyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWUdyaWRMaW5lcyhkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpZHRoLCBoZWlnaHR9LCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3lfc2hvdyAmJiAkJC51cGRhdGVZR3JpZCgpO1xyXG5cclxuXHRcdGxldCB5Z3JpZExpbmVzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy55Z3JpZExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkTGluZX1gKVxyXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF95X2xpbmVzKTtcclxuXHJcblx0XHQvLyBleGl0XHJcblx0XHR5Z3JpZExpbmVzLmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB5Z3JpZExpbmUgPSB5Z3JpZExpbmVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBpc1JvdGF0ZWQgPyBcInJvdGF0ZSgtOTApXCIgOiBcIlwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzID0geWdyaWRMaW5lLm1lcmdlKHlncmlkTGluZXMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZVxyXG5cdFx0Y29uc3QgeXYgPSAkJC55di5iaW5kKCQkKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy55Z3JpZExpbmV9ICR7ZC5jbGFzcyB8fCBcIlwifWAudHJpbSgpKVxyXG5cdFx0XHQuc2VsZWN0KFwibGluZVwiKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyB5diA6IDApXHJcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8geXYgOiB3aWR0aClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogeXYpXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gaGVpZ2h0IDogeXYpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZ2V0R3JpZFRleHRBbmNob3IpXHJcblx0XHRcdC5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoaXNSb3RhdGVkLCB3aWR0aCwgaGVpZ2h0KSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHl2KVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHQkZWwuZ3JpZExpbmVzLnkgPSB5Z3JpZExpbmVzO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0dyaWQod2l0aFRyYW5zaXRpb246IGJvb2xlYW4pOiBhbnlbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGNvbmZpZzoge2F4aXNfcm90YXRlZDogaXNSb3RhdGVkfSxcclxuXHRcdFx0c3RhdGU6IHt3aWR0aCwgaGVpZ2h0fSxcclxuXHRcdFx0JGVsOiB7Z3JpZExpbmVzfVxyXG5cdFx0fSA9ICQkO1xyXG5cdFx0Y29uc3QgeHYgPSAkJC54di5iaW5kKCQkKTtcclxuXHJcblx0XHRsZXQgbGluZXMgPSBncmlkTGluZXMueC5zZWxlY3QoXCJsaW5lXCIpO1xyXG5cdFx0bGV0IHRleHRzID0gZ3JpZExpbmVzLnguc2VsZWN0KFwidGV4dFwiKTtcclxuXHJcblx0XHRsaW5lcyA9ICh3aXRoVHJhbnNpdGlvbiA/IGxpbmVzLnRyYW5zaXRpb24oKSA6IGxpbmVzKVxyXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyB3aWR0aCA6IHh2KVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IHh2IDogMClcclxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyB4diA6IGhlaWdodCk7XHJcblxyXG5cdFx0dGV4dHMgPSAod2l0aFRyYW5zaXRpb24gPyB0ZXh0cy50cmFuc2l0aW9uKCkgOiB0ZXh0cylcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIGdldEdyaWRUZXh0WCghaXNSb3RhdGVkLCB3aWR0aCwgaGVpZ2h0KSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHh2KVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dCk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGluaXRGb2N1c0dyaWQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXB9LCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc0Zyb250ID0gY29uZmlnLmdyaWRfZnJvbnQ7XHJcblx0XHRjb25zdCBjbGFzc05hbWUgPSBgLiR7Q0xBU1NbaXNGcm9udCAmJiAkZWwuZ3JpZExpbmVzLm1haW4gPyBcImdyaWRMaW5lc1wiIDogXCJjaGFydFwiXX0ke2lzRnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YDtcclxuXHJcblx0XHRjb25zdCBncmlkID0gJGVsLm1haW4uaW5zZXJ0KFwiZ1wiLCBjbGFzc05hbWUpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXAucGF0aEdyaWQpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZ3JpZCk7XHJcblxyXG5cdFx0JGVsLmdyaWQubWFpbiA9IGdyaWQ7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeF9zaG93ICYmXHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRzKTtcclxuXHJcblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiZcclxuXHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZHMpO1xyXG5cclxuXHRcdGlmIChjb25maWcuZ3JpZF9mb2N1c19zaG93KSB7XHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cylcclxuXHRcdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cyk7XHJcblxyXG5cdFx0XHQvLyB0byBzaG93IHh5IGZvY3VzIGdyaWQgbGluZSwgc2hvdWxkIGJlICd0b29sdGlwLmdyb3VwZWQ9ZmFsc2UnXHJcblx0XHRcdGlmIChjb25maWcuZ3JpZF9mb2N1c195ICYmICFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkRm9jdXMpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZEZvY3VzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgZ3JpZCBmb2N1cyBsaW5lXHJcblx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWREYXRhIFNlbGVjdGVkIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpZHRoLCBoZWlnaHR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cclxuXHRcdC8vIEhpZGUgd2hlbiBidWJibGUvc2NhdHRlci9zdGFuZm9yZCBwbG90IGV4aXN0c1xyXG5cdFx0aWYgKCFjb25maWcudG9vbHRpcF9zaG93IHx8IGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBmb2N1c0VsID0gJCQuJGVsLm1haW4uc2VsZWN0QWxsKGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c30sIGxpbmUuJHtDTEFTUy55Z3JpZEZvY3VzfWApO1xyXG5cdFx0Y29uc3QgaXNFZGdlID0gY29uZmlnLmdyaWRfZm9jdXNfZWRnZSAmJiAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZDtcclxuXHRcdGNvbnN0IHh4ID0gJCQueHguYmluZCgkJCk7XHJcblxyXG5cdFx0Zm9jdXNFbFxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxyXG5cdFx0XHQuZGF0YShkYXRhVG9TaG93LmNvbmNhdChkYXRhVG9TaG93KSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IGVsID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgcG9zID0ge1xyXG5cdFx0XHRcdFx0eDogeHgoZCksXHJcblx0XHRcdFx0XHR5OiAkJC5nZXRZU2NhbGVCeUlkKGQuaWQpKGQudmFsdWUpXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRsZXQgeHk7XHJcblxyXG5cdFx0XHRcdGlmIChlbC5jbGFzc2VkKENMQVNTLnhncmlkRm9jdXMpKSB7XHJcblx0XHRcdFx0XHQvLyB3aWxsIGNvbnRhaW4gJ3gxLCB5MSwgeDIsIHkyJyBvcmRlclxyXG5cdFx0XHRcdFx0eHkgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFx0XHRbXHJcblx0XHRcdFx0XHRcdFx0bnVsbCwgLy8geDFcclxuXHRcdFx0XHRcdFx0XHRwb3MueCwgLy8geTFcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgPyBwb3MueSA6IHdpZHRoLCAvLyB4MlxyXG5cdFx0XHRcdFx0XHRcdHBvcy54IC8vIHkyXHJcblx0XHRcdFx0XHRcdF0gOiBbXHJcblx0XHRcdFx0XHRcdFx0cG9zLngsXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlID8gcG9zLnkgOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdHBvcy54LFxyXG5cdFx0XHRcdFx0XHRcdGhlaWdodFxyXG5cdFx0XHRcdFx0XHRdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zdCBpc1kyID0gJCQuYXhpcy5nZXRJZChkLmlkKSA9PT0gXCJ5MlwiO1xyXG5cclxuXHRcdFx0XHRcdHh5ID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRcdFx0W1xyXG5cdFx0XHRcdFx0XHRcdHBvcy55LCAvLyB4MVxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiAhaXNZMiA/IHBvcy54IDogbnVsbCwgLy8geTFcclxuXHRcdFx0XHRcdFx0XHRwb3MueSwgLy8geDJcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgaXNZMiA/IHBvcy54IDogaGVpZ2h0IC8vIHkyXHJcblx0XHRcdFx0XHRcdF0gOiBbXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmIGlzWTIgPyBwb3MueCA6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0cG9zLnksXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmICFpc1kyID8gcG9zLnggOiB3aWR0aCxcclxuXHRcdFx0XHRcdFx0XHRwb3MueVxyXG5cdFx0XHRcdFx0XHRdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0W1wieDFcIiwgXCJ5MVwiLCBcIngyXCIsIFwieTJcIl1cclxuXHRcdFx0XHRcdC5mb3JFYWNoKCh2LCBpKSA9PiBlbC5hdHRyKHYsIHh5W2ldKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHNtb290aExpbmVzKGZvY3VzRWwsIFwiZ3JpZFwiKTtcclxuXHJcblx0XHQkJC5zaG93Q2lyY2xlRm9jdXMoc2VsZWN0ZWREYXRhKTtcclxuXHR9LFxyXG5cclxuXHRoaWRlR3JpZEZvY3VzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7aW5wdXRUeXBlfSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGlucHV0VHlwZSA9PT0gXCJtb3VzZVwiKSB7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c30sIGxpbmUuJHtDTEFTUy55Z3JpZEZvY3VzfWApXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHJcblx0XHRcdCQkLmhpZGVDaXJjbGVGb2N1cygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUdyaWRGb2N1cygpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge2lucHV0VHlwZSwgd2lkdGgsIGhlaWdodH0sICRlbDoge2dyaWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeGdyaWRGb2N1cyA9IGdyaWQubWFpbi5zZWxlY3QoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfWApO1xyXG5cclxuXHRcdGlmIChpbnB1dFR5cGUgPT09IFwidG91Y2hcIikge1xyXG5cdFx0XHRpZiAoIXhncmlkRm9jdXMuZW1wdHkoKSkge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSB4Z3JpZEZvY3VzLmRhdHVtKCk7XHJcblxyXG5cdFx0XHRcdGQgJiYgJCQuc2hvd0dyaWRGb2N1cyhbZF0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkJC5zaG93Q2lyY2xlRm9jdXMoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0XHR4Z3JpZEZvY3VzXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogLTEwKVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gd2lkdGggOiAtMTApXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAtMTAgOiAwKVxyXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gLTEwIDogaGVpZ2h0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBuZWVkIHRvIHJldHVybiAndHJ1ZScgYXMgb2YgYmVpbmcgcHVzaGVkIHRvIHRoZSByZWRyYXcgbGlzdFxyXG5cdFx0Ly8gcmVmOiBnZXRSZWRyYXdMaXN0KClcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR3JpZERhdGEodHlwZTogc3RyaW5nLCBzY2FsZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGlja051bSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YClcclxuXHRcdFx0LnNlbGVjdEFsbChcIi50aWNrXCIpXHJcblx0XHRcdC5zaXplKCk7XHJcblx0XHRsZXQgZ3JpZERhdGE6IERhdGVbXSA9IFtdO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSBcInllYXJcIikge1xyXG5cdFx0XHRjb25zdCB4RG9tYWluID0gJCQuZ2V0WERvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBmaXJzdFllYXIgPSB4RG9tYWluWzBdLmdldEZ1bGxZZWFyKCk7XHJcblx0XHRcdGNvbnN0IGxhc3RZZWFyID0geERvbWFpblsxXS5nZXRGdWxsWWVhcigpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IGZpcnN0WWVhcjsgaSA8PSBsYXN0WWVhcjsgaSsrKSB7XHJcblx0XHRcdFx0Z3JpZERhdGEucHVzaChuZXcgRGF0ZShgJHtpfS0wMS0wMSAwMDowMDowMGApKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Z3JpZERhdGEgPSBzY2FsZS50aWNrcygxMCk7XHJcblxyXG5cdFx0XHRpZiAoZ3JpZERhdGEubGVuZ3RoID4gdGlja051bSkgeyAvLyB1c2Ugb25seSBpbnRcclxuXHRcdFx0XHRncmlkRGF0YSA9IGdyaWREYXRhLmZpbHRlcihkID0+IFN0cmluZyhkKS5pbmRleE9mKFwiLlwiKSA8IDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdyaWREYXRhO1xyXG5cdH0sXHJcblxyXG5cdGdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpOiBGdW5jdGlvbiB7XHJcblx0XHRyZXR1cm4gcGFyYW1zID8gbGluZSA9PiB7XHJcblx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0KGlzQXJyYXkocGFyYW1zKSA/IHBhcmFtcy5jb25jYXQoKSA6IFtwYXJhbXNdKS5mb3JFYWNoKHBhcmFtID0+IHtcclxuXHRcdFx0XHRpZiAoKChcInZhbHVlXCIgaW4gcGFyYW0gJiYgbGluZS52YWx1ZSA9PT0gcGFyYW0udmFsdWUpIHx8IChcImNsYXNzXCIgaW4gcGFyYW0gJiYgbGluZS5jbGFzcyA9PT0gcGFyYW0uY2xhc3MpKSkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZm91bmQ7XHJcblx0XHR9IDogKCkgPT4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmb3JYPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRvUmVtb3ZlID0gJCQuZ2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcyk7XHJcblx0XHRjb25zdCB0b1Nob3cgPSBsaW5lID0+ICF0b1JlbW92ZShsaW5lKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSBmb3JYID8gQ0xBU1MueGdyaWRMaW5lcyA6IENMQVNTLnlncmlkTGluZXM7XHJcblx0XHRjb25zdCBjbGFzc0xpbmUgPSBmb3JYID8gQ0xBU1MueGdyaWRMaW5lIDogQ0xBU1MueWdyaWRMaW5lO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgLiR7Y2xhc3NMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtjbGFzc0xpbmV9YClcclxuXHRcdFx0LmZpbHRlcih0b1JlbW92ZSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBncmlkTGluZXMgPSBgZ3JpZF8ke2ZvclggPyBcInhcIiA6IFwieVwifV9saW5lc2A7XHJcblxyXG5cdFx0Y29uZmlnW2dyaWRMaW5lc10gPSBjb25maWdbZ3JpZExpbmVzXS5maWx0ZXIodG9TaG93KTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7IC8vIHNlbGVjdGlvblxyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNWYWx1ZSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IHtBeGlzVHlwZX0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJlZ2lvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluID0gJGVsLm1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5zdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MucmVnaW9ucyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmVnaW9uKGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoISRlbC5yZWdpb24ubWFpbikge1xyXG5cdFx0XHQkJC5pbml0UmVnaW9uKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaGlkZSBpZiBhcmMgdHlwZVxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpO1xyXG5cclxuXHRcdC8vIHNlbGVjdCA8Zz4gZWxlbWVudFxyXG5cdFx0bGV0IGxpc3QgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MucmVnaW9ufWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5yZWdpb25zKTtcclxuXHJcblx0XHRsaXN0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGxpc3QgPSBsaXN0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0Lm1lcmdlKGxpc3QpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NSZWdpb24uYmluZCgkJCkpO1xyXG5cclxuXHRcdGxpc3RcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHQkZWwucmVnaW9uLmxpc3QgPSBsaXN0O1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JlZ2lvbih3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwucmVnaW9uLmxpc3Quc2VsZWN0KFwicmVjdFwiKTtcclxuXHJcblx0XHRyZWdpb25zID0gKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLnJlZ2lvblkuYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLnJlZ2lvbkhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBkID0+IChpc1ZhbHVlKGQub3BhY2l0eSkgPyBkLm9wYWNpdHkgOiBcIjAuMVwiKSlcclxuXHRcdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3NhcnkgcmVjdCBhZnRlciB0cmFuc2l0aW9uXHJcblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzLnBhcmVudE5vZGUpXHJcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJyZWN0Om5vdChbeF0pXCIpXHJcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25YWSh0eXBlOiBBeGlzVHlwZSwgZCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1ggPSB0eXBlID09PSBcInhcIjtcclxuXHRcdGxldCBrZXkgPSBcInN0YXJ0XCI7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IHBvcyA9IDA7XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1gpIHtcclxuXHRcdFx0XHRrZXkgPSBcImVuZFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzWCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdFx0Y3VyclNjYWxlID0gc2NhbGVbZC5heGlzXTtcclxuXHRcdFx0XHRwb3MgPSBjdXJyU2NhbGUoZFtrZXldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgoaXNYID8gIWlzUm90YXRlZCA6IGlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0Y3VyclNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cdFx0XHRwb3MgPSBjdXJyU2NhbGUoJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSA/IHBhcnNlRGF0ZS5jYWxsKCQkLCBkW2tleV0pIDogZFtrZXldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9zO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvblgoZCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25YWShcInhcIiwgZCk7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uWShkKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieVwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25TaXplKHR5cGUsIGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGlzV2lkdGggPSB0eXBlID09PSBcIndpZHRoXCI7XHJcblx0XHRjb25zdCBzdGFydCA9ICQkW2lzV2lkdGggPyBcInJlZ2lvblhcIiA6IFwicmVnaW9uWVwiXShkKTtcclxuXHRcdGxldCBjdXJyU2NhbGU7XHJcblx0XHRsZXQga2V5ID0gXCJlbmRcIjtcclxuXHRcdGxldCBlbmQgPSBzdGF0ZVt0eXBlXTtcclxuXHJcblx0XHRpZiAoZC5heGlzID09PSBcInlcIiB8fCBkLmF4aXMgPT09IFwieTJcIikge1xyXG5cdFx0XHRpZiAoIWlzV2lkdGgpIHtcclxuXHRcdFx0XHRrZXkgPSBcInN0YXJ0XCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgoaXNXaWR0aCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdFx0Y3VyclNjYWxlID0gc2NhbGVbZC5heGlzXTtcclxuXHRcdFx0XHRlbmQgPSBjdXJyU2NhbGUoZFtrZXldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgoaXNXaWR0aCA/ICFpc1JvdGF0ZWQgOiBpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHRcdFx0ZW5kID0gY3VyclNjYWxlKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgPyBwYXJzZURhdGUuY2FsbCgkJCwgZFtrZXldKSA6IGRba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVuZCA8IHN0YXJ0ID8gMCA6IGVuZCAtIHN0YXJ0O1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvbldpZHRoKGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcIndpZHRoXCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvbkhlaWdodChkKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblNpemUoXCJoZWlnaHRcIiwgZCk7XHJcblx0fSxcclxuXHJcblx0aXNSZWdpb25PblgoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuICFkLmF4aXMgfHwgZC5heGlzID09PSBcInhcIjtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7cmdiIGFzIGQzUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2VsZWN0IGEgcG9pbnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBwb2ludFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZWxlY3RQb2ludCh0YXJnZXQsIGQsIGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgY3ggPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY3kgPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50U2VsZWN0Ui5iaW5kKCQkKTtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHQvLyBhZGQgc2VsZWN0ZWQtY2lyY2xlIG9uIGxvdyBsYXllciBnXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9LSR7aX1gKVxyXG5cdFx0XHQuZGF0YShbZF0pXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJjaXJjbGVcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoKSA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlLCBpKSlcclxuXHRcdFx0LmF0dHIoXCJjeFwiLCBjeClcclxuXHRcdFx0LmF0dHIoXCJjeVwiLCBjeSlcclxuXHRcdFx0LmF0dHIoXCJzdHJva2VcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5hdHRyKFwiclwiLCBkMiA9PiAkJC5wb2ludFNlbGVjdFIoZDIpICogMS40KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5hdHRyKFwiclwiLCByKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmVsZWN0IGEgcG9pbnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBwb2ludFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1bnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29udW5zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHQvLyByZW1vdmUgc2VsZWN0ZWQtY2lyY2xlIGZyb20gbG93IGxheWVyIGdcclxuXHRcdCRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9LSR7aX1gKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5hdHRyKFwiclwiLCAwKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHBvaW50c1xyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0b2dnbGVQb2ludChzZWxlY3RlZCwgdGFyZ2V0LCBkLCBpOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IG1ldGhvZCA9IGAke3NlbGVjdGVkID8gXCJcIiA6IFwidW5cIn1zZWxlY3RQb2ludGA7XHJcblxyXG5cdFx0dGhpc1ttZXRob2RdKHRhcmdldCwgZCwgaSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2VsZWN0IGEgcGF0aFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IHBhdGhcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2VsZWN0UGF0aCh0YXJnZXQsIGQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29uc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xyXG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICgpID0+IGQzUmdiKCQkLmNvbG9yKGQpKS5icmlnaHRlcigwLjc1KSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5lbGVjdCBhIHBhdGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IHBhdGhcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UGF0aCh0YXJnZXQsIGQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29udW5zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2JyaWdodGVuKSB7XHJcblx0XHRcdHRhcmdldC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgKCkgPT4gJCQuY29sb3IoZCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBsaW5lc1xyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0b2dnbGVQYXRoKHNlbGVjdGVkLCB0YXJnZXQsIGQsIGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpc1tcclxuXHRcdFx0YCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBhdGhgXHJcblx0XHRdKHRhcmdldCwgZCwgaSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdG9nZ2xlIG1ldGhvZCBvZiB0aGUgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRoYXQgc2hhcGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdG9nZ2xlIG1ldGhvZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VG9nZ2xlKHRoYXQsIGQpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiID9cclxuXHRcdFx0JCQudG9nZ2xlUGF0aCA6IChcclxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cclxuXHRcdFx0XHRcdCgpID0+IHt9IDogLy8gY2lyY2xlIGlzIGhpZGRlbiBpbiBzdGVwIGNoYXJ0LCBzbyB0cmVhdCBhcyB3aXRoaW4gdGhlIGNsaWNrIGFyZWFcclxuXHRcdFx0XHRcdCQkLnRvZ2dsZVBvaW50XHJcblx0XHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHNoYXBlc1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IHNoYXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBJbmRleCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRvZ2dsZVNoYXBlKHRoYXQsIGQsIGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoYXQpO1xyXG5cdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoYXQsIGQpLmJpbmQoJCQpO1xyXG5cdFx0bGV0IHRvZ2dsZWRTaGFwZTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkpIHtcclxuXHRcdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUpIHtcclxuXHRcdFx0XHRsZXQgc2VsZWN0b3IgPSBgLiR7Q0xBU1Muc2hhcGVzfWA7XHJcblxyXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0c2VsZWN0b3IgKz0gJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYWluLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCkpIHtcclxuXHRcdFx0XHRcdFx0XHR0b2dnbGVkU2hhcGUgPSBzaGFwZTtcclxuXHRcdFx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXRvZ2dsZWRTaGFwZSB8fCB0b2dnbGVkU2hhcGUubm9kZSgpICE9PSBzaGFwZS5ub2RlKCkpIHtcclxuXHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCAhaXNTZWxlY3RlZCk7XHJcblx0XHRcdFx0dG9nZ2xlKCFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7bW91c2UgYXMgZDNNb3VzZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBnZXRSZWN0U2VnTGlzdCwgaXNOdW1iZXIsIGlzT2JqZWN0VHlwZSwgaXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdEJhcigpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHskZWx9ID0gdGhpcztcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQvLyBzaG91bGQgcG9zaXRpb25lZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzaGFwZSBub2RlIHRvIG5vdCBvdmVybGFwIG90aGVyc1xyXG5cdFx0XHQuaW5zZXJ0KFwiZ1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0c0ZvckJhcih0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmICghJGVsLmJhcikge1xyXG5cdFx0XHQkJC5pbml0QmFyKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWFpbkJhclVwZGF0ZSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QmFyfWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QmFyKGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpbkJhckVudGVyID0gbWFpbkJhclVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXHJcblx0XHRtYWluQmFyRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycylcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgYmFyRGF0YSA9ICQkLmJhckRhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0JhciA9ICQkLmNsYXNzQmFyLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgaW5pdGlhbE9wYWNpdHkgPSAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKTtcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfWApXHJcblx0XHRcdC5kYXRhKGJhckRhdGEpO1xyXG5cclxuXHRcdCRlbC5iYXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0JGVsLmJhciA9ICRlbC5iYXIuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5tZXJnZSgkZWwuYmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGluaXRpYWxPcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdCYXIoZHJhd0Jhciwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCB7YmFyfSA9IHRoaXMuJGVsO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IGJhcilcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0JhcilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0Z2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XHJcblx0XHRjb25zdCB0aWNrSW50ZXJ2YWwgPSAoc2NhbGUuem9vbSB8fCAkJCkgJiYgISQkLmF4aXMuaXNDYXRlZ29yaXplZCgpID9cclxuXHRcdFx0JCQueHgoc2NhbGUuc3ViWC5kb21haW4oKVsxXSkgLyBtYXhEYXRhQ291bnQgOiBheGlzLnRpY2tJbnRlcnZhbChtYXhEYXRhQ291bnQpO1xyXG5cdFx0bGV0IHJlc3VsdDtcclxuXHJcblx0XHRjb25zdCBnZXRXaWR0aCA9IChpZD86IHN0cmluZykgPT4ge1xyXG5cdFx0XHRjb25zdCB3aWR0aCA9IGlkID8gY29uZmlnLmJhcl93aWR0aFtpZF0gOiBjb25maWcuYmFyX3dpZHRoO1xyXG5cdFx0XHRjb25zdCByYXRpbyA9IGlkID8gd2lkdGgucmF0aW8gOiBjb25maWcuYmFyX3dpZHRoX3JhdGlvO1xyXG5cdFx0XHRjb25zdCBtYXggPSBpZCA/IHdpZHRoLm1heCA6IGNvbmZpZy5iYXJfd2lkdGhfbWF4O1xyXG5cdFx0XHRjb25zdCB3ID0gaXNOdW1iZXIod2lkdGgpID9cclxuXHRcdFx0XHR3aWR0aCA6IGJhclRhcmdldHNOdW0gPyAodGlja0ludGVydmFsICogcmF0aW8pIC8gYmFyVGFyZ2V0c051bSA6IDA7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF4ICYmIHcgPiBtYXggPyBtYXggOiB3O1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXN1bHQgPSBnZXRXaWR0aCgpO1xyXG5cclxuXHRcdGlmICghaXNHcm91cGVkICYmIGlzT2JqZWN0VHlwZShjb25maWcuYmFyX3dpZHRoKSkge1xyXG5cdFx0XHRyZXN1bHQgPSB7d2lkdGg6IHJlc3VsdCwgdG90YWw6IFtdfTtcclxuXHJcblx0XHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGlmIChjb25maWcuYmFyX3dpZHRoW3YuaWRdKSB7XHJcblx0XHRcdFx0XHRyZXN1bHRbdi5pZF0gPSBnZXRXaWR0aCh2LmlkKTtcclxuXHRcdFx0XHRcdHJlc3VsdC50b3RhbC5wdXNoKHJlc3VsdFt2LmlkXSB8fCByZXN1bHQud2lkdGgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHRnZXRCYXJzKGk6IG51bWJlciwgaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyBtYWluXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiBtYWluKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9JHtzdWZmaXh9YCk7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQmFycyhpOiBudW1iZXIsIGlkOiBzdHJpbmcsIHJlc2V0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRCYXJzKCk7XHJcblx0XHQkJC5nZXRCYXJzKGksIGlkKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZEJhcnMoaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmdldEJhcnMoaSkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XHJcblx0XHRjb25zdCBiYXJSYWRpdXMgPSBjb25maWcuYmFyX3JhZGl1cztcclxuXHRcdGNvbnN0IGJhclJhZGl1c1JhdGlvID0gY29uZmlnLmJhcl9yYWRpdXNfcmF0aW87XHJcblxyXG5cdFx0Ly8gZ2V0IHRoZSBiYXIgcmFkaXVzXHJcblx0XHRjb25zdCBnZXRSYWRpdXMgPSBpc051bWJlcihiYXJSYWRpdXMpICYmIGJhclJhZGl1cyA+IDAgP1xyXG5cdFx0XHQoKSA9PiBiYXJSYWRpdXMgOiAoXHJcblx0XHRcdFx0aXNOdW1iZXIoYmFyUmFkaXVzUmF0aW8pID8gdyA9PiB3ICogYmFyUmFkaXVzUmF0aW8gOiBudWxsXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdC8vIDQgcG9pbnRzIHRoYXQgbWFrZSBhIGJhclxyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBnZXRQb2ludHMoZCwgaSk7XHJcblxyXG5cdFx0XHQvLyBzd2l0Y2ggcG9pbnRzIGlmIGF4aXMgaXMgcm90YXRlZCwgbm90IGFwcGxpY2FibGUgZm9yIHN1YiBjaGFydFxyXG5cdFx0XHRjb25zdCBpbmRleFggPSAraXNSb3RhdGVkO1xyXG5cdFx0XHRjb25zdCBpbmRleFkgPSArIWluZGV4WDtcclxuXHJcblx0XHRcdGNvbnN0IGlzTmVnYXRpdmUgPSBkLnZhbHVlIDwgMDtcclxuXHRcdFx0Y29uc3QgcGF0aFJhZGl1cyA9IFtcIlwiLCBcIlwiXTtcclxuXHRcdFx0bGV0IHJhZGl1cyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoZ2V0UmFkaXVzICYmICFpc0dyb3VwZWQpIHtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGlzUm90YXRlZCA/IGluZGV4WSA6IGluZGV4WDtcclxuXHRcdFx0XHRjb25zdCBiYXJXID0gcG9pbnRzWzJdW2luZGV4XSAtIHBvaW50c1swXVtpbmRleF07XHJcblxyXG5cdFx0XHRcdHJhZGl1cyA9IGdldFJhZGl1cyhiYXJXKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXJjID0gYGEke3JhZGl1c30sJHtyYWRpdXN9ICR7aXNOZWdhdGl2ZSA/IGAxIDAgMGAgOiBgMCAwIDFgfSBgO1xyXG5cclxuXHRcdFx0XHRwYXRoUmFkaXVzWyshaXNSb3RhdGVkXSA9IGAke2FyY30ke3JhZGl1c30sJHtyYWRpdXN9YDtcclxuXHRcdFx0XHRwYXRoUmFkaXVzWytpc1JvdGF0ZWRdID0gYCR7YXJjfSR7Wy1yYWRpdXMsIHJhZGl1c11baXNSb3RhdGVkID8gXCJzb3J0XCIgOiBcInJldmVyc2VcIl0oKX1gO1xyXG5cclxuXHRcdFx0XHRpc05lZ2F0aXZlICYmIHBhdGhSYWRpdXMucmV2ZXJzZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBwYXRoIHN0cmluZyBkYXRhIHNob3VsZG4ndCBiZSBjb250YWluaW5nIG5ldyBsaW5lIGNoYXJzXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzUzMFxyXG5cdFx0XHRjb25zdCBwYXRoID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRgSCR7cG9pbnRzWzFdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1swXX1WJHtwb2ludHNbMl1baW5kZXhZXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfUgke3BvaW50c1szXVtpbmRleFhdfWAgOlxyXG5cdFx0XHRcdGBWJHtwb2ludHNbMV1baW5kZXhZXSArIChpc05lZ2F0aXZlID8gLXJhZGl1cyA6IHJhZGl1cyl9ICR7cGF0aFJhZGl1c1swXX1IJHtwb2ludHNbMl1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfVYke3BvaW50c1szXVtpbmRleFldfWA7XHJcblxyXG5cdFx0XHRyZXR1cm4gYE0ke3BvaW50c1swXVtpbmRleFhdfSwke3BvaW50c1swXVtpbmRleFldfSR7cGF0aH16YDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXMgPSBpc1N1YiA/ICQkLmF4aXMuc3ViWCA6ICQkLmF4aXMueDtcclxuXHRcdGNvbnN0IGJhclRhcmdldHNOdW0gPSAkJC5nZXRJbmRpY2VzTWF4KGJhckluZGljZXMpICsgMTtcclxuXHRcdGNvbnN0IGJhclcgPSAkJC5nZXRCYXJXKGF4aXMsIGJhclRhcmdldHNOdW0pO1xyXG5cdFx0Y29uc3QgYmFyWCA9ICQkLmdldFNoYXBlWChiYXJXLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IGJhclkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBiYXJPZmZzZXQgPSAkJC5nZXRTaGFwZU9mZnNldCgkJC5pc0JhclR5cGUsIGJhckluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0U2hhcGVZTWluKGQuaWQpKTtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gYmFyT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYmFyIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHdpZHRoID0gaXNOdW1iZXIoYmFyVykgPyBiYXJXIDogYmFyV1tkLmlkXSB8fCBiYXJXLndpZHRoO1xyXG5cdFx0XHRjb25zdCBwb3NYID0gYmFyWChkKTtcclxuXHRcdFx0bGV0IHBvc1kgPSBiYXJZKGQpO1xyXG5cclxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcclxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxyXG5cdFx0XHQpKSB7XHJcblx0XHRcdFx0cG9zWSA9IHkwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb3NZIC09ICh5MCAtIG9mZnNldCk7XHJcblxyXG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcclxuXHRcdFx0XHRbcG9zWCwgcG9zWV0sXHJcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgcG9zWV0sXHJcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgb2Zmc2V0XVxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpbkJhcih0aGF0KTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UodGhhdCk7XHJcblx0XHRjb25zdCBsaXN0ID0gZ2V0UmVjdFNlZ0xpc3QodGhhdCk7XHJcblx0XHRjb25zdCBbc2VnMCwgc2VnMV0gPSBsaXN0O1xyXG5cdFx0Y29uc3QgeCA9IE1hdGgubWluKHNlZzAueCwgc2VnMS54KTtcclxuXHRcdGNvbnN0IHkgPSBNYXRoLm1pbihzZWcwLnksIHNlZzEueSk7XHJcblx0XHRjb25zdCBvZmZzZXQgPSB0aGlzLmNvbmZpZy5iYXJfc2Vuc2l0aXZpdHk7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGF0LmdldEJCb3goKTtcclxuXHRcdGNvbnN0IHN4ID0geCAtIG9mZnNldDtcclxuXHRcdGNvbnN0IGV4ID0geCArIHdpZHRoICsgb2Zmc2V0O1xyXG5cdFx0Y29uc3Qgc3kgPSB5ICsgaGVpZ2h0ICsgb2Zmc2V0O1xyXG5cdFx0Y29uc3QgZXkgPSB5IC0gb2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiBzeCA8IG1vdXNlWzBdICYmXHJcblx0XHRcdG1vdXNlWzBdIDwgZXggJiZcclxuXHRcdFx0ZXkgPCBtb3VzZVsxXSAmJlxyXG5cdFx0XHRtb3VzZVsxXSA8IHN5O1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2dldE1pbk1heCwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdEJ1YmJsZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJidWJibGVcIikpIHtcclxuXHRcdFx0Y29uZmlnLnBvaW50X3Nob3cgPSB0cnVlO1xyXG5cdFx0XHRjb25maWcucG9pbnRfdHlwZSA9IFwiY2lyY2xlXCI7XHJcblx0XHRcdGNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSA9IDI1O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB1c2VyIGFnZW50J3MgY29tcHV0ZWQgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZUxlbmd0aCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5idWJibGVCYXNlTGVuZ3RoO1xyXG5cdFx0bGV0IGJhc2VMZW5ndGggPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghYmFzZUxlbmd0aCkge1xyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIGJhc2VMZW5ndGggPSBnZXRNaW5NYXgoXCJtaW5cIiwgW3dpZHRoLCBoZWlnaHRdKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2VMZW5ndGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSByYWRpdXMgdmFsdWUgZm9yIGJ1YmJsZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRCdWJibGVSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IG1heFIgPSAkJC5jb25maWcuYnViYmxlX21heFI7XHJcblxyXG5cdFx0aWYgKGlzRnVuY3Rpb24obWF4UikpIHtcclxuXHRcdFx0bWF4UiA9IG1heFIuYmluZCgkJC5hcGkpKGQpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNOdW1iZXIobWF4UikpIHtcclxuXHRcdFx0bWF4UiA9ICgkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSkgKyAxMjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heC5tYXAoZCA9PiAoXHJcblx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IChcclxuXHRcdFx0XHRcdGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlXHJcblx0XHRcdFx0KVxyXG5cdFx0KSkpO1xyXG5cdFx0Y29uc3QgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSTtcclxuXHRcdGNvbnN0IGFyZWEgPSAoJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWUpICogKG1heEFyZWEgLyBtYXgpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoYXJlYSAvIE1hdGguUEkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBidWJibGUgZGltZW5zaW9uIGRhdGFcclxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gZCBkYXRhIHZhbHVlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB5IG9yIHpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QnViYmxlWkRhdGEoZCwgdHlwZTogXCJ5XCIgfCBcInpcIik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gaXNPYmplY3QoZCkgPyBkW3R5cGVdIDogZFt0eXBlID09PSBcInlcIiA/IDAgOiAxXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmUgaWYgYnViYmxlIGhhcyBkaW1lbnNpb24gZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBkIGRhdGEgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGlzQnViYmxlWlR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5pc0J1YmJsZVR5cGUoZCkgJiYgKFxyXG5cdFx0XHQoaXNPYmplY3QoZC52YWx1ZSkgJiYgKFwielwiIGluIGQudmFsdWUgfHwgXCJ5XCIgaW4gZC52YWx1ZSkpIHx8XHJcblx0XHRcdChpc0FycmF5KGQudmFsdWUpICYmIGQudmFsdWUubGVuZ3RoID09PSAyKVxyXG5cdFx0KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRhcmVhIGFzIGQzQXJlYSxcclxuXHRsaW5lIGFzIGQzTGluZVxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBpc0FycmF5LCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBpc1ZhbHVlLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRMaW5lKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyRlbH0gPSB0aGlzO1xyXG5cclxuXHRcdCRlbC5saW5lID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRMaW5lcyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0c0ZvckxpbmUodGFyZ2V0cyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmICghJGVsLmxpbmUpIHtcclxuXHRcdFx0JCQuaW5pdExpbmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYWluTGluZVVwZGF0ZSA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRMaW5lKGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpbkxpbmVFbnRlciA9IG1haW5MaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0Ly8gTGluZXMgZm9yIGVhY2ggZGF0YVxyXG5cdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XHJcblxyXG5cdFx0Ly8gQXJlYXNcclxuXHRcdGlmICgkJC5oYXNUeXBlT2YoXCJBcmVhXCIpKSB7XHJcblx0XHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhcy5iaW5kKCQkKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi5cclxuXHRcdC8vIG1haW5MaW5lVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2Zvcm1hdDoge2V4dHJhTGluZUNsYXNzZXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLmxpbmUgPSAkZWwubWFpblxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwubGluZS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwubGluZSA9ICRlbC5saW5lLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAkeyQkLmNsYXNzTGluZS5iaW5kKCQkKShkKX0gJHtleHRyYUxpbmVDbGFzc2VzKGQpIHx8IFwiXCJ9YClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2UoJGVsLmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInNoYXBlLXJlbmRlcmluZ1wiLCBkID0+ICgkJC5pc1N0ZXBUeXBlKGQpID8gXCJjcmlzcEVkZ2VzXCIgOiBcIlwiKSlcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TGluZShkcmF3TGluZSwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCB7bGluZX0gPSB0aGlzLiRlbDtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBsaW5lLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogbGluZSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIHRoaXMuY29sb3IpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBjdXJ2ZSBpbnRlcnBvbGF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRDdXJ2ZShkKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkU3RlcFR5cGUgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkICYmICQkLmlzU3RlcFR5cGUoZCk7XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBzdGVwICYgcm90YXRlZCwgc2hvdWxkIGJlIGNvbXB1dGVkIGluIGRpZmZlcmVudCB3YXlcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ3MVxyXG5cdFx0cmV0dXJuIGlzUm90YXRlZFN0ZXBUeXBlID8gY29udGV4dCA9PiB7XHJcblx0XHRcdGNvbnN0IHN0ZXAgPSAkJC5nZXRJbnRlcnBvbGF0ZShkKShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIGtlZXAgdGhlIG9yaWdpbmFsIG1ldGhvZFxyXG5cdFx0XHRzdGVwLm9yZ1BvaW50ID0gc3RlcC5wb2ludDtcclxuXHJcblx0XHRcdC8vIHRvIGdldCByb3RhdGVkIHBhdGggZGF0YVxyXG5cdFx0XHRzdGVwLnBvaW50Um90YXRlZCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMSAmJiAodGhpcy5fcG9pbnQgPSAyKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgeTEgPSB0aGlzLl95ICogKDEgLSB0aGlzLl90KSArIHkgKiB0aGlzLl90O1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5MSk7XHJcblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8oeCwgeTEpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHN0ZXAucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDAgPyB0aGlzLm9yZ1BvaW50KHgsIHkpIDogdGhpcy5wb2ludFJvdGF0ZWQoeCwgeSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gc3RlcDtcclxuXHRcdH0gOiAkJC5nZXRJbnRlcnBvbGF0ZShkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURyYXdMaW5lKGxpbmVJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiAoZCkgPT4gc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgbGluZUNvbm5lY3ROdWxsID0gY29uZmlnLmxpbmVfY29ubmVjdE51bGw7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgeVZhbHVlID0gKGQsIGkpID0+IChcclxuXHRcdFx0JCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHRcdHlTY2FsZShkLmlkLCBpc1N1YikoJCQuZ2V0QmFzZVZhbHVlKGQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRsZXQgbGluZSA9IGQzTGluZSgpO1xyXG5cclxuXHRcdGxpbmUgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRsaW5lLngoeVZhbHVlKS55KHhWYWx1ZSkgOiBsaW5lLngoeFZhbHVlKS55KHlWYWx1ZSk7XHJcblxyXG5cdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcclxuXHRcdFx0bGluZSA9IGxpbmUuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeCA9IGlzU3ViID8gc2NhbGUuc3ViWCA6IHNjYWxlLng7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCB5ID0geVNjYWxlKGQuaWQsIGlzU3ViKTtcclxuXHRcdFx0bGV0IHZhbHVlcyA9IGxpbmVDb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXM7XHJcblx0XHRcdGxldCB4MCA9IDA7XHJcblx0XHRcdGxldCB5MCA9IDA7XHJcblx0XHRcdGxldCBwYXRoO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzTGluZVR5cGUoZCkpIHtcclxuXHRcdFx0XHRjb25zdCByZWdpb25zID0gY29uZmlnLmRhdGFfcmVnaW9uc1tkLmlkXTtcclxuXHJcblx0XHRcdFx0aWYgKHJlZ2lvbnMpIHtcclxuXHRcdFx0XHRcdHBhdGggPSAkJC5saW5lV2l0aFJlZ2lvbnModmFsdWVzLCB4LCB5LCByZWdpb25zKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBhdGggPSBsaW5lLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAodmFsdWVzWzBdKSB7XHJcblx0XHRcdFx0XHR4MCA9IHgodmFsdWVzWzBdLngpO1xyXG5cdFx0XHRcdFx0eTAgPSB5KHZhbHVlc1swXS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWJWYWx1ZT86IGJvb2xlYW4pOkZ1bmN0aW9uIHsgLy8gcGFydGlhbCBkdXBsaWNhdGlvbiBvZiBnZW5lcmF0ZUdldEJhclBvaW50c1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzU3ViID0gISFpc1N1YlZhbHVlO1xyXG5cdFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBsaW5lSW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgeSA9ICQkLmdldFNoYXBlWShpc1N1Yik7XHJcblx0XHRjb25zdCBsaW5lT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNMaW5lVHlwZSwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQuYmluZCgkJCk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKCQkLmdldFNoYXBlWU1pbihkLmlkKSk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGxpbmVPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgbGluZSBwb3NpdGlvblxyXG5cdFx0XHRjb25zdCBwb2ludCA9IFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV07XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50LCAvLyBmcm9tIGhlcmUgYW5kIGJlbG93LCBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRsaW5lV2l0aFJlZ2lvbnMoZCwgeCwgeSwgX3JlZ2lvbnMpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5heGlzLmlzVGltZVNlcmllcygpO1xyXG5cdFx0Y29uc3QgeE9mZnNldCA9ICQkLmF4aXMuaXNDYXRlZ29yaXplZCgpID8gMC41IDogMDtcclxuXHRcdGNvbnN0IHJlZ2lvbnM6IGFueVtdID0gW107XHJcblx0XHRjb25zdCBkYXNoYXJyYXkgPSBcIjIgMlwiOyAvLyBkZWZhdWx0IHZhbHVlXHJcblxyXG5cdFx0bGV0IHhwO1xyXG5cdFx0bGV0IHlwO1xyXG5cdFx0bGV0IGRpZmY7XHJcblx0XHRsZXQgZGlmZngyO1xyXG5cclxuXHRcdC8vIGNoZWNrIHdlYXRoZXIgZGF0YSBpcyB3aXRoaW4gcmVnaW9uXHJcblx0XHRjb25zdCBpc1dpdGhpblJlZ2lvbnMgPSAod2l0aGluWCwgd2l0aGluUmVnaW9ucykgPT4ge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gd2l0aGluUmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZWcuc3RhcnQgPCB3aXRoaW5YICYmIHdpdGhpblggPD0gcmVnLmVuZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlZy5zdHlsZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQ2hlY2sgc3RhcnQvZW5kIG9mIHJlZ2lvbnNcclxuXHRcdGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XHJcblx0XHRcdGNvbnN0IGdldFZhbHVlID0gKHY6IERhdGUgfCBhbnksIGRlZjogbnVtYmVyKTogRGF0ZSB8IGFueSA9PiAoXHJcblx0XHRcdFx0aXNVbmRlZmluZWQodikgPyBkZWYgOiAoaXNUaW1lU2VyaWVzID8gcGFyc2VEYXRlLmNhbGwoJCQsIHYpIDogdilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSBfcmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gZ2V0VmFsdWUocmVnLnN0YXJ0LCBkWzBdLngpO1xyXG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFZhbHVlKHJlZy5lbmQsIGRbZC5sZW5ndGggLSAxXS54KTtcclxuXHRcdFx0XHRjb25zdCBzdHlsZSA9IHJlZy5zdHlsZSB8fCB7ZGFzaGFycmF5fTtcclxuXHJcblx0XHRcdFx0cmVnaW9uc1tpXSA9IHtzdGFydCwgZW5kLCBzdHlsZX07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgc2NhbGVzXHJcblx0XHRjb25zdCB4VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB5KGR0LnZhbHVlKSA6IGR0ID0+IHgoZHQueCk7XHJcblx0XHRjb25zdCB5VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB4KGR0LngpIDogZHQgPT4geShkdC52YWx1ZSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHN2ZyBnZW5lcmF0b3IgZnVuY3Rpb24gZm9yIHJlZ2lvblxyXG5cdFx0Y29uc3QgZ2VuZXJhdGVNID0gcG9pbnRzID0+IGBNJHtwb2ludHNbMF1bMF19LCR7cG9pbnRzWzBdWzFdfUwke3BvaW50c1sxXVswXX0sJHtwb2ludHNbMV1bMV19YDtcclxuXHJcblx0XHRjb25zdCBzV2l0aFJlZ2lvbiA9IGlzVGltZVNlcmllcyA/IChkMCwgZDEsIGssIHRpbWVzZXJpZXNEaWZmKSA9PiB7XHJcblx0XHRcdGNvbnN0IHgwID0gZDAueC5nZXRUaW1lKCk7XHJcblx0XHRcdGNvbnN0IHhEaWZmID0gZDEueCAtIGQwLng7XHJcblx0XHRcdGNvbnN0IHh2MCA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiBrKTtcclxuXHRcdFx0Y29uc3QgeHYxID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIChrICsgdGltZXNlcmllc0RpZmYpKTtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0W1t5KHlwKGspKSwgeCh4djApXSwgW3koeXAoayArIGRpZmYpKSwgeCh4djEpXV0gOlxyXG5cdFx0XHRcdFtbeCh4djApLCB5KHlwKGspKV0sIFt4KHh2MSksIHkoeXAoayArIGRpZmYpKV1dO1xyXG5cclxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xyXG5cdFx0fSA6IChkMCwgZDEsIGssIG90aGVyRGlmZikgPT4ge1xyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFtbeSh5cChrKSwgdHJ1ZSksIHgoeHAoaykpXSwgW3koeXAoayArIG90aGVyRGlmZiksIHRydWUpLCB4KHhwKGsgKyBvdGhlckRpZmYpKV1dIDpcclxuXHRcdFx0XHRbW3goeHAoayksIHRydWUpLCB5KHlwKGspKV0sIFt4KHhwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeSh5cChrICsgb3RoZXJEaWZmKSldXTtcclxuXHJcblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGVcclxuXHRcdGxldCBwYXRoID0gXCJcIjtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCwgZGF0YTsgKGRhdGEgPSBkW2ldKTsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHByZXZEYXRhID0gZFtpIC0gMV07XHJcblx0XHRcdGNvbnN0IGhhc1ByZXZEYXRhID0gcHJldkRhdGEgJiYgaXNWYWx1ZShwcmV2RGF0YS52YWx1ZSk7XHJcblx0XHRcdGxldCBzdHlsZSA9IGlzV2l0aGluUmVnaW9ucyhkYXRhLngsIHJlZ2lvbnMpO1xyXG5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvMTE3MlxyXG5cdFx0XHRpZiAoIWlzVmFsdWUoZGF0YS52YWx1ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRHJhdyBhcyBub3JtYWxcclxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJlZ2lvbnMpIHx8ICFzdHlsZSB8fCAhaGFzUHJldkRhdGEpIHtcclxuXHRcdFx0XHRwYXRoICs9IGAke2kgJiYgaGFzUHJldkRhdGEgPyBcIkxcIiA6IFwiTVwifSR7eFZhbHVlKGRhdGEpfSwke3lWYWx1ZShkYXRhKX1gO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGhhc1ByZXZEYXRhKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHN0eWxlID0gc3R5bGUuZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRzdHlsZSA9IGRhc2hhcnJheS5zcGxpdChcIiBcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEcmF3IHdpdGggcmVnaW9uIC8vIFRPRE86IEZpeCBmb3IgaG9yaXpvdGFsIGNoYXJ0c1xyXG5cdFx0XHRcdHhwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEueCArIHhPZmZzZXQsIGRhdGEueCArIHhPZmZzZXQsIGlzVGltZVNlcmllcyk7XHJcblx0XHRcdFx0eXAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS52YWx1ZSwgZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGR4ID0geChkYXRhLngpIC0geChwcmV2RGF0YS54KTtcclxuXHRcdFx0XHRjb25zdCBkeSA9IHkoZGF0YS52YWx1ZSkgLSB5KHByZXZEYXRhLnZhbHVlKTtcclxuXHRcdFx0XHRjb25zdCBkZCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xyXG5cclxuXHRcdFx0XHRkaWZmID0gc3R5bGVbMF0gLyBkZDtcclxuXHRcdFx0XHRkaWZmeDIgPSBkaWZmICogc3R5bGVbMV07XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSBkaWZmOyBqIDw9IDE7IGogKz0gZGlmZngyKSB7XHJcblx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCBqLCBkaWZmKTtcclxuXHJcblx0XHRcdFx0XHQvLyB0byBtYWtlIHN1cmUgY29ycmVjdCBsaW5lIGRyYXdpbmdcclxuXHRcdFx0XHRcdGlmIChqICsgZGlmZngyID49IDEpIHtcclxuXHRcdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgMSwgMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhdGg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJlYUdyYWRpZW50KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtkYXRldGltZUlkfSwgJGVsOiB7ZGVmc319ID0gJCQ7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdGNvbnN0IGlkID0gYCR7ZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVR5cGUoZCkgJiYgZGVmcy5zZWxlY3QoYCMke2lkfWApLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9ICQkLmNvbG9yKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRcdHggPSBbMCwgMF0sXHJcblx0XHRcdFx0XHR5ID0gWzAsIDFdLFxyXG5cdFx0XHRcdFx0c3RvcHMgPSBbWzAsIGNvbG9yLCAxXSwgWzEsIGNvbG9yLCAwXV1cclxuXHRcdFx0XHR9ID0gY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxpbmVhckdyYWRpZW50ID0gZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJpZFwiLCBgJHtpZH1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4WzFdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5WzFdKTtcclxuXHJcblx0XHRcdFx0c3RvcHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHN0b3BDb2xvciA9IGlzRnVuY3Rpb24odlsxXSkgPyB2WzFdLmJpbmQoJCQuYXBpKShkLmlkKSA6IHZbMV07XHJcblxyXG5cdFx0XHRcdFx0bGluZWFyR3JhZGllbnQuYXBwZW5kKFwic3RvcFwiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIm9mZnNldFwiLCB2WzBdKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInN0b3AtY29sb3JcIiwgc3RvcENvbG9yIHx8IGNvbG9yKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInN0b3Atb3BhY2l0eVwiLCB2WzJdKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJlYUNvbG9yKGQpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/XHJcblx0XHRcdGB1cmwoIyR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX0pYCA6XHJcblx0XHRcdCQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Y29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQgJiYgJCQudXBkYXRlQXJlYUdyYWRpZW50KCk7XHJcblxyXG5cdFx0JGVsLmFyZWEgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWFzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWF9YClcclxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdCRlbC5hcmVhLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLmFyZWEuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZUFyZWFDb2xvci5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdGF0ZS5vcmdBcmVhT3BhY2l0eSA9IGQzU2VsZWN0KHRoaXMpLnN0eWxlKFwib3BhY2l0eVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gXCIwXCI7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5tZXJnZSgkZWwuYXJlYSk7XHJcblxyXG5cdFx0JGVsLmFyZWFcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBzdGF0ZS5vcmdBcmVhT3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QXJlYShkcmF3QXJlYSwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7b3JnQXJlYU9wYWNpdHl9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQuJGVsLmFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiAkJC4kZWwuYXJlYSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+IFN0cmluZygkJC5pc0FyZWFSYW5nZVR5cGUoZCkgPyBvcmdBcmVhT3BhY2l0eSAvIDEuNzUgOiBvcmdBcmVhT3BhY2l0eSkpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZWFJbmRpY2VzIEluZGljZXNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ViIFdlYXRoZXIgaXMgc3ViIGF4aXNcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZURyYXdBcmVhKGFyZWFJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiAoZCkgPT4gc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSAkJC5nZXRZU2NhbGVCeUlkLmJpbmQoJCQpO1xyXG5cclxuXHRcdGNvbnN0IHhWYWx1ZSA9IGQgPT4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XHJcblx0XHRjb25zdCB2YWx1ZTAgPSAoZCwgaSkgPT4gKCQkLmlzR3JvdXBlZChkLmlkKSA/XHJcblx0XHRcdGdldFBvaW50cyhkLCBpKVswXVsxXSA6XHJcblx0XHRcdHlTY2FsZShkLmlkLCBpc1N1YikoXHJcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cclxuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJoaWdoXCIpIDogJCQuZ2V0U2hhcGVZTWluKGQuaWQpXHJcblx0XHRcdCkpO1xyXG5cdFx0Y29uc3QgdmFsdWUxID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMV1bMV0gOlxyXG5cdFx0XHR5U2NhbGUoZC5pZCwgaXNTdWIpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwibG93XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBkM0FyZWEoKTtcclxuXHJcblx0XHRcdFx0YXJlYSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRhcmVhLnkoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQueDAodmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueDEodmFsdWUxKSA6XHJcblx0XHRcdFx0XHRhcmVhLngoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdC55MChjb25maWcuYXJlYV9hYm92ZSA/IDAgOiB2YWx1ZTApXHJcblx0XHRcdFx0XHRcdC55MSh2YWx1ZTEpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xyXG5cdFx0XHRcdFx0YXJlYSA9IGFyZWEuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGFyZWEuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSAkJC5zY2FsZS54KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0gJCQuZ2V0WVNjYWxlQnlJZChkLmlkKSh2YWx1ZXNbMF0udmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGlzUm90YXRlZCA/IGBNICR7eTB9ICR7eDB9YCA6IGBNICR7eDB9ICR7eTB9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGggfHwgXCJNIDAgMFwiO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldEFyZWFQb2ludHMoYXJlYUluZGljZXMsIGlzU3ViPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcclxuXHRcdC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBhcmVhT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNBcmVhVHlwZSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgkJC5nZXRTaGFwZVlNaW4oZC5pZCkpO1xyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBhcmVhT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYXJlYSBjaGFydFxyXG5cdFx0XHRjb25zdCBwb3NYID0geChkKTtcclxuXHRcdFx0bGV0IHBvc1kgPSB5KGQpO1xyXG5cclxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcclxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxyXG5cdFx0XHQpKSB7XHJcblx0XHRcdFx0cG9zWSA9IHkwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyAxIHBvaW50IHRoYXQgbWFya3MgdGhlIGFyZWEgcG9zaXRpb25cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcclxuXHRcdFx0XHRbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLFxyXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblN0ZXAodGhhdCwgeTogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoeSAtIGQzTW91c2UodGhhdClbMV0pIDwgMzA7XHJcblx0fSxcclxuXHJcblx0c2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbGluZVBvaW50ID0gdGhpcy5jb25maWcubGluZV9wb2ludDtcclxuXHJcblx0XHRyZXR1cm4gbGluZVBvaW50ID09PSB0cnVlIHx8XHJcblx0XHRcdChpc0FycmF5KGxpbmVQb2ludCkgJiYgbGluZVBvaW50LmluZGV4T2YoZC5pZCkgIT09IC0xKTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXMsXHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQge2dldEJvdW5kaW5nUmVjdCwgZ2V0UmFuZG9tLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNPYmplY3RUeXBlLCBpc1ZhbHVlLCB0b0FycmF5LCBub3RFbXB0eX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5jb25zdCBnZXRUcmFuc2l0aW9uTmFtZSA9ICgpID0+IGdldFJhbmRvbSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGhhc1ZhbGlkUG9pbnRUeXBlKHR5cGU/OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvXihjaXJjbGV8cmVjdChhbmdsZSk/fHBvbHlnb258ZWxsaXBzZXx1c2UpJC9pLnRlc3QodHlwZSB8fCB0aGlzLmNvbmZpZy5wb2ludF90eXBlKTtcclxuXHR9LFxyXG5cclxuXHRoYXNWYWxpZFBvaW50RHJhd01ldGhvZHModHlwZT86IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgcG9pbnRUeXBlID0gdHlwZSB8fCB0aGlzLmNvbmZpZy5wb2ludF90eXBlO1xyXG5cclxuXHRcdHJldHVybiBpc09iamVjdFR5cGUocG9pbnRUeXBlKSAmJlxyXG5cdFx0XHRpc0Z1bmN0aW9uKHBvaW50VHlwZS5jcmVhdGUpICYmIGlzRnVuY3Rpb24ocG9pbnRUeXBlLnVwZGF0ZSk7XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUoZCk6IFwiMVwiIHwgXCIwXCIge1xyXG5cdFx0Y29uc3Qge3dpdGhvdXRGYWRlSW59ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiZcclxuXHRcdFx0d2l0aG91dEZhZGVJbltkLmlkXSA/IHRoaXMub3BhY2l0eUZvckNpcmNsZShkKSA6IFwiMFwiO1xyXG5cdH0sXHJcblxyXG5cdG9wYWNpdHlGb3JDaXJjbGUoZCk6IFwiMC41XCIgfCBcIjFcIiB8IFwiMFwiIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG9wYWNpdHkgPSBjb25maWcucG9pbnRfc2hvdyAmJiAhY29uZmlnLnBvaW50X2ZvY3VzX29ubHkgPyBcIjFcIiA6IFwiMFwiO1xyXG5cclxuXHRcdHJldHVybiBpc1ZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKGQpKSA/XHJcblx0XHRcdCh0aGlzLmlzQnViYmxlVHlwZShkKSB8fCB0aGlzLmlzU2NhdHRlclR5cGUoZCkgP1xyXG5cdFx0XHRcdFwiMC41XCIgOiBvcGFjaXR5KSA6IFwiMFwiO1xyXG5cdH0sXHJcblxyXG5cdGluaXRDaXJjbGUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHQkJC5wb2ludCA9ICQkLmdlbmVyYXRlUG9pbnQoKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0Q2lyY2xlcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0Rm9yQ2lyY2xlKHQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIGRhdGEsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSB0IHx8IGRhdGEudGFyZ2V0cztcclxuXHRcdGNvbnN0IGNsYXNzQ2lyY2xlcyA9ICQkLmNsYXNzQ2lyY2xlcy5iaW5kKCQkKTtcclxuXHJcblx0XHRpZiAoISRlbC5jaXJjbGUgJiYgY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0JCQuaW5pdENpcmNsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1haW5DaXJjbGUgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0Q2lyY2xlc31gKVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc31gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2lyY2xlcyk7XHJcblxyXG5cdFx0Y29uc3QgbWFpbkNpcmNsZUVudGVyID0gbWFpbkNpcmNsZS5lbnRlcigpO1xyXG5cclxuXHRcdC8vIENpcmNsZXMgZm9yIGVhY2ggZGF0YSBwb2ludCBvbiBsaW5lc1xyXG5cdFx0Y29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgbWFpbkNpcmNsZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+ICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2VsZWN0ZWRDaXJjbGVzLCBkLmlkKSk7XHJcblxyXG5cdFx0bWFpbkNpcmNsZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NpcmNsZXMpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBkYXRlIGZvciBzZWxlY3RlZCBjaXJjbGVzXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodC5pZCl9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfWApXHJcblx0XHRcdFx0LmVhY2goZCA9PiB7XHJcblx0XHRcdFx0XHRkLnZhbHVlID0gdC52YWx1ZXNbZC5pbmRleF0udmFsdWU7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVDaXJjbGUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBmb2N1c09ubHkgPSBjb25maWcucG9pbnRfZm9jdXNfb25seTtcclxuXHJcblx0XHRpZiAoY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0Y29uc3QgY2lyY2xlcyA9ICRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc31gKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZX1gKVxyXG5cdFx0XHRcdC5kYXRhKGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9ICEkJC5pc0JhclR5cGUoZCkgJiYgKFxyXG5cdFx0XHRcdFx0XHQhJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5zaG91bGREcmF3UG9pbnRzRm9yTGluZShkKVxyXG5cdFx0XHRcdFx0KSAmJiAkJC5sYWJlbGlzaERhdGEoZCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGZvY3VzT25seSA/IFtkYXRhWzBdXSA6IGRhdGE7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjaXJjbGVzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJjcmVhdGVcIiwgdGhpcywgJCQucG9pbnRSLmJpbmQoJCQpLCAkJC5jb2xvcik7XHJcblxyXG5cdFx0XHRjaXJjbGVzLmVudGVyKClcclxuXHRcdFx0XHQuYXBwZW5kKGZuKVxyXG5cdFx0XHRcdC5tZXJnZShjaXJjbGVzKVxyXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpKTtcclxuXHJcblx0XHRcdCRlbC5jaXJjbGUgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9IC4ke0NMQVNTLmNpcmNsZX1gKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZWRyYXdDaXJjbGUoY3g6IEZ1bmN0aW9uLCBjeTogRnVuY3Rpb24sIHdpdGhUcmFuc2l0aW9uOiBib29sZWFuLCBmbG93KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHtyZW5kZXJlZH0sICRlbDoge2NpcmNsZSwgbWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBzZWxlY3RlZENpcmNsZXMgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9YCk7XHJcblxyXG5cdFx0aWYgKCEkJC5jb25maWcucG9pbnRfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZm4gPSAkJC5wb2ludChcInVwZGF0ZVwiLCAkJCwgY3gsIGN5LCAkJC5jb2xvciwgd2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcyk7XHJcblx0XHRjb25zdCBwb3NBdHRyID0gJCQuaXNDaXJjbGVQb2ludCgpID8gXCJjXCIgOiBcIlwiO1xyXG5cclxuXHRcdGNvbnN0IHQ6IGFueSA9IGdldFJhbmRvbSgpO1xyXG5cdFx0Y29uc3Qgb3BhY2l0eVN0eWxlRm4gPSAkJC5vcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5DaXJjbGVzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdGNpcmNsZS5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0bGV0IHJlc3VsdDogZDNTZWxlY3Rpb24gfCBhbnkgPSBmbi5iaW5kKHRoaXMpKGQpO1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gKCh3aXRoVHJhbnNpdGlvbiB8fCAhcmVuZGVyZWQpID8gcmVzdWx0LnRyYW5zaXRpb24odCkgOiByZXN1bHQpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbik7XHJcblxyXG5cdFx0XHRtYWluQ2lyY2xlcy5wdXNoKHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRtYWluQ2lyY2xlcyxcclxuXHRcdFx0c2VsZWN0ZWRDaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoYCR7cG9zQXR0cn14YCwgY3gpXHJcblx0XHRcdFx0LmF0dHIoYCR7cG9zQXR0cn15YCwgY3kpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgZm9jdXNlZCBkYXRhIHBvaW50IGNpcmNsZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIFNlbGVjdGVkIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNob3dDaXJjbGVGb2N1cyhkPyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoc3RhdGUudHJhbnNpdGluZyA9PT0gZmFsc2UgJiYgY29uZmlnLnBvaW50X2ZvY3VzX29ubHkpIHtcclxuXHRcdFx0bGV0IHtjaXJjbGV9ID0gJGVsO1xyXG5cdFx0XHRjb25zdCB7aGFzUmFkYXJ9ID0gc3RhdGU7XHJcblx0XHRcdGNvbnN0IGN4ID0gKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVYIDogJCQuY2lyY2xlWCkuYmluZCgkJCk7XHJcblx0XHRcdGNvbnN0IGN5ID0gKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVZIDogJCQuY2lyY2xlWSkuYmluZCgkJCk7XHJcblx0XHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJ1cGRhdGVcIiwgJCQsIGN4LCBjeSwgJCQuY29sb3IsIGZhbHNlKTtcclxuXHJcblx0XHRcdGlmIChkKSB7XHJcblx0XHRcdFx0Y2lyY2xlID0gY2lyY2xlXHJcblx0XHRcdFx0XHQuZmlsdGVyKHQgPT4gZC5zb21lKHYgPT4gdi5pZCA9PT0gdC5pZCkpXHJcblx0XHRcdFx0XHQuZGF0YShkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2lyY2xlXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGZuLmJpbmQodGhpcykoZCk7XHJcblx0XHRcdFx0XHQkJC5leHBhbmRDaXJjbGVzKGQuaW5kZXgsIGQuaWQpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBudWxsKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGZvY3VzZWQgZGF0YSBwb2ludCBjaXJjbGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhpZGVDaXJjbGVGb2N1cygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLnBvaW50X2ZvY3VzX29ubHkpIHtcclxuXHRcdFx0JGVsLmNpcmNsZS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y2lyY2xlWChkKTogbnVtYmVyIHwgbnVsbCB7XHJcblx0XHRyZXR1cm4gdGhpcy54eChkKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVDaXJjbGVZKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKCQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKSwgZmFsc2UpO1xyXG5cclxuXHRcdCQkLmNpcmNsZVkgPSAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBpZCA9IGQuaWQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuaXNHcm91cGVkKGlkKSA/XHJcblx0XHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcclxuXHRcdFx0XHQkJC5nZXRZU2NhbGVCeUlkKGlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRDaXJjbGVzKGk6IG51bWJlciwgaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyAkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC4kZWwubWFpbilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfSR7c3VmZml4fWApO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZENpcmNsZXMoaTogbnVtYmVyLCBpZDogc3RyaW5nLCByZXNldD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludEV4cGFuZGVkUi5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IHIoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcjtcclxuXHRcdGNvbnN0IHJhdGlvID0gMSAtIHNjYWxlO1xyXG5cclxuXHRcdGlmICgkJC5pc0NpcmNsZVBvaW50KCkpIHtcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHRyYW5zZm9ybSBtdXN0IGJlIGFwcGxpZWQgdG8gZWFjaCBub2RlIGluZGl2aWR1YWxseVxyXG5cdFx0XHRjaXJjbGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInJcIiwgcik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuZ2V0QkJveCgpO1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieFwiKSArIHdpZHRoIC8gMik7XHJcblx0XHRcdFx0XHRjb25zdCB5ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ5XCIpICsgaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0gJHt5fSkgc2NhbGUoJHtzY2FsZX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZENpcmNsZXMoaSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50Ui5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcclxuXHJcblx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xyXG5cclxuXHRcdCEkJC5pc0NpcmNsZVBvaW50KCkgJiZcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3IoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcn0pYCk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0bGV0IHIgPSBwb2ludFI7XHJcblxyXG5cdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0ciA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xyXG5cdFx0XHRyID0gJCQuZ2V0QnViYmxlUihkKTtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwb2ludFIpKSB7XHJcblx0XHRcdHIgPSBwb2ludFIuYmluZCgkJC5hcGkpKGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50RXhwYW5kZWRSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHNjYWxlID0gJCQuaXNCdWJibGVUeXBlKGQpID8gMS4xNSA6IDEuNzU7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCA/XHJcblx0XHRcdChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX3IgfHwgJCQucG9pbnRSKGQpICogc2NhbGUpIDogJCQucG9pbnRSKGQpO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50U2VsZWN0UihkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNlbGVjdFIgPSAkJC5jb25maWcucG9pbnRfc2VsZWN0X3I7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oc2VsZWN0UikgP1xyXG5cdFx0XHRzZWxlY3RSKGQpIDogKHNlbGVjdFIgfHwgJCQucG9pbnRSKGQpICogNCk7XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5DaXJjbGUobm9kZSwgcj86IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKG5vZGUpO1xyXG5cdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KG5vZGUpO1xyXG5cdFx0Y29uc3QgcHJlZml4ID0gdGhpcy5pc0NpcmNsZVBvaW50KG5vZGUpID8gXCJjXCIgOiBcIlwiO1xyXG5cdFx0bGV0IGN4ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eGApO1xyXG5cdFx0bGV0IGN5ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eWApO1xyXG5cclxuXHRcdC8vIGlmIG5vZGUgZG9uJ3QgaGF2ZSBjeC95IG9yIHgveSBhdHRyaWJ1dGUgdmFsdWVcclxuXHRcdGlmICghKGN4IHx8IGN5KSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcblx0XHRcdGNvbnN0IHt4LCB5fSA9IGdldEJvdW5kaW5nUmVjdChub2RlKTtcclxuXHJcblx0XHRcdGN4ID0geDtcclxuXHRcdFx0Y3kgPSB5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoXHJcblx0XHRcdE1hdGgucG93KGN4IC0gbW91c2VbMF0sIDIpICsgTWF0aC5wb3coY3kgLSBtb3VzZVsxXSwgMilcclxuXHRcdCkgPCAociB8fCB0aGlzLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSk7XHJcblx0fSxcclxuXHJcblx0aW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY29weUF0dHIgPSAoZnJvbSwgdGFyZ2V0KSA9PiB7XHJcblx0XHRcdGNvbnN0IGF0dHJpYnMgPSBmcm9tLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbmFtZTsgKG5hbWUgPSBhdHRyaWJzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0bmFtZSA9IG5hbWUubmFtZTtcclxuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBvaW50LCBcImltYWdlL3N2Zyt4bWxcIik7XHJcblx0XHRjb25zdCBub2RlID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XHJcblxyXG5cdFx0Y2xvbmUuaWQgPSBpZDtcclxuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcclxuXHRcdGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiO1xyXG5cclxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcclxuXHJcblx0XHRpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xyXG5cclxuXHRcdFx0aWYgKFwiaW5uZXJIVE1MXCIgaW4gY2xvbmUpIHtcclxuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9BcnJheShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCQkLiRlbC5kZWZzLm5vZGUoKS5hcHBlbmRDaGlsZChjbG9uZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRGcm9tRGVmcyhpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy4kZWwuZGVmcy5zZWxlY3QoYCMke2lkfWApO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVBvaW50Q2xhc3MoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NpcmNsZX0gPSAkJC4kZWw7XHJcblx0XHRsZXQgcG9pbnRDbGFzcyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChkKSB8fCBjaXJjbGUpIHtcclxuXHRcdFx0cG9pbnRDbGFzcyA9IGQgPT09IHRydWUgP1xyXG5cdFx0XHRcdGNpcmNsZS5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGxldCBjbGFzc05hbWUgPSAkJC5jbGFzc0NpcmNsZS5iaW5kKCQkKShkKTtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5pbmRleE9mKENMQVNTLkVYUEFOREVEKSA+IC0xKSB7XHJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSArPSBgICR7Q0xBU1MuRVhQQU5ERUR9YDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzTmFtZSk7XHJcblx0XHRcdFx0fSkgOiAkJC5jbGFzc0NpcmNsZShkKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRDbGFzcztcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVBvaW50KCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7ZGF0ZXRpbWVJZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID8gY29uZmlnLnBvaW50X3BhdHRlcm4gOiBbY29uZmlnLnBvaW50X3R5cGVdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIC4uLmFyZ3MpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBpZDogc3RyaW5nID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcclxuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0cG9pbnQgPSAkJFtwb2ludF07XHJcblx0XHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRJZCA9IGAke2RhdGV0aW1lSWR9LXBvaW50LSR7aWR9YDtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50RnJvbURlZnMgPSAkJC5wb2ludEZyb21EZWZzKHBvaW50SWQpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwb2ludEZyb21EZWZzLnNpemUoKSA8IDEpIHtcclxuXHRcdFx0XHRcdFx0JCQuaW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgcG9pbnRJZCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1ldGhvZCA9PT0gXCJjcmVhdGVcIikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuY3VzdG9tLmNyZWF0ZS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIHBvaW50SWQsIC4uLmFyZ3MpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtZXRob2QgPT09IFwidXBkYXRlXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS51cGRhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCAuLi5hcmdzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBwb2ludFttZXRob2RdLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGN1c3RvbToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGlkLCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInVzZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieGxpbms6aHJlZlwiLCBgIyR7aWR9YClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBmaWxsU3R5bGVGbixcclxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xyXG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XHJcblxyXG5cdFx0XHRjb25zdCB4UG9zRm4yID0gZCA9PiB4UG9zRm4oZCkgLSB3aWR0aCAvIDI7XHJcblx0XHRcdGNvbnN0IHlQb3NGbjIgPSBkID0+IHlQb3NGbihkKSAtIGhlaWdodCAvIDI7XHJcblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9IGdldFRyYW5zaXRpb25OYW1lKCk7XHJcblxyXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcInhcIiwgeFBvc0ZuMik7XHJcblxyXG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XHJcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCB4UG9zRm4yKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCB5UG9zRm4yKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vICdjaXJjbGUnIGRhdGEgcG9pbnRcclxuXHRjaXJjbGU6IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcImNpcmNsZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgdGhpcy51cGRhdGVQb2ludENsYXNzLmJpbmQodGhpcykpXHJcblx0XHRcdFx0LmF0dHIoXCJyXCIsIHNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0Ly8gd2hlbiAnLmxvYWQoKScgY2FsbGVkLCBidWJibGUgc2l6ZSBzaG91bGQgYmUgdXBkYXRlZFxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xyXG5cdFx0XHRcdG1haW5DaXJjbGVzLmF0dHIoXCJyXCIsICQkLnBvaW50Ui5iaW5kKCQkKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gZ2V0VHJhbnNpdGlvbk5hbWUoKTtcclxuXHJcblx0XHRcdFx0ZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwiY3hcIiwgeFBvc0ZuKTtcclxuXHJcblx0XHRcdFx0aWYgKG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiKSkge1xyXG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKGdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcImN4XCIsIHhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyAncmVjdGFuZ2xlJyBkYXRhIHBvaW50XHJcblx0cmVjdGFuZ2xlOiB7XHJcblx0XHRjcmVhdGUoZWxlbWVudCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xyXG5cdFx0XHRjb25zdCByZWN0U2l6ZUZuID0gZCA9PiBzaXplRm4oZCkgKiAyLjA7XHJcblxyXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHJlY3RTaXplRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgcmVjdFNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRjb25zdCByID0gJCQuY29uZmlnLnBvaW50X3I7XHJcblx0XHRcdGNvbnN0IHJlY3RYUG9zRm4gPSBkID0+IHhQb3NGbihkKSAtIHI7XHJcblx0XHRcdGNvbnN0IHJlY3RZUG9zRm4gPSBkID0+IHlQb3NGbihkKSAtIHI7XHJcblxyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSBnZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKGdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgcmVjdFhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgcmVjdFlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRjdXJ2ZVN0ZXBCZWZvcmUgYXMgZDNDdXJ2ZVN0ZXBCZWZvcmUsXHJcblx0Y3VydmVTdGVwQWZ0ZXIgYXMgZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRjdXJ2ZUJhc2lzQ2xvc2VkIGFzIGQzQ3VydmVCYXNpc0Nsb3NlZCxcclxuXHRjdXJ2ZUJhc2lzT3BlbiBhcyBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdGN1cnZlQmFzaXMgYXMgZDNDdXJ2ZUJhc2lzLFxyXG5cdGN1cnZlQnVuZGxlIGFzIGQzQ3VydmVCdW5kbGUsXHJcblx0Y3VydmVDYXJkaW5hbENsb3NlZCBhcyBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXHJcblx0Y3VydmVDYXJkaW5hbE9wZW4gYXMgZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRjdXJ2ZUNhcmRpbmFsIGFzIGQzQ3VydmVDYXJkaW5hbCxcclxuXHRjdXJ2ZUNhdG11bGxSb21DbG9zZWQgYXMgZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0Y3VydmVDYXRtdWxsUm9tT3BlbiBhcyBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0Y3VydmVDYXRtdWxsUm9tIGFzIGQzQ3VydmVDYXRtdWxsUm9tLFxyXG5cdGN1cnZlTGluZWFyQ2xvc2VkIGFzIGQzQ3VydmVMaW5lYXJDbG9zZWQsXHJcblx0Y3VydmVMaW5lYXIgYXMgZDNDdXJ2ZUxpbmVhcixcclxuXHRjdXJ2ZU1vbm90b25lWCBhcyBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdGN1cnZlTW9ub3RvbmVZIGFzIGQzQ3VydmVNb25vdG9uZVksXHJcblx0Y3VydmVOYXR1cmFsIGFzIGQzQ3VydmVOYXR1cmFsLFxyXG5cdGN1cnZlU3RlcCBhcyBkM0N1cnZlU3RlcFxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0VW5pcXVlLCBpc09iamVjdFR5cGUsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgc2hhcGUgZHJhdyBmdW5jdGlvblxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXREcmF3U2hhcGUoKSB7XHJcblx0XHR0eXBlIFNIQVBFID0ge1xyXG5cdFx0XHRhcmVhPzogYW55O1xyXG5cdFx0XHRiYXI/OiBhbnk7XHJcblx0XHRcdGxpbmU/OiBhbnk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCB7aGFzUmFkYXJ9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBzaGFwZSA9IHt0eXBlOiA8U0hBUEU+IHt9LCBpbmRpY2VzOiA8U0hBUEU+IHt9LCBwb3M6IHt9fTtcclxuXHJcblx0XHQvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcclxuXHRcdGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzVHlwZShcInNjYXR0ZXJcIikpIHtcclxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKTtcclxuXHJcblx0XHRcdHNoYXBlLmluZGljZXMubGluZSA9IGluZGljZXM7XHJcblx0XHRcdHNoYXBlLnR5cGUubGluZSA9ICQkLmdlbmVyYXRlRHJhd0xpbmUgPyAkJC5nZW5lcmF0ZURyYXdMaW5lKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJBcmVhXCIpKSB7XHJcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0FyZWFUeXBlKTtcclxuXHJcblx0XHRcdFx0c2hhcGUuaW5kaWNlcy5hcmVhID0gaW5kaWNlcztcclxuXHRcdFx0XHRzaGFwZS50eXBlLmFyZWEgPSAkJC5nZW5lcmF0ZURyYXdBcmVhID8gJCQuZ2VuZXJhdGVEcmF3QXJlYShpbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQmFyVHlwZSk7XHJcblxyXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmJhciA9IGluZGljZXM7XHJcblx0XHRcdHNoYXBlLnR5cGUuYmFyID0gJCQuZ2VuZXJhdGVEcmF3QmFyID8gJCQuZ2VuZXJhdGVEcmF3QmFyKGluZGljZXMpIDogdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghJCQuaGFzQXJjVHlwZSgpIHx8IGhhc1JhZGFyKSB7XHJcblx0XHRcdHNoYXBlLnBvcyA9IHtcclxuXHRcdFx0XHR4Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgdHJ1ZSksXHJcblx0XHRcdFx0eUZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIGZhbHNlKSxcclxuXHJcblx0XHRcdFx0Ly8gZ2VuZXJhdGUgY2lyY2xlIHgveSBmdW5jdGlvbnMgZGVwZW5kaW5nIG9uIHVwZGF0ZWQgcGFyYW1zXHJcblx0XHRcdFx0Y3g6IChoYXNSYWRhciA/ICQkLnJhZGFyQ2lyY2xlWCA6IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkpLmJpbmQoJCQpLFxyXG5cdFx0XHRcdGN5OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVkgOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpKS5iaW5kKCQkKVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaGFwZTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaGFwZUluZGljZXModHlwZUZpbHRlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHhzID0gY29uZmlnLmRhdGFfeHM7XHJcblx0XHRjb25zdCBoYXNYcyA9IG5vdEVtcHR5KHhzKTtcclxuXHRcdGNvbnN0IGluZGljZXMgPSB7fTtcclxuXHRcdGxldCBpOiBhbnkgPSBoYXNYcyA/IHt9IDogMDtcclxuXHJcblx0XHRpZiAoaGFzWHMpIHtcclxuXHRcdFx0Z2V0VW5pcXVlKE9iamVjdC5rZXlzKHhzKS5tYXAodiA9PiB4c1t2XSkpXHJcblx0XHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRpW3ZdID0gMDtcclxuXHRcdFx0XHRcdGluZGljZXNbdl0gPSB7fTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cy5maWx0ZXIodHlwZUZpbHRlciwgJCQpKVxyXG5cdFx0XHQuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRjb25zdCB4S2V5ID0gZC5pZCBpbiB4cyA/IHhzW2QuaWRdIDogXCJcIjtcclxuXHRcdFx0XHRjb25zdCBpbmQgPSB4S2V5ID8gaW5kaWNlc1t4S2V5XSA6IGluZGljZXM7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSAwLCBncm91cHM7IChncm91cHMgPSBjb25maWcuZGF0YV9ncm91cHNbal0pOyBqKyspIHtcclxuXHRcdFx0XHRcdGlmIChncm91cHMuaW5kZXhPZihkLmlkKSA8IDApIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgayA9IDAsIHJvdzsgKHJvdyA9IGdyb3Vwc1trXSk7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAocm93IGluIGluZCkge1xyXG5cdFx0XHRcdFx0XHRcdGluZFtkLmlkXSA9IGluZFtyb3ddO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoaW5kW2QuaWRdKSkge1xyXG5cdFx0XHRcdFx0aW5kW2QuaWRdID0geEtleSA/IGlbeEtleV0rKyA6IGkrKztcclxuXHRcdFx0XHRcdGluZC5fX21heF9fID0gKHhLZXkgPyBpW3hLZXldIDogaSkgLSAxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGluZGljZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGluZGljZXMgdmFsdWUgYmFzZWQgb24gZGF0YSBJRCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbmRpY2VzIEluZGljZXMgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIERhdGEgaWQgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kaWNlcyhpbmRpY2VzLCBpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCB4cyA9IHRoaXMuY29uZmlnLmRhdGFfeHM7XHJcblxyXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHhzKSA/XHJcblx0XHRcdGluZGljZXNbeHNbaWRdXSA6IGluZGljZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGluZGljZXMgbWF4IG51bWJlclxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbmRpY2VzIEluZGljZXMgb2JqZWN0XHJcblx0ICogQHJldHVybnMge251bWJlcn0gTWF4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kaWNlc01heChpbmRpY2VzKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBub3RFbXB0eSh0aGlzLmNvbmZpZy5kYXRhX3hzKSA/XHJcblx0XHRcdC8vIGlmIGlzIG11bHRpcGxlIHhzLCByZXR1cm4gdG90YWwgc3VtIG9mIHhzJyBfX21heF9fIHZhbHVlXHJcblx0XHRcdE9iamVjdC5rZXlzKGluZGljZXMpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IGluZGljZXNbdl0uX19tYXhfXyB8fCAwKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3VycikgOiBpbmRpY2VzLl9fbWF4X187XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVYKG9mZnNldCwgaW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogKGQpID0+IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGN1cnJTY2FsZSA9IGlzU3ViID8gc2NhbGUuc3ViWCA6IChzY2FsZS56b29tIHx8IHNjYWxlLngpO1xyXG5cdFx0Y29uc3QgYmFyUGFkZGluZyA9IGNvbmZpZy5iYXJfcGFkZGluZztcclxuXHRcdGNvbnN0IHN1bSA9IChwLCBjKSA9PiBwICsgYztcclxuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGNvbnN0IGluZCA9ICQkLmdldEluZGljZXMoaW5kaWNlcywgZC5pZCk7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gZC5pZCBpbiBpbmQgPyBpbmRbZC5pZF0gOiAwO1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzTnVtID0gKGluZC5fX21heF9fIHx8IDApICsgMTtcclxuXHRcdFx0bGV0IHggPSAwO1xyXG5cclxuXHRcdFx0aWYgKG5vdEVtcHR5KGQueCkpIHtcclxuXHRcdFx0XHRjb25zdCB4UG9zID0gY3VyclNjYWxlKGQueCk7XHJcblxyXG5cdFx0XHRcdGlmIChoYWxmV2lkdGgpIHtcclxuXHRcdFx0XHRcdHggPSB4UG9zIC0gKG9mZnNldFtkLmlkXSB8fCBvZmZzZXQud2lkdGgpICtcclxuXHRcdFx0XHRcdFx0b2Zmc2V0LnRvdGFsLnNsaWNlKDAsIGluZGV4ICsgMSkucmVkdWNlKHN1bSkgLVxyXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHggPSB4UG9zIC0gKGlzTnVtYmVyKG9mZnNldCkgPyBvZmZzZXQgOiBvZmZzZXQud2lkdGgpICogKHRhcmdldHNOdW0gLyAyIC0gaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRqdXN0IHggcG9zaXRpb24gZm9yIGJhci5wYWRkaW5nIG9wdGlvbnFcclxuXHRcdFx0aWYgKG9mZnNldCAmJiB4ICYmIHRhcmdldHNOdW0gPiAxICYmIGJhclBhZGRpbmcpIHtcclxuXHRcdFx0XHRpZiAoaW5kZXgpIHtcclxuXHRcdFx0XHRcdHggKz0gYmFyUGFkZGluZyAqIGluZGV4O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRhcmdldHNOdW0gPiAyKSB7XHJcblx0XHRcdFx0XHR4IC09ICh0YXJnZXRzTnVtIC0gMSkgKiBiYXJQYWRkaW5nIC8gMjtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldHNOdW0gPT09IDIpIHtcclxuXHRcdFx0XHRcdHggLT0gYmFyUGFkZGluZyAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4geDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVZKGlzU3ViPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzU3RhY2tOb3JtYWxpemVkID0gJCQuaXNTdGFja05vcm1hbGl6ZWQoKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gaXNTdGFja05vcm1hbGl6ZWQgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIGQsIHRydWUpIDogKFxyXG5cdFx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInlcIikgOiBkLnZhbHVlXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuZ2V0WVNjYWxlQnlJZChkLmlkLCBpc1N1YikodmFsdWUpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgc2hhcGUgYmFzZWQgeSBBeGlzIG1pbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBEYXRhIGlkXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFNoYXBlWU1pbihpZDogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IFt5TWluXSA9ICQkLnNjYWxlWyQkLmF4aXMuZ2V0SWQoaWQpXS5kb21haW4oKTtcclxuXHJcblx0XHRyZXR1cm4gISQkLmlzR3JvdXBlZChpZCkgJiYgeU1pbiA+IDAgPyB5TWluIDogMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgU2hhcGUncyBvZmZzZXQgZGF0YVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGVGaWx0ZXIgVHlwZSBmaWx0ZXIgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0U2hhcGVPZmZzZXREYXRhKHR5cGVGaWx0ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSkpO1xyXG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xyXG5cclxuXHRcdGNvbnN0IHNoYXBlT2Zmc2V0VGFyZ2V0cyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiB7XHJcblx0XHRcdGxldCByb3dWYWx1ZXMgPSB0YXJnZXQudmFsdWVzO1xyXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSB7fTtcclxuXHJcblx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKHRhcmdldCkpIHtcclxuXHRcdFx0XHRyb3dWYWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHJvd1ZhbHVlcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHJvd1ZhbHVlTWFwQnlYVmFsdWUgPSByb3dWYWx1ZXMucmVkdWNlKChvdXQsIGQpID0+IHtcclxuXHRcdFx0XHRjb25zdCBrZXkgPSBOdW1iZXIoZC54KTtcclxuXHJcblx0XHRcdFx0b3V0W2tleV0gPSBkO1xyXG5cdFx0XHRcdHZhbHVlc1trZXldID0gaXNTdGFja05vcm1hbGl6ZWQgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIGQsIHRydWUpIDogZC52YWx1ZTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG91dDtcclxuXHRcdFx0fSwge30pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRpZDogdGFyZ2V0LmlkLFxyXG5cdFx0XHRcdHJvd1ZhbHVlcyxcclxuXHRcdFx0XHRyb3dWYWx1ZU1hcEJ5WFZhbHVlLFxyXG5cdFx0XHRcdHZhbHVlc1xyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblx0XHRjb25zdCBpbmRleE1hcEJ5VGFyZ2V0SWQgPSB0YXJnZXRzLnJlZHVjZSgob3V0LCB7aWR9LCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbaWRdID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtpbmRleE1hcEJ5VGFyZ2V0SWQsIHNoYXBlT2Zmc2V0VGFyZ2V0c307XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVPZmZzZXQodHlwZUZpbHRlciwgaW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NoYXBlT2Zmc2V0VGFyZ2V0cywgaW5kZXhNYXBCeVRhcmdldElkfSA9ICQkLmdldFNoYXBlT2Zmc2V0RGF0YSh0eXBlRmlsdGVyKTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGlkeCkgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQoZC5pZCwgaXNTdWIpO1xyXG5cdFx0XHRjb25zdCB5MCA9IHNjYWxlKCQkLmdldFNoYXBlWU1pbihkLmlkKSk7XHJcblxyXG5cdFx0XHRjb25zdCBkYXRhWEFzTnVtYmVyID0gTnVtYmVyKGQueCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSB5MDtcclxuXHJcblx0XHRcdHNoYXBlT2Zmc2V0VGFyZ2V0c1xyXG5cdFx0XHRcdC5maWx0ZXIodCA9PiB0LmlkICE9PSBkLmlkKVxyXG5cdFx0XHRcdC5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGluZFt0LmlkXSA9PT0gaW5kW2QuaWRdICYmIGluZGV4TWFwQnlUYXJnZXRJZFt0LmlkXSA8IGluZGV4TWFwQnlUYXJnZXRJZFtkLmlkXSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgcm93ID0gdC5yb3dWYWx1ZXNbaWR4XTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSB4IHZhbHVlcyBsaW5lIHVwXHJcblx0XHRcdFx0XHRcdGlmICghcm93IHx8IE51bWJlcihyb3cueCkgIT09IGRhdGFYQXNOdW1iZXIpIHtcclxuXHRcdFx0XHRcdFx0XHRyb3cgPSB0LnJvd1ZhbHVlTWFwQnlYVmFsdWVbZGF0YVhBc051bWJlcl07XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3cgJiYgcm93LnZhbHVlICogZC52YWx1ZSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IHNjYWxlKHQudmFsdWVzW2RhdGFYQXNOdW1iZXJdKSAtIHkwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblNoYXBlKHRoYXQsIGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XHJcblx0XHRsZXQgaXNXaXRoaW47XHJcblxyXG5cdFx0aWYgKCEkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZSh0aGF0Lm5vZGVOYW1lKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9ICQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmlzV2l0aGluU3RlcCh0aGF0LCAkJC5nZXRZU2NhbGVCeUlkKGQuaWQpKGQudmFsdWUpKSA6XHJcblx0XHRcdFx0JCQuaXNXaXRoaW5DaXJjbGUodGhhdCwgJCQuaXNCdWJibGVUeXBlKGQpID8gJCQucG9pbnRTZWxlY3RSKGQpICogMS41IDogMCk7XHJcblx0XHR9IGVsc2UgaWYgKHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XHJcblx0XHRcdGlzV2l0aGluID0gc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpID8gJCQuaXNXaXRoaW5CYXIodGhhdCkgOiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc1dpdGhpbjtcclxuXHR9LFxyXG5cclxuXHRnZXRJbnRlcnBvbGF0ZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gJCQuZ2V0SW50ZXJwb2xhdGVUeXBlKGQpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdFwiYmFzaXNcIjogZDNDdXJ2ZUJhc2lzLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiOiBkM0N1cnZlQmFzaXNDbG9zZWQsXHJcblx0XHRcdFwiYmFzaXMtb3BlblwiOiBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdFx0XHRcImJ1bmRsZVwiOiBkM0N1cnZlQnVuZGxlLFxyXG5cdFx0XHRcImNhcmRpbmFsXCI6IGQzQ3VydmVDYXJkaW5hbCxcclxuXHRcdFx0XCJjYXJkaW5hbC1jbG9zZWRcIjogZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIjogZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiOiBkM0N1cnZlQ2F0bXVsbFJvbSxcclxuXHRcdFx0XCJjYXRtdWxsLXJvbS1jbG9zZWRcIjogZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiOiBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0XHRcdFwibW9ub3RvbmUteFwiOiBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIjogZDNDdXJ2ZU1vbm90b25lWSxcclxuXHRcdFx0XCJuYXR1cmFsXCI6IGQzQ3VydmVOYXR1cmFsLFxyXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIjogZDNDdXJ2ZUxpbmVhckNsb3NlZCxcclxuXHRcdFx0XCJsaW5lYXJcIjogZDNDdXJ2ZUxpbmVhcixcclxuXHRcdFx0XCJzdGVwXCI6IGQzQ3VydmVTdGVwLFxyXG5cdFx0XHRcInN0ZXAtYWZ0ZXJcIjogZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRcdFx0XCJzdGVwLWJlZm9yZVwiOiBkM0N1cnZlU3RlcEJlZm9yZVxyXG5cdFx0fVtpbnRlcnBvbGF0aW9uXTtcclxuXHR9LFxyXG5cclxuXHRnZXRJbnRlcnBvbGF0ZVR5cGUoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGUgPSBjb25maWcuc3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTtcclxuXHRcdGNvbnN0IGludGVycG9sYXRpb24gPSAkJC5pc0ludGVycG9sYXRpb25UeXBlKHR5cGUpID8gdHlwZSA6IFwiY2FyZGluYWxcIjtcclxuXHJcblx0XHRyZXR1cm4gJCQuaXNTcGxpbmVUeXBlKGQpID9cclxuXHRcdFx0aW50ZXJwb2xhdGlvbiA6IChcclxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cclxuXHRcdFx0XHRcdGNvbmZpZy5saW5lX3N0ZXBfdHlwZSA6IFwibGluZWFyXCJcclxuXHRcdFx0KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIE1vZHVsZXMgZXhwb3J0cyBmb3IgQXhpcyBiYXNlZCBjaGFydFxyXG4gKi9cclxuLy8gQ2hhcnRcclxuaW1wb3J0IGFwaUF4aXMgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9heGlzXCI7XHJcbmltcG9ydCBhcGlDYXRlZ29yeSBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2NhdGVnb3J5XCI7XHJcbmltcG9ydCBhcGlGbG93IGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZmxvd1wiO1xyXG5pbXBvcnQgYXBpWEdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9ncmlkLnhcIjtcclxuaW1wb3J0IGFwaVlHcmlkIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZ3JpZC55XCI7XHJcbmltcG9ydCBhcGlHcm91cCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2dyb3VwXCI7XHJcbmltcG9ydCBhcGlSZWdpb24gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9yZWdpb25zXCI7XHJcbmltcG9ydCBhcGlTZWxlY3Rpb24gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9zZWxlY3Rpb25cIjtcclxuaW1wb3J0IGFwaVggZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS94XCI7XHJcbmltcG9ydCBhcGlab29tIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRJbnRlcm5hbFxyXG5pbXBvcnQgZHJhZyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZ1wiO1xyXG5pbXBvcnQgZmxvdyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvd1wiO1xyXG5pbXBvcnQgZXZlbnRyZWN0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9ldmVudHJlY3RcIjtcclxuaW1wb3J0IHN1YmNoYXJ0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydFwiO1xyXG5pbXBvcnQgem9vbSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbVwiO1xyXG5cclxuaW1wb3J0IGNsaXAgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsaXBcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2dyaWRcIjtcclxuaW1wb3J0IHJlZ2lvbiBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVnaW9uXCI7XHJcbmltcG9ydCBzZWxlY3Rpb24gZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NlbGVjdGlvblwiO1xyXG5cclxuaW1wb3J0IGJhciBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9iYXJcIjtcclxuaW1wb3J0IGJ1YmJsZSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9idWJibGVcIjtcclxuaW1wb3J0IGxpbmUgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvbGluZVwiO1xyXG5pbXBvcnQgcG9pbnQgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcG9pbnRcIjtcclxuaW1wb3J0IHNoYXBlIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL3NoYXBlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgYXBpID0gW1xyXG5cdGFwaUF4aXMsXHJcblx0YXBpQ2F0ZWdvcnksXHJcblx0YXBpRmxvdyxcclxuXHRhcGlYR3JpZCxcclxuXHRhcGlZR3JpZCxcclxuXHRhcGlHcm91cCxcclxuXHRhcGlSZWdpb24sXHJcblx0YXBpU2VsZWN0aW9uLFxyXG5cdGFwaVgsXHJcblx0YXBpWm9vbVxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IGludGVybmFsID0gW1xyXG5cdGRyYWcsXHJcblx0ZmxvdyxcclxuXHRzdWJjaGFydCxcclxuXHR6b29tLFxyXG5cclxuXHRjbGlwLFxyXG5cdGdyaWQsXHJcblx0cmVnaW9uLFxyXG5cdHNlbGVjdGlvbixcclxuXHRldmVudHJlY3QsXHJcblxyXG5cdGJhcixcclxuXHRidWJibGUsXHJcblx0bGluZSxcclxuXHRwb2ludCxcclxuXHRzaGFwZVxyXG5dO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7XHJcblx0YXJjIGFzIGQzQXJjLFxyXG5cdHBpZSBhcyBkM1BpZVxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge2ludGVycG9sYXRlIGFzIGQzSW50ZXJwb2xhdGV9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgZW5kYWxsLCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRQaWUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YVR5cGUgPSBjb25maWcuZGF0YV90eXBlO1xyXG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5waWVfcGFkZGluZztcclxuXHRcdGNvbnN0IHN0YXJ0aW5nQW5nbGUgPSBjb25maWdbYCR7ZGF0YVR5cGV9X3N0YXJ0aW5nQW5nbGVgXSB8fCAwO1xyXG5cdFx0Y29uc3QgcGFkQW5nbGUgPSAoXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgcGFkZGluZyA/IHBhZGRpbmcgKiAwLjAxIDpcclxuXHRcdFx0XHRjb25maWdbYCR7ZGF0YVR5cGV9X3BhZEFuZ2xlYF1cclxuXHRcdCkgfHwgMDtcclxuXHRcdGNvbnN0IHNvcnRWYWx1ZTogYW55ID0gJCQuaXNPcmRlckFzYygpIHx8ICQkLmlzT3JkZXJEZXNjKCkgP1xyXG5cdFx0XHQoYSwgYikgPT4gKCQkLmlzT3JkZXJBc2MoKSA/IGEgLSBiIDogYiAtIGEpIDogbnVsbDtcclxuXHJcblx0XHQkJC5waWUgPSBkM1BpZSgpXHJcblx0XHRcdC5zdGFydEFuZ2xlKHN0YXJ0aW5nQW5nbGUpXHJcblx0XHRcdC5lbmRBbmdsZShzdGFydGluZ0FuZ2xlICsgKDIgKiBNYXRoLlBJKSlcclxuXHRcdFx0LnBhZEFuZ2xlKHBhZEFuZ2xlKVxyXG5cdFx0XHQuc29ydFZhbHVlcyhzb3J0VmFsdWUpXHJcblx0XHRcdC52YWx1ZSgoZDogYW55KSA9PiBkLnZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkaXVzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucGllX2lubmVyUmFkaXVzO1xyXG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5waWVfcGFkZGluZztcclxuXHRcdGNvbnN0IHcgPSBjb25maWcuZ2F1Z2Vfd2lkdGggfHwgY29uZmlnLmRvbnV0X3dpZHRoO1xyXG5cdFx0Y29uc3QgZ2F1Z2VBcmNXaWR0aCA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggKlxyXG5cdFx0XHRjb25maWcuZ2F1Z2VfYXJjc19taW5XaWR0aDtcclxuXHJcblx0XHRzdGF0ZS5yYWRpdXNFeHBhbmRlZCA9IE1hdGgubWluKHN0YXRlLmFyY1dpZHRoLCBzdGF0ZS5hcmNIZWlnaHQpIC8gMiAqIChcclxuXHRcdFx0JCQuaGFzTXVsdGlBcmNHYXVnZSgpID8gMC44NSA6IDEpO1xyXG5cdFx0c3RhdGUucmFkaXVzID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgKiAwLjk1O1xyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA9IHcgPyAoc3RhdGUucmFkaXVzIC0gdykgLyBzdGF0ZS5yYWRpdXMgOiAwLjY7XHJcblx0XHRzdGF0ZS5nYXVnZUFyY1dpZHRoID0gdyB8fCAoXHJcblx0XHRcdGdhdWdlQXJjV2lkdGggPD0gc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzIDpcclxuXHRcdFx0XHQoZ2F1Z2VBcmNXaWR0aCA8PSBzdGF0ZS5yYWRpdXMgPyBnYXVnZUFyY1dpZHRoIDogc3RhdGUucmFkaXVzKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyB8fCAoXHJcblx0XHRcdHBhZGRpbmcgPyBwYWRkaW5nICogKHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gKyAwLjEpIDogMFxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBOT1RFOiBpbm5lclJhZGl1cyBjYW4gYmUgYW4gb2JqZWN0IGJ5IHVzZXIgc2V0dGluZywgb25seSBmb3IgJ3BpZScgdHlwZVxyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID9cclxuXHRcdFx0c3RhdGUucmFkaXVzICogc3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA6IGlubmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdGdldElubmVyUmFkaXVzKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHtpbm5lclJhZGl1c30gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRpZiAoIWlzTnVtYmVyKGlubmVyUmFkaXVzKSAmJiBkKSB7XHJcblx0XHRcdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXNbZC5kYXRhLmlkXSB8fCAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbm5lclJhZGl1cztcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuc3ZnQXJjID0gJCQuZ2V0U3ZnQXJjKCk7XHJcblx0XHQkJC5zdmdBcmNFeHBhbmRlZCA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQW5nbGUoZFZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGxldCBwaWUgPSAkJC5waWU7XHJcblx0XHRsZXQgZCA9IGRWYWx1ZTtcclxuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICghY29uZmlnKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJhZGl1cyA9IE1hdGguUEkgKiAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XHJcblx0XHRjb25zdCBnU3RhcnQgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgISQkLmhhc011bHRpQXJjR2F1Z2UoKSkge1xyXG5cdFx0XHQvLyB0byBwcmV2ZW50IGV4Y2x1ZGluZyB0b3RhbCBkYXRhIHN1bSBkdXJpbmcgdGhlIGluaXQod2hlbiBkYXRhLmhpZGUgb3B0aW9uIGlzIHVzZWQpLCB1c2UgJCQucmVuZGVyZWQgc3RhdGUgdmFsdWVcclxuXHRcdFx0Y29uc3QgdG90YWxTdW0gPSAkJC5nZXRUb3RhbERhdGFTdW0oc3RhdGUucmVuZGVyZWQpO1xyXG5cclxuXHRcdFx0Ly8gaWYgZ2F1Z2VfbWF4IGxlc3MgdGhhbiB0b3RhbFN1bSwgbWFrZSB0b3RhbFN1bSB0byBtYXggdmFsdWVcclxuXHRcdFx0aWYgKHRvdGFsU3VtID4gY29uZmlnLmdhdWdlX21heCkge1xyXG5cdFx0XHRcdGNvbmZpZy5nYXVnZV9tYXggPSB0b3RhbFN1bTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZ0VuZCA9IHJhZGl1cyAqICh0b3RhbFN1bSAvIChjb25maWcuZ2F1Z2VfbWF4IC0gY29uZmlnLmdhdWdlX21pbikpO1xyXG5cclxuXHRcdFx0cGllID0gcGllXHJcblx0XHRcdFx0LnN0YXJ0QW5nbGUoZ1N0YXJ0KVxyXG5cdFx0XHRcdC5lbmRBbmdsZShnRW5kICsgZ1N0YXJ0KTtcclxuXHRcdH1cclxuXHJcblx0XHRwaWUoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygpKVxyXG5cdFx0XHQuZm9yRWFjaCgodCwgaSkgPT4ge1xyXG5cdFx0XHRcdGlmICghZm91bmQgJiYgdC5kYXRhLmlkID09PSBkLmRhdGEuaWQpIHtcclxuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGQgPSB0O1xyXG5cdFx0XHRcdFx0ZC5pbmRleCA9IGk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNOYU4oZC5zdGFydEFuZ2xlKSkge1xyXG5cdFx0XHRkLnN0YXJ0QW5nbGUgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc05hTihkLmVuZEFuZ2xlKSkge1xyXG5cdFx0XHRkLmVuZEFuZ2xlID0gZC5zdGFydEFuZ2xlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkLmRhdGEgJiYgJCQuaGFzTXVsdGlBcmNHYXVnZSgpKSB7XHJcblx0XHRcdGNvbnN0IG1heFZhbHVlID0gJCQuZ2V0TWluTWF4RGF0YSgpLm1heFswXS52YWx1ZTtcclxuXHJcblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gbWF4VmFsdWUsIG1ha2UgbWF4VmFsdWUgdG8gbWF4IHZhbHVlXHJcblx0XHRcdGlmIChtYXhWYWx1ZSA+IGNvbmZpZy5nYXVnZV9tYXgpIHtcclxuXHRcdFx0XHRjb25maWcuZ2F1Z2VfbWF4ID0gbWF4VmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGdNaW4gPSBjb25maWcuZ2F1Z2VfbWluO1xyXG5cdFx0XHRjb25zdCBnTWF4ID0gY29uZmlnLmdhdWdlX21heDtcclxuXHRcdFx0Y29uc3QgZ1RpYyA9IHJhZGl1cyAvIChnTWF4IC0gZ01pbik7XHJcblx0XHRcdGNvbnN0IGdWYWx1ZSA9IGQudmFsdWUgPCBnTWluID8gMCA6IGQudmFsdWUgPCBnTWF4ID8gZC52YWx1ZSAtIGdNaW4gOiAoZ01heCAtIGdNaW4pO1xyXG5cclxuXHRcdFx0ZC5zdGFydEFuZ2xlID0gZ1N0YXJ0O1xyXG5cdFx0XHRkLmVuZEFuZ2xlID0gZ1N0YXJ0ICsgZ1RpYyAqIGdWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm91bmQgPyBkIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRTdmdBcmMoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXIgPSAkJC5nZXRJbm5lclJhZGl1cygpO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bGV0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChcclxuXHRcdFx0XHRoYXNNdWx0aUFyY0dhdWdlID8gKHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCkgOiBzdGF0ZS5yYWRpdXMpKVxyXG5cdFx0XHQuaW5uZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6XHJcblx0XHRcdFx0aXNOdW1iZXIoaXIpID8gaXIgOiAwKSk7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXJjID0gZnVuY3Rpb24oZCwgd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRsZXQgcGF0aDogc3RyaW5nIHwgbnVsbCA9IFwiTSAwIDBcIjtcclxuXHJcblx0XHRcdGlmIChkLnZhbHVlIHx8IGQuZGF0YSkge1xyXG5cdFx0XHRcdGlmICghaXNOdW1iZXIoaXIpKSB7XHJcblx0XHRcdFx0XHRhcmMgPSBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0XHRpZiAod2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRcdFx0cGF0aCA9IGFyYyhkKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdHBhdGggPSBhcmModXBkYXRlZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aDtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cclxuXHRcdG5ld0FyYy5jZW50cm9pZCA9IGFyYy5jZW50cm9pZDtcclxuXHJcblx0XHRyZXR1cm4gbmV3QXJjO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0FyY0V4cGFuZGVkKHJhdGU/OiBudW1iZXIpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBuZXdSYXRlID0gcmF0ZSB8fCAxO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblx0XHRjb25zdCBleHBhbmRXaWR0aCA9IE1hdGgubWluKHN0YXRlLnJhZGl1c0V4cGFuZGVkICogbmV3UmF0ZSAtIHN0YXRlLnJhZGl1cyxcclxuXHRcdFx0c2luZ2xlQXJjV2lkdGggKiAwLjggLSAoMSAtIG5ld1JhdGUpICogMTAwXHJcblx0XHQpO1xyXG5cclxuXHRcdGNvbnN0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIGQuaW5kZXggKyBleHBhbmRXaWR0aCA6XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlKVxyXG5cdFx0XHQpXHJcblx0XHRcdC5pbm5lclJhZGl1cygoZDogYW55KSA9PiAoaGFzTXVsdGlBcmNHYXVnZSA/XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiAoZC5pbmRleCArIDEpIDogc3RhdGUuaW5uZXJSYWRpdXMpKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblxyXG5cdFx0XHRpZiAodXBkYXRlZCkge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRoYXNNdWx0aUFyY0dhdWdlID8gYXJjIDogYXJjLmlubmVyUmFkaXVzKCQkLmdldElubmVyUmFkaXVzKGQpKVxyXG5cdFx0XHRcdCkodXBkYXRlZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIFwiTSAwIDBcIjtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmMoZCwgd2l0aG91dFVwZGF0ZTogYm9vbGVhbiwgZm9yY2U/OiBib29sZWFuKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBmb3JjZSB8fCB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gdGhpcy5zdmdBcmMoZCwgd2l0aG91dFVwZGF0ZSkgOiBcIk0gMCAwXCI7XHJcblx0fSxcclxuXHJcblx0dHJhbnNmb3JtRm9yQXJjTGFiZWwoZCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3JhZGl1cywgcmFkaXVzRXhwYW5kZWR9fSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdGxldCB0cmFuc2xhdGUgPSBcIlwiO1xyXG5cclxuXHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdGlmICgkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcclxuXHRcdFx0XHRjb25zdCB5MSA9IE1hdGguc2luKHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHggPSBNYXRoLmNvcyh1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpICogKHJhZGl1c0V4cGFuZGVkICsgMjUpO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSB5MSAqIChyYWRpdXNFeHBhbmRlZCArIDE1IC0gTWF0aC5hYnMoeTEgKiAxMCkpICsgMztcclxuXHJcblx0XHRcdFx0dHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYDtcclxuXHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVHlwZShcImdhdWdlXCIpIHx8ICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0Y29uc3QgYyA9IHRoaXMuc3ZnQXJjLmNlbnRyb2lkKHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IHggPSBpc05hTihjWzBdKSA/IDAgOiBjWzBdO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSBpc05hTihjWzFdKSA/IDAgOiBjWzFdO1xyXG5cdFx0XHRcdGNvbnN0IGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblxyXG5cdFx0XHRcdGxldCByYXRpbyA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvKSB8fFxyXG5cdFx0XHRcdFx0KCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgY29uZmlnLnBpZV9sYWJlbF9yYXRpbyk7XHJcblxyXG5cdFx0XHRcdGlmIChyYXRpbykge1xyXG5cdFx0XHRcdFx0cmF0aW8gPSBpc0Z1bmN0aW9uKHJhdGlvKSA/IHJhdGlvLmJpbmQoJCQuYXBpKShkLCByYWRpdXMsIGgpIDogcmF0aW87XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gcmFkaXVzICYmIChcclxuXHRcdFx0XHRcdFx0aCA/ICgzNiAvIHJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvIHJhZGl1cyA6IDAuOCkgKiByYWRpdXMgLyBoIDogMFxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4ICogcmF0aW99LCR7eSAqIHJhdGlvfSlgO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyYW5zbGF0ZTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VG9BcmNEYXRhKGQpOiBvYmplY3Qge1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTmFtZSh7XHJcblx0XHRcdGlkOiBkLmRhdGEuaWQsXHJcblx0XHRcdHZhbHVlOiBkLnZhbHVlLFxyXG5cdFx0XHRyYXRpbzogdGhpcy5nZXRSYXRpbyhcImFyY1wiLCBkKSxcclxuXHRcdFx0aW5kZXg6IGQuaW5kZXgsXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yQXJjTGFiZWwoc2VsZWN0aW9uOiBkM1NlbGVjdGlvbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblxyXG5cdFx0aWYgKCQkLnNob3VsZFNob3dBcmNMYWJlbCgpKSB7XHJcblx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBub2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHJhdGlvID0gJCQuZ2V0UmF0aW8oXCJhcmNcIiwgdXBkYXRlZCk7XHJcblx0XHRcdFx0Y29uc3QgaXNVbmRlclRocmVzaG9sZCA9ICEoXHJcblx0XHRcdFx0XHQhaGFzR2F1Z2UgJiYgISQkLm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQocmF0aW8pXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0aWYgKGlzVW5kZXJUaHJlc2hvbGQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt2YWx1ZX0gPSB1cGRhdGVkIHx8IGQ7XHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0ID0gKFxyXG5cdFx0XHRcdFx0XHQkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdFxyXG5cdFx0XHRcdFx0KSh2YWx1ZSwgcmF0aW8sIGQuZGF0YS5pZCkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0XHRzZXRUZXh0VmFsdWUobm9kZSwgdGV4dCwgWy0xLCAxXSwgaGFzR2F1Z2UpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRub2RlLnRleHQoXCJcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yR2F1Z2VNaW5NYXgodmFsdWU6IG51bWJlciwgaXNNYXg/OiBib29sZWFuKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZXh0ZW50cztcclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0LmJpbmQoJCQuYXBpKSh2YWx1ZSwgaXNNYXgpIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQXJjKHRhcmdldElkczogc3RyaW5nW10pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge3RyYW5zaXRpbmd9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gTUVNTzogYXZvaWQgdG8gY2FuY2VsIHRyYW5zaXRpb25cclxuXHRcdGlmICh0cmFuc2l0aW5nKSB7XHJcblx0XHRcdGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG5cdFx0XHRcdGlmICghdHJhbnNpdGluZykge1xyXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcblxyXG5cdFx0XHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkfWApLnNpemUoKSA+IDAgJiZcclxuXHRcdFx0XHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCAxMCk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbmV3VGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZiAoISQkLnNob3VsZEV4cGFuZChkLmRhdGEuaWQpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBleHBhbmREdXJhdGlvbiA9ICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIik7XHJcblx0XHRcdFx0Y29uc3Qgc3ZnQXJjRXhwYW5kZWRTdWIgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgkJC5nZXRFeHBhbmRDb25maWcoZC5kYXRhLmlkLCBcInJhdGVcIikpO1xyXG5cclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJwYXRoXCIpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24pXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWQpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24gKiAyKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIHN2Z0FyY0V4cGFuZGVkU3ViKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dW5leHBhbmRBcmModGFyZ2V0SWRzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7dHJhbnNpdGluZ30sICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpbmcpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXHJcblx0XHRcdC5zZWxlY3RBbGwoXCJwYXRoXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGQgPT4gJCQuZ2V0RXhwYW5kQ29uZmlnKGQuZGF0YS5pZCwgXCJkdXJhdGlvblwiKSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyYyk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbChgJHtDTEFTUy5hcmN9YClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGV4cGFuZCBjb25maWcgdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgZGF0YSBJRFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgY29uZmlnIGtleTogJ2R1cmF0aW9uIHwgcmF0ZSdcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RXhwYW5kQ29uZmlnKGlkOiBzdHJpbmcsIGtleTogXCJkdXJhdGlvblwiIHwgXCJyYXRlXCIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRlZiA9IHtcclxuXHRcdFx0ZHVyYXRpb246IDUwLFxyXG5cdFx0XHRyYXRlOiAwLjk4XHJcblx0XHR9O1xyXG5cdFx0bGV0IHR5cGU7XHJcblxyXG5cdFx0aWYgKCQkLmlzRG9udXRUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJkb251dFwiO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0dhdWdlVHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwiZ2F1Z2VcIjtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNQaWVUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJwaWVcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHlwZSA/IGNvbmZpZ1tgJHt0eXBlfV9leHBhbmRfJHtrZXl9YF0gOiBkZWZba2V5XTtcclxuXHR9LFxyXG5cclxuXHRzaG91bGRFeHBhbmQoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gKCQkLmlzRG9udXRUeXBlKGlkKSAmJiBjb25maWcuZG9udXRfZXhwYW5kKSB8fFxyXG5cdFx0XHQoJCQuaXNHYXVnZVR5cGUoaWQpICYmIGNvbmZpZy5nYXVnZV9leHBhbmQpIHx8XHJcblx0XHRcdCgkJC5pc1BpZVR5cGUoaWQpICYmIGNvbmZpZy5waWVfZXhwYW5kKTtcclxuXHR9LFxyXG5cclxuXHRzaG91bGRTaG93QXJjTGFiZWwoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCJdXHJcblx0XHRcdC5zb21lKHYgPT4gJCQuaGFzVHlwZSh2KSAmJiBjb25maWdbYCR7dn1fbGFiZWxfc2hvd2BdKTtcclxuXHR9LFxyXG5cclxuXHRtZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0aHJlc2hvbGQgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgPyBjb25maWcuZG9udXRfbGFiZWxfdGhyZXNob2xkIDogY29uZmlnLnBpZV9sYWJlbF90aHJlc2hvbGQ7XHJcblxyXG5cdFx0cmV0dXJuIHJhdGlvID49IHRocmVzaG9sZDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmNMYWJlbEZvcm1hdCgpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBmb3JtYXQgPSBjb25maWcucGllX2xhYmVsX2Zvcm1hdDtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XHJcblx0XHRcdGZvcm1hdCA9IGNvbmZpZy5nYXVnZV9sYWJlbF9mb3JtYXQ7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJkb251dFwiKSkge1xyXG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZG9udXRfbGFiZWxfZm9ybWF0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQuYmluZCgkJC5hcGkpIDogZm9ybWF0O1xyXG5cdH0sXHJcblxyXG5cdGdldEFyY1RpdGxlKCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0eXBlID0gKCQkLmhhc1R5cGUoXCJkb251dFwiKSAmJiBcImRvbnV0XCIpIHx8ICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgXCJnYXVnZVwiKTtcclxuXHJcblx0XHRyZXR1cm4gdHlwZSA/ICQkLmNvbmZpZ1tgJHt0eXBlfV90aXRsZWBdIDogXCJcIjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydEFyYyA9ICQkLmNsYXNzQ2hhcnRBcmMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0FyY3MgPSAkJC5jbGFzc0FyY3MuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IG1haW5QaWVVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXHJcblx0XHRcdC5kYXRhKCQkLnBpZSh0YXJnZXRzKSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRBcmMoZCkgKyBjbGFzc0ZvY3VzKGQuZGF0YSkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5QaWVFbnRlciA9IG1haW5QaWVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEFyYyk7XHJcblxyXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyY3MpXHJcblx0XHRcdC5tZXJnZShtYWluUGllVXBkYXRlKTtcclxuXHJcblx0XHRtYWluUGllRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcImR5XCIsIGhhc0dhdWdlICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IFwiLS4xZW1cIiA6IFwiLjM1ZW1cIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi4sIGJ1dCBub3QgYmFkIHRvIHVwZGF0ZSBjb2xvciBpbiByZWRyYXdcclxuXHRcdC8vIG1haW5QaWVVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRBcmMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cclxuXHRcdCRlbC5hcmNzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QXJjcylcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiYXJjXCIpKTtcclxuXHJcblx0XHQkJC5zZXRBcmNUaXRsZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhcmMgdGl0bGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0QXJjVGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0aXRsZSA9ICQkLmdldEFyY1RpdGxlKCk7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHJcblx0XHRpZiAodGl0bGUpIHtcclxuXHRcdFx0Y29uc3QgdGV4dCA9ICQkLiRlbC5hcmNzLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTW2hhc0dhdWdlID8gXCJjaGFydEFyY3NHYXVnZVRpdGxlXCIgOiBcImNoYXJ0QXJjc1RpdGxlXCJdKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xyXG5cclxuXHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0wLjNlbVwiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMjdweFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2V0VGV4dFZhbHVlKHRleHQsIHRpdGxlLCBoYXNHYXVnZSA/IHVuZGVmaW5lZCA6IFstMC42LCAxLjM1XSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QXJjKGR1cmF0aW9uOiBudW1iZXIsIGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyLCB3aXRoVHJhbnNmb3JtPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzSW50ZXJhY3Rpb24gPSBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZDtcclxuXHJcblx0XHRsZXQgbWFpbkFyYyA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY31gKVxyXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRtYWluQXJjLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdG1haW5BcmMgPSBtYWluQXJjLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJjLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZC5kYXRhKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGhhc0ludGVyYWN0aW9uICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGlmICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpKSB7XHJcblx0XHRcdFx0XHRkLnN0YXJ0QW5nbGUgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHRcdFx0XHRcdGQuZW5kQW5nbGUgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBkO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UobWFpbkFyYyk7XHJcblxyXG5cdFx0JCQuaGFzTXVsdGlBcmNHYXVnZSgpICYmICQkLnJlZHJhd011bHRpQXJjR2F1Z2UoKTtcclxuXHJcblx0XHRtYWluQXJjXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gKCEkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmIHdpdGhUcmFuc2Zvcm0gPyBcInNjYWxlKDApXCIgOiBcIlwiKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0cmV0dXJuIGQgPT09IHRoaXMuX2N1cnJlbnQgPyBcIjBcIiA6IFwiMVwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZWFjaCgoKSA9PiB7XHJcblx0XHRcdFx0c3RhdGUudHJhbnNpdGluZyA9IHRydWU7XHJcblx0XHRcdH0pXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuYXR0clR3ZWVuKFwiZFwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0XHRpZiAoIXVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiAoKSA9PiBcIk0gMCAwXCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5zdGFydEFuZ2xlKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudC5zdGFydEFuZ2xlID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc05hTih0aGlzLl9jdXJyZW50LmVuZEFuZ2xlKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudC5lbmRBbmdsZSA9IHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCB1cGRhdGVkKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhdGVkID0gaW50ZXJwb2xhdGUodCk7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGVkLmRhdGEgPSBkLmRhdGE7IC8vIGRhdGEuaWQgd2lsbCBiZSB1cGRhdGVkIGJ5IGludGVycG9yYXRvclxyXG5cdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhpbnRlcnBvbGF0ZWQsIHRydWUpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0pXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHdpdGhUcmFuc2Zvcm0gPyBcInNjYWxlKDEpXCIgOiBcIlwiKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4ge1xyXG5cdFx0XHRcdGxldCBjb2xvcjtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmxldmVsQ29sb3IpIHtcclxuXHRcdFx0XHRcdGNvbG9yID0gJCQubGV2ZWxDb2xvcihkLmRhdGEudmFsdWVzWzBdLnZhbHVlKTtcclxuXHJcblx0XHRcdFx0XHQvLyB1cGRhdGUgZGF0YSdzIGNvbG9yXHJcblx0XHRcdFx0XHRjb25maWcuZGF0YV9jb2xvcnNbZC5kYXRhLmlkXSA9IGNvbG9yO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb2xvciA9ICQkLmNvbG9yKGQuZGF0YS5pZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29sb3I7XHJcblx0XHRcdH0pXHJcblx0XHRcdC8vIFdoZXJlIGdhdWdlIHJlYWRpbmcgY29sb3Igd291bGQgcmVjZWl2ZSBjdXN0b21pemF0aW9uLlxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XHQuY2FsbChlbmRhbGwsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICgkJC5sZXZlbENvbG9yKSB7XHJcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0XHRjb25zdCBkOiBhbnkgPSBwYXRoLmRhdHVtKCk7XHJcblxyXG5cdFx0XHRcdFx0JCQudXBkYXRlTGVnZW5kSXRlbUNvbG9yKGQuZGF0YS5pZCwgcGF0aC5zdHlsZShcImZpbGxcIikpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUudHJhbnNpdGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdGNhbGxGbihjb25maWcub25yZW5kZXJlZCwgJCQuYXBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gYmluZCBhcmMgZXZlbnRzXHJcblx0XHRoYXNJbnRlcmFjdGlvbiAmJiAkJC5iaW5kQXJjRXZlbnQobWFpbkFyYyk7XHJcblxyXG5cdFx0JCQucmVkcmF3QXJjVGV4dChkdXJhdGlvbik7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TXVsdGlBcmNHYXVnZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB7aGlkZGVuVGFyZ2V0SWRzfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IGFyY0xhYmVsTGluZXMgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY3N9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjTGFiZWxMaW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmFyY0RhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5BcmNMYWJlbExpbmUgPSBhcmNMYWJlbExpbmVzLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLmFyY0xhYmVsTGluZX0gJHtDTEFTUy50YXJnZXR9ICR7Q0xBU1MudGFyZ2V0fS0ke2QuZGF0YS5pZH1gKVxyXG5cdFx0XHQubWVyZ2UoYXJjTGFiZWxMaW5lcyk7XHJcblxyXG5cdFx0bWFpbkFyY0xhYmVsTGluZVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gKCQkLmxldmVsQ29sb3IgPyAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhKSkpXHJcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBcIlwiIDogXCJub25lXCIpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRsZXQgbGluZUxlbmd0aCA9IDA7XHJcblx0XHRcdFx0Y29uc3QgbGluZVRoaWNrbmVzcyA9IDI7XHJcblx0XHRcdFx0bGV0IHggPSAwO1xyXG5cdFx0XHRcdGxldCB5ID0gMDtcclxuXHRcdFx0XHRsZXQgdHJhbnNmb3JtID0gXCJcIjtcclxuXHJcblx0XHRcdFx0aWYgKGhpZGRlblRhcmdldElkcy5pbmRleE9mKGQuZGF0YS5pZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBpbm5lckxpbmVMZW5ndGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCAqXHJcblx0XHRcdFx0XHRcdCh1cGRhdGVkLmluZGV4ICsgMSk7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lQW5nbGUgPSB1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNJbm5lclJhZGl1cyA9IHN0YXRlLnJhZGl1cyAtIGlubmVyTGluZUxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnN0IGxpbmVQb3NpdGlvbmluZ0FuZ2xlID0gbGluZUFuZ2xlIC0gKGFyY0lubmVyUmFkaXVzID09PSAwID8gMCA6ICgxIC8gYXJjSW5uZXJSYWRpdXMpKTtcclxuXHJcblx0XHRcdFx0XHRsaW5lTGVuZ3RoID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgLSBzdGF0ZS5yYWRpdXMgKyBpbm5lckxpbmVMZW5ndGg7XHJcblx0XHRcdFx0XHR4ID0gTWF0aC5jb3MobGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zaW4obGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XHJcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBgcm90YXRlKCR7bGluZUFuZ2xlICogMTgwIC8gTWF0aC5QSX0sICR7eH0sICR7eX0pYDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBsaW5lTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgbGluZVRoaWNrbmVzcylcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgYDAsICR7bGluZUxlbmd0aCArIGxpbmVUaGlja25lc3N9LCAwYCk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGJpbmRBcmNFdmVudChhcmMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNUb3VjaCA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xyXG5cdFx0Y29uc3QgaXNNb3VzZSA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gc2VsZWN0QXJjKF90aGlzLCBhcmNEYXRhLCBpZCkge1xyXG5cdFx0XHQvLyB0cmFuc2l0aW9uc1xyXG5cdFx0XHQkJC5leHBhbmRBcmMoaWQpO1xyXG5cdFx0XHQkJC5hcGkuZm9jdXMoaWQpO1xyXG5cdFx0XHQkJC50b2dnbGVGb2N1c0xlZ2VuZChpZCwgdHJ1ZSk7XHJcblx0XHRcdCQkLnNob3dUb29sdGlwKFthcmNEYXRhXSwgX3RoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YT8pIHtcclxuXHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHQkJC51bmV4cGFuZEFyYyhpZCk7XHJcblx0XHRcdCQkLmFwaS5yZXZlcnQoKTtcclxuXHRcdFx0JCQucmV2ZXJ0TGVnZW5kKCk7XHJcblx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0YXJjXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0bGV0IGFyY0RhdGE7XHJcblxyXG5cdFx0XHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRhcmNEYXRhID0gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKTtcclxuXHJcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSAmJiAkJC50b2dnbGVTaGFwZSh0aGlzLCBhcmNEYXRhLCBpKTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suYmluZCgkJC5hcGkpKGFyY0RhdGEsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gbW91c2UgZXZlbnRzXHJcblx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRhcmNcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdFx0c2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQodHJ1ZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpO1xyXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIHRoaXMpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvdWNoIGV2ZW50c1xyXG5cdFx0aWYgKGlzVG91Y2ggJiYgJCQuaGFzQXJjVHlwZSgpICYmICEkJC5yYWRhcnMpIHtcclxuXHRcdFx0Y29uc3QgZ2V0RXZlbnRBcmMgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG91Y2ggPSBkM0V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBldmVudEFyYztcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoc3RhdGUudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZ2V0RXZlbnRBcmMoKTtcclxuXHRcdFx0XHRjb25zdCBkYXR1bTogYW55ID0gZXZlbnRBcmMuZGF0dW0oKTtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gKGRhdHVtICYmIGRhdHVtLmRhdGEgJiYgZGF0dW0uZGF0YS5pZCkgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goYXJjRGF0YSk7XHJcblxyXG5cdFx0XHRcdGlzVW5kZWZpbmVkKGlkKSA/XHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpIDogc2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdCQkLiRlbC5zdmdcclxuXHRcdFx0XHQub24oXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZXIpXHJcblx0XHRcdFx0Lm9uKFwidG91Y2htb3ZlXCIsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyY1RleHQoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW4sIGFyY3N9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRjb25zdCBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpO1xyXG5cdFx0bGV0IHRleHQ7XHJcblxyXG5cdFx0Ly8gZm9yIGdhdWdlIHR5cGUsIHVwZGF0ZSB0ZXh0IHdoZW4gaGFzIG5vIHRpdGxlICYgbXVsdGkgZGF0YVxyXG5cdFx0aWYgKCEoaGFzR2F1Z2UgJiYgJCQuZGF0YS50YXJnZXRzLmxlbmd0aCA9PT0gMSAmJiBjb25maWcuZ2F1Z2VfdGl0bGUpKSB7XHJcblx0XHRcdHRleHQgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRBcmN9YClcclxuXHRcdFx0XHQuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+ICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpID8gQ0xBU1MuZ2F1Z2VWYWx1ZSA6IG51bGwpKVxyXG5cdFx0XHRcdC5jYWxsKCQkLnRleHRGb3JBcmNMYWJlbC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC50cmFuc2Zvcm1Gb3JBcmNMYWJlbC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgZCA9PiAoXHJcblx0XHRcdFx0XHQkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgIWhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdFx0XHRgJHtNYXRoLnJvdW5kKHN0YXRlLnJhZGl1cyAvIDUpfXB4YCA6IG51bGxcclxuXHRcdFx0XHQpKVxyXG5cdFx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+ICgkJC5pc1RhcmdldFRvU2hvdyhkLmRhdGEuaWQpICYmICQkLmlzQXJjVHlwZShkLmRhdGEpID8gXCIxXCIgOiBcIjBcIikpO1xyXG5cclxuXHRcdFx0aGFzTXVsdGlBcmNHYXVnZSAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBcIi0uMWVtXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NUaXRsZX1gKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmhhc1R5cGUoXCJkb251dFwiKSB8fCBoYXNHYXVnZSA/IFwiMVwiIDogXCIwXCIpO1xyXG5cclxuXHRcdGlmIChoYXNHYXVnZSkge1xyXG5cdFx0XHRjb25zdCBpc0Z1bGxDaXJjbGUgPSBjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcclxuXHRcdFx0Y29uc3Qgc3RhcnRBbmdsZSA9IC0xICogTWF0aC5QSSAvIDI7XHJcblx0XHRcdGNvbnN0IGVuZEFuZ2xlID0gKGlzRnVsbENpcmNsZSA/IC00IDogLTEpICogc3RhcnRBbmdsZTtcclxuXHJcblx0XHRcdGlzRnVsbENpcmNsZSAmJiB0ZXh0ICYmIHRleHQuYXR0cihcImR5XCIsIGAke01hdGgucm91bmQoc3RhdGUucmFkaXVzIC8gMTQpfWApO1xyXG5cclxuXHRcdFx0bGV0IGJhY2tncm91bmRBcmMgPSAkJC4kZWwuYXJjcy5zZWxlY3QoXHJcblx0XHRcdFx0YCR7aGFzTXVsdGlBcmNHYXVnZSA/IFwiZ1wiIDogXCJcIn0uJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfWBcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGlmIChoYXNNdWx0aUFyY0dhdWdlKSB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gMDtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZEFyYyA9IGJhY2tncm91bmRBcmNcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoYHBhdGguJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfWApXHJcblx0XHRcdFx0XHQuZGF0YSgkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmVudGVyKClcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfSAke0NMQVNTLmNoYXJ0QXJjc0JhY2tncm91bmR9LSR7aX1gKVxyXG5cdFx0XHRcdFx0Lm1lcmdlKGJhY2tncm91bmRBcmMpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZDEgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAoc3RhdGUuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YoZDEuaWQpID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJNIDAgMFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBkID0ge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGE6IFt7dmFsdWU6IGNvbmZpZy5nYXVnZV9tYXh9XSxcclxuXHRcdFx0XHRcdFx0XHRzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGVuZEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpbmRleCsrXHJcblx0XHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMuYXR0cihcImRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgZCA9IHtcclxuXHRcdFx0XHRcdFx0ZGF0YTogW3t2YWx1ZTogY29uZmlnLmdhdWdlX21heH1dLFxyXG5cdFx0XHRcdFx0XHRzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRlbmRBbmdsZVxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0fWApXHJcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi43NWVtXCIpXHJcblx0XHRcdFx0LnRleHQoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBjb25maWcuZ2F1Z2VfdW5pdHMgOiBcIlwiKTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuZ2F1Z2VfbGFiZWxfc2hvdykge1xyXG5cdFx0XHRcdGFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1pbn1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCBgJHstMSAqIChzdGF0ZS5pbm5lclJhZGl1cyArICgoc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMpIC8gKGlzRnVsbENpcmNsZSA/IDEgOiAyKSkpfXB4YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKVxyXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9taW4sIGZhbHNlKSk7XHJcblxyXG5cdFx0XHRcdC8vIHNob3cgbWF4IHRleHQgd2hlbiBpc24ndCBmdWxsQ2lyY2xlXHJcblx0XHRcdFx0IWlzRnVsbENpcmNsZSAmJiBhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXh9YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7c3RhdGUuaW5uZXJSYWRpdXMgKyAoKHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzKSAvIDIpfXB4YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKVxyXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9tYXgsIHRydWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRHYXVnZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge2FyY3N9fSA9ICQkO1xyXG5cdFx0Y29uc3QgYXBwZW5kVGV4dCA9IGNsYXNzTmFtZSA9PiB7XHJcblx0XHRcdGFyY3MuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XHJcblx0XHRcdGFyY3MuYXBwZW5kKCQkLmhhc011bHRpQXJjR2F1Z2UoKSA/IFwiZ1wiIDogXCJwYXRoXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKTtcclxuXHJcblx0XHRcdGNvbmZpZy5nYXVnZV91bml0cyAmJiBhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdCk7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cpIHtcclxuXHRcdFx0XHRhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlTWluKTtcclxuXHRcdFx0XHQhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1heCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRHYXVnZUxhYmVsSGVpZ2h0KCk6IDIwIHwgMCB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZ2F1Z2VfbGFiZWxfc2hvdyA/IDIwIDogMDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldE1pbk1heCwgZ2V0UmFuZ2UsIGlzRGVmaW5lZCwgaXNFbXB0eSwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBzZXRUZXh0VmFsdWUsIHRvQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcG9zaXRpb24gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFufSBpc0Nsb2Nrd2lzZSBJZiB0aGUgZGlyZWN0aW9uIGlzIGNsb2Nrd2lzZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDb29yZGluYXRlIHR5cGUgJ3gnIG9yICd5J1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZWRnZSBOdW1iZXIgb2YgZWRnZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBpbmRleGVkIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZSBSYW5nZSB2YWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gUmF0aW8gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGlzQ2xvY2t3aXNlOiBib29sZWFuLCB0eXBlOiBcInhcIiB8IFwieVwiLCBlZGdlOiBudW1iZXIsIHBvczogbnVtYmVyLCByYW5nZTogbnVtYmVyLCByYXRpbzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRjb25zdCBpbmRleCA9IGlzQ2xvY2t3aXNlICYmIHBvcyA+IDAgPyBlZGdlIC0gcG9zIDogcG9zO1xyXG5cdGNvbnN0IHIgPSAyICogTWF0aC5QSTtcclxuXHRjb25zdCBmdW5jID0gdHlwZSA9PT0gXCJ4XCIgPyBNYXRoLnNpbiA6IE1hdGguY29zO1xyXG5cclxuXHRyZXR1cm4gcmFuZ2UgKiAoMSAtIHJhdGlvICogZnVuYyhpbmRleCAqIHIgLyBlZGdlKSk7XHJcbn1cclxuXHJcbi8vIGNhY2hlIGtleVxyXG5jb25zdCBjYWNoZUtleSA9IEtFWS5yYWRhclBvaW50cztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UmFkYXIoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnR9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJyYWRhclwiKSkge1xyXG5cdFx0XHQkZWwucmFkYXJzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydFJhZGFycyk7XHJcblxyXG5cdFx0XHQvLyBsZXZlbFxyXG5cdFx0XHQkZWwucmFkYXJzLmxldmVscyA9ICRlbC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGV2ZWxzKTtcclxuXHJcblx0XHRcdC8vIGF4aXNcclxuXHRcdFx0JGVsLnJhZGFycy5heGVzID0gJGVsLnJhZGFycy5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzKTtcclxuXHJcblx0XHRcdC8vIHNoYXBlc1xyXG5cdFx0XHQkZWwucmFkYXJzLnNoYXBlcyA9ICRlbC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muc2hhcGVzKTtcclxuXHJcblx0XHRcdGN1cnJlbnQuZGF0YU1heCA9IGNvbmZpZy5yYWRhcl9heGlzX21heCB8fCAkJC5nZXRNaW5NYXhEYXRhKCkubWF4WzBdLnZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFJhZGFyU2l6ZSgpOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7YXJjV2lkdGgsIGFyY0hlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA8IDQgPyAtMjAgOiAxMDtcclxuXHRcdGNvbnN0IHNpemUgPSAoTWF0aC5taW4oYXJjV2lkdGgsIGFyY0hlaWdodCkgLSBwYWRkaW5nKSAvIDI7XHJcblxyXG5cdFx0cmV0dXJuIFtzaXplLCBzaXplXTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X2NhdGVnb3JpZXMpKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGdldFJhbmdlKDAsIGdldE1pbk1heChcIm1heFwiLCB0YXJnZXRzLm1hcCh2ID0+IHYudmFsdWVzLmxlbmd0aCkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkYXJQb3NpdGlvbih0eXBlLCBpbmRleDogbnVtYmVyLCByYW5nZSwgcmF0aW86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGlzQ2xvY2t3aXNlID0gY29uZmlnLnJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U7XHJcblxyXG5cdFx0Y29uc3QgcG9zID0gdG9BcnJheSh0eXBlKS5tYXAodiA9PiBnZXRQb3NpdGlvbihcclxuXHRcdFx0aXNDbG9ja3dpc2UsXHJcblx0XHRcdHYsXHJcblx0XHRcdGVkZ2UsXHJcblx0XHRcdGluZGV4LFxyXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UpID8gcmFuZ2UgOiAodHlwZSA9PT0gXCJ4XCIgPyB3aWR0aCA6IGhlaWdodCksXHJcblx0XHRcdGlzTnVtYmVyKHJhdGlvKSA/IHJhdGlvIDogY29uZmlnLnJhZGFyX3NpemVfcmF0aW9cclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiBwb3MubGVuZ3RoID09PSAxID8gcG9zWzBdIDogcG9zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVJhZGFyUG9pbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cztcclxuXHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmNhY2hlLmdldChjYWNoZUtleSkgfHwge307XHJcblx0XHRjb25zdCBzaXplID0gcG9pbnRzLl9zaXplO1xyXG5cclxuXHRcdC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9ubHkgd2hlbiB0aGUgcHJldmlvdXMgZGltZW5zaW9uIGhhcyBiZWVuIGNoYW5nZWRcclxuXHRcdGlmICghc2l6ZSB8fCAoc2l6ZS53aWR0aCAhPT0gd2lkdGggJiYgc2l6ZS5oZWlnaHQgIT09IGhlaWdodCkpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdHBvaW50c1tkLmlkXSA9IGQudmFsdWVzLm1hcCgodiwgaSkgPT4gKFxyXG5cdFx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgdW5kZWZpbmVkLCAkJC5nZXRSYXRpbyhcInJhZGFyXCIsIHYpKVxyXG5cdFx0XHRcdCkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBvaW50cy5fc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JhZGFyKGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7cmFkYXJzLCBtYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZSA9ICQkLmdldFRyYW5zbGF0ZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdC8vIEFkanVzdCByYWRhciwgY2lyY2xlcyBhbmQgdGV4dHMnIHBvc2l0aW9uXHJcblx0XHRpZiAodHJhbnNsYXRlKSB7XHJcblx0XHRcdHJhZGFycy5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfWApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKTtcclxuXHRcdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xyXG5cclxuXHRcdFx0JCQuZ2VuZXJhdGVSYWRhclBvaW50cygpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhckxldmVsKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyQXhlcygpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhclNoYXBlKGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRSYWRhclBvaW50cygpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2QuaWRdW2ldO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSYWRhckxldmVsKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3JhZGFyc319ID0gJCQ7XHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IGRlcHRoID0gY29uZmlnLnJhZGFyX2xldmVsX2RlcHRoO1xyXG5cdFx0Y29uc3QgZWRnZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XHJcblx0XHRjb25zdCBzaG93VGV4dCA9IGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X3Nob3c7XHJcblxyXG5cdFx0Y29uc3QgcmFkYXJMZXZlbHMgPSByYWRhcnMubGV2ZWxzO1xyXG5cdFx0Y29uc3QgbGV2ZWxEYXRhID0gZ2V0UmFuZ2UoMCwgZGVwdGgpO1xyXG5cclxuXHRcdGNvbnN0IHJhZGl1cyA9IGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvICogTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XHJcblx0XHRjb25zdCBsZXZlbFJhdGlvID0gbGV2ZWxEYXRhLm1hcChsID0+IHJhZGl1cyAqICgobCArIDEpIC8gZGVwdGgpKTtcclxuXHRcdGNvbnN0IGxldmVsVGV4dEZvcm1hdCA9IChjb25maWcucmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQgfHwgZnVuY3Rpb24oKSB7fSkuYmluZCgkJC5hcGkpO1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlIHBvaW50c1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gbGV2ZWxEYXRhLm1hcCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBsZXZlbFJhdGlvW3ZdO1xyXG5cdFx0XHRjb25zdCBwb3MgPSBnZXRSYW5nZSgwLCBlZGdlKS5tYXAoaSA9PiAoXHJcblx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgcmFuZ2UsIDEpKS5qb2luKFwiLFwiKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHBvcy5qb2luKFwiIFwiKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IGxldmVsID0gcmFkYXJMZXZlbHNcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGV2ZWx9YClcclxuXHRcdFx0LmRhdGEobGV2ZWxEYXRhKTtcclxuXHJcblx0XHRsZXZlbC5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWxFbnRlciA9IGxldmVsLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5sZXZlbH0gJHtDTEFTUy5sZXZlbH0tJHtpfWApO1xyXG5cclxuXHRcdGxldmVsRW50ZXIuYXBwZW5kKFwicG9seWdvblwiKVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5yYWRhcl9sZXZlbF9zaG93ID8gbnVsbCA6IFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdGlmIChzaG93VGV4dCkge1xyXG5cdFx0XHRpZiAocmFkYXJMZXZlbHMuc2VsZWN0KFwidGV4dFwiKS5lbXB0eSgpKSB7XHJcblx0XHRcdFx0cmFkYXJMZXZlbHNcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIFwiLS41ZW1cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItLjdlbVwiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuXHRcdFx0XHRcdC50ZXh0KCgpID0+IGxldmVsVGV4dEZvcm1hdCgwKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldmVsRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcblx0XHRcdFx0LnRleHQoZCA9PiBsZXZlbFRleHRGb3JtYXQoXHJcblx0XHRcdFx0XHRzdGF0ZS5jdXJyZW50LmRhdGFNYXggLyBsZXZlbERhdGEubGVuZ3RoICogKGQgKyAxKVxyXG5cdFx0XHRcdCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldmVsRW50ZXJcclxuXHRcdFx0Lm1lcmdlKGxldmVsKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IGB0cmFuc2xhdGUoJHt3aWR0aCAtIGxldmVsUmF0aW9bZF19LCAke2hlaWdodCAtIGxldmVsUmF0aW9bZF19KWApXHJcblx0XHRcdC5zZWxlY3RBbGwoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5hdHRyKFwicG9pbnRzXCIsIGQgPT4gcG9pbnRzW2RdKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgbGV2ZWwgdGV4dCBwb3NpdGlvblxyXG5cdFx0aWYgKHNob3dUZXh0KSB7XHJcblx0XHRcdHJhZGFyTGV2ZWxzLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyB3aWR0aCA6IHBvaW50c1tkXS5zcGxpdChcIixcIilbMF0pKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCBkID0+IChpc1VuZGVmaW5lZChkKSA/IGhlaWdodCA6IDApKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSYWRhckF4ZXMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtyYWRhcnN9fSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBjYXRlZ29yaWVzID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cclxuXHRcdGxldCBheGlzID0gcmFkYXJzLmF4ZXMuc2VsZWN0QWxsKFwiZ1wiKVxyXG5cdFx0XHQuZGF0YShjYXRlZ29yaWVzKTtcclxuXHJcblx0XHRheGlzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBheGlzRW50ZXIgPSBheGlzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5heGlzfS0ke2l9YCk7XHJcblxyXG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xyXG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdGF4aXMgPSBheGlzRW50ZXIubWVyZ2UoYXhpcyk7XHJcblxyXG5cdFx0Ly8gYXhpcyBsaW5lXHJcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93KSB7XHJcblx0XHRcdGF4aXMuc2VsZWN0KFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgd2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBoZWlnaHQpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAoZCwgaSkgPT4gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgaSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAoZCwgaSkgPT4gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInlcIiwgaSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGF4aXMgdGV4dFxyXG5cdFx0aWYgKGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdykge1xyXG5cdFx0XHRjb25zdCB7eCA9IDAsIHkgPSAwfSA9IGNvbmZpZy5yYWRhcl9heGlzX3RleHRfcG9zaXRpb247XHJcblxyXG5cdFx0XHRheGlzLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuNWVtXCIpXHJcblx0XHRcdFx0LmNhbGwoc2VsZWN0aW9uID0+IHtcclxuXHRcdFx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0c2V0VGV4dFZhbHVlKGQzU2VsZWN0KHRoaXMpLCBTdHJpbmcoZCksIFstMC42LCAxLjJdKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmRhdHVtKChkLCBpKSA9PiAoe2luZGV4OiBpfSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHRoaXMud2lkdGgpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGNhY2hlIGV2YWx1YXRlZCBheGlzIHRleHQgd2lkdGhcclxuXHRcdFx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBwb3NYID0gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgZC5pbmRleCwgdW5kZWZpbmVkLCAxKTtcclxuXHRcdFx0XHRcdGxldCBwb3NZID0gTWF0aC5yb3VuZCgkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBkLmluZGV4LCB1bmRlZmluZWQsIDEpKTtcclxuXHJcblx0XHRcdFx0XHRpZiAocG9zWCA+IHdpZHRoKSB7XHJcblx0XHRcdFx0XHRcdHBvc1ggKz0gdGhpcy53aWR0aCArIHg7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKE1hdGgucm91bmQocG9zWCkgPCB3aWR0aCkge1xyXG5cdFx0XHRcdFx0XHRwb3NYIC09IHRoaXMud2lkdGggKyB4O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChwb3NZID4gaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB2ZXJ0aWNhbCBjZW50ZXJlZCBlZGdlIGF4aXMgdGV4dCBkeSBwb3NpdGlvblxyXG5cdFx0XHRcdFx0XHRpZiAocG9zWSAvIDIgPT09IGhlaWdodCAmJiB0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gXCJ0c3BhblwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImR5XCIsIFwiMGVtXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRwb3NZICs9IHk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvc1kgPCBoZWlnaHQpIHtcclxuXHRcdFx0XHRcdFx0cG9zWSAtPSB5O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWH0gJHtwb3NZfSlgO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmJpbmRFdmVudCgpO1xyXG5cdH0sXHJcblxyXG5cdGJpbmRFdmVudCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aW5wdXRUeXBlLCB0cmFuc2l0aW5nfSwgJGVsOiB7cmFkYXJzLCBzdmd9fSA9ICQkO1xyXG5cdFx0Y29uc3QgZm9jdXNPbmx5ID0gY29uZmlnLnBvaW50X2ZvY3VzX29ubHk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdGNvbnN0IGlzTW91c2UgPSBpbnB1dFR5cGUgPT09IFwibW91c2VcIjtcclxuXHRcdFx0Y29uc3QgZ2V0SW5kZXggPSAoKSA9PiB7XHJcblx0XHRcdFx0bGV0IHRhcmdldCA9IGQzRXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIG11bHRpbGluZWQgYXhpcyB0ZXh0XHJcblx0XHRcdFx0aWYgKC90c3Bhbi9pLnRlc3QodGFyZ2V0LnRhZ05hbWUpKSB7XHJcblx0XHRcdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGQ6IGFueSA9IGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGQgJiYgT2JqZWN0LmtleXMoZCkubGVuZ3RoID09PSAxID8gZC5pbmRleCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29uc3QgaGlkZSA9ICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XHJcblx0XHRcdFx0Y29uc3Qgbm9JbmRleCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcclxuXHJcblx0XHRcdFx0aWYgKGlzTW91c2UgfHwgbm9JbmRleCkge1xyXG5cdFx0XHRcdFx0JCQuaGlkZVRvb2x0aXAoKTtcclxuXHJcblx0XHRcdFx0XHRmb2N1c09ubHkgP1xyXG5cdFx0XHRcdFx0XHQkJC5oaWRlQ2lyY2xlRm9jdXMoKSA6XHJcblx0XHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc01vdXNlKSB7XHJcblx0XHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGluZGV4KTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9JbmRleCkge1xyXG5cdFx0XHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmFkYXJzLnNlbGVjdChgLiR7Q0xBU1MuYXhpc31gKVxyXG5cdFx0XHRcdC5vbihpc01vdXNlID8gXCJtb3VzZW92ZXIgXCIgOiBcInRvdWNoc3RhcnRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKHRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XHJcblxyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZShzdmcubm9kZSgpLCBudWxsLCBpbmRleCk7XHJcblx0XHRcdFx0XHRpc01vdXNlID8gJCQuc2V0T3Zlck91dCh0cnVlLCBpbmRleCkgOiAkJC5jYWxsT3Zlck91dEZvclRvdWNoKGluZGV4KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGlzTW91c2UgPyBoaWRlIDogbnVsbCk7XHJcblxyXG5cdFx0XHRpZiAoIWlzTW91c2UpIHtcclxuXHRcdFx0XHRzdmcub24oXCJ0b3VjaHN0YXJ0XCIsIGhpZGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJTaGFwZShkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHM7XHJcblx0XHRjb25zdCBwb2ludHMgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGNvbnN0IGFyZWFzID0gJCQuJGVsLnJhZGFycy5zaGFwZXNcclxuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgYXJlYXNFbnRlciA9IGFyZWFzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2hhcnRSYWRhci5iaW5kKCQkKSk7XHJcblxyXG5cdFx0YXJlYXMuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0YXJlYXNFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwicG9seWdvblwiKVxyXG5cdFx0XHQubWVyZ2UoYXJlYXMpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZC5pZF0uam9pbihcIiBcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIHBvaW50IHggY29vcmRpbmF0ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJhZGFyQ2lyY2xlWChkKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlLmdldChjYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgcG9pbnQgeSBjb29yZGluYXRlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmFkYXJDaXJjbGVZKGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVsxXTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIE1vZHVsZXMgZXhwb3J0cyBmb3IgQXJjIGJhc2VkIGNoYXJ0XHJcbiAqL1xyXG4vLyBzaGFwZVxyXG5pbXBvcnQgYXJjIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL2FyY1wiO1xyXG5pbXBvcnQgcmFkYXIgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXJcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBpbnRlcm5hbCA9IFtcclxuXHRhcmMsXHJcblx0cmFkYXJcclxuXTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7XHJcblx0dGltZVBhcnNlIGFzIGQzVGltZVBhcnNlLFxyXG5cdHRpbWVGb3JtYXQgYXMgZDNUaW1lRm9ybWF0LFxyXG5cdHV0Y1BhcnNlIGFzIGQzVXRjUGFyc2UsXHJcblx0dXRjRm9ybWF0IGFzIGQzVXRjRm9ybWF0XHJcbn0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IFN0b3JlIGZyb20gXCIuLi9jb25maWcvU3RvcmUvU3RvcmVcIjtcclxuaW1wb3J0IE9wdGlvbnMgZnJvbSBcIi4uL2NvbmZpZy9PcHRpb25zL09wdGlvbnNcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENhY2hlIGZyb20gXCIuLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtnZW5lcmF0ZVJlc2l6ZX0gZnJvbSBcIi4uL21vZHVsZS9nZW5lcmF0b3JcIjtcclxuaW1wb3J0IHtleHRlbmQsIG5vdEVtcHR5LCBjb252ZXJ0SW5wdXRUeXBlLCBnZXRPcHRpb24sIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZywgY2FsbEZuLCBzb3J0VmFsdWV9IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gQXhpc1xyXG5pbXBvcnQgQXhpcyBmcm9tIFwiLi9BeGlzL0F4aXNcIjtcclxuXHJcbi8vIGRhdGFcclxuaW1wb3J0IGRhdGFDb252ZXJ0IGZyb20gXCIuL2RhdGEvZGF0YS5jb252ZXJ0XCI7XHJcbmltcG9ydCBkYXRhIGZyb20gXCIuL2RhdGEvZGF0YVwiO1xyXG5pbXBvcnQgZGF0YUxvYWQgZnJvbSBcIi4vZGF0YS9kYXRhLmxvYWRcIjtcclxuXHJcbi8vIGludGVyYWN0aW9uc1xyXG5pbXBvcnQgaW50ZXJhY3Rpb24gZnJvbSBcIi4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uXCI7XHJcblxyXG4vLyBpbnRlcm5hbHNcclxuaW1wb3J0IGNsYXNzTW9kdWxlIGZyb20gXCIuL2ludGVybmFscy9jbGFzc1wiO1xyXG5pbXBvcnQgY2F0ZWdvcnkgZnJvbSBcIi4vaW50ZXJuYWxzL2NhdGVnb3J5XCI7IC8vIHVzZWQgdG8gcmV0cmlldmUgcmFkYXIgQXhpcyBuYW1lXHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9pbnRlcm5hbHMvY29sb3JcIjtcclxuaW1wb3J0IGRvbWFpbiBmcm9tIFwiLi9pbnRlcm5hbHMvZG9tYWluXCI7XHJcbmltcG9ydCBmb3JtYXQgZnJvbSBcIi4vaW50ZXJuYWxzL2Zvcm1hdFwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2ludGVybmFscy9sZWdlbmRcIjtcclxuaW1wb3J0IHJlZHJhdyBmcm9tIFwiLi9pbnRlcm5hbHMvcmVkcmF3XCI7XHJcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi9pbnRlcm5hbHMvc2NhbGVcIjtcclxuaW1wb3J0IHNpemUgZnJvbSBcIi4vaW50ZXJuYWxzL3NpemVcIjtcclxuaW1wb3J0IHRleHQgZnJvbSBcIi4vaW50ZXJuYWxzL3RleHRcIjtcclxuaW1wb3J0IHRpdGxlIGZyb20gXCIuL2ludGVybmFscy90aXRsZVwiO1xyXG5pbXBvcnQgdG9vbHRpcCBmcm9tIFwiLi9pbnRlcm5hbHMvdG9vbHRpcFwiO1xyXG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL2ludGVybmFscy90cmFuc2Zvcm1cIjtcclxuaW1wb3J0IHR5cGUgZnJvbSBcIi4vaW50ZXJuYWxzL3R5cGVcIjtcclxuXHJcbmltcG9ydCB7aW50ZXJuYWwgYXMgYXhpc0ludGVybmFsfSBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2F4aXNcIjtcclxuaW1wb3J0IHtpbnRlcm5hbCBhcyBhcmNJbnRlcm5hbH0gZnJvbSBcIi4uL2NvbmZpZy9yZXNvbHZlci9hcmNcIjtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjaGFydCBjbGFzcy5cclxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cclxuICogQGNsYXNzIENoYXJ0SW50ZXJuYWxcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnRJbnRlcm5hbCB7XHJcblx0cHVibGljIGFwaTtcdC8vIEFQSSBpbnRlcmZhY2VcclxuXHRwdWJsaWMgY29uZmlnOyAvLyBjb25maWcgb2JqZWN0XHJcblx0cHVibGljIGNhY2hlOyAvLyBjYWNoZSBpbnN0YW5jZVxyXG5cdHB1YmxpYyAkZWw7IC8vIGVsZW1lbnRzXHJcblx0cHVibGljIHN0YXRlOyAvLyBzdGF0ZSB2YXJpYWJsZXNcclxuXHRwdWJsaWMgY2hhcnRzOyAvLyBhbGwgQ2hhcnQgaW5zdGFuY2VzIGFycmF5IHdpdGhpbiBwYWdlIChlcXVpdmFsZW50IG9mICdiYi5pbnN0YW5jZXMnKVxyXG5cdHB1YmxpYyBpc0FyYyA9IGZhbHNlOyAvLyBpZiBpcyBBcmMgdHlwZSBjaGFydFxyXG5cclxuXHQvLyBkYXRhIG9iamVjdFxyXG5cdHB1YmxpYyBkYXRhID0ge1xyXG5cdFx0eHM6IHt9LFxyXG5cdFx0dGFyZ2V0czogW11cclxuXHR9O1xyXG5cclxuXHQvLyBBeGlzXHJcblx0cHVibGljIGF4aXM7IC8vIEF4aXNcclxuXHJcblx0Ly8gc2NhbGVzXHJcblx0cHVibGljIHNjYWxlID0ge1xyXG5cdFx0eDogbnVsbCxcclxuXHRcdHk6IG51bGwsXHJcblx0XHR5MjogbnVsbCxcclxuXHRcdHN1Ylg6IG51bGwsXHJcblx0XHRzdWJZOiBudWxsLFxyXG5cdFx0c3ViWTI6IG51bGwsXHJcblx0XHR6b29tOiBudWxsXHJcblx0fVxyXG5cclxuXHQvLyBvcmlnaW5hbCB2YWx1ZXNcclxuXHRwdWJsaWMgb3JnID0ge1xyXG5cdFx0eFNjYWxlOiBudWxsLFxyXG5cdFx0eERvbWFpbjogbnVsbFxyXG5cdH07XHJcblxyXG5cdC8vIGZvcm1hdHRlciBmdW5jdGlvblxyXG5cdHB1YmxpYyBjb2xvcjtcclxuXHRwdWJsaWMgcGF0dGVybnM7XHJcblx0cHVibGljIGxldmVsQ29sb3I7XHJcblx0cHVibGljIHBvaW50O1xyXG5cdHB1YmxpYyBicnVzaDtcclxuXHJcblx0Ly8gZm9ybWF0IGZ1bmN0aW9uXHJcblx0cHVibGljIGZvcm1hdCA9IHtcclxuXHRcdGV4dHJhTGluZUNsYXNzZXM6IG51bGwsXHJcblx0XHR4QXhpc1RpY2s6IG51bGwsXHJcblx0XHRkYXRhVGltZTogbnVsbCwgLy8gZGF0YVRpbWVGb3JtYXRcclxuXHRcdGRlZmF1bHRBeGlzVGltZTogbnVsbCwgLy8gZGVmYXVsdEF4aXNUaW1lRm9ybWF0XHJcblx0XHRheGlzVGltZTogbnVsbCAvLyBheGlzVGltZUZvcm1hdFxyXG5cdH07XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmFwaSA9IGFwaTsgLy8gQ2hhcnQgaW5zdGFuY2VcclxuXHRcdCQkLmNvbmZpZyA9IG5ldyBPcHRpb25zKCk7XHJcblx0XHQkJC5jYWNoZSA9IG5ldyBDYWNoZSgpO1xyXG5cclxuXHRcdGNvbnN0IHN0b3JlID0gbmV3IFN0b3JlKCk7XHJcblxyXG5cdFx0JCQuJGVsID0gc3RvcmUuZ2V0U3RvcmUoXCJlbGVtZW50XCIpO1xyXG5cdFx0JCQuc3RhdGUgPSBzdG9yZS5nZXRTdG9yZShcInN0YXRlXCIpO1xyXG5cdH1cclxuXHJcblx0YmVmb3JlSW5pdCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRiZWZvcmVJbml0XCIpO1xyXG5cclxuXHRcdC8vIGNhbiBkbyBzb21ldGhpbmdcclxuXHRcdGNhbGxGbigkJC5jb25maWcub25iZWZvcmVpbml0LCAkJC5hcGkpO1xyXG5cdH1cclxuXHJcblx0YWZ0ZXJJbml0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGFmdGVySW5pdFwiKTtcclxuXHJcblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLm9uYWZ0ZXJpbml0LCAkJC5hcGkpO1xyXG5cdH1cclxuXHJcblx0aW5pdCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0c3RhdGUuaGFzQXhpcyA9ICEkJC5oYXNBcmNUeXBlKCk7XHJcblx0XHRzdGF0ZS5oYXNSYWRhciA9ICFzdGF0ZS5oYXNBeGlzICYmICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcclxuXHJcblx0XHQkJC5pbml0UGFyYW1zKCk7XHJcblxyXG5cdFx0Y29uc3QgYmluZHRvID0ge1xyXG5cdFx0XHRlbGVtZW50OiBjb25maWcuYmluZHRvLFxyXG5cdFx0XHRjbGFzc25hbWU6IFwiYmJcIlxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoY29uZmlnLmJpbmR0bykpIHtcclxuXHRcdFx0YmluZHRvLmVsZW1lbnQgPSBjb25maWcuYmluZHRvLmVsZW1lbnQgfHwgXCIjY2hhcnRcIjtcclxuXHRcdFx0YmluZHRvLmNsYXNzbmFtZSA9IGNvbmZpZy5iaW5kdG8uY2xhc3NuYW1lIHx8IGJpbmR0by5jbGFzc25hbWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VsZWN0IGJpbmQgZWxlbWVudFxyXG5cdFx0JGVsLmNoYXJ0ID0gaXNGdW5jdGlvbihiaW5kdG8uZWxlbWVudC5ub2RlKSA/XHJcblx0XHRcdGNvbmZpZy5iaW5kdG8uZWxlbWVudCA6IGQzU2VsZWN0KGJpbmR0by5lbGVtZW50IHx8IFtdKTtcclxuXHJcblx0XHRpZiAoJGVsLmNoYXJ0LmVtcHR5KCkpIHtcclxuXHRcdFx0JGVsLmNoYXJ0ID0gZDNTZWxlY3QoZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JGVsLmNoYXJ0Lmh0bWwoXCJcIikuY2xhc3NlZChiaW5kdG8uY2xhc3NuYW1lLCB0cnVlKTtcclxuXHJcblx0XHQkJC5pbml0VG9SZW5kZXIoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIHJlbmRlcmluZyBwcm9jZXNzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBmb3JjZWQgRm9yY2UgdG8gcmVuZGVyIHByb2Nlc3NcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUb1JlbmRlcihmb3JjZWQ/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7Y2hhcnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNIaWRkZW4gPSAoKSA9PiBjaGFydC5zdHlsZShcImRpc3BsYXlcIikgPT09IFwibm9uZVwiIHx8IGNoYXJ0LnN0eWxlKFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIjtcclxuXHJcblx0XHRjb25zdCBpc0xhenkgPSBjb25maWcucmVuZGVyLmxhenkgfHwgaXNIaWRkZW4oKTtcclxuXHRcdGNvbnN0IE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcclxuXHJcblx0XHRpZiAoaXNMYXp5ICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgY29uZmlnLnJlbmRlci5vYnNlcnZlICE9PSBmYWxzZSAmJiAhZm9yY2VkKSB7XHJcblx0XHRcdG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbiwgb2JzZXJ2ZXIpID0+IHtcclxuXHRcdFx0XHRpZiAoIWlzSGlkZGVuKCkpIHtcclxuXHRcdFx0XHRcdG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuXHRcdFx0XHRcdCFzdGF0ZS5yZW5kZXJlZCAmJiAkJC5pbml0VG9SZW5kZXIodHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KS5vYnNlcnZlKGNoYXJ0Lm5vZGUoKSwge1xyXG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHRydWUsXHJcblx0XHRcdFx0YXR0cmlidXRlRmlsdGVyOiBbXCJjbGFzc1wiLCBcInN0eWxlXCJdXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNMYXp5IHx8IGZvcmNlZCkge1xyXG5cdFx0XHRjb25zdCBjb252ZXJ0ZWREYXRhID0gJCQuY29udmVydERhdGEoY29uZmlnLCAkJC5pbml0V2l0aERhdGEpO1xyXG5cclxuXHRcdFx0Y29udmVydGVkRGF0YSAmJiAkJC5pbml0V2l0aERhdGEoY29udmVydGVkRGF0YSk7XHJcblx0XHRcdCQkLmFmdGVySW5pdCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aW5pdFBhcmFtcygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIGZvcm1hdCwgc3RhdGV9ID0gPGFueT4gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdC8vIGRhdGV0aW1lIHRvIGJlIHVzZWQgZm9yIHVuaXF1ZW5lc3NcclxuXHRcdHN0YXRlLmRhdGV0aW1lSWQgPSBgYmItJHsrbmV3IERhdGUoKX1gO1xyXG5cclxuXHRcdCQkLmNvbG9yID0gJCQuZ2VuZXJhdGVDb2xvcigpO1xyXG5cdFx0JCQubGV2ZWxDb2xvciA9ICQkLmdlbmVyYXRlTGV2ZWxDb2xvcigpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNQb2ludFR5cGUoKSkge1xyXG5cdFx0XHQkJC5wb2ludCA9ICQkLmdlbmVyYXRlUG9pbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhdGUuaGFzQXhpcykge1xyXG5cdFx0XHQkJC5pbml0Q2xpcCgpO1xyXG5cclxuXHRcdFx0Zm9ybWF0LmV4dHJhTGluZUNsYXNzZXMgPSAkJC5nZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCk7XHJcblx0XHRcdGZvcm1hdC5kYXRhVGltZSA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkM1RpbWVQYXJzZSA6IGQzVXRjUGFyc2U7XHJcblx0XHRcdGZvcm1hdC5heGlzVGltZSA9IGNvbmZpZy5heGlzX3hfbG9jYWx0aW1lID8gZDNUaW1lRm9ybWF0IDogZDNVdGNGb3JtYXQ7XHJcblxyXG5cdFx0XHRjb25zdCBpc0RyYWdab29tID0gJCQuY29uZmlnLnpvb21fZW5hYmxlZCAmJiAkJC5jb25maWcuem9vbV9lbmFibGVkLnR5cGUgPT09IFwiZHJhZ1wiO1xyXG5cclxuXHRcdFx0Zm9ybWF0LmRlZmF1bHRBeGlzVGltZSA9IGQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHt4LCB6b29tfSA9ICQkLnNjYWxlO1xyXG5cdFx0XHRcdGNvbnN0IGlzWm9vbWVkID0gaXNEcmFnWm9vbSA/IHpvb20gOlxyXG5cdFx0XHRcdFx0em9vbSAmJiB4Lm9yZ0RvbWFpbigpLnRvU3RyaW5nKCkgIT09IHpvb20uZG9tYWluKCkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc3BlY2lmaWVyOiBzdHJpbmcgPSAoZC5nZXRNaWxsaXNlY29uZHMoKSAmJiBcIi4lTFwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0U2Vjb25kcygpICYmIFwiLjolU1wiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0TWludXRlcygpICYmIFwiJUk6JU1cIikgfHxcclxuXHRcdFx0XHRcdChkLmdldEhvdXJzKCkgJiYgXCIlSSAlcFwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0RGF0ZSgpICE9PSAxICYmIFwiJWIgJWRcIikgfHxcclxuXHRcdFx0XHRcdChpc1pvb21lZCAmJiBkLmdldERhdGUoKSA9PT0gMSAmJiBcIiViXFwnJXlcIikgfHxcclxuXHRcdFx0XHRcdChkLmdldE1vbnRoKCkgJiYgXCIlLW0vJS1kXCIpIHx8IFwiJVlcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZvcm1hdC5heGlzVGltZShzcGVjaWZpZXIpKGQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmlzTGVnZW5kUmlnaHQgPSBjb25maWcubGVnZW5kX3Bvc2l0aW9uID09PSBcInJpZ2h0XCI7XHJcblx0XHRzdGF0ZS5pc0xlZ2VuZEluc2V0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJpbnNldFwiO1xyXG5cclxuXHRcdHN0YXRlLmlzTGVnZW5kVG9wID0gY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwidG9wLWxlZnRcIiB8fFxyXG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtcmlnaHRcIjtcclxuXHJcblx0XHRzdGF0ZS5pc0xlZ2VuZExlZnQgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcImJvdHRvbS1sZWZ0XCI7XHJcblxyXG5cdFx0c3RhdGUucm90YXRlZFBhZGRpbmdSaWdodCA9IGlzUm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeF9zaG93ID8gMCA6IDMwO1xyXG5cclxuXHRcdHN0YXRlLmlucHV0VHlwZSA9IGNvbnZlcnRJbnB1dFR5cGUoXHJcblx0XHRcdGNvbmZpZy5pbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2UsXHJcblx0XHRcdGNvbmZpZy5pbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2hcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRpbml0V2l0aERhdGEoZGF0YSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIHN0YXRlLCAkZWwsIG9yZ30gPSAkJDtcclxuXHRcdGNvbnN0IHtoYXNBeGlzfSA9IHN0YXRlO1xyXG5cclxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXHJcblx0XHQvLyAkJC5oYXNBcmNUeXBlKCkgJiYgW1wieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGlkID0+IChjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID0gZmFsc2UpKTtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQkJC5heGlzID0gbmV3IEF4aXMoJCQpO1xyXG5cdFx0XHRjb25maWcuem9vbV9lbmFibGVkICYmICQkLmluaXRab29tKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5pdCBkYXRhIGFzIHRhcmdldHNcclxuXHRcdCQkLmRhdGEueHMgPSB7fTtcclxuXHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpO1xyXG5cclxuXHRcdGlmIChjb25maWcuZGF0YV9maWx0ZXIpIHtcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcihjb25maWcuZGF0YV9maWx0ZXIuYmluZCgkJC5hcGkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgdGFyZ2V0cyB0byBoaWRlIGlmIG5lZWRlZFxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2hpZGUpIHtcclxuXHRcdFx0JCQuYWRkSGlkZGVuVGFyZ2V0SWRzKFxyXG5cdFx0XHRcdGNvbmZpZy5kYXRhX2hpZGUgPT09IHRydWUgP1xyXG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5kYXRhX2hpZGVcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHRcdGlmIChjb25maWcubGVnZW5kX2hpZGUpIHtcclxuXHRcdFx0JCQuYWRkSGlkZGVuTGVnZW5kSWRzKFxyXG5cdFx0XHRcdGNvbmZpZy5sZWdlbmRfaGlkZSA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmxlZ2VuZF9oaWRlXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5pdCBzaXplcyBhbmQgc2NhbGVzXHJcblx0XHQkJC51cGRhdGVTaXplcygpO1xyXG5cdFx0JCQudXBkYXRlU2NhbGVzKHRydWUpO1xyXG5cclxuXHRcdC8vIHJldHJpZXZlIHNjYWxlIGFmdGVyIHRoZSAndXBkYXRlU2NhbGVzKCknIGlzIGNhbGxlZFxyXG5cdFx0Y29uc3Qge3gsIHksIHkyLCBzdWJYLCBzdWJZLCBzdWJZMn0gPSBzY2FsZTtcclxuXHJcblx0XHQvLyBTZXQgZG9tYWlucyBmb3IgZWFjaCBzY2FsZVxyXG5cdFx0aWYgKHgpIHtcclxuXHRcdFx0eC5kb21haW4oc29ydFZhbHVlKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSkpO1xyXG5cdFx0XHRzdWJYLmRvbWFpbih4LmRvbWFpbigpKTtcclxuXHJcblx0XHRcdC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXHJcblx0XHRcdG9yZy54RG9tYWluID0geC5kb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoeSkge1xyXG5cdFx0XHR5LmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5XCIpKTtcclxuXHRcdFx0c3ViWS5kb21haW4oeS5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHkyKSB7XHJcblx0XHRcdHkyLmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5MlwiKSk7XHJcblx0XHRcdHN1YlkyICYmIHN1YlkyLmRvbWFpbih5Mi5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gLS0gQmFzaWMgRWxlbWVudHMgLS1cclxuXHRcdCRlbC5zdmcgPSAkZWwuY2hhcnQuYXBwZW5kKFwic3ZnXCIpXHJcblx0XHRcdC5zdHlsZShcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgc3RhdGUuaW5wdXRUeXBlKSB7XHJcblx0XHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHJcblx0XHRcdCRlbC5zdmcub24oaXNUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWVudGVyXCIsICgpID0+IGNhbGxGbihjb25maWcub25vdmVyLCAkJC5hcGkpKVxyXG5cdFx0XHRcdC5vbihpc1RvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZWxlYXZlXCIsICgpID0+IGNhbGxGbihjb25maWcub25vdXQsICQkLmFwaSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5zdmdfY2xhc3NuYW1lICYmICRlbC5zdmcuYXR0cihcImNsYXNzXCIsIGNvbmZpZy5zdmdfY2xhc3NuYW1lKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZGVmc1xyXG5cdFx0Y29uc3QgaGFzQ29sb3JQYXR0ZXJucyA9IChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykgJiYgJCQucGF0dGVybnMpO1xyXG5cclxuXHRcdGlmIChoYXNBeGlzIHx8IGhhc0NvbG9yUGF0dGVybnMpIHtcclxuXHRcdFx0JGVsLmRlZnMgPSAkZWwuc3ZnLmFwcGVuZChcImRlZnNcIik7XHJcblxyXG5cdFx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHRcdFtcImlkXCIsIFwiaWRYQXhpc1wiLCBcImlkWUF4aXNcIiwgXCJpZFhBeGlzVGlja1RleHRzXCIsIFwiaWRHcmlkXCJdLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHQkJC5hcHBlbmRDbGlwKCRlbC5kZWZzLCBzdGF0ZS5jbGlwW3ZdKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2V0IGNvbG9yIHBhdHRlcm5zXHJcblx0XHRcdGlmIChoYXNDb2xvclBhdHRlcm5zKSB7XHJcblx0XHRcdFx0JCQucGF0dGVybnMuZm9yRWFjaChwID0+ICRlbC5kZWZzLmFwcGVuZCgoKSA9PiBwLm5vZGUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcclxuXHJcblx0XHQvLyBCaW5kIHJlc2l6ZSBldmVudFxyXG5cdFx0JCQuYmluZFJlc2l6ZSgpO1xyXG5cclxuXHRcdC8vIERlZmluZSByZWdpb25zXHJcblx0XHRjb25zdCBtYWluID0gJGVsLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibWFpblwiKSk7XHJcblxyXG5cdFx0JGVsLm1haW4gPSBtYWluO1xyXG5cclxuXHRcdC8vIGluaXRpYWxpemUgc3ViY2hhcnQgd2hlbiBzdWJjaGFydCBzaG93IG9wdGlvbiBpcyBzZXRcclxuXHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICQkLmluaXRTdWJjaGFydCgpO1xyXG5cclxuXHRcdGNvbmZpZy50b29sdGlwX3Nob3cgJiYgJCQuaW5pdFRvb2x0aXAoKTtcclxuXHRcdGNvbmZpZy50aXRsZV90ZXh0ICYmICQkLmluaXRUaXRsZSgpO1xyXG5cdFx0Y29uZmlnLmxlZ2VuZF9zaG93ICYmICQkLmluaXRMZWdlbmQoKTtcclxuXHJcblx0XHQvLyAtLSBNYWluIFJlZ2lvbiAtLVxyXG5cclxuXHRcdC8vIHRleHQgd2hlbiBlbXB0eVxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2VtcHR5X2xhYmVsX3RleHQpIHtcclxuXHRcdFx0bWFpbi5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy50ZXh0fSAke0NMQVNTLmVtcHR5fWApXHJcblx0XHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAvLyBob3Jpem9udGFsIGNlbnRlcmluZyBvZiB0ZXh0IGF0IHggcG9zaXRpb24gaW4gYWxsIGJyb3dzZXJzLlxyXG5cdFx0XHRcdC5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIik7IC8vIHZlcnRpY2FsIGNlbnRlcmluZyBvZiB0ZXh0IGF0IHkgcG9zaXRpb24gaW4gYWxsIGJyb3dzZXJzLCBleGNlcHQgSUUuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0Ly8gUmVnaW9uc1xyXG5cdFx0XHRjb25maWcucmVnaW9ucy5sZW5ndGggJiYgJCQuaW5pdFJlZ2lvbigpO1xyXG5cclxuXHRcdFx0Ly8gQWRkIEF4aXMgaGVyZSwgd2hlbiBjbGlwUGF0aCBpcyAnZmFsc2UnXHJcblx0XHRcdCFjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcy5pbml0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcclxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnQpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIHN0YXRlLmNsaXAucGF0aCk7XHJcblxyXG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkaW5pdFwiKTtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQvLyBDb3ZlciB3aG9sZSB3aXRoIHJlY3RzIGZvciBldmVudHNcclxuXHRcdFx0JCQuaW5pdEV2ZW50UmVjdCAmJiAkJC5pbml0RXZlbnRSZWN0KCk7XHJcblxyXG5cdFx0XHQvLyBHcmlkc1xyXG5cdFx0XHQkJC5pbml0R3JpZCgpO1xyXG5cclxuXHRcdFx0Ly8gQWRkIEF4aXMgaGVyZSwgd2hlbiBjbGlwUGF0aCBpcyAndHJ1ZSdcclxuXHRcdFx0Y29uZmlnLmNsaXBQYXRoICYmICQkLmF4aXMgJiYgJCQuYXhpcy5pbml0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuaW5pdENoYXJ0RWxlbWVudHMoKTtcclxuXHJcblx0XHQvLyBTZXQgdGFyZ2V0c1xyXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdC8vIERyYXcgd2l0aCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVEaW1lbnNpb24oKTtcclxuXHJcblx0XHQvLyBvbmluaXQgY2FsbGJhY2tcclxuXHRcdGNhbGxGbihjb25maWcub25pbml0LCAkJC5hcGkpO1xyXG5cclxuXHRcdC8vIFNldCBiYWNrZ3JvdW5kXHJcblx0XHQkJC5zZXRCYWNrZ3JvdW5kKCk7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yQXhpczogZmFsc2UsXHJcblx0XHRcdGluaXRpYWxpemluZzogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gZGF0YS5vbm1pbi9tYXggY2FsbGJhY2tcclxuXHRcdGlmIChjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xyXG5cdFx0XHRjb25zdCBtaW5NYXggPSAkJC5nZXRNaW5NYXhEYXRhKCk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLmFwaSwgbWluTWF4Lm1pbik7XHJcblx0XHRcdGNhbGxGbihjb25maWcuZGF0YV9vbm1heCwgJCQuYXBpLCBtaW5NYXgubWF4KTtcclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5yZW5kZXJlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRpbml0Q2hhcnRFbGVtZW50cygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtoYXNBeGlzLCBoYXNSYWRhcn0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IHR5cGVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgdHlwZXMucHVzaChcIkJhclwiKTtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJ1YmJsZVwiKSAmJiB0eXBlcy5wdXNoKFwiQnViYmxlXCIpO1xyXG5cdFx0XHQkJC5oYXNUeXBlT2YoXCJMaW5lXCIpICYmIHR5cGVzLnB1c2goXCJMaW5lXCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCFoYXNSYWRhcikge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goXCJBcmNcIiwgXCJQaWVcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFwiR2F1Z2VcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoaGFzUmFkYXIpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFwiUmFkYXJcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0eXBlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHQkJFtgaW5pdCR7dn1gXSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bm90RW1wdHkoJCQuY29uZmlnLmRhdGFfbGFiZWxzKSAmJiAkJC5pbml0VGV4dCgpO1xyXG5cdH1cclxuXHJcblx0c2V0Q2hhcnRFbGVtZW50cygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtcclxuXHRcdFx0Y2hhcnQsIHN2ZywgZGVmcywgbWFpbiwgdG9vbHRpcCwgbGVnZW5kLCB0aXRsZSwgZ3JpZCxcclxuXHRcdFx0YXJjczogYXJjLFxyXG5cdFx0XHRjaXJjbGU6IGNpcmNsZXMsXHJcblx0XHRcdGJhcjogYmFycyxcclxuXHRcdFx0bGluZTogbGluZXMsXHJcblx0XHRcdGFyZWE6IGFyZWFzLFxyXG5cdFx0XHR0ZXh0OiB0ZXh0c1xyXG5cdFx0fX0gPSAkJDtcclxuXHJcblx0XHQkJC5hcGkuJCA9IHtcclxuXHRcdFx0Y2hhcnQsXHJcblx0XHRcdHN2ZyxcclxuXHRcdFx0ZGVmcyxcclxuXHRcdFx0bWFpbixcclxuXHRcdFx0dG9vbHRpcCxcclxuXHRcdFx0bGVnZW5kLFxyXG5cdFx0XHR0aXRsZSxcclxuXHRcdFx0Z3JpZCxcclxuXHRcdFx0YXJjLFxyXG5cdFx0XHRjaXJjbGVzLFxyXG5cdFx0XHRiYXI6IHtiYXJzfSxcclxuXHRcdFx0bGluZToge2xpbmVzLCBhcmVhc30sXHJcblx0XHRcdHRleHQ6IHt0ZXh0c31cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYmFja2dyb3VuZCBlbGVtZW50L2ltYWdlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRCYWNrZ3JvdW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZzoge2JhY2tncm91bmQ6IGJnfSwgc3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG5vdEVtcHR5KGJnKSkge1xyXG5cdFx0XHRjb25zdCBlbGVtZW50ID0gc3ZnLnNlbGVjdChcImdcIilcclxuXHRcdFx0XHQuaW5zZXJ0KGJnLmltZ1VybCA/IFwiaW1hZ2VcIiA6IFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcclxuXHJcblx0XHRcdGlmIChiZy5pbWdVcmwpIHtcclxuXHRcdFx0XHRlbGVtZW50LmF0dHIoXCJocmVmXCIsIGJnLmltZ1VybCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoYmcuY29sb3IpIHtcclxuXHRcdFx0XHRlbGVtZW50XHJcblx0XHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGJnLmNvbG9yKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgc3RhdGUuY2xpcC5wYXRoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxlbWVudFxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYmcuY2xhc3MgfHwgbnVsbClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0YXJnZXRlZCBlbGVtZW50IHdpdGggZ2l2ZW4gZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRzIERhdGEgb2JqZWN0IGZvcm1hdHRlZCBhcyAndGFyZ2V0J1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0cyh0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7aGFzQXhpcywgaGFzUmFkYXJ9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0Ly8gVGV4dFxyXG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gY2lyY2xlXHJcblx0XHRpZiAoJCQuaGFzUG9pbnRUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0Rm9yQ2lyY2xlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpOyAvLyBCYXJcclxuXHRcdFx0JCQuaGFzVHlwZU9mKFwiTGluZVwiKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yTGluZSh0YXJnZXRzKTsgLy8gTGluZVxyXG5cclxuXHRcdFx0Ly8gU3ViIENoYXJ0XHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCAmJlxyXG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEFyYyAmIFJhZGFyXHJcblx0XHRcdCQkLmhhc0FyY1R5cGUodGFyZ2V0cykgJiYgKFxyXG5cdFx0XHRcdGhhc1JhZGFyID9cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6XHJcblx0XHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFkZS1pbiBlYWNoIGNoYXJ0XHJcblx0XHQkJC5zaG93VGFyZ2V0cygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGxheSB0YXJnZXRlZCBlbGVtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd1RhcmdldHMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnRhcmdldH1gKVxyXG5cdFx0XHQuZmlsdGVyKGQgPT4gJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9XHJcblxyXG5cdGdldFdpdGhPcHRpb24ob3B0aW9ucykge1xyXG5cdFx0Y29uc3Qgd2l0aE9wdGlvbnMgPSB7XHJcblx0XHRcdFk6IHRydWUsXHJcblx0XHRcdFN1YmNoYXJ0OiB0cnVlLFxyXG5cdFx0XHRUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRFdmVudFJlY3Q6IHRydWUsXHJcblx0XHRcdERpbWVuc2lvbjogdHJ1ZSxcclxuXHRcdFx0VHJpbVhEb21haW46IHRydWUsXHJcblx0XHRcdFRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdFVwZGF0ZVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHRVcGRhdGVPcmdYRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0TGVnZW5kOiBmYWxzZSxcclxuXHRcdFx0VXBkYXRlWEF4aXM6IFwiVXBkYXRlWERvbWFpblwiLFxyXG5cdFx0XHRUcmFuc2l0aW9uRm9yRXhpdDogXCJUcmFuc2l0aW9uXCIsXHJcblx0XHRcdFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRsZXQgZGVmVmFsID0gd2l0aE9wdGlvbnNba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc1N0cmluZyhkZWZWYWwpKSB7XHJcblx0XHRcdFx0ZGVmVmFsID0gd2l0aE9wdGlvbnNbZGVmVmFsXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2l0aE9wdGlvbnNba2V5XSA9IGdldE9wdGlvbihvcHRpb25zLCBgd2l0aCR7a2V5fWAsIGRlZlZhbCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gd2l0aE9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRpbml0aWFsT3BhY2l0eShkKTogXCIxXCIgfCBcIjBcIiB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7d2l0aG91dEZhZGVJbn0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyBcIjFcIiA6IFwiMFwiO1xyXG5cdH1cclxuXHJcblx0YmluZFJlc2l6ZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcclxuXHRcdGNvbnN0IHJlc2l6ZUZ1bmN0aW9uID0gZ2VuZXJhdGVSZXNpemUoKTtcclxuXHRcdGNvbnN0IGxpc3Q6IEZ1bmN0aW9uW10gPSBbXTtcclxuXHJcblx0XHRsaXN0LnB1c2goKCkgPT4gY2FsbEZuKGNvbmZpZy5vbnJlc2l6ZSwgJCQsICQkLmFwaSkpO1xyXG5cclxuXHRcdGlmIChjb25maWcucmVzaXplX2F1dG8pIHtcclxuXHRcdFx0bGlzdC5wdXNoKCgpID0+ICQkLmFwaS5mbHVzaChmYWxzZSwgdHJ1ZSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3QucHVzaCgoKSA9PiBjYWxsRm4oY29uZmlnLm9ucmVzaXplZCwgJCQsICQkLmFwaSkpO1xyXG5cclxuXHRcdC8vIGFkZCByZXNpemUgZnVuY3Rpb25zXHJcblx0XHRsaXN0LmZvckVhY2godiA9PiByZXNpemVGdW5jdGlvbi5hZGQodikpO1xyXG5cclxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uID0gcmVzaXplRnVuY3Rpb24pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbCBwbHVnaW4gaG9va1xyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwaGFzZSBUaGUgbGlmZWN5Y2xlIHBoYXNlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNhbGxQbHVnaW5Ib29rKHBoYXNlLCAuLi5hcmdzKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbmZpZy5wbHVnaW5zLmZvckVhY2godiA9PiB7XHJcblx0XHRcdGlmIChwaGFzZSA9PT0gXCIkYmVmb3JlSW5pdFwiKSB7XHJcblx0XHRcdFx0di4kJCA9IHRoaXM7XHJcblx0XHRcdFx0dGhpcy5hcGkucGx1Z2lucy5wdXNoKHYpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2W3BoYXNlXSguLi5hcmdzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCBbXHJcblx0Ly8gY29tbW9uXHJcblx0ZGF0YUNvbnZlcnQsXHJcblx0ZGF0YSxcclxuXHRkYXRhTG9hZCxcclxuXHRjYXRlZ29yeSxcclxuXHRjbGFzc01vZHVsZSxcclxuXHRjb2xvcixcclxuXHRkb21haW4sXHJcblx0aW50ZXJhY3Rpb24sXHJcblx0Zm9ybWF0LFxyXG5cdGxlZ2VuZCxcclxuXHRyZWRyYXcsXHJcblx0c2NhbGUsXHJcblx0c2l6ZSxcclxuXHR0ZXh0LFxyXG5cdHRpdGxlLFxyXG5cdHRvb2x0aXAsXHJcblx0dHJhbnNmb3JtLFxyXG5cdHR5cGUsXHJcblx0Li4uYXJjSW50ZXJuYWwsXHJcblx0Li4uYXhpc0ludGVybmFsXHJcbl0pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgT3B0aW9ucyBmcm9tIFwiLi9PcHRpb25zL09wdGlvbnNcIjtcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGNvbmZpZ3VyYXRpb24gb3B0aW9uXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVXNlcidzIGdlbmVyYXRpb24gY29uZmlnIHZhbHVlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbG9hZENvbmZpZyhjb25maWc6IE9wdGlvbnMpOiB2b2lkIHtcclxuXHRjb25zdCB0aGlzQ29uZmlnOiBPcHRpb25zID0gdGhpcy5jb25maWc7XHJcblx0bGV0IHRhcmdldDtcclxuXHRsZXQga2V5cztcclxuXHRsZXQgcmVhZDtcclxuXHJcblx0Y29uc3QgZmluZCA9ICgpID0+IHtcclxuXHRcdGNvbnN0IGtleSA9IGtleXMuc2hpZnQoKTtcclxuXHJcblx0XHRpZiAoa2V5ICYmIHRhcmdldCAmJiBpc09iamVjdFR5cGUodGFyZ2V0KSAmJiBrZXkgaW4gdGFyZ2V0KSB7XHJcblx0XHRcdHRhcmdldCA9IHRhcmdldFtrZXldO1xyXG5cdFx0XHRyZXR1cm4gZmluZCgpO1xyXG5cdFx0fSBlbHNlIGlmICgha2V5KSB7XHJcblx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9O1xyXG5cclxuXHRPYmplY3Qua2V5cyh0aGlzQ29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHR0YXJnZXQgPSBjb25maWc7XHJcblx0XHRrZXlzID0ga2V5LnNwbGl0KFwiX1wiKTtcclxuXHRcdHJlYWQgPSBmaW5kKCk7XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChyZWFkKSkge1xyXG5cdFx0XHR0aGlzQ29uZmlnW2tleV0gPSByZWFkO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQge25vdEVtcHR5LCBpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIHJlc2l6ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzaXplIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHMuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBSZXNpemUgdG8gNjQweDQ4MFxyXG5cdCAqIGNoYXJ0LnJlc2l6ZSh7XHJcblx0ICogICAgd2lkdGg6IDY0MCxcclxuXHQgKiAgICBoZWlnaHQ6IDQ4MFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdHJlc2l6ZShzaXplPzoge3dpZHRoPzogbnVtYmVyLCBoZWlnaHQ/OiBudW1iZXJ9KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRpZiAoc3RhdGUucmVuZGVyZWQpIHtcclxuXHRcdFx0Y29uZmlnLnNpemVfd2lkdGggPSBzaXplID8gc2l6ZS53aWR0aCA6IG51bGw7XHJcblx0XHRcdGNvbmZpZy5zaXplX2hlaWdodCA9IHNpemUgPyBzaXplLmhlaWdodCA6IG51bGw7XHJcblxyXG5cdFx0XHR0aGlzLmZsdXNoKGZhbHNlLCB0cnVlKTtcclxuXHRcdFx0JCQucmVzaXplRnVuY3Rpb24oKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBGb3JjZSB0byByZWRyYXcuXHJcblx0ICogQGZ1bmN0aW9uIGZsdXNoXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbc29mdF0gRm9yIHNvZnQgcmVkcmF3LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZmx1c2goKTtcclxuXHQgKlxyXG5cdCAqIC8vIGZvciBzb2Z0IHJlZHJhd1xyXG5cdCAqIGNoYXJ0LmZsdXNoKHRydWUpO1xyXG5cdCAqL1xyXG5cdGZsdXNoKHNvZnQ/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0aWYgKCQkLnN0YXRlLnJlbmRlcmVkKSB7XHJcblx0XHRcdC8vIHJlc2V0IHBvc3NpYmxlIHpvb20gc2NhbGUgd2hlbiBpcyBjYWxsZWQgZnJvbSByZXNpemUgZXZlbnRcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xyXG5cdFx0XHRpZiAoYXJndW1lbnRzWzFdKSB7IC8vIGFyZ3VtZW50c1sxXSBpcyBnaXZlbiB3aGVuIGlzIGNhbGxlZCBmcm9tIHJlc2l6ZVxyXG5cdFx0XHRcdCQkLmJydXNoICYmICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHJlLXVwZGF0ZSBjb25maWcgaW5mb1xyXG5cdFx0XHRcdCQkLmF4aXMgJiYgJCQuYXhpcy5zZXRPcmllbnQoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JCQuc2NhbGUuem9vbSA9IG51bGw7XHJcblxyXG5cdFx0XHRzb2Z0ID8gJCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHRcdFx0fSkgOiAkJC51cGRhdGVBbmRSZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWUsXHJcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5pbml0VG9SZW5kZXIodHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgdGhlIGNoYXJ0IG9iamVjdCBhbmQgcmVtb3ZlIGVsZW1lbnQgYW5kIGV2ZW50cyBjb21wbGV0ZWx5LlxyXG5cdCAqIEBmdW5jdGlvbiBkZXN0cm95XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHJldHVybnMge251bGx9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5kZXN0cm95KCk7XHJcblx0ICovXHJcblx0ZGVzdHJveSgpOiBudWxsIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHskZWw6IHtjaGFydCwgc3ZnfX0gPSAkJDtcclxuXHJcblx0XHRpZiAobm90RW1wdHkoJCQpKSB7XHJcblx0XHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJHdpbGxEZXN0cm95XCIpO1xyXG5cdFx0XHQkJC5jaGFydHMuc3BsaWNlKCQkLmNoYXJ0cy5pbmRleE9mKHRoaXMpLCAxKTtcclxuXHJcblx0XHRcdC8vIGNsZWFyIHRpbWVycyAmJiBwZW5kaW5nIHRyYW5zaXRpb25cclxuXHRcdFx0c3ZnLnNlbGVjdChcIipcIikuaW50ZXJydXB0KCk7XHJcblx0XHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmNsZWFyKCk7XHJcblxyXG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAkJC5yZXNpemVGdW5jdGlvbik7XHJcblx0XHRcdGNoYXJ0LmNsYXNzZWQoXCJiYlwiLCBmYWxzZSkuaHRtbChcIlwiKTtcclxuXHJcblx0XHRcdC8vIHJlbGVhc2luZyByZWZlcmVuY2VzXHJcblx0XHRcdE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRrZXkgPT09IFwiaW50ZXJuYWxcIiAmJiBPYmplY3Qua2V5cygkJCkuZm9yRWFjaChrID0+IHtcclxuXHRcdFx0XHRcdCQkW2tdID0gbnVsbDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dGhpc1trZXldID0gbnVsbDtcclxuXHRcdFx0XHRkZWxldGUgdGhpc1trZXldO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgb3Igc2V0IHNpbmdsZSBjb25maWcgb3B0aW9uIHZhbHVlLlxyXG5cdCAqIEBmdW5jdGlvbiBjb25maWdcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgb3B0aW9uIGtleSBuYW1lLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgYWNjZXB0ZWQgZm9yIGluZGljYXRlZCBvcHRpb24uXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVkcmF3XSBTZXQgdG8gcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb24gY2hhbmdlcy5cclxuXHQgKiAtICoqTk9URToqKiBEb2Vzbid0IGd1YXJhbnRlZSB3b3JrIGluIGFsbCBjaXJjdW1zdGFuY2VzLiBJdCBjYW4gYmUgYXBwbGllZCBmb3IgbGltaXRlZCBvcHRpb25zIG9ubHkuXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXR0ZXJcclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIik7XHJcblx0ICpcclxuXHQgKiAvLyBTZXR0ZXJcclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIiwgMTAwKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNldHRlciAmIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCwgdHJ1ZSk7XHJcblx0ICovXHJcblx0Y29uZmlnKG5hbWU6IHN0cmluZywgdmFsdWU/OiBhbnksIHJlZHJhdz86IGJvb2xlYW4pOiBhbnkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGtleSA9IG5hbWUgJiYgbmFtZS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xyXG5cdFx0bGV0IHJlcztcclxuXHJcblx0XHRpZiAoa2V5IGluIGNvbmZpZykge1xyXG5cdFx0XHRpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG5cdFx0XHRcdGNvbmZpZ1trZXldID0gdmFsdWU7XHJcblx0XHRcdFx0cmVzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdHJlZHJhdyAmJiB0aGlzLmZsdXNoKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzID0gY29uZmlnW2tleV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBjb2xvclxyXG5cdCAqIEBmdW5jdGlvbiBjb2xvclxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCB0byBnZXQgdGhlIGNvbG9yXHJcblx0ICogQHJldHVybnMge3N0cmluZ31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmNvbG9yKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0Y29sb3IoaWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5jb2xvcihpZCk7IC8vIG1vcmUgcGF0dGVybnNcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtEYXRhSXRlbX0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcbmltcG9ydCB7S0VZfSBmcm9tIFwiLi4vLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCB7ZXh0ZW5kLCBpc1VuZGVmaW5lZCwgaXNBcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG50eXBlIGRhdGFQYXJhbSA9IHt4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGlkOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9W107XHJcblxyXG4vKipcclxuICogR2V0IGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuICogQGZ1bmN0aW9uIGRhdGFcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIHJldHVybnMgdGhlIHNwZWNpZmllZCB0YXJnZXQgZGF0YS4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIEdldCBvbmx5IGRhdGExIGRhdGFcclxuICogY2hhcnQuZGF0YShcImRhdGExXCIpO1xyXG4gKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cclxuICpcclxuICogLy8gR2V0IGRhdGExIGFuZCBkYXRhMiBkYXRhXHJcbiAqIGNoYXJ0LmRhdGEoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcbiAqXHJcbiAqIC8vIEdldCBhbGwgZGF0YVxyXG4gKiBjaGFydC5kYXRhKCk7XHJcbiAqL1xyXG5mdW5jdGlvbiBkYXRhKHRhcmdldElkczogc3RyaW5nfHN0cmluZ1tdKTogRGF0YUl0ZW1bXSB7XHJcblx0Y29uc3Qge3RhcmdldHN9ID0gdGhpcy5pbnRlcm5hbC5kYXRhO1xyXG5cclxuXHRpZiAoIWlzVW5kZWZpbmVkKHRhcmdldElkcykpIHtcclxuXHRcdGNvbnN0IGlkczogYW55ID0gaXNBcnJheSh0YXJnZXRJZHMpID8gdGFyZ2V0SWRzIDogW3RhcmdldElkc107XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHMuZmlsdGVyKHQgPT4gaWRzLnNvbWUodiA9PiB2ID09PSB0LmlkKSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFyZ2V0cztcclxufVxyXG5cclxuZXh0ZW5kKGRhdGEsIHtcclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YSBzaG93biBpbiB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRzaG93blxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBBUEkgZmlsdGVycyB0aGUgZGF0YSB3aXRoIHNwZWNpZmllZCB0YXJnZXQgaWRzLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgYWxsIHNob3duIGRhdGEgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgb2JqZWN0c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IHNob3duIGRhdGEgYnkgZmlsdGVyaW5nIHRvIGluY2x1ZGUgb25seSBkYXRhMSBkYXRhXHJcblx0ICogY2hhcnQuZGF0YS5zaG93bihcImRhdGExXCIpO1xyXG5cdCAqIC8vIC0tPiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IEFycmF5KDYpfSwgLi4uXVxyXG5cdCAqXHJcblx0ICogLy8gR2V0IHNob3duIGRhdGEgYnkgZmlsdGVyaW5nIHRvIGluY2x1ZGUgZGF0YTEgYW5kIGRhdGEyIGRhdGFcclxuXHQgKiBjaGFydC5kYXRhLnNob3duKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gR2V0IGFsbCBzaG93biBkYXRhXHJcblx0ICogY2hhcnQuZGF0YS5zaG93bigpO1xyXG5cdCAqL1xyXG5cdHNob3duOiBmdW5jdGlvbih0YXJnZXRJZHM6IHN0cmluZyB8IHN0cmluZ1tdKTogRGF0YUl0ZW1bXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5maWx0ZXJUYXJnZXRzVG9TaG93KHRoaXMuZGF0YSh0YXJnZXRJZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdmFsdWVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKR2YWx1ZXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIFRoaXMgQVBJIHJldHVybnMgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgbnVsbCB3aWxsIGJlIHJldHJ1bmVkXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhdD10cnVlXSBHZXQgZmxhdHRlbiB2YWx1ZXNcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgdmFsdWVzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgZGF0YTEgdmFsdWVzXHJcblx0ICogY2hhcnQuZGF0YS52YWx1ZXMoXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gWzEwLCAyMCwgMzAsIDQwXVxyXG5cdCAqL1xyXG5cdHZhbHVlczogZnVuY3Rpb24odGFyZ2V0SWRzPzogc3RyaW5nIHwgc3RyaW5nW10sIGZsYXQ6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyW118bnVtYmVyW11bXSB7XHJcblx0XHRsZXQgdmFsdWVzID0gbnVsbDtcclxuXHJcblx0XHRpZiAodGFyZ2V0SWRzKSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldHMgPSB0aGlzLmRhdGEodGFyZ2V0SWRzKTtcclxuXHJcblx0XHRcdGlmICh0YXJnZXRzICYmIGlzQXJyYXkodGFyZ2V0cykpIHtcclxuXHRcdFx0XHR2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgZGF0YVZhbHVlID0gdi52YWx1ZXMubWFwKGQgPT4gZC52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0ZmxhdCA/ICh2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGRhdGFWYWx1ZSkpIDogdmFsdWVzLnB1c2goZGF0YVZhbHVlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgbmFtZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24gZGF0YeKApG5hbWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG5hbWVzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBuYW1lcyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBuYW1lcyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXNcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBDb3JyZXNwb25kaW5nIG5hbWVzIGFjY29yZGluZyBpdHMga2V5IHZhbHVlLCBpZiBzcGVjaWZpZWQgbmFtZXMgdmFsdWVzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgbmFtZXNcclxuXHQgKiBjaGFydC5kYXRhLm5hbWVzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ0ZXN0MVwiLCBkYXRhMjogXCJ0ZXN0MlwifVxyXG5cdCAqXHJcblx0ICogLy8gVXBkYXRlIG5hbWVzXHJcblx0ICogY2hhcnQuZGF0YS5uYW1lcyh7XHJcblx0ICogIGRhdGExOiBcIk5ldyBOYW1lIDFcIixcclxuXHQgKiAgZGF0YTI6IFwiTmV3IE5hbWUgMlwiXHJcblx0ICp9KTtcclxuXHQgKi9cclxuXHRuYW1lczogZnVuY3Rpb24obmFtZXM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfT4pOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0Ly8gcmVzZXQgZXhpc3RpbmcgbGVnZW5kIGl0ZW0gZGltZW5zaW9uIGNhY2hlIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlbW92ZShLRVkubGVnZW5kSXRlbVRleHRCb3gpO1xyXG5cclxuXHRcdHJldHVybiAkJC51cGRhdGVEYXRhQXR0cmlidXRlcyhcIm5hbWVzXCIsIG5hbWVzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBjb2xvcnMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24gZGF0YeKApGNvbG9yc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjb2xvcnMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbG9ycyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBjb2xvcnMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIFtkYXRhLmNvbG9yc10oLi9PcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRjb2xvcnMpLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IENvcnJlc3BvbmRpbmcgZGF0YSBjb2xvciB2YWx1ZSBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZS5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IGNvbG9yc1xyXG5cdCAqIGNoYXJ0LmRhdGEuY29sb3JzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCIjMDBjNzNjXCIsIGRhdGEyOiBcIiNmYTcxNzFcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBjb2xvcnNcclxuXHQgKiBjaGFydC5kYXRhLmNvbG9ycyh7XHJcblx0ICogIGRhdGExOiBcIiNGRkZGRkZcIixcclxuXHQgKiAgZGF0YTI6IFwiIzAwMDAwMFwiXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0Y29sb3JzOiBmdW5jdGlvbihjb2xvcnM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfT4pOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiY29sb3JzXCIsIGNvbG9ycyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIC0gKipOT1RFOioqIElmIGFsbCBkYXRhIGlzIHJlbGF0ZWQgdG8gb25lIG9mIHRoZSBheGVzLCB0aGUgZG9tYWluIG9mIGF4aXMgd2l0aG91dCByZWxhdGVkIGRhdGEgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZG9tYWluIGZyb20gdGhlIGF4aXMgd2l0aCByZWxhdGVkIGRhdGFcclxuXHQgKiBAZnVuY3Rpb24gZGF0YeKApGF4ZXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXhlcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgYXhlcyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBheGVzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhc1xyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IENvcnJlc3BvbmRpbmcgYXhlcyB2YWx1ZSBmb3IgZGF0YSwgaWYgc3BlY2lmaWVkIGF4ZXMgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5heGVzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ5XCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcyh7XHJcblx0ICogIGRhdGExOiBcInlcIixcclxuXHQgKiAgZGF0YTI6IFwieTJcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGF4ZXM6IGZ1bmN0aW9uKGF4ZXM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Pik6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwudXBkYXRlRGF0YUF0dHJpYnV0ZXMoXCJheGVzXCIsIGF4ZXMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluaW11bSBkYXRhIHZhbHVlIGJvdW5kIHRvIHRoZSBjaGFydFxyXG5cdCAqIEBmdW5jdGlvbiBkYXRh4oCkbWluXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHJldHVybnMge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IGF4ZXNcclxuXHQgKiBjaGFydC5kYXRhLm1pbigpO1xyXG5cdCAqIC8vIC0tPiBbe3g6IDAsIHZhbHVlOiAzMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDB9LCAuLi5dXHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbigpOiBkYXRhUGFyYW0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1pbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1heGltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gZGF0YeKApG1heFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5tYXgoKTtcclxuXHQgKiAvLyAtLT4gW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLl1cclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKCk6IGRhdGFQYXJhbSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRNaW5NYXhEYXRhKCkubWF4O1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7ZGF0YX07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtuYW1lc3BhY2VzIGFzIGQzTmFtZXNwYWNlc30gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IHtpc0Z1bmN0aW9uLCB0b0FycmF5LCBnZXRDc3NSdWxlc30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRW5jb2RlIHRvIGJhc2U2NFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBiZSBlbmNvZGVkXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nXHJcbiAqL1xyXG5jb25zdCBiNjRFbmNvZGVVbmljb2RlID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IGJ0b2EoXHJcblx0ZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcclxuXHRcdC5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAobWF0Y2gsIHA6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlcihgMHgke3B9YCkpKVxyXG4pO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc3ZnIG5vZGUgdG8gZGF0YSB1cmxcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSB0YXJnZXQgbm9kZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc2l6ZSBvYmplY3QgY29udGFpbmluZyB7d2lkdGgsIGhlaWdodH1cclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG5vZGVUb1N2Z0RhdGFVcmwobm9kZSwgc2l6ZSkge1xyXG5cdGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xyXG5cdGNvbnN0IGNsb25lID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XHJcblx0Y29uc3QgY3NzVGV4dCA9IGdldENzc1J1bGVzKHRvQXJyYXkoZG9jdW1lbnQuc3R5bGVTaGVldHMpKVxyXG5cdFx0LmZpbHRlcigocjogYW55KSA9PiByLmNzc1RleHQpXHJcblx0XHQubWFwKChyOiBhbnkpID0+IHIuY3NzVGV4dCk7XHJcblxyXG5cdGNsb25lLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIGQzTmFtZXNwYWNlcy54aHRtbCk7XHJcblxyXG5cdGNvbnN0IG5vZGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKGNsb25lKTtcclxuXHJcblx0Ly8gZXNjYXBlIGNzcyBmb3IgWE1MXHJcblx0Y29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblxyXG5cdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQuam9pbihcIlxcblwiKSkpO1xyXG5cclxuXHRjb25zdCBzdHlsZVhtbCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3R5bGUpO1xyXG5cclxuXHQvLyBmb3JlaWduT2JqZWN0IG5vdCBzdXBwb3J0ZWQgaW4gSUUxMSBhbmQgYmVsb3dcclxuXHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2hoODM0Njc1KHY9dnMuODUpLmFzcHhcclxuXHRjb25zdCBkYXRhU3RyID0gYDxzdmcgeG1sbnM9XCIke2QzTmFtZXNwYWNlcy5zdmd9XCIgd2lkdGg9XCIke3NpemUud2lkdGh9XCIgaGVpZ2h0PVwiJHtzaXplLmhlaWdodH1cIj5cclxuXHRcdFx0PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPlxyXG5cdFx0XHRcdCR7c3R5bGVYbWx9XHJcblx0XHRcdFx0JHtub2RlWG1sLnJlcGxhY2UoLyh1cmxcXCgpW14jXSsvZywgXCIkMVwiKX1cclxuXHRcdFx0PC9mb3JlaWduT2JqZWN0Pjwvc3ZnPmBcclxuXHRcdC5yZXBsYWNlKFwiL1xcbi9nXCIsIFwiJTBBXCIpO1xyXG5cclxuXHRyZXR1cm4gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtiNjRFbmNvZGVVbmljb2RlKGRhdGFTdHIpfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBFeHBvcnQgY2hhcnQgYXMgYW4gaW1hZ2UuXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gSUUxMSBhbmQgYmVsb3cgbm90IHdvcmsgcHJvcGVybHkgZHVlIHRvIHRoZSBsYWNrIG9mIHRoZSBmZWF0dXJlKDxhIGhyZWY9XCJodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2hoODM0Njc1KHY9dnMuODUpLmFzcHhcIj5mb3JlaWduT2JqZWN0PC9hPikgc3VwcG9ydFxyXG5cdCAqICAgLSBUaGUgYmFzaWMgQ1NTIGZpbGUoZXguIGJpbGxib2FyZC5jc3MpIHNob3VsZCBiZSBhdCBzYW1lIGRvbWFpbiBhcyBBUEkgY2FsbCBjb250ZXh0IHRvIGdldCBjb3JyZWN0IHN0eWxlZCBleHBvcnQgaW1hZ2UuXHJcblx0ICogQGZ1bmN0aW9uIGV4cG9ydFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbWltZVR5cGU9aW1hZ2UvcG5nXSBUaGUgZGVzaXJlZCBvdXRwdXQgaW1hZ2UgZm9ybWF0LiAoZXguICdpbWFnZS9wbmcnIGZvciBwbmcsICdpbWFnZS9qcGVnJyBmb3IganBlZyBmb3JtYXQpXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGV4cG9ydCBpcyByZWFkeS5cclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBkYXRhVVJJXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgY2hhcnQuZXhwb3J0KCk7XHJcblx0ICogIC8vIC0tPiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOLi4uXCJcclxuXHQgKlxyXG5cdCAqICAvLyBJbml0aWFsaXplIHRoZSBkb3dubG9hZCBhdXRvbWF0aWNhbGx5XHJcblx0ICogIGNoYXJ0LmV4cG9ydChcImltYWdlL3BuZ1wiLCBkYXRhVXJsID0+IHtcclxuXHQgKiAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG5cdCAqXHJcblx0ICogICAgIGxpbmsuZG93bmxvYWQgPSBgJHtEYXRlLm5vdygpfS5wbmdgO1xyXG5cdCAqICAgICBsaW5rLmhyZWYgPSBkYXRhVXJsO1xyXG5cdCAqICAgICBsaW5rLmlubmVySFRNTCA9IFwiRG93bmxvYWQgY2hhcnQgYXMgaW1hZ2VcIjtcclxuXHQgKlxyXG5cdCAqICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRleHBvcnQobWltZVR5cGU/OiBzdHJpbmcsIGNhbGxiYWNrPzogKGRhdGFVcmw6IHN0cmluZykgPT4gdm9pZCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7c3RhdGUsICRlbDoge2NoYXJ0fX0gPSAkJDtcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHN0YXRlLmN1cnJlbnQ7XHJcblx0XHRjb25zdCBzdmdEYXRhVXJsID0gbm9kZVRvU3ZnRGF0YVVybChjaGFydC5ub2RlKCksIHt3aWR0aCwgaGVpZ2h0fSk7XHJcblxyXG5cdFx0aWYgKGNhbGxiYWNrICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcblx0XHRcdGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG5cclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcclxuXHRcdFx0aW1nLm9ubG9hZCA9ICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG5cclxuXHRcdFx0XHRjYWxsYmFjay5iaW5kKHRoaXMpKGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUpKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGltZy5zcmMgPSBzdmdEYXRhVXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdmdEYXRhVXJsO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG50eXBlIGZvY3VzUGFyYW0gPSBzdHJpbmcgfCBzdHJpbmdbXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSBoaWdobGlnaHRzIHNwZWNpZmllZCB0YXJnZXRzIGFuZCBmYWRlIG91dCB0aGUgb3RoZXJzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSBoaWdobGlnaHRlZC5cclxuXHQgKiBAZnVuY3Rpb24gZm9jdXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzVmFsdWUgVGFyZ2V0IGlkcyB0byBiZSBoaWdobGlnaHRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBkYXRhMSB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgZmFkZWQgb3V0XHJcblx0ICogIGNoYXJ0LmZvY3VzKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxyXG5cdCAqIGNoYXJ0LmZvY3VzKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSBoaWdobGlnaHRlZFxyXG5cdCAqIGNoYXJ0LmZvY3VzKCk7XHJcblx0ICovXHJcblx0Zm9jdXModGFyZ2V0SWRzVmFsdWU/OiBmb2N1c1BhcmFtKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoXHJcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMucmV2ZXJ0KCk7XHJcblx0XHR0aGlzLmRlZm9jdXMoKTtcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgdHJ1ZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpICYmICFzdGF0ZS5oYXNSYWRhcikge1xyXG5cdFx0XHQkJC5leHBhbmRBcmModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJlxyXG5cdFx0XHRcdCQkLm1hcmtPdmVybGFwcGVkKHRhcmdldElkc1ZhbHVlLCAkJCwgYC4ke0NMQVNTLmdhdWdlVmFsdWV9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCB0cnVlKTtcclxuXHJcblx0XHRzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gc3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSBmYWRlcyBvdXQgc3BlY2lmaWVkIHRhcmdldHMgYW5kIHJldmVydHMgdGhlIG90aGVycy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxyXG5cdCAqIEBmdW5jdGlvbiBkZWZvY3VzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgZmFkZWQgb3V0LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gZGF0YTEgd2lsbCBiZSBmYWRlZCBvdXQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5kZWZvY3VzKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBmYWRlZCBvdXQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5kZWZvY3VzKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSBmYWRlZCBvdXQuXHJcblx0ICogY2hhcnQuZGVmb2N1cygpO1xyXG5cdCAqL1xyXG5cdGRlZm9jdXModGFyZ2V0SWRzVmFsdWU/OiBmb2N1c1BhcmFtKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoXHJcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXHJcblx0XHQpO1xyXG5cclxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCBmYWxzZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0JCQudW5leHBhbmRBcmModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJlxyXG5cdFx0XHRcdCQkLnVuZG9NYXJrT3ZlcmxhcHBlZCgkJCwgYC4ke0NMQVNTLmdhdWdlVmFsdWV9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCBmYWxzZSk7XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgQVBJIHJldmVydHMgc3BlY2lmaWVkIHRhcmdldHMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIEBmdW5jdGlvbiByZXZlcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzVmFsdWUgVGFyZ2V0IGlkcyB0byBiZSByZXZlcnRlZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gZGF0YTEgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5yZXZlcnQoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LnJldmVydChbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQucmV2ZXJ0KCk7XHJcblx0ICovXHJcblx0cmV2ZXJ0KHRhcmdldElkc1ZhbHVlPzogZm9jdXNQYXJhbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcclxuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSAkZWwuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7IC8vIHNob3VsZCBiZSBmb3IgYWxsIHRhcmdldHNcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XHJcblx0XHQkJC5oYXNBcmNUeXBlKCkgJiYgJCQudW5leHBhbmRBcmModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93KSB7XHJcblx0XHRcdCQkLnNob3dMZWdlbmQodGFyZ2V0SWRzLmZpbHRlcigkJC5pc0xlZ2VuZFRvU2hvdy5iaW5kKCQkKSkpO1xyXG5cdFx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzID0gW107XHJcblx0XHRzdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIERlZmluZSBsZWdlbmRcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY29uc3QgbGVnZW5kID0ge1xyXG5cdC8qKlxyXG5cdCAqIFNob3cgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cclxuXHQgKiBAZnVuY3Rpb24gbGVnZW5k4oCkc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB0YXJnZXRJZHNcclxuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIHNob3duLlxyXG5cdCAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxyXG5cdCAqIC0gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBzaG93bi5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMS5cclxuXHQgKiBjaGFydC5sZWdlbmQuc2hvdyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gU2hvdyBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cclxuXHQgKiBjaGFydC5sZWdlbmQuc2hvdyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNob3cgYWxsIGxlZ2VuZC5cclxuXHQgKiBjaGFydC5sZWdlbmQuc2hvdygpO1xyXG5cdCAqL1xyXG5cdHNob3c6IGZ1bmN0aW9uKHRhcmdldElkcz86IHN0cmluZyB8IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuc2hvd0xlZ2VuZCgkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpKTtcclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cclxuXHQgKiBAZnVuY3Rpb24gbGVnZW5k4oCkaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB0YXJnZXRJZHNcclxuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cclxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBIaWRlIGxlZ2VuZCBmb3IgZGF0YTEgYW5kIGRhdGEyLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gSGlkZSBhbGwgbGVnZW5kLlxyXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKCk7XHJcblx0ICovXHJcblx0aGlkZTogZnVuY3Rpb24odGFyZ2V0SWRzPzogc3RyaW5nIHwgc3RyaW5nW10pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHQkJC5oaWRlTGVnZW5kKCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykpO1xyXG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2xlZ2VuZH07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1N0cmluZywgaXNBcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogTG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgdG9nZ2xlcy5cclxuXHQgKiAtIDxiPk5vdGU6PC9iPlxyXG5cdCAqICAgLSB1bmxvYWQgc2hvdWxkIGJlIHVzZWQgaWYgc29tZSBkYXRhIG5lZWRzIHRvIGJlIHVubG9hZGVkIHNpbXVsdGFuZW91c2x5LlxyXG5cdCAqICAgICBJZiB5b3UgY2FsbCB1bmxvYWQgQVBJIHNvb24gYWZ0ZXIvYmVmb3JlIGxvYWQgaW5zdGVhZCBvZiB1bmxvYWQgcGFyYW0sIGNoYXJ0IHdpbGwgbm90IGJlIHJlbmRlcmVkIHByb3Blcmx5IGJlY2F1c2Ugb2YgY2FuY2VsIG9mIGFuaW1hdGlvbi48YnI+XHJcblx0ICogICAtIGRvbmUgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuXHJcblx0ICogICAgIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nXHJcblx0ICogQGZ1bmN0aW9uIGxvYWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgLSB1cmw8YnI+LSBqc29uPGJyPi0gcm93czxicj4tIGNvbHVtbnMgfCBUaGUgZGF0YSB3aWxsIGJlIGxvYWRlZC4gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHVwZGF0ZWQuIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkIHxcclxuXHQgKiAgICB8IGRhdGEgfCBEYXRhIG9iamVjdHMgdG8gYmUgbG9hZGVkLiBDaGVja291dCB0aGUgZXhhbXBsZS4gfFxyXG5cdCAqICAgIHwgbmFtZXMgfCBTYW1lIGFzIGRhdGEubmFtZXMoKSB8XHJcblx0ICogICAgfCB4cyB8IFNhbWUgYXMgZGF0YS54cyBvcHRpb24gIHxcclxuXHQgKiAgICB8IGNsYXNzZXMgfCBUaGUgY2xhc3NlcyBzcGVjaWZpZWQgYnkgZGF0YS5jbGFzc2VzIHdpbGwgYmUgdXBkYXRlZC4gY2xhc3NlcyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxyXG5cdCAqICAgIHwgY2F0ZWdvcmllcyB8IFRoZSBjYXRlZ29yaWVzIHNwZWNpZmllZCBieSBheGlzLnguY2F0ZWdvcmllcyBvciBkYXRhLnggd2lsbCBiZSB1cGRhdGVkLiBjYXRlZ29yaWVzIG11c3QgYmUgQXJyYXkuIHxcclxuXHQgKiAgICB8IGF4ZXMgfCBUaGUgYXhlcyBzcGVjaWZpZWQgYnkgZGF0YS5heGVzIHdpbGwgYmUgdXBkYXRlZC4gYXhlcyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxyXG5cdCAqICAgIHwgY29sb3JzIHwgVGhlIGNvbG9ycyBzcGVjaWZpZWQgYnkgZGF0YS5jb2xvcnMgd2lsbCBiZSB1cGRhdGVkLiBjb2xvcnMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGhlYWRlcnMgfCAgU2V0IHJlcXVlc3QgaGVhZGVyIGlmIGxvYWRpbmcgdmlhIGBkYXRhLnVybGAuPGJyPkBzZWUgW2RhdGHigKRoZWFkZXJzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRoZWFkZXJzKSB8XHJcblx0ICogICAgfCBrZXlzIHwgIENob29zZSB3aGljaCBKU09OIG9iamVjdHMga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS48YnI+KipOT1RFOioqIE9ubHkgZm9yIEpTT04gb2JqZWN0IGdpdmVuIGFzIGFycmF5Ljxicj5Ac2VlIFtkYXRh4oCka2V5c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cykgfFxyXG5cdCAqICAgIHwgbWltZVR5cGUgfCAgU2V0ICdqc29uJyBpZiBsb2FkaW5nIEpTT04gdmlhIHVybC48YnI+QHNlZSBbZGF0YeKApG1pbWVUeXBlXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRtaW1lVHlwZSkgfFxyXG5cdCAqICAgIHwgLSB0eXBlPGJyPi0gdHlwZXMgfCBUaGUgdHlwZSBvZiB0YXJnZXRzIHdpbGwgYmUgdXBkYXRlZC4gdHlwZSBtdXN0IGJlIFN0cmluZyBhbmQgdHlwZXMgbXVzdCBiZSBPYmplY3QuIHxcclxuXHQgKiAgICB8IHVubG9hZCB8IFNwZWNpZnkgdGhlIGRhdGEgd2lsbCBiZSB1bmxvYWRlZCBiZWZvcmUgbG9hZGluZyBuZXcgZGF0YS4gSWYgdHJ1ZSBnaXZlbiwgYWxsIG9mIGRhdGEgd2lsbCBiZSB1bmxvYWRlZC4gSWYgdGFyZ2V0IGlkcyBnaXZlbiBhcyBTdHJpbmcgb3IgQXJyYXksIHNwZWNpZmllZCB0YXJnZXRzIHdpbGwgYmUgdW5sb2FkZWQuIElmIGFic2VudCBvciBmYWxzZSBnaXZlbiwgdW5sb2FkIHdpbGwgbm90IG9jY3VyLiB8XHJcblx0ICogICAgfCBkb25lIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZC58XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUZyb21VUkwpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBMb2FkIGRhdGExIGFuZCB1bmxvYWQgZGF0YTIgYW5kIGRhdGEzXHJcblx0ICogY2hhcnQubG9hZCh7XHJcblx0ICogICAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMTAwLCAyMDAsIDE1MCwgLi4uXSxcclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgXSxcclxuXHQgKiAgICB1bmxvYWQ6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXHJcblx0ICogICAgdXJsOiBcIi4uLlwiLFxyXG5cdCAqICAgIGRvbmU6IGZ1bmN0aW9uKCkgeyAuLi4gfVxyXG5cdCAqIH0pO1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gbXlBUEkuanNvblxyXG5cdCAqIC8vIHtcclxuXHQgKiAvLyAgIFwiZGF0YTFcIjogWzIyMCwgMjQwLCAyNzAsIDI1MCwgMjgwXSxcclxuXHQgKiAvLyAgIFwiZGF0YTJcIjogWzE4MCwgMTUwLCAzMDAsIDcwLCAxMjBdXHJcblx0ICogLy8gfVxyXG5cdCAqXHJcblx0ICogY2hhcnQubG9hZCh7XHJcblx0ICogICAgIHVybDogJy4vZGF0YS9teUFQSS5qc29uJyxcclxuXHQgKiAgICAgbWltZVR5cGU6IFwianNvblwiLFxyXG5cdCAqXHJcblx0ICogICAgIC8vIHNldCByZXF1ZXN0IGhlYWRlciBpZiBpcyBuZWVkZWRcclxuXHQgKiAgICAgaGVhZGVyczoge1xyXG5cdCAqICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9qc29uXCJcclxuXHQgKiAgICAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQubG9hZCh7XHJcblx0ICogICAgIGRhdGE6IFtcclxuXHQgKiAgICAgICAvLyBlcXVpdmFsZW50IGFzOiBjb2x1bW5zOiBbW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwXV1cclxuXHQgKiAgICAgICB7XCJkYXRhMVwiOiAzMH0sIHtcImRhdGExXCI6IDIwMH0sIHtcImRhdGExXCI6IDEwMH1cclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIG9yXHJcblx0ICogICAgICAgLy8gZXF1aXZhbGVudCBhczogY29sdW1uczogW1tcImRhdGExXCIsIDEwLCAyMF0sIFtcImRhdGEyXCIsIDEzLCAzMF1dXHJcblx0ICogICAgICAgLy8ge1wiZGF0YTFcIjogMTAsIFwiZGF0YTJcIjogMTN9LCB7XCJkYXRhMVwiOiAyMCwgXCJkYXRhMlwiOiAzMH19XHJcblx0ICogICAgIF1cclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRsb2FkKGFyZ3MpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHhzIGlmIHNwZWNpZmllZFxyXG5cdFx0YXJncy54cyAmJiAkJC5hZGRYcyhhcmdzLnhzKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgbmFtZXMgaWYgZXhpc3RzXHJcblx0XHRcIm5hbWVzXCIgaW4gYXJncyAmJiB0aGlzLmRhdGEubmFtZXMoYXJncy5uYW1lcyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNsYXNzZXMgaWYgZXhpc3RzXHJcblx0XHRcImNsYXNzZXNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY2xhc3NlcykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbmZpZy5kYXRhX2NsYXNzZXNbaWRdID0gYXJncy5jbGFzc2VzW2lkXTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjYXRlZ29yaWVzIGlmIGV4aXN0c1xyXG5cdFx0aWYgKFwiY2F0ZWdvcmllc1wiIGluIGFyZ3MgJiYgJCQuYXhpcy5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gYXJncy5jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBheGVzIGlmIGV4aXN0c1xyXG5cdFx0XCJheGVzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmF4ZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY29sb3JzIGlmIGV4aXN0c1xyXG5cdFx0XCJjb2xvcnNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY29sb3JzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfY29sb3JzW2lkXSA9IGFyZ3MuY29sb3JzW2lkXTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHVubG9hZCBpZiBuZWVkZWRcclxuXHRcdGlmIChcInVubG9hZFwiIGluIGFyZ3MgJiYgYXJncy51bmxvYWQgIT09IGZhbHNlKSB7XHJcblx0XHRcdC8vIFRPRE86IGRvIG5vdCB1bmxvYWQgaWYgdGFyZ2V0IHdpbGwgbG9hZCAoaW5jbHVkZWQgaW4gdXJsL3Jvd3MvY29sdW1ucylcclxuXHRcdFx0JCQudW5sb2FkKCQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MudW5sb2FkID09PSB0cnVlID8gbnVsbCA6IGFyZ3MudW5sb2FkKSwgKCkgPT5cclxuXHRcdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncylcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmxvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXHJcblx0ICogLSA8Yj5Ob3RlOjwvYj5cclxuXHQgKiBJZiB5b3UgY2FsbCBsb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSB1bmxvYWQsIHVubG9hZCBwYXJhbSBvZiBsb2FkIHNob3VsZCBiZSB1c2VkLiBPdGhlcndpc2UgY2hhcnQgd2lsbCBub3QgYmUgcmVuZGVyZWQgcHJvcGVybHkgYmVjYXVzZSBvZiBjYW5jZWwgb2YgYW5pbWF0aW9uLjxicj5cclxuXHQgKiBgZG9uZWAgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nLlxyXG5cdCAqIEBmdW5jdGlvbiB1bmxvYWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnc1ZhbHVlXHJcblx0ICogIHwga2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICB8IGlkcyB8IFN0cmluZyAmdmVydDsgQXJyYXkgfCBUYXJnZXQgaWQgZGF0YSB0byBiZSB1bmxvYWRlZC4gSWYgbm90IGdpdmVuLCBhbGwgZGF0YSB3aWxsIGJlIHVubG9hZGVkLiB8XHJcblx0ICogIHwgZG9uZSB8IEZ1Y3Rpb24gfCBDYWxsYmFjayBhZnRlciBkYXRhIGlzIHVubG9hZGVkLiB8XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gVW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xyXG5cdCAqICBjaGFydC51bmxvYWQoe1xyXG5cdCAqICAgIGlkczogW1wiZGF0YTJcIiwgXCJkYXRhM1wiXSxcclxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHtcclxuXHQgKiAgICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHVubG9hZGVkXHJcblx0ICogICAgfVxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHR1bmxvYWQoYXJnc1ZhbHVlKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRsZXQgYXJncyA9IGFyZ3NWYWx1ZSB8fCB7fTtcclxuXHJcblx0XHRpZiAoaXNBcnJheShhcmdzKSkge1xyXG5cdFx0XHRhcmdzID0ge2lkczogYXJnc307XHJcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGFyZ3MpKSB7XHJcblx0XHRcdGFyZ3MgPSB7aWRzOiBbYXJnc119O1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MuaWRzKTtcclxuXHJcblx0XHQkJC51bmxvYWQoaWRzLCAoKSA9PiB7XHJcblx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmNhY2hlLnJlbW92ZShpZHMpO1xyXG5cdFx0XHRhcmdzLmRvbmUgJiYgYXJncy5kb25lLmNhbGwodGhpcyk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtlbmRhbGx9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFNob3cvSGlkZSBkYXRhIHNlcmllc1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3cgU2hvdyBvciBoaWRlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZCB2YWx1ZXNcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2hvd0hpZGUoc2hvdzogYm9vbGVhbiwgdGFyZ2V0SWRzVmFsdWU6IHN0cmluZ1tdLCBvcHRpb25zOiBhbnkpOiB2b2lkIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cclxuXHQkJFtgJHtzaG93ID8gXCJyZW1vdmVcIiA6IFwiYWRkXCJ9SGlkZGVuVGFyZ2V0SWRzYF0odGFyZ2V0SWRzKTtcclxuXHJcblx0Y29uc3QgdGFyZ2V0cyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMpKTtcclxuXHRjb25zdCBvcGFjaXR5ID0gc2hvdyA/IFwiMVwiIDogXCIwXCI7XHJcblxyXG5cdHRhcmdldHMudHJhbnNpdGlvbigpXHJcblx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHksIFwiaW1wb3J0YW50XCIpXHJcblx0XHQuY2FsbChlbmRhbGwsICgpID0+IHtcclxuXHRcdFx0dGFyZ2V0cy5zdHlsZShcIm9wYWNpdHlcIiwgbnVsbCkuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpO1xyXG5cdFx0fSk7XHJcblxyXG5cdG9wdGlvbnMud2l0aExlZ2VuZCAmJiAkJFtgJHtzaG93ID8gXCJzaG93XCIgOiBcImhpZGVcIn1MZWdlbmRgXSh0YXJnZXRJZHMpO1xyXG5cclxuXHQkJC5yZWRyYXcoe1xyXG5cdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHR9KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNob3cgZGF0YSBzZXJpZXMgb24gY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWVdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgYm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBzaG93ICdkYXRhMSdcclxuXHQgKiBjaGFydC5zaG93KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBzaG93ICdkYXRhMScgYW5kICdkYXRhMydcclxuXHQgKiBjaGFydC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHNob3codGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmdbXSB8IHN0cmluZywgb3B0aW9ucyA9IHt9KTogdm9pZCB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIHRydWUsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGRhdGEgc2VyaWVzIGZyb20gY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWVdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgYm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBoaWRlICdkYXRhMSdcclxuXHQgKiBjaGFydC5oaWRlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBoaWRlICdkYXRhMScgYW5kICdkYXRhMydcclxuXHQgKiBjaGFydC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdGhpZGUodGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmdbXSwgb3B0aW9ucyA9IHt9KTogdm9pZCB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIGZhbHNlLCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIGRhdGEgc2VyaWVzIG9uIGNoYXJ0LiBXaGVuIHRhcmdldCBkYXRhIGlzIGhpZGRlbiwgaXQgd2lsbCBzaG93LiBJZiBpcyBzaG93biwgaXQgd2lsbCBoaWRlIGluIHZpY2UgdmVyc2EuXHJcblx0ICogQGZ1bmN0aW9uIHRvZ2dsZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgd2l0aExlZ2VuZCB8IGJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gdG9nZ2xlICdkYXRhMSdcclxuXHQgKiBjaGFydC50b2dnbGUoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnIGFuZCAnZGF0YTMnXHJcblx0ICogY2hhcnQudG9nZ2xlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHRvZ2dsZSh0YXJnZXRJZHM6IHN0cmluZ3xzdHJpbmdbXSwgb3B0aW9ucyA9IHt9KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB0YXJnZXRzID0ge3Nob3c6IDxzdHJpbmdbXT4gW10sIGhpZGU6IDxzdHJpbmdbXT4gW119O1xyXG5cclxuXHRcdC8vIHNvcnQgc2hvdyAmIGhpZGUgdGFyZ2V0IGlkc1xyXG5cdFx0JCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKVxyXG5cdFx0XHQuZm9yRWFjaCgoaWQ6IHN0cmluZykgPT4gdGFyZ2V0c1skJC5pc1RhcmdldFRvU2hvdyhpZCkgPyBcImhpZGVcIiA6IFwic2hvd1wiXS5wdXNoKGlkKSk7XHJcblxyXG5cdFx0Ly8gcGVyZm9ybSBzaG93ICYgaGlkZSB0YXNrIHNlcGFyYXRlbHlcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ1NFxyXG5cdFx0dGFyZ2V0cy5zaG93Lmxlbmd0aCAmJiB0aGlzLnNob3codGFyZ2V0cy5zaG93LCBvcHRpb25zKTtcclxuXHRcdHRhcmdldHMuaGlkZS5sZW5ndGggJiYgc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpZGUodGFyZ2V0cy5oaWRlLCBvcHRpb25zKSwgMCk7XHJcblx0fVxyXG59O1xyXG5cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRGVmaW5lIHRvb2x0aXBcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY29uc3QgdG9vbHRpcCA9IHtcclxuXHQvKipcclxuXHQgKiBTaG93IHRvb2x0aXBcclxuXHQgKiBAZnVuY3Rpb24gdG9vbHRpcOKApHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcclxuXHQgKiAgICB8IHggfCBOdW1iZXIgJnZlcnQ7IERhdGUgfCBEZXRlcm1pbmUgZm9jdXMgYnkgeCBBeGlzIGluZGV4IHxcclxuXHQgKiAgICB8IG1vdXNlIHwgQXJyYXkgfCBEZXRlcm1pbmUgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlIHJlbGF0aXZlIHRoZSB0YXJnZXRlZCAnLmJiLWV2ZW50LXJlY3QnIHggQXhpcy48YnI+SXQgc2hvdWxkIGJlIHVzZWQgYWxvbmcgd2l0aCBgZGF0YWAsIGBpbmRleGAgb3IgYHhgIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBzZXQgYXMgYFswLDBdYCB8XHJcblx0ICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge251bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge251bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7c3RyaW5nfTogZGF0YSBpZDxicj4tIHZhbHVlIHtudW1iZXJ9OiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgdG9vbHRpcC4gfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gc2hvdyB0aGUgMm5kIHggQXhpcyBjb29yZGluYXRlIHRvb2x0aXBcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICBpbmRleDogMVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRoZSAzcmQgeCBBeGlzIGluIHg6NTAgYW5kIHk6MTAwIGNvb3JkaW5hdGUgb2YgJy5iYi1ldmVudC1yZWN0JyBvZiB0aGUgeCBBeGlzLlxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIHg6IDIsXHJcblx0ICogICAgbW91c2U6IFs1MCwgMTAwXVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRpbWVzZXJpZXMgeCBheGlzXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgeDogbmV3IERhdGUoXCIyMDE4LTAxLTAyIDAwOjAwXCIpXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHdoZW4gZGF0YS54cyBpcyB1c2VkXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgZGF0YToge1xyXG5cdCAqICAgICAgICB4OiAzLCAgLy8geCBBeGlzIHZhbHVlXHJcblx0ICogICAgICAgIGlkOiBcImRhdGExXCIsICAvLyBkYXRhIGlkXHJcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHdoZW4gZGF0YS54cyBpc24ndCB1c2VkLCBidXQgdG9vbHRpcC5ncm91cGVkPWZhbHNlIGlzIHNldFxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIGRhdGE6IHtcclxuXHQgKiAgICAgICAgaW5kZXg6IDMsICAvLyBvciAneCcga2V5IHZhbHVlXHJcblx0ICogICAgICAgIGlkOiBcImRhdGExXCIsICAvLyBkYXRhIGlkXHJcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHNob3c6IGZ1bmN0aW9uKGFyZ3MpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aW5wdXRUeXBlfX0gPSAkJDtcclxuXHRcdGxldCBpbmRleDtcclxuXHRcdGxldCBtb3VzZTtcclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgbW91c2UgcG9zaXRpb24gb24gdGhlIGNoYXJ0XHJcblx0XHRpZiAoYXJncy5tb3VzZSkge1xyXG5cdFx0XHRtb3VzZSA9IGFyZ3MubW91c2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIGZvY3VzIGRhdGFcclxuXHRcdGlmIChhcmdzLmRhdGEpIHtcclxuXHRcdFx0Y29uc3Qge2RhdGF9ID0gYXJncztcclxuXHRcdFx0Y29uc3QgeSA9ICQkLmdldFlTY2FsZUJ5SWQoZGF0YS5pZCkoZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHRcdC8vIGlmIG11bHRpcGxlIHhzLCB0YXJnZXQgcG9pbnQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG1vdXNlXHJcblx0XHRcdFx0bW91c2UgPSBbJCQuc2NhbGUueChkYXRhLngpLCB5XTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdG1vdXNlID0gWzAsIHldO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5kZXggPSBpc1ZhbHVlKGRhdGEuaW5kZXgpID8gZGF0YS5pbmRleCA6ICQkLmdldEluZGV4QnlYKGRhdGEueCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MueCkpIHtcclxuXHRcdFx0aW5kZXggPSAkJC5nZXRJbmRleEJ5WChhcmdzLngpO1xyXG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5pbmRleCkpIHtcclxuXHRcdFx0aW5kZXggPSBhcmdzLmluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVtdWxhdGUgZXZlbnRzIHRvIHNob3dcclxuXHRcdChpbnB1dFR5cGUgPT09IFwibW91c2VcIiA/XHJcblx0XHRcdFtcIm1vdXNlb3ZlclwiLCBcIm1vdXNlbW92ZVwiXSA6IFtcInRvdWNoc3RhcnRcIl1cclxuXHRcdCkuZm9yRWFjaChldmVudE5hbWUgPT4ge1xyXG5cdFx0XHQkJC5kaXNwYXRjaEV2ZW50KGV2ZW50TmFtZSwgaW5kZXgsIG1vdXNlKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdG9vbHRpcFxyXG5cdCAqIEBmdW5jdGlvbiB0b29sdGlw4oCkaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqL1xyXG5cdGhpZGU6IGZ1bmN0aW9uKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdC8vIHJlc2V0IGxhc3QgdG91Y2ggcG9pbnQgaW5kZXhcclxuXHRcdCQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcclxuXHJcblx0XHQkJC5oaWRlVG9vbHRpcCh0cnVlKTtcclxuXHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0JCQudW5leHBhbmRCYXJzKCk7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3Rvb2x0aXB9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9DaGFydEludGVybmFsL0NoYXJ0SW50ZXJuYWxcIjtcclxuaW1wb3J0IHtsb2FkQ29uZmlnfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xyXG5pbXBvcnQge2V4dGVuZCwgaXNGdW5jdGlvbn0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5pbXBvcnQgYXBpQ2hhcnQgZnJvbSBcIi4vYXBpL2NoYXJ0XCI7XHJcbmltcG9ydCBhcGlDb2xvciBmcm9tIFwiLi9hcGkvY29sb3JcIjtcclxuaW1wb3J0IGFwaURhdGEgZnJvbSBcIi4vYXBpL2RhdGFcIjtcclxuaW1wb3J0IGFwaUV4cG9ydCBmcm9tIFwiLi9hcGkvZXhwb3J0XCI7XHJcbmltcG9ydCBhcGlGb2N1cyBmcm9tIFwiLi9hcGkvZm9jdXNcIjtcclxuaW1wb3J0IGFwaUxlZ2VuZCBmcm9tIFwiLi9hcGkvbGVnZW5kXCI7XHJcbmltcG9ydCBhcGlMb2FkIGZyb20gXCIuL2FwaS9sb2FkXCI7XHJcbmltcG9ydCBhcGlTaG93IGZyb20gXCIuL2FwaS9zaG93XCI7XHJcbmltcG9ydCBhcGlUb29sdGlwIGZyb20gXCIuL2FwaS90b29sdGlwXCI7XHJcblxyXG5pbXBvcnQge2FwaSBhcyBhcGlBeGlzfSBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2F4aXNcIjtcclxuXHJcbi8qKlxyXG4gKiBNYWluIGNoYXJ0IGNsYXNzLlxyXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCB2aWEgYGJiLmdlbmVyYXRlKClgLlxyXG4gKiBAY2xhc3MgQ2hhcnRcclxuICogQGV4YW1wbGVcclxuICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG4gKiAgZGF0YToge1xyXG4gKiAgICBjb2x1bW5zOiBbXHJcbiAqXHQgICAgW1wieFwiLCBcIjIwMTUtMTEtMDJcIiwgXCIyMDE1LTEyLTAxXCIsIFwiMjAxNi0wMS0wMVwiLCBcIjIwMTYtMDItMDFcIiwgXCIyMDE2LTAzLTAxXCJdLFxyXG4gKiBcdCAgICBbXCJjb3VudDFcIiwgMTEsIDgsIDcsIDYsIDUgXSxcclxuICpcdCAgICBbXCJjb3VudDJcIiwgOSwgMywgNiwgMiwgOCBdXHJcbiAqICAgXX1cclxuICogfVxyXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICovXHJcbi8qKlxyXG4gKiBBY2Nlc3MgaW5zdGFuY2UncyBwcmltYXJ5IG5vZGUgZWxlbWVudHNcclxuICogQG1lbWJlciB7b2JqZWN0fSAkXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAkIEFjY2VzcyBpbnN0YW5jZSdzIHByaW1hcnkgbm9kZSBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5jaGFydCBXcmFwcGVyIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuc3ZnIE1haW4gc3ZnIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuZGVmcyBEZWZpbml0aW9uIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubWFpbiBNYWluIGdyb3VwaW5nIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudG9vbHRpcCBUb29sdGlwIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGVnZW5kIExlZ2VuZCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRpdGxlIFRpdGxlIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuZ3JpZCBHcmlkIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYXJjIEFyYyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmNpcmNsZXMgRGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtvYmplY3R9ICQuYmFyIEJhciBlbGVtZW50IG9iamVjdFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5iYXIuYmFycyBCYXIgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtvYmplY3R9ICQubGluZSBMaW5lIGVsZW1lbnQgb2JqZWN0XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUubGluZXMgTGluZSBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmFyZWFzIEFyZWFzIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAkLnRleHQgVGV4dCBlbGVtZW50IG9iamVjdFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50ZXh0LnRleHRzIERhdGEgbGFiZWwgdGV4dCBlbGVtZW50c1xyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQGV4YW1wbGVcclxuICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcbiAqXHJcbiAqIGNoYXJ0LiQuY2hhcnQ7IC8vIHdyYXBwZXIgZWxlbWVudFxyXG4gKiBjaGFydC4kLmxpbmUuY2lyY2xlczsgIC8vIGFsbCBkYXRhIHBvaW50IGNpcmNsZSBlbGVtZW50c1xyXG4gKi9cclxuLyoqXHJcbiAqIFBsdWdpbiBpbnN0YW5jZSBhcnJheVxyXG4gKiBAbWVtYmVyIHtBcnJheX0gcGx1Z2luc1xyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQGV4YW1wbGVcclxuICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuICogICAgIC4uLlxyXG4gKiAgICAgcGx1Z2luczogW1xyXG4gKiAgICAgICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcclxuICogICAgICAgIG5ldyBQbHVnaW5BKClcclxuICogICAgIF1cclxuICogIH0pO1xyXG4gKlxyXG4gKiAgY2hhcnQucGx1Z2luczsgLy8gW1N0YW5mb3JkLCBQbHVnaW5BXSAtIGluc3RhbmNlIGFycmF5XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydCB7XHJcblx0cHVibGljIHBsdWdpbnMgPSBbXTtcclxuXHRwdWJsaWMgaW50ZXJuYWw6IENoYXJ0SW50ZXJuYWw7XHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuXHRcdGNvbnN0IGN0eCA9IHRoaXM7XHJcblx0XHQvLyBjb25zdCB7dHlwZSwgdHlwZXN9ID0gb3B0aW9ucy5kYXRhO1xyXG5cdFx0Ly8gbGV0IGlzQXJjID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgKHR5cGUpIHtcclxuXHRcdC8vIFx0aXNBcmMgPSBUWVBFUy5BcmMuaW5kZXhPZih0eXBlKSA+IC0xO1xyXG5cdFx0Ly8gfSBlbHNlIGlmICh0eXBlcykge1xyXG5cdFx0Ly8gXHRmb3IgKGNvbnN0IHggaW4gdHlwZXMpIHtcclxuXHRcdC8vIFx0XHRpZiAoVFlQRVMuQXJjLmluZGV4T2YodHlwZXNbeF0pID4gLTEpIHtcclxuXHRcdC8vIFx0XHRcdGlzQXJjID0gdHJ1ZTtcclxuXHRcdC8vIFx0XHRcdGJyZWFrO1xyXG5cdFx0Ly8gXHRcdH1cclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfVxyXG5cclxuXHRcdGNvbnN0ICQkID0gbmV3IENoYXJ0SW50ZXJuYWwoY3R4KTtcclxuXHJcblx0XHR0aGlzLmludGVybmFsID0gJCQ7XHJcblxyXG5cdFx0Ly8gYmluZCB0byBuYW1lc3BhY2VkIEFQSXNcclxuXHRcdChmdW5jdGlvbiBiaW5kVGhpcyhmbiwgdGFyZ2V0LCBhcmdUaGlzKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgaXNGdW5jID0gaXNGdW5jdGlvbihmbltrZXldKTtcclxuXHRcdFx0XHRjb25zdCBpc0NoaWxkID0gdGFyZ2V0ICE9PSBhcmdUaGlzO1xyXG5cdFx0XHRcdGNvbnN0IGhhc0NoaWxkID0gT2JqZWN0LmtleXMoZm5ba2V5XSkubGVuZ3RoID4gMDtcclxuXHJcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiAoKCFpc0NoaWxkICYmIGhhc0NoaWxkKSB8fCBpc0NoaWxkKSkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBmbltrZXldLmJpbmQoYXJnVGhpcyk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICghaXNGdW5jKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHt9O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aGFzQ2hpbGQgJiYgYmluZFRoaXMoZm5ba2V5XSwgdGFyZ2V0W2tleV0sIGFyZ1RoaXMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pKENoYXJ0LnByb3RvdHlwZSwgdGhpcywgdGhpcyk7XHJcblxyXG5cdFx0bG9hZENvbmZpZy5jYWxsKCQkLCBvcHRpb25zKTtcclxuXHJcblx0XHQkJC5iZWZvcmVJbml0KCk7XHJcblx0XHQkJC5pbml0KCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBleHRlbmQgY29tbW9uIEFQSXMgYXMgcGFydCBvZiBDaGFydCBjbGFzc1xyXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCBbXHJcblx0YXBpQ2hhcnQsXHJcblx0YXBpQ29sb3IsXHJcblx0YXBpRGF0YSxcclxuXHRhcGlFeHBvcnQsXHJcblx0YXBpRm9jdXMsXHJcblx0YXBpTGVnZW5kLFxyXG5cdGFwaUxvYWQsXHJcblx0YXBpU2hvdyxcclxuXHRhcGlUb29sdGlwLFxyXG5cdC4uLmFwaUF4aXNcclxuXSk7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZCBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IENoYXJ0IGZyb20gXCIuL0NoYXJ0L0NoYXJ0XCI7XHJcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlT2JqfSBmcm9tIFwiLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXHJcbmV4cG9ydCB7YmIsIGJiIGFzIGRlZmF1bHR9O1xyXG5cclxubGV0IGRlZmF1bHRzID0ge307XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBiYlxyXG4gKiBAdmVyc2lvbiAyLjAuMC1hbHBoYVxyXG4gKi9cclxuY29uc3QgYmIgPSB7XHJcblx0LyoqXHJcblx0ICogVmVyc2lvbiBpbmZvcm1hdGlvblxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uIHZlcnNpb25cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAgIGJiLnZlcnNpb247ICAvLyBcIjEuMC4wXCJcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHR2ZXJzaW9uOiBcIjIuMC4wLWFscGhhXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtPcHRpb25zfSBjb25maWcgY2hhcnQgb3B0aW9uc1xyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqIEByZXR1cm5zIHtDaGFydH1cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfSBmb3IgZGlmZmVyZW50IGdlbmVyYXRpb24gb3B0aW9uc1xyXG5cdCAqIEBzZWUge0BsaW5rIENoYXJ0fSBmb3IgZGlmZmVyZW50IG1ldGhvZHMgQVBJXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgPCEtLSBjaGFydCBob2xkZXIgLS0+XHJcblx0ICogPGRpdiBpZD1cIkxpbmVDaGFydFwiPjwvZGl2PlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogICAvLyBnZW5lcmF0ZSBjaGFydCB3aXRoIG9wdGlvbnNcclxuXHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG5cdCAqICAgICAgXCJiaW5kdG9cIjogXCIjTGluZUNoYXJ0XCJcclxuXHQgKiAgICAgIFwiZGF0YVwiOiB7XHJcblx0ICogICAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwLCA0MDAsIDE1MCwgMjUwXSxcclxuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTJcIiwgNTAsIDIwLCAxMCwgNDAsIDE1LCAyNV1cclxuXHQgKiAgICAgICAgICAgXVxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBjYWxsIHNvbWUgQVBJXHJcblx0ICogIC8vIGV4KSBnZXQgdGhlIGRhdGEgb2YgJ2RhdGExJ1xyXG5cdCAqICBjaGFydC5kYXRhKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0Z2VuZXJhdGUoY29uZmlnKSB7XHJcblx0XHRjb25zdCBvcHRpb25zID0gbWVyZ2VPYmooe30sIGRlZmF1bHRzLCBjb25maWcpO1xyXG5cdFx0Y29uc3QgaW5zdCA9IG5ldyBDaGFydChvcHRpb25zKTtcclxuXHJcblx0XHRpbnN0LmludGVybmFsLmNoYXJ0cyA9IHRoaXMuaW5zdGFuY2U7XHJcblx0XHR0aGlzLmluc3RhbmNlLnB1c2goaW5zdCk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3Q7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG9yIGdldCBnbG9iYWwgZGVmYXVsdCBvcHRpb25zLlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIFRoZSBvcHRpb25zIHZhbHVlcyBzZXR0aW5ncyBhcmUgdmFsaWQgd2l0aGluIHBhZ2UgY29udGV4dCBvbmx5LlxyXG5cdCAqICAgLSBJZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHdpbGwgb3ZlcnJpZGUgdGhlIGxhc3QgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKiBAcmV0dXJucyB7T3B0aW9uc31cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXHJcblx0ICogYmIuZGVmYXVsdHMoe1xyXG5cdCAqICAgZGF0YToge1xyXG5cdCAqICAgICB0eXBlOiBcImJhclwiXHJcblx0ICogICB9XHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiBiYi5kZWZhdWx0cygpOyAgLy8ge2RhdGE6e3R5cGU6IFwiYmFyXCJ9fVxyXG5cdCAqXHJcblx0ICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXHJcblx0ICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcblx0ICovXHJcblx0ZGVmYXVsdHMob3B0aW9ucz8pIHtcclxuXHRcdGlmIChpc09iamVjdChvcHRpb25zKSkge1xyXG5cdFx0XHRkZWZhdWx0cyA9IG9wdGlvbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRlZmF1bHRzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2UgY3JlYXRlZFxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IGluc3RhbmNlIGluc3RhbmNlIGFycmF5XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZ2VuZXJhdGUgY2hhcnRzXHJcblx0ICogIHZhciBjaGFydDEgPSBiYi5nZW5lcmF0ZSguLi4pO1xyXG5cdCAqICB2YXIgY2hhcnQyID0gYmIuZ2VuZXJhdGUoLi4uKTtcclxuXHQgKlxyXG5cdCAqICBiYi5pbnN0YW5jZTsgIC8vIFsgY2hhcnQxLCBjaGFydDIsIC4uLiBdXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0aW5zdGFuY2U6IFtdLFxyXG5cclxuXHQvKipcclxuXHQgKiBOYW1lc3BhY2UgZm9yIHBsdWdpbnNcclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gcGx1Z2luIHBsdWdpbiBuYW1lc3BhY2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTdGFuZm9yZCBkaWFncmFtIHBsdWdpblxyXG5cdCAqICBiYi5wbHVnaW4uc3RhbmZvcmQ7XHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0cGx1Z2luOiB7fVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9